{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/about/index.html","path":"about/index.html","modified":1,"renderable":0},{"_id":"source/about/asd","path":"about/asd","modified":1,"renderable":0},{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/myintelex.png","path":"img/myintelex.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":1,"renderable":1},{"_id":"source/about/static/fonts/iconfont.svg","path":"about/static/fonts/iconfont.svg","modified":1,"renderable":0},{"_id":"source/about/static/fonts/iconfont.ttf","path":"about/static/fonts/iconfont.ttf","modified":1,"renderable":0},{"_id":"source/about/static/image/image.png","path":"about/static/image/image.png","modified":1,"renderable":0},{"_id":"source/about/static/fonts/iconfont.eot","path":"about/static/fonts/iconfont.eot","modified":1,"renderable":0},{"_id":"source/about/static/image/weixin.png","path":"about/static/image/weixin.png","modified":1,"renderable":0},{"_id":"source/about/static/fonts/iconfont.woff","path":"about/static/fonts/iconfont.woff","modified":1,"renderable":0},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":1,"renderable":1},{"_id":"source/about/static/image/bg.jpg","path":"about/static/image/bg.jpg","modified":1,"renderable":0},{"_id":"source/about/static/image/my.png","path":"about/static/image/my.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yelee/.gitignore","hash":"79b4a9ac435bc5833a0bc461ebacb10908b34ed3","modified":1481796671461},{"_id":"themes/yelee/README.md","hash":"12bc9cdb68f51df81bcc36a5263e0a6c5860f646","modified":1481796671477},{"_id":"themes/yelee/_config.yml","hash":"d6add245c213482cadc5dedd608e8432cbb5db28","modified":1482749830000},{"_id":"themes/yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1481796671561},{"_id":"source/_posts/BOA服务器移植.md","hash":"39a5bfe5a3942e7bbb941014f2be70e260e54c7b","modified":1513754880865},{"_id":"source/_posts/02C-学习笔记（二）——面向对象.md","hash":"6599f778e80b3b538f3cc4a73eba0ec9ca51e216","modified":1512567134095},{"_id":"source/_posts/C-学习笔记（三）——STL.md","hash":"9acfc5e6b72bc943d43ae0901ebc7450f648b12a","modified":1512567286767},{"_id":"source/about/index.html","hash":"5e31097e34e9d420dace0f89a8bb3982b7abf9d4","modified":1478843179369},{"_id":"source/_posts/C-学习笔记（一）——基础知识.md","hash":"da88e004a8fdc06ba9a8511c0602d1fa3553bba7","modified":1512568032043},{"_id":"source/_posts/C语言学习总结（一）-开篇.md","hash":"7f637f7b5d7d8283916e4cfcbef8fb3bd50d07e9","modified":1512567312221},{"_id":"source/_posts/C语言学习总结（三）——C语言的基本语法.md","hash":"ec7e103673e68f165cf5aee6d6c2681fa42d674d","modified":1482329302000},{"_id":"source/_posts/C-整形和字符串的转换.md","hash":"36835baa23243a5e64bca8502f83a178128a8506","modified":1488250083000},{"_id":"source/_posts/C语言学习总结（五）——C库函数总结.md","hash":"c7e1fa406904b62f723402e1e515a0faea53950b","modified":1482329294000},{"_id":"source/_posts/C语言学习总结（二）——GCC和GDB.md","hash":"5803a16c46645cad741305fa83b05088804e39d9","modified":1482329298000},{"_id":"source/_posts/C语言学习总结（四）——数据结构.md","hash":"6059a3607f7fbfb47af33afa0f4082e885686b55","modified":1513228781896},{"_id":"source/_posts/Google-C-Style-Guide.md","hash":"0dc300bffb6afc2e8ebcc3e4fd2089b6c08c2112","modified":1512567369199},{"_id":"source/_posts/Linux学习总结01.md","hash":"11ae85e12e12ff7272702a1b5e2fac73daf04f3b","modified":1482329280000},{"_id":"source/about/asd","hash":"2a889ee9ad47ef5a1d5d5f790087c47d884d48fc","modified":1479449552035},{"_id":"source/_posts/Linux学习总结02.md","hash":"d1875240e6670b59021032acd959602650b94df3","modified":1512567457618},{"_id":"source/_posts/Linux学习总结03.md","hash":"7fddfff72a390f5c1758fb4da1ce51d24b1077ae","modified":1512567522254},{"_id":"source/_posts/Linux学习总结05.md","hash":"3e5aa2d29bf2c04fbd09faade3c77d366a0d954b","modified":1482479541000},{"_id":"source/_posts/Linux学习总结04.md","hash":"5c14935f3c5e4002472c6d0626443d2523f7df6f","modified":1482329269000},{"_id":"source/_posts/Linux学习总结06.md","hash":"81f0c945bc70fa0100706732d859f62913945cab","modified":1512568131717},{"_id":"source/_posts/Linux驱动开发01.md","hash":"a2d427d9bf68281f0558c2288a2cc2c40cb3fb3a","modified":1482653415000},{"_id":"source/_posts/Linux学习总结07.md","hash":"1d0eb4135d8f8a1aecd8cb2138f33edcae373e19","modified":1512567608992},{"_id":"source/_posts/Linux学习总结09.md","hash":"af5f2c981c2fde2d3a3c07910fcb2eae78b687ba","modified":1512567736154},{"_id":"source/_posts/Linux学习总结08.md","hash":"93003e3bb699b462c492397fda4dceb817308c28","modified":1512567623024},{"_id":"source/_posts/Linux驱动开发02.md","hash":"2df7b90335e3243d8ddaa993700d923acc50d98a","modified":1512568113460},{"_id":"source/_posts/Linux驱动开发03.md","hash":"f900dd561a68f17a2397d6717f8c59abda358aa7","modified":1512567810144},{"_id":"source/_posts/Linux驱动开发04.md","hash":"70443d5c42c01466760f123483a4b714188ba203","modified":1482653397000},{"_id":"source/_posts/Ubutu安装VSCode步骤.md","hash":"8b81074540fb72c93d09bd43a114498bb380be72","modified":1513228774557},{"_id":"source/_posts/Linux驱动开发05.md","hash":"6d610c6507c35b01752f196ec2afe652526946e9","modified":1482749366000},{"_id":"source/_posts/Linux驱动开发06.md","hash":"22771d5705ac3d3ff5dfb36a0aa99d1b5a999a6e","modified":1482749930000},{"_id":"source/_posts/Linux驱动开发07.md","hash":"4050e2af4d2d4b5f15e4cddc9742f92114ec0ad7","modified":1512567853326},{"_id":"source/_posts/VS-Code-快捷键总结.md","hash":"0202e62b0eeabdfc8d5cdf23d955cd2f0d88cd36","modified":1512900734946},{"_id":"source/_posts/使用Hexo配置Github建立个人站点方法备忘.md","hash":"6e11bf417bd0d115535e82d0c85ac7655191632d","modified":1514787204734},{"_id":"source/_posts/Visual-Studio-Code-自动补全插件设置“.md","hash":"311ef2ec9439a5f7ba4d5442900138c6263ef879","modified":1512566950130},{"_id":"source/_posts/system调用Qt程序的问题.md","hash":"17e9c49f2b6b6d2c17173b212bf0e5670181008f","modified":1481545045000},{"_id":"source/_posts/在windows下打出tar-gz的尝试.md","hash":"989115afbda2718ed6d9afbd7bd4877bcd7e093a","modified":1479808708000},{"_id":"source/_posts/《程序员的修炼之道》读书笔记.md","hash":"1237afabd2ba65d78a3d5e44faf331fe57ce8834","modified":1512567108408},{"_id":"source/_posts/操作系统命名规范.md","hash":"731ee113e9f896ccb5f647f6491cda70fd0ef1e4","modified":1512567883496},{"_id":"source/tags/index.md","hash":"05553b6469bd09f235f1785f2cac5b502b240560","modified":1479449516521},{"_id":"source/404/index.md","hash":"33823c02cad0c573c2670f062f6b7399facc0808","modified":1479449878000},{"_id":"themes/yelee/.github/ISSUE_TEMPLATE.md","hash":"ce083abf397c12747893a23e901d46558b53e0ad","modified":1481796671461},{"_id":"themes/yelee/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1481796671445},{"_id":"themes/yelee/.git/config","hash":"fc9762f33cf36a22baab4720f661eeaa651e1c24","modified":1481796671461},{"_id":"themes/yelee/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1481796630829},{"_id":"themes/yelee/.git/index","hash":"7b37987bdd2e44c3c734c84fa9a48ca965714d2f","modified":1482203049924},{"_id":"themes/yelee/.git/packed-refs","hash":"fad6a43ad617793304d9241562a71596db559018","modified":1481796671430},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1481796671545},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1481796671545},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1481796671561},{"_id":"themes/yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1481796671561},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1481796671561},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1481796671561},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1481796671561},{"_id":"themes/yelee/languages/default.yml","hash":"3bdad891c90029447b4fbaedbbb11b8a59d06418","modified":1481796671477},{"_id":"themes/yelee/languages/en.yml","hash":"ff991c2c80d9ab69c984acb1c40480c8b98be2bc","modified":1481796671477},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"4fa4068a65089810e7dd95692f9157eb80c2e8de","modified":1481796671477},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"bbc73dcd9170fe9efaab6fbbe1571886e0b8aa89","modified":1481796671494},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"88b4678bba940bc270c7aea2debbf869ecf6cc18","modified":1481796671497},{"_id":"themes/yelee/source/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1479448353549},{"_id":"source/_posts/环境变量总结.md","hash":"1d8181527788c5b0aae211841d6f8cc0381ce503","modified":1512568247457},{"_id":"source/_posts/线性表的实现.md","hash":"8ed80f987c8d466dcbdd4e85151b4388b22dfe9e","modified":1481851740000},{"_id":"themes/yelee/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1481796630829},{"_id":"themes/yelee/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1481796630844},{"_id":"themes/yelee/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1481796630844},{"_id":"themes/yelee/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1481796630844},{"_id":"themes/yelee/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1481796630844},{"_id":"themes/yelee/.git/logs/HEAD","hash":"de0215e03f471755728bff3fdb14a7a6e57af681","modified":1481796671445},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"748391b89b661fa1ed7da0b15ed6870981ec4dc3","modified":1481796671498},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1481796671498},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"afd85b362d732fa9b439af7dc44b657d0d1aae3d","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"82653e3bbdc605b51e1b0a36e30f3ac1180c838e","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"55e90c3d5de6d7ffcfe26c4dc22189a7a27b6651","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"8d1e1f3953efbcf5ec84a451439a62a1c95b55d7","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"90fd7c763faf8d64d58612f592cbacbefdaea161","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a59d4c768009dd621e741a29cf6446ebc2668fe9","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"9fe869b2fbeb32cb3b4ad7271a01dc433cbfd896","modified":1481802414000},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"d894c6017cc32c7d0c22e5e200bba25f53aea82f","modified":1481802458000},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"7c4a7177e0c77de2d7607ca29fc395abebd34db7","modified":1481796671545},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"c7b25ef136e129c948ac37d6ff19e8815ab9fee6","modified":1481796671545},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"7ee88b1a98eea5cbd44c0f9a11b86b46aa2d6752","modified":1481797403000},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1479448353585},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1479448353592},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1479448353599},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1479448353606},{"_id":"themes/yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1479448353627},{"_id":"themes/yelee/source/css/_variables.styl","hash":"f429eb9bc9f0a270ec68c4f4c63903250746a01c","modified":1479448353834},{"_id":"themes/yelee/source/css/style.styl","hash":"b285f9a75abd09c7d06fe89e70f9e1819eac27dd","modified":1479448353842},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"5fb1bf6cf973062771ddf275ceeca5bc69c81c77","modified":1479448353897},{"_id":"themes/yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1479448353949},{"_id":"themes/yelee/source/js/main.js","hash":"d1051a945d24d5b8ea5b64e9bb304700b3df70ce","modified":1481799348000},{"_id":"themes/yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1479448353981},{"_id":"themes/yelee/source/js/pc.js","hash":"bc289c5dc610e2a34d308daeb9adea96d01f7788","modified":1479448353996},{"_id":"themes/yelee/source/js/search.js","hash":"001e324844e63f3bfb6f60d173b9c6954127be0b","modified":1479448354011},{"_id":"themes/yelee/source/js/toc.js","hash":"973c1a4e2c9de8f4f662b99623027658fe6d94c2","modified":1479448354028},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1479448353845},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1479448353846},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1479448353847},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1479448353848},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1479448353849},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1479448353851},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1479448353854},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1479448353855},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1479448353857},{"_id":"themes/yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1479448353858},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1479448353859},{"_id":"themes/yelee/source/img/myintelex.png","hash":"de823e8d59e4538ed4ae26bff4538769e81eb867","modified":1477904546000},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1479448353861},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1479448353862},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1479448353864},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1479448353866},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1479448353867},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1479448353868},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1479448353870},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1479448353871},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1479448353873},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1479448353613},{"_id":"themes/yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1479448353621},{"_id":"source/about/static/fonts/iconfont.css","hash":"2a91b6d9b4493a31aa8525644f17a16c28585aa7","modified":1478762445283},{"_id":"source/about/static/fonts/demo.css","hash":"49984732f03976f4ecff88283aeac3143a484419","modified":1478762445271},{"_id":"source/about/static/fonts/iconfont.svg","hash":"a97f3a46fa54a5fd8139a38db6f2878e3c637ddd","modified":1478762445296},{"_id":"source/about/static/css/style.css","hash":"197f8f313ab1bc1e60a037eb216b64c63e51978c","modified":1478837258140},{"_id":"source/about/static/fonts/iconfont.ttf","hash":"20725ceca5ef3360823981790e73c49cd45dd06f","modified":1478762445302},{"_id":"source/about/static/fonts/demo.html","hash":"d2b6160f8583041ebbcd139aae626af2a1aec801","modified":1478762445277},{"_id":"source/about/static/image/image.png","hash":"1fa41653f7ac4627d294ac9e4d8eb8cfc7b027af","modified":1478776942160},{"_id":"source/about/static/js/script.js","hash":"ae5cea1a203ae41e3a7e40ac1404a0e5c49545fd","modified":1478777296360},{"_id":"source/about/static/fonts/iconfont.eot","hash":"f5d0ba07443c5d30969366f395e027ebc1b30131","modified":1478762445289},{"_id":"source/about/static/image/weixin.png","hash":"51a672d9ffd91c8501f1dbbb5897d3226ac4c819","modified":1478762445318},{"_id":"themes/yelee/.git/refs/heads/master","hash":"a098c9ba7d644627d0ba7fb675f0168faedeb258","modified":1481796671445},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"ecc4d3ca997c6fd127e00fa2edf0158b925d1d3e","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"ada2032e401b73b312c50b75bdbb8ee71d5a291e","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"df7ee469b648b12b5ee3104ef513d54cbb7418af","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"e7f12f1246a67a5b556c2d5b37dc78733f1cf15a","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"d150085faee4809ba50f69c55d904605699040cb","modified":1481796671514},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"329ed372296a86bce73ff8936af5601723fdd70a","modified":1481796671545},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1481796671530},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"6ce901659340b64f2957884c868893dd3ff83733","modified":1481797829000},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1481796671545},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1481796671545},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1481796671545},{"_id":"source/about/static/fonts/iconfont.woff","hash":"a6458d08ef5be4a2435c0b583bf66160fb5920b6","modified":1478762445309},{"_id":"source/about/static/js/modal.js","hash":"f76edd208752ae83210d5ffe8c8f3f7758aed68a","modified":1478762445343},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1479448353564},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1479448353557},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1479448353570},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1479448353577},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"4efa63d0d87a9ccae9aeea58fe5807bce151a9c1","modified":1482201922000},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"36e7aed0decc45de26c8695bdf482defe2fb7c1b","modified":1482203102000},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"a419108f1b820c59fcc56d218bfaaa4ffc4f1d4d","modified":1479448353697},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1479448353702},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1479448353716},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"97f821b7b9476af758f828b85037cf249b87473e","modified":1482200304000},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"7c7788be148337f996e016789b619fe0e135b639","modified":1482201503000},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1479448353735},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"dfb20f2515a26d75e42fe09741e91cc889426b11","modified":1479448353743},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1479448353749},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1479448353755},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"688ff535a6005be02d947be75d22cfe1f8ce72cd","modified":1479448353761},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1479448353771},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1479448353783},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"8f2a057dc072285093e37f1f645e9cb53608642f","modified":1479448353792},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1479448353799},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1479448353810},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1479448353823},{"_id":"themes/yelee/.git/objects/pack/pack-f0f8f5c948094eacada1f6f7d0dd95fc7f273d74.idx","hash":"7bb9a889a7f3f67e28fc18748a04064816487747","modified":1481796671361},{"_id":"source/about/static/image/bg.jpg","hash":"341a34f608e99af918a35dbc8ea50c38da2696e1","modified":1478762445316},{"_id":"source/about/static/image/my.png","hash":"99221fabdab22d8d388a82914e441df4d196bd13","modified":1477469095703},{"_id":"themes/yelee/.git/logs/refs/heads/master","hash":"de0215e03f471755728bff3fdb14a7a6e57af681","modified":1481796671445},{"_id":"themes/yelee/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1481796671445},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"0e549026aecf35748f8667eb9cc5ce0f398572c2","modified":1481805662000},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"135cdc6020d6b9d6c18a4ef91601f0fb9c5693d4","modified":1482200550000},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1479448353656},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"c29799f09ebd87767fd9cc3b1fa795db44a94670","modified":1482203048000},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"fbcfebe32a5a60276b47955c1f97c52068b006bf","modified":1482203410000},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"7db683e2837a078ad7817fb88914535588e49cfa","modified":1479448353678},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"6f2e0269ad55936e983762d4662581180f5d268c","modified":1482199584000},{"_id":"themes/yelee/.git/logs/refs/remotes/origin/HEAD","hash":"de0215e03f471755728bff3fdb14a7a6e57af681","modified":1481796671445},{"_id":"themes/yelee/.git/objects/pack/pack-f0f8f5c948094eacada1f6f7d0dd95fc7f273d74.pack","hash":"12e7731e9e76de0cc18b199ca0f35d0c24436e74","modified":1481796671376}],"Category":[{"name":"Linux 应用","_id":"cjbvt9mzf0004bkw1mh1r0wie"},{"name":"C++学习笔记","_id":"cjbvt9mzt0009bkw1lfiza05y"},{"name":"C语言学习总结","_id":"cjbvt9n0b000pbkw1xxzkbl80"},{"name":"工作总结","_id":"cjbvt9n0m000vbkw1q2byqiyg"},{"name":"学习记录","_id":"cjbvt9n17001qbkw10hrmztnq"},{"name":"Linux学习记录","_id":"cjbvt9n17001wbkw1nrnlv3yk"},{"name":"驱动开发","_id":"cjbvt9n23002tbkw1gj6mq67d"},{"name":"工具使用","_id":"cjbvt9n2m003kbkw1rfsqicd8"},{"name":"开发经验","_id":"cjbvt9n2n0045bkw1hyo3lj94"},{"name":"工作记录","_id":"cjbvt9n33004dbkw18bwuhoi1"},{"name":"读书笔记","_id":"cjbvt9n33004jbkw1yl2ijp0c"},{"name":"数据结构","_id":"cjbvt9n4v008bbkw1bryjyk9z"}],"Data":[],"Page":[{"title":"tags","date":"2016-11-18T06:11:56.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-18 14:11:56\n---\n","updated":"2016-11-18T06:11:56.521Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjbvt9myw0001bkw1totihg99","content":"","excerpt":"","more":""},{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"","source":"404/index.md","raw":"title: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---","date":"2016-11-18T06:17:58.168Z","updated":"2016-11-18T06:17:58.000Z","path":"/404.html","layout":"page","_id":"cjbvt9mzd0003bkw1wyyyar3c","content":"","excerpt":"","more":""},{"_content":"\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1472035662'); /* IE9*/\n  src: url('iconfont.eot?t=1472035662#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('iconfont.woff?t=1472035662') format('woff'), /* chrome, firefox */\n  url('iconfont.ttf?t=1472035662') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1472035662#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.iconfont {\n  font-family:\"iconfont\" !important;\n  font-size:16px;\n  font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n.icon-accountcircle:before { content: \"\\ea39\"; }\n.icon-cardtravel:before { content: \"\\eac9\"; }\n.icon-contentpaste:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-phoneandroid:before { content: \"\\ec7b\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-staroutline:before { content: \"\\ed1d\"; }\n.icon-star:before { content: \"\\ed1b\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-work:before { content: \"\\edac\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-importcontacts:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-comment:before { content: \"\\ead7\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-camera:before { content: \"\\eabe\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-accountbox:before { content: \"\\ea38\"; }\n.icon-attachmoney:before { content: \"\\ea7d\"; }\n.icon-bookmarkoutline:before { content: \"\\ea95\"; }\n.icon-chatbubbleoutline:before { content: \"\\ead2\"; }\n.icon-chat:before { content: \"\\ead0\"; }\n.icon-cloud:before { content: \"\\eadf\"; }\n.icon-desktopwindows:before { content: \"\\eb0f\"; }\n.icon-desktopmac:before { content: \"\\eb0e\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-favoriteoutline:before { content: \"\\eb4d\"; }\n.icon-favorite:before { content: \"\\eb4c\"; }\n.icon-exposureplus1:before { content: \"\\eb45\"; }\n.icon-extension:before { content: \"\\eb48\"; }\n.icon-flag:before { content: \"\\eb6f\"; }\n.icon-fitnesscenter:before { content: \"\\eb6e\"; }\n.icon-freebreakfast:before { content: \"\\eb9c\"; }\n.icon-forum:before { content: \"\\eb97\"; }\n.icon-goat:before { content: \"\\eba3\"; }\n.icon-home:before { content: \"\\ebc2\"; }\n.icon-hourglassempty:before { content: \"\\ebc5\"; }\n.icon-localflorist:before { content: \"\\ec0a\"; }\n.icon-locationon:before { content: \"\\ec24\"; }\n.icon-locallibrary:before { content: \"\\ec10\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-highlightremove:before { content: \"\\ebc0\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-delete1:before { content: \"\\e610\"; }\n.icon-delete2:before { content: \"\\e643\"; }\n.icon-add:before { content: \"\\e620\"; }\n.icon-add1:before { content: \"\\e676\"; }\n.icon-trophy:before { content: \"\\e816\"; }\n.icon-trophy1:before { content: \"\\e6fc\"; }\n.icon-trophy2:before { content: \"\\e80b\"; }\n","source":"about/static/fonts/iconfont.css","raw":"\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1472035662'); /* IE9*/\n  src: url('iconfont.eot?t=1472035662#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('iconfont.woff?t=1472035662') format('woff'), /* chrome, firefox */\n  url('iconfont.ttf?t=1472035662') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1472035662#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.iconfont {\n  font-family:\"iconfont\" !important;\n  font-size:16px;\n  font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n.icon-accountcircle:before { content: \"\\ea39\"; }\n.icon-cardtravel:before { content: \"\\eac9\"; }\n.icon-contentpaste:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-phoneandroid:before { content: \"\\ec7b\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-staroutline:before { content: \"\\ed1d\"; }\n.icon-star:before { content: \"\\ed1b\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-work:before { content: \"\\edac\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-importcontacts:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-comment:before { content: \"\\ead7\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-camera:before { content: \"\\eabe\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-accountbox:before { content: \"\\ea38\"; }\n.icon-attachmoney:before { content: \"\\ea7d\"; }\n.icon-bookmarkoutline:before { content: \"\\ea95\"; }\n.icon-chatbubbleoutline:before { content: \"\\ead2\"; }\n.icon-chat:before { content: \"\\ead0\"; }\n.icon-cloud:before { content: \"\\eadf\"; }\n.icon-desktopwindows:before { content: \"\\eb0f\"; }\n.icon-desktopmac:before { content: \"\\eb0e\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-favoriteoutline:before { content: \"\\eb4d\"; }\n.icon-favorite:before { content: \"\\eb4c\"; }\n.icon-exposureplus1:before { content: \"\\eb45\"; }\n.icon-extension:before { content: \"\\eb48\"; }\n.icon-flag:before { content: \"\\eb6f\"; }\n.icon-fitnesscenter:before { content: \"\\eb6e\"; }\n.icon-freebreakfast:before { content: \"\\eb9c\"; }\n.icon-forum:before { content: \"\\eb97\"; }\n.icon-goat:before { content: \"\\eba3\"; }\n.icon-home:before { content: \"\\ebc2\"; }\n.icon-hourglassempty:before { content: \"\\ebc5\"; }\n.icon-localflorist:before { content: \"\\ec0a\"; }\n.icon-locationon:before { content: \"\\ec24\"; }\n.icon-locallibrary:before { content: \"\\ec10\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-highlightremove:before { content: \"\\ebc0\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-delete1:before { content: \"\\e610\"; }\n.icon-delete2:before { content: \"\\e643\"; }\n.icon-add:before { content: \"\\e620\"; }\n.icon-add1:before { content: \"\\e676\"; }\n.icon-trophy:before { content: \"\\e816\"; }\n.icon-trophy1:before { content: \"\\e6fc\"; }\n.icon-trophy2:before { content: \"\\e80b\"; }\n","date":"2016-11-10T07:20:45.283Z","updated":"2016-11-10T07:20:45.283Z","path":"about/static/fonts/iconfont.css","layout":"false","title":"","comments":1,"_id":"cjbvt9n5q008ibkw1corpvc1l","content":"\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1472035662'); /* IE9*/\n  src: url('iconfont.eot?t=1472035662#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('iconfont.woff?t=1472035662') format('woff'), /* chrome, firefox */\n  url('iconfont.ttf?t=1472035662') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1472035662#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.iconfont {\n  font-family:\"iconfont\" !important;\n  font-size:16px;\n  font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n.icon-accountcircle:before { content: \"\\ea39\"; }\n.icon-cardtravel:before { content: \"\\eac9\"; }\n.icon-contentpaste:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-phoneandroid:before { content: \"\\ec7b\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-staroutline:before { content: \"\\ed1d\"; }\n.icon-star:before { content: \"\\ed1b\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-work:before { content: \"\\edac\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-importcontacts:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-comment:before { content: \"\\ead7\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-camera:before { content: \"\\eabe\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-accountbox:before { content: \"\\ea38\"; }\n.icon-attachmoney:before { content: \"\\ea7d\"; }\n.icon-bookmarkoutline:before { content: \"\\ea95\"; }\n.icon-chatbubbleoutline:before { content: \"\\ead2\"; }\n.icon-chat:before { content: \"\\ead0\"; }\n.icon-cloud:before { content: \"\\eadf\"; }\n.icon-desktopwindows:before { content: \"\\eb0f\"; }\n.icon-desktopmac:before { content: \"\\eb0e\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-favoriteoutline:before { content: \"\\eb4d\"; }\n.icon-favorite:before { content: \"\\eb4c\"; }\n.icon-exposureplus1:before { content: \"\\eb45\"; }\n.icon-extension:before { content: \"\\eb48\"; }\n.icon-flag:before { content: \"\\eb6f\"; }\n.icon-fitnesscenter:before { content: \"\\eb6e\"; }\n.icon-freebreakfast:before { content: \"\\eb9c\"; }\n.icon-forum:before { content: \"\\eb97\"; }\n.icon-goat:before { content: \"\\eba3\"; }\n.icon-home:before { content: \"\\ebc2\"; }\n.icon-hourglassempty:before { content: \"\\ebc5\"; }\n.icon-localflorist:before { content: \"\\ec0a\"; }\n.icon-locationon:before { content: \"\\ec24\"; }\n.icon-locallibrary:before { content: \"\\ec10\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-highlightremove:before { content: \"\\ebc0\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-delete1:before { content: \"\\e610\"; }\n.icon-delete2:before { content: \"\\e643\"; }\n.icon-add:before { content: \"\\e620\"; }\n.icon-add1:before { content: \"\\e676\"; }\n.icon-trophy:before { content: \"\\e816\"; }\n.icon-trophy1:before { content: \"\\e6fc\"; }\n.icon-trophy2:before { content: \"\\e80b\"; }\n","excerpt":"","more":"\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1472035662'); /* IE9*/\n  src: url('iconfont.eot?t=1472035662#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('iconfont.woff?t=1472035662') format('woff'), /* chrome, firefox */\n  url('iconfont.ttf?t=1472035662') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1472035662#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.iconfont {\n  font-family:\"iconfont\" !important;\n  font-size:16px;\n  font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n.icon-accountcircle:before { content: \"\\ea39\"; }\n.icon-cardtravel:before { content: \"\\eac9\"; }\n.icon-contentpaste:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-phoneandroid:before { content: \"\\ec7b\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-staroutline:before { content: \"\\ed1d\"; }\n.icon-star:before { content: \"\\ed1b\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-work:before { content: \"\\edac\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-importcontacts:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-comment:before { content: \"\\ead7\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-camera:before { content: \"\\eabe\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-accountbox:before { content: \"\\ea38\"; }\n.icon-attachmoney:before { content: \"\\ea7d\"; }\n.icon-bookmarkoutline:before { content: \"\\ea95\"; }\n.icon-chatbubbleoutline:before { content: \"\\ead2\"; }\n.icon-chat:before { content: \"\\ead0\"; }\n.icon-cloud:before { content: \"\\eadf\"; }\n.icon-desktopwindows:before { content: \"\\eb0f\"; }\n.icon-desktopmac:before { content: \"\\eb0e\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-favoriteoutline:before { content: \"\\eb4d\"; }\n.icon-favorite:before { content: \"\\eb4c\"; }\n.icon-exposureplus1:before { content: \"\\eb45\"; }\n.icon-extension:before { content: \"\\eb48\"; }\n.icon-flag:before { content: \"\\eb6f\"; }\n.icon-fitnesscenter:before { content: \"\\eb6e\"; }\n.icon-freebreakfast:before { content: \"\\eb9c\"; }\n.icon-forum:before { content: \"\\eb97\"; }\n.icon-goat:before { content: \"\\eba3\"; }\n.icon-home:before { content: \"\\ebc2\"; }\n.icon-hourglassempty:before { content: \"\\ebc5\"; }\n.icon-localflorist:before { content: \"\\ec0a\"; }\n.icon-locationon:before { content: \"\\ec24\"; }\n.icon-locallibrary:before { content: \"\\ec10\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-highlightremove:before { content: \"\\ebc0\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-delete1:before { content: \"\\e610\"; }\n.icon-delete2:before { content: \"\\e643\"; }\n.icon-add:before { content: \"\\e620\"; }\n.icon-add1:before { content: \"\\e676\"; }\n.icon-trophy:before { content: \"\\e816\"; }\n.icon-trophy1:before { content: \"\\e6fc\"; }\n.icon-trophy2:before { content: \"\\e80b\"; }\n"},{"_content":"*{margin: 0;padding: 0;list-style: none;}\n/*\nKISSY CSS Reset\n理念：1. reset 的目的不是清除浏览器的默认样式，这仅是部分工作。清除和重置是紧密不可分的。\n2. reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。\n3. reset 期望提供一套普适通用的基础样式。但没有银弹，推荐根据具体需求，裁剪和修改后再使用。\n特色：1. 适应中文；2. 基于最新主流浏览器。\n维护：玉伯<lifesinger@gmail.com>, 正淳<ragecarrier@gmail.com>\n */\n\n/** 清除内外边距 **/\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* structural elements 结构元素 */\ndl, dt, dd, ul, ol, li, /* list elements 列表元素 */\npre, /* text formatting elements 文本格式元素 */\nform, fieldset, legend, button, input, textarea, /* form elements 表单元素 */\nth, td /* table elements 表格元素 */ {\n  margin: 0;\n  padding: 0;\n}\n\n/** 设置默认字体 **/\nbody,\nbutton, input, select, textarea /* for ie */ {\n  font: 12px/1.5 tahoma, arial, \\5b8b\\4f53, sans-serif;\n}\nh1, h2, h3, h4, h5, h6 { font-size: 100%; }\naddress, cite, dfn, em, var { font-style: normal; } /* 将斜体扶正 */\ncode, kbd, pre, samp { font-family: courier new, courier, monospace; } /* 统一等宽字体 */\nsmall { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */\n\n/** 重置列表元素 **/\nul, ol { list-style: none; }\n\n/** 重置文本格式元素 **/\na { text-decoration: none; }\na:hover { text-decoration: underline; }\n\n\n/** 重置表单元素 **/\nlegend { color: #000; } /* for ie6 */\nfieldset, img { border: 0; } /* img 搭车：让链接里的 img 无边框 */\nbutton, input, select, textarea { font-size: 100%; } /* 使得表单元素在 ie 下能继承字体大小 */\n/* 注：optgroup 无法扶正 */\n\n/** 重置表格元素 **/\ntable { border-collapse: collapse; border-spacing: 0; }\n\n/* 清除浮动 */\n.ks-clear:after, .clear:after {\n  content: '\\20';\n  display: block;\n  height: 0;\n  clear: both;\n}\n.ks-clear, .clear {\n  *zoom: 1;\n}\n\n.main {padding: 30px 100px;}\n.main h1{font-size:36px; color:#333; text-align:left;margin-bottom:30px; border-bottom: 1px solid #eee;}\n\n.helps{margin-top:40px;}\n.helps pre{\n  padding:20px;\n  margin:10px 0;\n  border:solid 1px #e7e1cd;\n  background-color: #fffdef;\n  overflow: auto;\n}\n\n.icon_lists li{\n  float:left;\n  width: 100px;\n  height:180px;\n  text-align: center;\n}\n.icon_lists .icon{\n  font-size: 42px;\n  line-height: 100px;\n  margin: 10px 0;\n  color:#333;\n  -webkit-transition: font-size 0.25s ease-out 0s;\n  -moz-transition: font-size 0.25s ease-out 0s;\n  transition: font-size 0.25s ease-out 0s;\n\n}\n.icon_lists .icon:hover{\n  font-size: 100px;\n}\n","source":"about/static/fonts/demo.css","raw":"*{margin: 0;padding: 0;list-style: none;}\n/*\nKISSY CSS Reset\n理念：1. reset 的目的不是清除浏览器的默认样式，这仅是部分工作。清除和重置是紧密不可分的。\n2. reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。\n3. reset 期望提供一套普适通用的基础样式。但没有银弹，推荐根据具体需求，裁剪和修改后再使用。\n特色：1. 适应中文；2. 基于最新主流浏览器。\n维护：玉伯<lifesinger@gmail.com>, 正淳<ragecarrier@gmail.com>\n */\n\n/** 清除内外边距 **/\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* structural elements 结构元素 */\ndl, dt, dd, ul, ol, li, /* list elements 列表元素 */\npre, /* text formatting elements 文本格式元素 */\nform, fieldset, legend, button, input, textarea, /* form elements 表单元素 */\nth, td /* table elements 表格元素 */ {\n  margin: 0;\n  padding: 0;\n}\n\n/** 设置默认字体 **/\nbody,\nbutton, input, select, textarea /* for ie */ {\n  font: 12px/1.5 tahoma, arial, \\5b8b\\4f53, sans-serif;\n}\nh1, h2, h3, h4, h5, h6 { font-size: 100%; }\naddress, cite, dfn, em, var { font-style: normal; } /* 将斜体扶正 */\ncode, kbd, pre, samp { font-family: courier new, courier, monospace; } /* 统一等宽字体 */\nsmall { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */\n\n/** 重置列表元素 **/\nul, ol { list-style: none; }\n\n/** 重置文本格式元素 **/\na { text-decoration: none; }\na:hover { text-decoration: underline; }\n\n\n/** 重置表单元素 **/\nlegend { color: #000; } /* for ie6 */\nfieldset, img { border: 0; } /* img 搭车：让链接里的 img 无边框 */\nbutton, input, select, textarea { font-size: 100%; } /* 使得表单元素在 ie 下能继承字体大小 */\n/* 注：optgroup 无法扶正 */\n\n/** 重置表格元素 **/\ntable { border-collapse: collapse; border-spacing: 0; }\n\n/* 清除浮动 */\n.ks-clear:after, .clear:after {\n  content: '\\20';\n  display: block;\n  height: 0;\n  clear: both;\n}\n.ks-clear, .clear {\n  *zoom: 1;\n}\n\n.main {padding: 30px 100px;}\n.main h1{font-size:36px; color:#333; text-align:left;margin-bottom:30px; border-bottom: 1px solid #eee;}\n\n.helps{margin-top:40px;}\n.helps pre{\n  padding:20px;\n  margin:10px 0;\n  border:solid 1px #e7e1cd;\n  background-color: #fffdef;\n  overflow: auto;\n}\n\n.icon_lists li{\n  float:left;\n  width: 100px;\n  height:180px;\n  text-align: center;\n}\n.icon_lists .icon{\n  font-size: 42px;\n  line-height: 100px;\n  margin: 10px 0;\n  color:#333;\n  -webkit-transition: font-size 0.25s ease-out 0s;\n  -moz-transition: font-size 0.25s ease-out 0s;\n  transition: font-size 0.25s ease-out 0s;\n\n}\n.icon_lists .icon:hover{\n  font-size: 100px;\n}\n","date":"2016-11-10T07:20:45.271Z","updated":"2016-11-10T07:20:45.271Z","path":"about/static/fonts/demo.css","layout":"false","title":"","comments":1,"_id":"cjbvt9n5q008jbkw1ahovk2wd","content":"*{margin: 0;padding: 0;list-style: none;}\n/*\nKISSY CSS Reset\n理念：1. reset 的目的不是清除浏览器的默认样式，这仅是部分工作。清除和重置是紧密不可分的。\n2. reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。\n3. reset 期望提供一套普适通用的基础样式。但没有银弹，推荐根据具体需求，裁剪和修改后再使用。\n特色：1. 适应中文；2. 基于最新主流浏览器。\n维护：玉伯<lifesinger@gmail.com>, 正淳<ragecarrier@gmail.com>\n */\n\n/** 清除内外边距 **/\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* structural elements 结构元素 */\ndl, dt, dd, ul, ol, li, /* list elements 列表元素 */\npre, /* text formatting elements 文本格式元素 */\nform, fieldset, legend, button, input, textarea, /* form elements 表单元素 */\nth, td /* table elements 表格元素 */ {\n  margin: 0;\n  padding: 0;\n}\n\n/** 设置默认字体 **/\nbody,\nbutton, input, select, textarea /* for ie */ {\n  font: 12px/1.5 tahoma, arial, \\5b8b\\4f53, sans-serif;\n}\nh1, h2, h3, h4, h5, h6 { font-size: 100%; }\naddress, cite, dfn, em, var { font-style: normal; } /* 将斜体扶正 */\ncode, kbd, pre, samp { font-family: courier new, courier, monospace; } /* 统一等宽字体 */\nsmall { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */\n\n/** 重置列表元素 **/\nul, ol { list-style: none; }\n\n/** 重置文本格式元素 **/\na { text-decoration: none; }\na:hover { text-decoration: underline; }\n\n\n/** 重置表单元素 **/\nlegend { color: #000; } /* for ie6 */\nfieldset, img { border: 0; } /* img 搭车：让链接里的 img 无边框 */\nbutton, input, select, textarea { font-size: 100%; } /* 使得表单元素在 ie 下能继承字体大小 */\n/* 注：optgroup 无法扶正 */\n\n/** 重置表格元素 **/\ntable { border-collapse: collapse; border-spacing: 0; }\n\n/* 清除浮动 */\n.ks-clear:after, .clear:after {\n  content: '\\20';\n  display: block;\n  height: 0;\n  clear: both;\n}\n.ks-clear, .clear {\n  *zoom: 1;\n}\n\n.main {padding: 30px 100px;}\n.main h1{font-size:36px; color:#333; text-align:left;margin-bottom:30px; border-bottom: 1px solid #eee;}\n\n.helps{margin-top:40px;}\n.helps pre{\n  padding:20px;\n  margin:10px 0;\n  border:solid 1px #e7e1cd;\n  background-color: #fffdef;\n  overflow: auto;\n}\n\n.icon_lists li{\n  float:left;\n  width: 100px;\n  height:180px;\n  text-align: center;\n}\n.icon_lists .icon{\n  font-size: 42px;\n  line-height: 100px;\n  margin: 10px 0;\n  color:#333;\n  -webkit-transition: font-size 0.25s ease-out 0s;\n  -moz-transition: font-size 0.25s ease-out 0s;\n  transition: font-size 0.25s ease-out 0s;\n\n}\n.icon_lists .icon:hover{\n  font-size: 100px;\n}\n</ragecarrier@gmail.com></lifesinger@gmail.com>","excerpt":"","more":"*{margin: 0;padding: 0;list-style: none;}\n/*\nKISSY CSS Reset\n理念：1. reset 的目的不是清除浏览器的默认样式，这仅是部分工作。清除和重置是紧密不可分的。\n2. reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。\n3. reset 期望提供一套普适通用的基础样式。但没有银弹，推荐根据具体需求，裁剪和修改后再使用。\n特色：1. 适应中文；2. 基于最新主流浏览器。\n维护：玉伯<lifesinger@gmail.com>, 正淳<ragecarrier@gmail.com>\n */\n\n/** 清除内外边距 **/\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* structural elements 结构元素 */\ndl, dt, dd, ul, ol, li, /* list elements 列表元素 */\npre, /* text formatting elements 文本格式元素 */\nform, fieldset, legend, button, input, textarea, /* form elements 表单元素 */\nth, td /* table elements 表格元素 */ {\n  margin: 0;\n  padding: 0;\n}\n\n/** 设置默认字体 **/\nbody,\nbutton, input, select, textarea /* for ie */ {\n  font: 12px/1.5 tahoma, arial, \\5b8b\\4f53, sans-serif;\n}\nh1, h2, h3, h4, h5, h6 { font-size: 100%; }\naddress, cite, dfn, em, var { font-style: normal; } /* 将斜体扶正 */\ncode, kbd, pre, samp { font-family: courier new, courier, monospace; } /* 统一等宽字体 */\nsmall { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */\n\n/** 重置列表元素 **/\nul, ol { list-style: none; }\n\n/** 重置文本格式元素 **/\na { text-decoration: none; }\na:hover { text-decoration: underline; }\n\n\n/** 重置表单元素 **/\nlegend { color: #000; } /* for ie6 */\nfieldset, img { border: 0; } /* img 搭车：让链接里的 img 无边框 */\nbutton, input, select, textarea { font-size: 100%; } /* 使得表单元素在 ie 下能继承字体大小 */\n/* 注：optgroup 无法扶正 */\n\n/** 重置表格元素 **/\ntable { border-collapse: collapse; border-spacing: 0; }\n\n/* 清除浮动 */\n.ks-clear:after, .clear:after {\n  content: '\\20';\n  display: block;\n  height: 0;\n  clear: both;\n}\n.ks-clear, .clear {\n  *zoom: 1;\n}\n\n.main {padding: 30px 100px;}\n.main h1{font-size:36px; color:#333; text-align:left;margin-bottom:30px; border-bottom: 1px solid #eee;}\n\n.helps{margin-top:40px;}\n.helps pre{\n  padding:20px;\n  margin:10px 0;\n  border:solid 1px #e7e1cd;\n  background-color: #fffdef;\n  overflow: auto;\n}\n\n.icon_lists li{\n  float:left;\n  width: 100px;\n  height:180px;\n  text-align: center;\n}\n.icon_lists .icon{\n  font-size: 42px;\n  line-height: 100px;\n  margin: 10px 0;\n  color:#333;\n  -webkit-transition: font-size 0.25s ease-out 0s;\n  -moz-transition: font-size 0.25s ease-out 0s;\n  transition: font-size 0.25s ease-out 0s;\n\n}\n.icon_lists .icon:hover{\n  font-size: 100px;\n}\n"},{"_content":"@font-face {font-family: 'iconfont';\n    src: url('../fonts/iconfont.eot'); /* IE9*/\n    src: url('../fonts/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../fonts/iconfont.woff') format('woff'), /* chrome、firefox */\n    url('../fonts/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('../fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n\n.icon-work:before { content: \"\\eac9\"; }\n.icon-project:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-star:before { content: \"\\ed1d\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-education:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-flower:before { content: \"\\ec0a\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-trophy:before { content: \"\\e80b\"; }\n\nspan {\n    display: inline-block;\n}\n\n.label-value{\n    width: 200px;\n    vertical-align: top;\n}\n\n.iconfont {\n    font-family:\"iconfont\" !important;\n    font-size:1.1em;font-style:normal;\n    color:inherit;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n* {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    margin: 0; \n}\n\nh1 {\n    font-weight: 700;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\n\nh2 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #3084bf;\n    line-height: 1.5;\n}\n\n\nh3, h5 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\nh4 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #cccccc;\n    background-color: #076f94;\n    margin: 0 auto;\n    -webkit-border-radius:5px 5px 5px 5px;\n    width: 250px;\n\n    line-height: 1.5;\n}\n.progress-list div {\n    width: 100%;\n    margin-left: 200px;\n}\n\n.info-list, .progress-list{\n    list-style: none;\n    padding-left: 0px;\n    font-size: 16px;\n    line-height: 2;\n}\n\n.stack-list {\n    list-style: none;\n    padding-left: 0px;\n    line-height: 1.5;\n}\n\n.stack-list li {\n    margin-bottom: 12px;\n}\n\n.right-list li {\n    margin-bottom: 12px;\n}\n\n\nhr {\n    margin-bottom: 8px;\n    border-bottom:1px solid #3084bf;\n}\n\n.info-unit {\n    color: #666;\n    margin-bottom: 20px;\n}\n\n.remodal-img h3 {\n    float: left;\n    margin-bottom: 10px;\n}\n\n.remodal-img input {\n    float: left;\n    width: 480px;\n    height: 42px;\n    font-size: 20px;\n    padding: 6px;\n    color: #666;\n    \n}\n\n.remodal-img button {\n    float: right;\n    background: #607d8b;\n\n}\n\n.remodal-img button:hover{\n    float: right;\n    background: #607d8b;\n\n}\n\n\nbody {\n    background-color: #ffffcc;\n    font-family: sans-serif, Microsoft Yahei, Helvetica Neue;\n    zoom: 80%;\n}\n\nfooter {\n}\n\np {\n    line-height: 1.5;\n}\n\nprogress {\n    background-color: #f6f6f6;\n    display: inline;\n    /*width: 195px;*/\n    height: 1em;\n\n}\n\nprogress::-webkit-progress-bar {\n    background-color: #e0eaf0;\n}\n\nprogress::-webkit-progress-value {\n    background-color: #708d9b;\n}\n\nprogress::-moz-progress-bar {\n    background-color: #e0eaf0;\n\n}\n\nprogress::-moz-progress-value {\n    background-color: #708d9b;\n}\n\n.progress-list {\n    line-height: 2;\n}\n\n\n\n.me {\n    text-align: center;\n    margin-top: 20px;\n}\n\n.weixin{\n    margin-top: 20px;\n    background-color: #e0eaf0;   \n    position: relative;\n    padding-top: 40px;\n    padding-bottom: 40px;\n    text-align: center;\n}\n\n.weixin img{\n    width: 200px;\n}\n\n.left-label {\n    display: inline-block;\n    width: 120px;\n}\n\n\n\n.container {\n    position: relative;\n    margin: 0 auto;\n\n    width: 1050px;\n    height: 1550px;\n    background-color: white;\n\n}\n\n.top {\n    position: relative;\n    width: 100%;\n    height: 290px;\n    background-color: #3084bf;\n    margin-top: 10px;\n    padding-top: 10px;\n    padding-left: 20px;\n    padding-right: 20px;\n    -webkit-border-radius:10px 10px 0 0;\n}\n\n.portrait {\n    margin: 0 auto;\n    position: relative;;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    background-image:url(../image/image.png);\n    background-size: 120%;\n    background-position:center;\n    border-radius:50%;\n    background-color: #076f94;\n    width:160px;\n    height:160px;\n}\n\n.side {\n    position: absolute;\n    width: 360px;\n    background-color: #EEEEEE;\n    padding: 20px;\n}\n\n\n\n.main {\n    \n    position: absolute;;\n    margin-left: 360px;\n    min-height: 100%;\n    padding: 20px;\n\n}\n\n.info-header:hover {\n    background-color: #d4dee4;\n}\n\n.info-unit ul li:hover {\n    background-color: #d4dee4;\n}\n\n.info-header .unit-remove {\n    float: right;\n    margin-left: 20px;\n    visibility: hidden;\n    cursor: pointer;\n\n}\n\n.info-header .item-add {\n    float: right;\n    margin-left: 20px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .item-remove {\n    position: absolute;\n    right: 2px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\nul li{\n    position: relative;\n}\n\n .experience-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .stack-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n\n","source":"about/static/css/style.css","raw":"@font-face {font-family: 'iconfont';\n    src: url('../fonts/iconfont.eot'); /* IE9*/\n    src: url('../fonts/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../fonts/iconfont.woff') format('woff'), /* chrome、firefox */\n    url('../fonts/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('../fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n\n.icon-work:before { content: \"\\eac9\"; }\n.icon-project:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-star:before { content: \"\\ed1d\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-education:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-flower:before { content: \"\\ec0a\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-trophy:before { content: \"\\e80b\"; }\n\nspan {\n    display: inline-block;\n}\n\n.label-value{\n    width: 200px;\n    vertical-align: top;\n}\n\n.iconfont {\n    font-family:\"iconfont\" !important;\n    font-size:1.1em;font-style:normal;\n    color:inherit;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n* {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    margin: 0; \n}\n\nh1 {\n    font-weight: 700;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\n\nh2 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #3084bf;\n    line-height: 1.5;\n}\n\n\nh3, h5 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\nh4 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #cccccc;\n    background-color: #076f94;\n    margin: 0 auto;\n    -webkit-border-radius:5px 5px 5px 5px;\n    width: 250px;\n\n    line-height: 1.5;\n}\n.progress-list div {\n    width: 100%;\n    margin-left: 200px;\n}\n\n.info-list, .progress-list{\n    list-style: none;\n    padding-left: 0px;\n    font-size: 16px;\n    line-height: 2;\n}\n\n.stack-list {\n    list-style: none;\n    padding-left: 0px;\n    line-height: 1.5;\n}\n\n.stack-list li {\n    margin-bottom: 12px;\n}\n\n.right-list li {\n    margin-bottom: 12px;\n}\n\n\nhr {\n    margin-bottom: 8px;\n    border-bottom:1px solid #3084bf;\n}\n\n.info-unit {\n    color: #666;\n    margin-bottom: 20px;\n}\n\n.remodal-img h3 {\n    float: left;\n    margin-bottom: 10px;\n}\n\n.remodal-img input {\n    float: left;\n    width: 480px;\n    height: 42px;\n    font-size: 20px;\n    padding: 6px;\n    color: #666;\n    \n}\n\n.remodal-img button {\n    float: right;\n    background: #607d8b;\n\n}\n\n.remodal-img button:hover{\n    float: right;\n    background: #607d8b;\n\n}\n\n\nbody {\n    background-color: #ffffcc;\n    font-family: sans-serif, Microsoft Yahei, Helvetica Neue;\n    zoom: 80%;\n}\n\nfooter {\n}\n\np {\n    line-height: 1.5;\n}\n\nprogress {\n    background-color: #f6f6f6;\n    display: inline;\n    /*width: 195px;*/\n    height: 1em;\n\n}\n\nprogress::-webkit-progress-bar {\n    background-color: #e0eaf0;\n}\n\nprogress::-webkit-progress-value {\n    background-color: #708d9b;\n}\n\nprogress::-moz-progress-bar {\n    background-color: #e0eaf0;\n\n}\n\nprogress::-moz-progress-value {\n    background-color: #708d9b;\n}\n\n.progress-list {\n    line-height: 2;\n}\n\n\n\n.me {\n    text-align: center;\n    margin-top: 20px;\n}\n\n.weixin{\n    margin-top: 20px;\n    background-color: #e0eaf0;   \n    position: relative;\n    padding-top: 40px;\n    padding-bottom: 40px;\n    text-align: center;\n}\n\n.weixin img{\n    width: 200px;\n}\n\n.left-label {\n    display: inline-block;\n    width: 120px;\n}\n\n\n\n.container {\n    position: relative;\n    margin: 0 auto;\n\n    width: 1050px;\n    height: 1550px;\n    background-color: white;\n\n}\n\n.top {\n    position: relative;\n    width: 100%;\n    height: 290px;\n    background-color: #3084bf;\n    margin-top: 10px;\n    padding-top: 10px;\n    padding-left: 20px;\n    padding-right: 20px;\n    -webkit-border-radius:10px 10px 0 0;\n}\n\n.portrait {\n    margin: 0 auto;\n    position: relative;;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    background-image:url(../image/image.png);\n    background-size: 120%;\n    background-position:center;\n    border-radius:50%;\n    background-color: #076f94;\n    width:160px;\n    height:160px;\n}\n\n.side {\n    position: absolute;\n    width: 360px;\n    background-color: #EEEEEE;\n    padding: 20px;\n}\n\n\n\n.main {\n    \n    position: absolute;;\n    margin-left: 360px;\n    min-height: 100%;\n    padding: 20px;\n\n}\n\n.info-header:hover {\n    background-color: #d4dee4;\n}\n\n.info-unit ul li:hover {\n    background-color: #d4dee4;\n}\n\n.info-header .unit-remove {\n    float: right;\n    margin-left: 20px;\n    visibility: hidden;\n    cursor: pointer;\n\n}\n\n.info-header .item-add {\n    float: right;\n    margin-left: 20px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .item-remove {\n    position: absolute;\n    right: 2px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\nul li{\n    position: relative;\n}\n\n .experience-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .stack-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n\n","date":"2016-11-11T04:07:38.140Z","updated":"2016-11-11T04:07:38.140Z","path":"about/static/css/style.css","layout":"false","title":"","comments":1,"_id":"cjbvt9n5q008kbkw1a40rn65d","content":"@font-face {font-family: 'iconfont';\n    src: url('../fonts/iconfont.eot'); /* IE9*/\n    src: url('../fonts/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../fonts/iconfont.woff') format('woff'), /* chrome、firefox */\n    url('../fonts/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('../fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n\n.icon-work:before { content: \"\\eac9\"; }\n.icon-project:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-star:before { content: \"\\ed1d\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-education:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-flower:before { content: \"\\ec0a\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-trophy:before { content: \"\\e80b\"; }\n\nspan {\n    display: inline-block;\n}\n\n.label-value{\n    width: 200px;\n    vertical-align: top;\n}\n\n.iconfont {\n    font-family:\"iconfont\" !important;\n    font-size:1.1em;font-style:normal;\n    color:inherit;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n* {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    margin: 0; \n}\n\nh1 {\n    font-weight: 700;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\n\nh2 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #3084bf;\n    line-height: 1.5;\n}\n\n\nh3, h5 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\nh4 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #cccccc;\n    background-color: #076f94;\n    margin: 0 auto;\n    -webkit-border-radius:5px 5px 5px 5px;\n    width: 250px;\n\n    line-height: 1.5;\n}\n.progress-list div {\n    width: 100%;\n    margin-left: 200px;\n}\n\n.info-list, .progress-list{\n    list-style: none;\n    padding-left: 0px;\n    font-size: 16px;\n    line-height: 2;\n}\n\n.stack-list {\n    list-style: none;\n    padding-left: 0px;\n    line-height: 1.5;\n}\n\n.stack-list li {\n    margin-bottom: 12px;\n}\n\n.right-list li {\n    margin-bottom: 12px;\n}\n\n\nhr {\n    margin-bottom: 8px;\n    border-bottom:1px solid #3084bf;\n}\n\n.info-unit {\n    color: #666;\n    margin-bottom: 20px;\n}\n\n.remodal-img h3 {\n    float: left;\n    margin-bottom: 10px;\n}\n\n.remodal-img input {\n    float: left;\n    width: 480px;\n    height: 42px;\n    font-size: 20px;\n    padding: 6px;\n    color: #666;\n    \n}\n\n.remodal-img button {\n    float: right;\n    background: #607d8b;\n\n}\n\n.remodal-img button:hover{\n    float: right;\n    background: #607d8b;\n\n}\n\n\nbody {\n    background-color: #ffffcc;\n    font-family: sans-serif, Microsoft Yahei, Helvetica Neue;\n    zoom: 80%;\n}\n\nfooter {\n}\n\np {\n    line-height: 1.5;\n}\n\nprogress {\n    background-color: #f6f6f6;\n    display: inline;\n    /*width: 195px;*/\n    height: 1em;\n\n}\n\nprogress::-webkit-progress-bar {\n    background-color: #e0eaf0;\n}\n\nprogress::-webkit-progress-value {\n    background-color: #708d9b;\n}\n\nprogress::-moz-progress-bar {\n    background-color: #e0eaf0;\n\n}\n\nprogress::-moz-progress-value {\n    background-color: #708d9b;\n}\n\n.progress-list {\n    line-height: 2;\n}\n\n\n\n.me {\n    text-align: center;\n    margin-top: 20px;\n}\n\n.weixin{\n    margin-top: 20px;\n    background-color: #e0eaf0;   \n    position: relative;\n    padding-top: 40px;\n    padding-bottom: 40px;\n    text-align: center;\n}\n\n.weixin img{\n    width: 200px;\n}\n\n.left-label {\n    display: inline-block;\n    width: 120px;\n}\n\n\n\n.container {\n    position: relative;\n    margin: 0 auto;\n\n    width: 1050px;\n    height: 1550px;\n    background-color: white;\n\n}\n\n.top {\n    position: relative;\n    width: 100%;\n    height: 290px;\n    background-color: #3084bf;\n    margin-top: 10px;\n    padding-top: 10px;\n    padding-left: 20px;\n    padding-right: 20px;\n    -webkit-border-radius:10px 10px 0 0;\n}\n\n.portrait {\n    margin: 0 auto;\n    position: relative;;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    background-image:url(../image/image.png);\n    background-size: 120%;\n    background-position:center;\n    border-radius:50%;\n    background-color: #076f94;\n    width:160px;\n    height:160px;\n}\n\n.side {\n    position: absolute;\n    width: 360px;\n    background-color: #EEEEEE;\n    padding: 20px;\n}\n\n\n\n.main {\n    \n    position: absolute;;\n    margin-left: 360px;\n    min-height: 100%;\n    padding: 20px;\n\n}\n\n.info-header:hover {\n    background-color: #d4dee4;\n}\n\n.info-unit ul li:hover {\n    background-color: #d4dee4;\n}\n\n.info-header .unit-remove {\n    float: right;\n    margin-left: 20px;\n    visibility: hidden;\n    cursor: pointer;\n\n}\n\n.info-header .item-add {\n    float: right;\n    margin-left: 20px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .item-remove {\n    position: absolute;\n    right: 2px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\nul li{\n    position: relative;\n}\n\n .experience-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .stack-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n\n","excerpt":"","more":"@font-face {font-family: 'iconfont';\n    src: url('../fonts/iconfont.eot'); /* IE9*/\n    src: url('../fonts/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../fonts/iconfont.woff') format('woff'), /* chrome、firefox */\n    url('../fonts/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('../fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n\n.icon-work:before { content: \"\\eac9\"; }\n.icon-project:before { content: \"\\eaf4\"; }\n.icon-phone:before { content: \"\\ec7a\"; }\n.icon-stars:before { content: \"\\ed32\"; }\n.icon-star:before { content: \"\\ed1d\"; }\n.icon-person:before { content: \"\\ec88\"; }\n.icon-librarybooks:before { content: \"\\ebf9\"; }\n.icon-education:before { content: \"\\ebca\"; }\n.icon-create:before { content: \"\\eaf8\"; }\n.icon-call:before { content: \"\\eab6\"; }\n.icon-weixin:before { content: \"\\3488\"; }\n.icon-build:before { content: \"\\eaa2\"; }\n.icon-edit:before { content: \"\\eb31\"; }\n.icon-flower:before { content: \"\\ec0a\"; }\n.icon-playlistadd:before { content: \"\\ecae\"; }\n.icon-delete:before { content: \"\\e61b\"; }\n.icon-trophy:before { content: \"\\e80b\"; }\n\nspan {\n    display: inline-block;\n}\n\n.label-value{\n    width: 200px;\n    vertical-align: top;\n}\n\n.iconfont {\n    font-family:\"iconfont\" !important;\n    font-size:1.1em;font-style:normal;\n    color:inherit;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n* {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    margin: 0; \n}\n\nh1 {\n    font-weight: 700;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\n\nh2 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #3084bf;\n    line-height: 1.5;\n}\n\n\nh3, h5 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #003366;\n    line-height: 1.5;\n}\nh4 {\n    font-weight: 500;\n    font-family:微软雅黑;\n    color: #cccccc;\n    background-color: #076f94;\n    margin: 0 auto;\n    -webkit-border-radius:5px 5px 5px 5px;\n    width: 250px;\n\n    line-height: 1.5;\n}\n.progress-list div {\n    width: 100%;\n    margin-left: 200px;\n}\n\n.info-list, .progress-list{\n    list-style: none;\n    padding-left: 0px;\n    font-size: 16px;\n    line-height: 2;\n}\n\n.stack-list {\n    list-style: none;\n    padding-left: 0px;\n    line-height: 1.5;\n}\n\n.stack-list li {\n    margin-bottom: 12px;\n}\n\n.right-list li {\n    margin-bottom: 12px;\n}\n\n\nhr {\n    margin-bottom: 8px;\n    border-bottom:1px solid #3084bf;\n}\n\n.info-unit {\n    color: #666;\n    margin-bottom: 20px;\n}\n\n.remodal-img h3 {\n    float: left;\n    margin-bottom: 10px;\n}\n\n.remodal-img input {\n    float: left;\n    width: 480px;\n    height: 42px;\n    font-size: 20px;\n    padding: 6px;\n    color: #666;\n    \n}\n\n.remodal-img button {\n    float: right;\n    background: #607d8b;\n\n}\n\n.remodal-img button:hover{\n    float: right;\n    background: #607d8b;\n\n}\n\n\nbody {\n    background-color: #ffffcc;\n    font-family: sans-serif, Microsoft Yahei, Helvetica Neue;\n    zoom: 80%;\n}\n\nfooter {\n}\n\np {\n    line-height: 1.5;\n}\n\nprogress {\n    background-color: #f6f6f6;\n    display: inline;\n    /*width: 195px;*/\n    height: 1em;\n\n}\n\nprogress::-webkit-progress-bar {\n    background-color: #e0eaf0;\n}\n\nprogress::-webkit-progress-value {\n    background-color: #708d9b;\n}\n\nprogress::-moz-progress-bar {\n    background-color: #e0eaf0;\n\n}\n\nprogress::-moz-progress-value {\n    background-color: #708d9b;\n}\n\n.progress-list {\n    line-height: 2;\n}\n\n\n\n.me {\n    text-align: center;\n    margin-top: 20px;\n}\n\n.weixin{\n    margin-top: 20px;\n    background-color: #e0eaf0;   \n    position: relative;\n    padding-top: 40px;\n    padding-bottom: 40px;\n    text-align: center;\n}\n\n.weixin img{\n    width: 200px;\n}\n\n.left-label {\n    display: inline-block;\n    width: 120px;\n}\n\n\n\n.container {\n    position: relative;\n    margin: 0 auto;\n\n    width: 1050px;\n    height: 1550px;\n    background-color: white;\n\n}\n\n.top {\n    position: relative;\n    width: 100%;\n    height: 290px;\n    background-color: #3084bf;\n    margin-top: 10px;\n    padding-top: 10px;\n    padding-left: 20px;\n    padding-right: 20px;\n    -webkit-border-radius:10px 10px 0 0;\n}\n\n.portrait {\n    margin: 0 auto;\n    position: relative;;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    background-image:url(../image/image.png);\n    background-size: 120%;\n    background-position:center;\n    border-radius:50%;\n    background-color: #076f94;\n    width:160px;\n    height:160px;\n}\n\n.side {\n    position: absolute;\n    width: 360px;\n    background-color: #EEEEEE;\n    padding: 20px;\n}\n\n\n\n.main {\n    \n    position: absolute;;\n    margin-left: 360px;\n    min-height: 100%;\n    padding: 20px;\n\n}\n\n.info-header:hover {\n    background-color: #d4dee4;\n}\n\n.info-unit ul li:hover {\n    background-color: #d4dee4;\n}\n\n.info-header .unit-remove {\n    float: right;\n    margin-left: 20px;\n    visibility: hidden;\n    cursor: pointer;\n\n}\n\n.info-header .item-add {\n    float: right;\n    margin-left: 20px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .item-remove {\n    position: absolute;\n    right: 2px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\nul li{\n    position: relative;\n}\n\n .experience-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n .stack-list .item-remove {\n    position: absolute;\n    right: 2px;\n    top: 0px;\n    margin-right: 2px;\n    visibility: hidden;\n    cursor: pointer;\n    \n}\n\n\n"},{"_content":"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>IconFont</title>\n    <link rel=\"stylesheet\" href=\"demo.css\">\n    <link rel=\"stylesheet\" href=\"iconfont.css\">\n</head>\n<body>\n    <div class=\"main\">\n        <h1>IconFont 图标</h1>\n        <ul class=\"icon_lists clear\">\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea39;</i>\n                    <div class=\"name\">account_circle</div>\n                    <div class=\"code\">&amp;#xea39;</div>\n                    <div class=\"fontclass\">.accountcircle</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeac9;</i>\n                    <div class=\"name\">card_travel</div>\n                    <div class=\"code\">&amp;#xeac9;</div>\n                    <div class=\"fontclass\">.cardtravel</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf4;</i>\n                    <div class=\"name\">content_paste</div>\n                    <div class=\"code\">&amp;#xeaf4;</div>\n                    <div class=\"fontclass\">.contentpaste</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7a;</i>\n                    <div class=\"name\">phone</div>\n                    <div class=\"code\">&amp;#xec7a;</div>\n                    <div class=\"fontclass\">.phone</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7b;</i>\n                    <div class=\"name\">phone_android</div>\n                    <div class=\"code\">&amp;#xec7b;</div>\n                    <div class=\"fontclass\">.phoneandroid</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed32;</i>\n                    <div class=\"name\">stars</div>\n                    <div class=\"code\">&amp;#xed32;</div>\n                    <div class=\"fontclass\">.stars</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1d;</i>\n                    <div class=\"name\">star_outline</div>\n                    <div class=\"code\">&amp;#xed1d;</div>\n                    <div class=\"fontclass\">.staroutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1b;</i>\n                    <div class=\"name\">star</div>\n                    <div class=\"code\">&amp;#xed1b;</div>\n                    <div class=\"fontclass\">.star</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec88;</i>\n                    <div class=\"name\">person</div>\n                    <div class=\"code\">&amp;#xec88;</div>\n                    <div class=\"fontclass\">.person</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xedac;</i>\n                    <div class=\"name\">work</div>\n                    <div class=\"code\">&amp;#xedac;</div>\n                    <div class=\"fontclass\">.work</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebf9;</i>\n                    <div class=\"name\">library_books</div>\n                    <div class=\"code\">&amp;#xebf9;</div>\n                    <div class=\"fontclass\">.librarybooks</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebca;</i>\n                    <div class=\"name\">import_contacts</div>\n                    <div class=\"code\">&amp;#xebca;</div>\n                    <div class=\"fontclass\">.importcontacts</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf8;</i>\n                    <div class=\"name\">create</div>\n                    <div class=\"code\">&amp;#xeaf8;</div>\n                    <div class=\"fontclass\">.create</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead7;</i>\n                    <div class=\"name\">comment</div>\n                    <div class=\"code\">&amp;#xead7;</div>\n                    <div class=\"fontclass\">.comment</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeab6;</i>\n                    <div class=\"name\">call</div>\n                    <div class=\"code\">&amp;#xeab6;</div>\n                    <div class=\"fontclass\">.call</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#x3488;</i>\n                    <div class=\"name\">微信</div>\n                    <div class=\"code\">&amp;#x3488;</div>\n                    <div class=\"fontclass\">.weixin</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeabe;</i>\n                    <div class=\"name\">camera</div>\n                    <div class=\"code\">&amp;#xeabe;</div>\n                    <div class=\"fontclass\">.camera</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaa2;</i>\n                    <div class=\"name\">build</div>\n                    <div class=\"code\">&amp;#xeaa2;</div>\n                    <div class=\"fontclass\">.build</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea38;</i>\n                    <div class=\"name\">account_box</div>\n                    <div class=\"code\">&amp;#xea38;</div>\n                    <div class=\"fontclass\">.accountbox</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea7d;</i>\n                    <div class=\"name\">attach_money</div>\n                    <div class=\"code\">&amp;#xea7d;</div>\n                    <div class=\"fontclass\">.attachmoney</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea95;</i>\n                    <div class=\"name\">bookmark_outline</div>\n                    <div class=\"code\">&amp;#xea95;</div>\n                    <div class=\"fontclass\">.bookmarkoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead2;</i>\n                    <div class=\"name\">chat_bubble_outline</div>\n                    <div class=\"code\">&amp;#xead2;</div>\n                    <div class=\"fontclass\">.chatbubbleoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead0;</i>\n                    <div class=\"name\">chat</div>\n                    <div class=\"code\">&amp;#xead0;</div>\n                    <div class=\"fontclass\">.chat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeadf;</i>\n                    <div class=\"name\">cloud</div>\n                    <div class=\"code\">&amp;#xeadf;</div>\n                    <div class=\"fontclass\">.cloud</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0f;</i>\n                    <div class=\"name\">desktop_windows</div>\n                    <div class=\"code\">&amp;#xeb0f;</div>\n                    <div class=\"fontclass\">.desktopwindows</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0e;</i>\n                    <div class=\"name\">desktop_mac</div>\n                    <div class=\"code\">&amp;#xeb0e;</div>\n                    <div class=\"fontclass\">.desktopmac</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb31;</i>\n                    <div class=\"name\">edit</div>\n                    <div class=\"code\">&amp;#xeb31;</div>\n                    <div class=\"fontclass\">.edit</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4d;</i>\n                    <div class=\"name\">favorite_outline</div>\n                    <div class=\"code\">&amp;#xeb4d;</div>\n                    <div class=\"fontclass\">.favoriteoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4c;</i>\n                    <div class=\"name\">favorite</div>\n                    <div class=\"code\">&amp;#xeb4c;</div>\n                    <div class=\"fontclass\">.favorite</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb45;</i>\n                    <div class=\"name\">exposure_plus_1</div>\n                    <div class=\"code\">&amp;#xeb45;</div>\n                    <div class=\"fontclass\">.exposureplus1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb48;</i>\n                    <div class=\"name\">extension</div>\n                    <div class=\"code\">&amp;#xeb48;</div>\n                    <div class=\"fontclass\">.extension</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6f;</i>\n                    <div class=\"name\">flag</div>\n                    <div class=\"code\">&amp;#xeb6f;</div>\n                    <div class=\"fontclass\">.flag</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6e;</i>\n                    <div class=\"name\">fitness_center</div>\n                    <div class=\"code\">&amp;#xeb6e;</div>\n                    <div class=\"fontclass\">.fitnesscenter</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb9c;</i>\n                    <div class=\"name\">free_breakfast</div>\n                    <div class=\"code\">&amp;#xeb9c;</div>\n                    <div class=\"fontclass\">.freebreakfast</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb97;</i>\n                    <div class=\"name\">forum</div>\n                    <div class=\"code\">&amp;#xeb97;</div>\n                    <div class=\"fontclass\">.forum</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeba3;</i>\n                    <div class=\"name\">goat</div>\n                    <div class=\"code\">&amp;#xeba3;</div>\n                    <div class=\"fontclass\">.goat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc2;</i>\n                    <div class=\"name\">home</div>\n                    <div class=\"code\">&amp;#xebc2;</div>\n                    <div class=\"fontclass\">.home</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc5;</i>\n                    <div class=\"name\">hourglass_empty</div>\n                    <div class=\"code\">&amp;#xebc5;</div>\n                    <div class=\"fontclass\">.hourglassempty</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec0a;</i>\n                    <div class=\"name\">local_florist</div>\n                    <div class=\"code\">&amp;#xec0a;</div>\n                    <div class=\"fontclass\">.localflorist</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec24;</i>\n                    <div class=\"name\">location_on</div>\n                    <div class=\"code\">&amp;#xec24;</div>\n                    <div class=\"fontclass\">.locationon</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec10;</i>\n                    <div class=\"name\">local_library</div>\n                    <div class=\"code\">&amp;#xec10;</div>\n                    <div class=\"fontclass\">.locallibrary</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xecae;</i>\n                    <div class=\"name\">playlist_add</div>\n                    <div class=\"code\">&amp;#xecae;</div>\n                    <div class=\"fontclass\">.playlistadd</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc0;</i>\n                    <div class=\"name\">highlight_remove</div>\n                    <div class=\"code\">&amp;#xebc0;</div>\n                    <div class=\"fontclass\">.highlightremove</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe61b;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe61b;</div>\n                    <div class=\"fontclass\">.delete</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe610;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe610;</div>\n                    <div class=\"fontclass\">.delete1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe643;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe643;</div>\n                    <div class=\"fontclass\">.delete2</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe620;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe620;</div>\n                    <div class=\"fontclass\">.add</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe676;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe676;</div>\n                    <div class=\"fontclass\">.add1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe816;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe816;</div>\n                    <div class=\"fontclass\">.trophy</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe6fc;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe6fc;</div>\n                    <div class=\"fontclass\">.trophy1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe80b;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe80b;</div>\n                    <div class=\"fontclass\">.trophy2</div>\n                </li>\n            \n        </ul>\n\n\n        <div class=\"helps\">\n            第一步：使用font-face声明字体\n            <pre>\n@font-face {font-family: 'iconfont';\n    src: url('iconfont.eot'); /* IE9*/\n    src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('iconfont.woff') format('woff'), /* chrome、firefox */\n    url('iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n</pre>\n第二步：定义使用iconfont的样式\n            <pre>\n.iconfont{\n    font-family:\"iconfont\" !important;\n    font-size:16px;font-style:normal;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;}\n</pre>\n第三步：挑选相应图标并获取字体编码，应用于页面\n<pre>\n&lt;i class=\"iconfont\"&gt;&amp;#x33;&lt;/i&gt;\n</pre>\n        </div>\n\n    </div>\n</body>\n</html>\n","source":"about/static/fonts/demo.html","raw":"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>IconFont</title>\n    <link rel=\"stylesheet\" href=\"demo.css\">\n    <link rel=\"stylesheet\" href=\"iconfont.css\">\n</head>\n<body>\n    <div class=\"main\">\n        <h1>IconFont 图标</h1>\n        <ul class=\"icon_lists clear\">\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea39;</i>\n                    <div class=\"name\">account_circle</div>\n                    <div class=\"code\">&amp;#xea39;</div>\n                    <div class=\"fontclass\">.accountcircle</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeac9;</i>\n                    <div class=\"name\">card_travel</div>\n                    <div class=\"code\">&amp;#xeac9;</div>\n                    <div class=\"fontclass\">.cardtravel</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf4;</i>\n                    <div class=\"name\">content_paste</div>\n                    <div class=\"code\">&amp;#xeaf4;</div>\n                    <div class=\"fontclass\">.contentpaste</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7a;</i>\n                    <div class=\"name\">phone</div>\n                    <div class=\"code\">&amp;#xec7a;</div>\n                    <div class=\"fontclass\">.phone</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7b;</i>\n                    <div class=\"name\">phone_android</div>\n                    <div class=\"code\">&amp;#xec7b;</div>\n                    <div class=\"fontclass\">.phoneandroid</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed32;</i>\n                    <div class=\"name\">stars</div>\n                    <div class=\"code\">&amp;#xed32;</div>\n                    <div class=\"fontclass\">.stars</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1d;</i>\n                    <div class=\"name\">star_outline</div>\n                    <div class=\"code\">&amp;#xed1d;</div>\n                    <div class=\"fontclass\">.staroutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1b;</i>\n                    <div class=\"name\">star</div>\n                    <div class=\"code\">&amp;#xed1b;</div>\n                    <div class=\"fontclass\">.star</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec88;</i>\n                    <div class=\"name\">person</div>\n                    <div class=\"code\">&amp;#xec88;</div>\n                    <div class=\"fontclass\">.person</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xedac;</i>\n                    <div class=\"name\">work</div>\n                    <div class=\"code\">&amp;#xedac;</div>\n                    <div class=\"fontclass\">.work</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebf9;</i>\n                    <div class=\"name\">library_books</div>\n                    <div class=\"code\">&amp;#xebf9;</div>\n                    <div class=\"fontclass\">.librarybooks</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebca;</i>\n                    <div class=\"name\">import_contacts</div>\n                    <div class=\"code\">&amp;#xebca;</div>\n                    <div class=\"fontclass\">.importcontacts</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf8;</i>\n                    <div class=\"name\">create</div>\n                    <div class=\"code\">&amp;#xeaf8;</div>\n                    <div class=\"fontclass\">.create</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead7;</i>\n                    <div class=\"name\">comment</div>\n                    <div class=\"code\">&amp;#xead7;</div>\n                    <div class=\"fontclass\">.comment</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeab6;</i>\n                    <div class=\"name\">call</div>\n                    <div class=\"code\">&amp;#xeab6;</div>\n                    <div class=\"fontclass\">.call</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#x3488;</i>\n                    <div class=\"name\">微信</div>\n                    <div class=\"code\">&amp;#x3488;</div>\n                    <div class=\"fontclass\">.weixin</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeabe;</i>\n                    <div class=\"name\">camera</div>\n                    <div class=\"code\">&amp;#xeabe;</div>\n                    <div class=\"fontclass\">.camera</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaa2;</i>\n                    <div class=\"name\">build</div>\n                    <div class=\"code\">&amp;#xeaa2;</div>\n                    <div class=\"fontclass\">.build</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea38;</i>\n                    <div class=\"name\">account_box</div>\n                    <div class=\"code\">&amp;#xea38;</div>\n                    <div class=\"fontclass\">.accountbox</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea7d;</i>\n                    <div class=\"name\">attach_money</div>\n                    <div class=\"code\">&amp;#xea7d;</div>\n                    <div class=\"fontclass\">.attachmoney</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea95;</i>\n                    <div class=\"name\">bookmark_outline</div>\n                    <div class=\"code\">&amp;#xea95;</div>\n                    <div class=\"fontclass\">.bookmarkoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead2;</i>\n                    <div class=\"name\">chat_bubble_outline</div>\n                    <div class=\"code\">&amp;#xead2;</div>\n                    <div class=\"fontclass\">.chatbubbleoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead0;</i>\n                    <div class=\"name\">chat</div>\n                    <div class=\"code\">&amp;#xead0;</div>\n                    <div class=\"fontclass\">.chat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeadf;</i>\n                    <div class=\"name\">cloud</div>\n                    <div class=\"code\">&amp;#xeadf;</div>\n                    <div class=\"fontclass\">.cloud</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0f;</i>\n                    <div class=\"name\">desktop_windows</div>\n                    <div class=\"code\">&amp;#xeb0f;</div>\n                    <div class=\"fontclass\">.desktopwindows</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0e;</i>\n                    <div class=\"name\">desktop_mac</div>\n                    <div class=\"code\">&amp;#xeb0e;</div>\n                    <div class=\"fontclass\">.desktopmac</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb31;</i>\n                    <div class=\"name\">edit</div>\n                    <div class=\"code\">&amp;#xeb31;</div>\n                    <div class=\"fontclass\">.edit</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4d;</i>\n                    <div class=\"name\">favorite_outline</div>\n                    <div class=\"code\">&amp;#xeb4d;</div>\n                    <div class=\"fontclass\">.favoriteoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4c;</i>\n                    <div class=\"name\">favorite</div>\n                    <div class=\"code\">&amp;#xeb4c;</div>\n                    <div class=\"fontclass\">.favorite</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb45;</i>\n                    <div class=\"name\">exposure_plus_1</div>\n                    <div class=\"code\">&amp;#xeb45;</div>\n                    <div class=\"fontclass\">.exposureplus1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb48;</i>\n                    <div class=\"name\">extension</div>\n                    <div class=\"code\">&amp;#xeb48;</div>\n                    <div class=\"fontclass\">.extension</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6f;</i>\n                    <div class=\"name\">flag</div>\n                    <div class=\"code\">&amp;#xeb6f;</div>\n                    <div class=\"fontclass\">.flag</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6e;</i>\n                    <div class=\"name\">fitness_center</div>\n                    <div class=\"code\">&amp;#xeb6e;</div>\n                    <div class=\"fontclass\">.fitnesscenter</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb9c;</i>\n                    <div class=\"name\">free_breakfast</div>\n                    <div class=\"code\">&amp;#xeb9c;</div>\n                    <div class=\"fontclass\">.freebreakfast</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb97;</i>\n                    <div class=\"name\">forum</div>\n                    <div class=\"code\">&amp;#xeb97;</div>\n                    <div class=\"fontclass\">.forum</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeba3;</i>\n                    <div class=\"name\">goat</div>\n                    <div class=\"code\">&amp;#xeba3;</div>\n                    <div class=\"fontclass\">.goat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc2;</i>\n                    <div class=\"name\">home</div>\n                    <div class=\"code\">&amp;#xebc2;</div>\n                    <div class=\"fontclass\">.home</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc5;</i>\n                    <div class=\"name\">hourglass_empty</div>\n                    <div class=\"code\">&amp;#xebc5;</div>\n                    <div class=\"fontclass\">.hourglassempty</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec0a;</i>\n                    <div class=\"name\">local_florist</div>\n                    <div class=\"code\">&amp;#xec0a;</div>\n                    <div class=\"fontclass\">.localflorist</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec24;</i>\n                    <div class=\"name\">location_on</div>\n                    <div class=\"code\">&amp;#xec24;</div>\n                    <div class=\"fontclass\">.locationon</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec10;</i>\n                    <div class=\"name\">local_library</div>\n                    <div class=\"code\">&amp;#xec10;</div>\n                    <div class=\"fontclass\">.locallibrary</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xecae;</i>\n                    <div class=\"name\">playlist_add</div>\n                    <div class=\"code\">&amp;#xecae;</div>\n                    <div class=\"fontclass\">.playlistadd</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc0;</i>\n                    <div class=\"name\">highlight_remove</div>\n                    <div class=\"code\">&amp;#xebc0;</div>\n                    <div class=\"fontclass\">.highlightremove</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe61b;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe61b;</div>\n                    <div class=\"fontclass\">.delete</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe610;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe610;</div>\n                    <div class=\"fontclass\">.delete1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe643;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe643;</div>\n                    <div class=\"fontclass\">.delete2</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe620;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe620;</div>\n                    <div class=\"fontclass\">.add</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe676;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe676;</div>\n                    <div class=\"fontclass\">.add1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe816;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe816;</div>\n                    <div class=\"fontclass\">.trophy</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe6fc;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe6fc;</div>\n                    <div class=\"fontclass\">.trophy1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe80b;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe80b;</div>\n                    <div class=\"fontclass\">.trophy2</div>\n                </li>\n            \n        </ul>\n\n\n        <div class=\"helps\">\n            第一步：使用font-face声明字体\n            <pre>\n@font-face {font-family: 'iconfont';\n    src: url('iconfont.eot'); /* IE9*/\n    src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('iconfont.woff') format('woff'), /* chrome、firefox */\n    url('iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n</pre>\n第二步：定义使用iconfont的样式\n            <pre>\n.iconfont{\n    font-family:\"iconfont\" !important;\n    font-size:16px;font-style:normal;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;}\n</pre>\n第三步：挑选相应图标并获取字体编码，应用于页面\n<pre>\n&lt;i class=\"iconfont\"&gt;&amp;#x33;&lt;/i&gt;\n</pre>\n        </div>\n\n    </div>\n</body>\n</html>\n","date":"2016-11-10T07:20:45.277Z","updated":"2016-11-10T07:20:45.277Z","path":"about/static/fonts/demo.html","title":"","comments":1,"layout":"page","_id":"cjbvt9n5q008lbkw1zv3iuyf0","content":"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>IconFont</title>\n    <link rel=\"stylesheet\" href=\"demo.css\">\n    <link rel=\"stylesheet\" href=\"iconfont.css\">\n</head>\n<body>\n    <div class=\"main\">\n        <h1>IconFont 图标</h1>\n        <ul class=\"icon_lists clear\">\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea39;</i>\n                    <div class=\"name\">account_circle</div>\n                    <div class=\"code\">&amp;#xea39;</div>\n                    <div class=\"fontclass\">.accountcircle</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeac9;</i>\n                    <div class=\"name\">card_travel</div>\n                    <div class=\"code\">&amp;#xeac9;</div>\n                    <div class=\"fontclass\">.cardtravel</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf4;</i>\n                    <div class=\"name\">content_paste</div>\n                    <div class=\"code\">&amp;#xeaf4;</div>\n                    <div class=\"fontclass\">.contentpaste</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7a;</i>\n                    <div class=\"name\">phone</div>\n                    <div class=\"code\">&amp;#xec7a;</div>\n                    <div class=\"fontclass\">.phone</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7b;</i>\n                    <div class=\"name\">phone_android</div>\n                    <div class=\"code\">&amp;#xec7b;</div>\n                    <div class=\"fontclass\">.phoneandroid</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed32;</i>\n                    <div class=\"name\">stars</div>\n                    <div class=\"code\">&amp;#xed32;</div>\n                    <div class=\"fontclass\">.stars</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1d;</i>\n                    <div class=\"name\">star_outline</div>\n                    <div class=\"code\">&amp;#xed1d;</div>\n                    <div class=\"fontclass\">.staroutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1b;</i>\n                    <div class=\"name\">star</div>\n                    <div class=\"code\">&amp;#xed1b;</div>\n                    <div class=\"fontclass\">.star</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec88;</i>\n                    <div class=\"name\">person</div>\n                    <div class=\"code\">&amp;#xec88;</div>\n                    <div class=\"fontclass\">.person</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xedac;</i>\n                    <div class=\"name\">work</div>\n                    <div class=\"code\">&amp;#xedac;</div>\n                    <div class=\"fontclass\">.work</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebf9;</i>\n                    <div class=\"name\">library_books</div>\n                    <div class=\"code\">&amp;#xebf9;</div>\n                    <div class=\"fontclass\">.librarybooks</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebca;</i>\n                    <div class=\"name\">import_contacts</div>\n                    <div class=\"code\">&amp;#xebca;</div>\n                    <div class=\"fontclass\">.importcontacts</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf8;</i>\n                    <div class=\"name\">create</div>\n                    <div class=\"code\">&amp;#xeaf8;</div>\n                    <div class=\"fontclass\">.create</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead7;</i>\n                    <div class=\"name\">comment</div>\n                    <div class=\"code\">&amp;#xead7;</div>\n                    <div class=\"fontclass\">.comment</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeab6;</i>\n                    <div class=\"name\">call</div>\n                    <div class=\"code\">&amp;#xeab6;</div>\n                    <div class=\"fontclass\">.call</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#x3488;</i>\n                    <div class=\"name\">微信</div>\n                    <div class=\"code\">&amp;#x3488;</div>\n                    <div class=\"fontclass\">.weixin</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeabe;</i>\n                    <div class=\"name\">camera</div>\n                    <div class=\"code\">&amp;#xeabe;</div>\n                    <div class=\"fontclass\">.camera</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaa2;</i>\n                    <div class=\"name\">build</div>\n                    <div class=\"code\">&amp;#xeaa2;</div>\n                    <div class=\"fontclass\">.build</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea38;</i>\n                    <div class=\"name\">account_box</div>\n                    <div class=\"code\">&amp;#xea38;</div>\n                    <div class=\"fontclass\">.accountbox</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea7d;</i>\n                    <div class=\"name\">attach_money</div>\n                    <div class=\"code\">&amp;#xea7d;</div>\n                    <div class=\"fontclass\">.attachmoney</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea95;</i>\n                    <div class=\"name\">bookmark_outline</div>\n                    <div class=\"code\">&amp;#xea95;</div>\n                    <div class=\"fontclass\">.bookmarkoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead2;</i>\n                    <div class=\"name\">chat_bubble_outline</div>\n                    <div class=\"code\">&amp;#xead2;</div>\n                    <div class=\"fontclass\">.chatbubbleoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead0;</i>\n                    <div class=\"name\">chat</div>\n                    <div class=\"code\">&amp;#xead0;</div>\n                    <div class=\"fontclass\">.chat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeadf;</i>\n                    <div class=\"name\">cloud</div>\n                    <div class=\"code\">&amp;#xeadf;</div>\n                    <div class=\"fontclass\">.cloud</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0f;</i>\n                    <div class=\"name\">desktop_windows</div>\n                    <div class=\"code\">&amp;#xeb0f;</div>\n                    <div class=\"fontclass\">.desktopwindows</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0e;</i>\n                    <div class=\"name\">desktop_mac</div>\n                    <div class=\"code\">&amp;#xeb0e;</div>\n                    <div class=\"fontclass\">.desktopmac</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb31;</i>\n                    <div class=\"name\">edit</div>\n                    <div class=\"code\">&amp;#xeb31;</div>\n                    <div class=\"fontclass\">.edit</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4d;</i>\n                    <div class=\"name\">favorite_outline</div>\n                    <div class=\"code\">&amp;#xeb4d;</div>\n                    <div class=\"fontclass\">.favoriteoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4c;</i>\n                    <div class=\"name\">favorite</div>\n                    <div class=\"code\">&amp;#xeb4c;</div>\n                    <div class=\"fontclass\">.favorite</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb45;</i>\n                    <div class=\"name\">exposure_plus_1</div>\n                    <div class=\"code\">&amp;#xeb45;</div>\n                    <div class=\"fontclass\">.exposureplus1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb48;</i>\n                    <div class=\"name\">extension</div>\n                    <div class=\"code\">&amp;#xeb48;</div>\n                    <div class=\"fontclass\">.extension</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6f;</i>\n                    <div class=\"name\">flag</div>\n                    <div class=\"code\">&amp;#xeb6f;</div>\n                    <div class=\"fontclass\">.flag</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6e;</i>\n                    <div class=\"name\">fitness_center</div>\n                    <div class=\"code\">&amp;#xeb6e;</div>\n                    <div class=\"fontclass\">.fitnesscenter</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb9c;</i>\n                    <div class=\"name\">free_breakfast</div>\n                    <div class=\"code\">&amp;#xeb9c;</div>\n                    <div class=\"fontclass\">.freebreakfast</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb97;</i>\n                    <div class=\"name\">forum</div>\n                    <div class=\"code\">&amp;#xeb97;</div>\n                    <div class=\"fontclass\">.forum</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeba3;</i>\n                    <div class=\"name\">goat</div>\n                    <div class=\"code\">&amp;#xeba3;</div>\n                    <div class=\"fontclass\">.goat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc2;</i>\n                    <div class=\"name\">home</div>\n                    <div class=\"code\">&amp;#xebc2;</div>\n                    <div class=\"fontclass\">.home</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc5;</i>\n                    <div class=\"name\">hourglass_empty</div>\n                    <div class=\"code\">&amp;#xebc5;</div>\n                    <div class=\"fontclass\">.hourglassempty</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec0a;</i>\n                    <div class=\"name\">local_florist</div>\n                    <div class=\"code\">&amp;#xec0a;</div>\n                    <div class=\"fontclass\">.localflorist</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec24;</i>\n                    <div class=\"name\">location_on</div>\n                    <div class=\"code\">&amp;#xec24;</div>\n                    <div class=\"fontclass\">.locationon</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec10;</i>\n                    <div class=\"name\">local_library</div>\n                    <div class=\"code\">&amp;#xec10;</div>\n                    <div class=\"fontclass\">.locallibrary</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xecae;</i>\n                    <div class=\"name\">playlist_add</div>\n                    <div class=\"code\">&amp;#xecae;</div>\n                    <div class=\"fontclass\">.playlistadd</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc0;</i>\n                    <div class=\"name\">highlight_remove</div>\n                    <div class=\"code\">&amp;#xebc0;</div>\n                    <div class=\"fontclass\">.highlightremove</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe61b;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe61b;</div>\n                    <div class=\"fontclass\">.delete</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe610;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe610;</div>\n                    <div class=\"fontclass\">.delete1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe643;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe643;</div>\n                    <div class=\"fontclass\">.delete2</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe620;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe620;</div>\n                    <div class=\"fontclass\">.add</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe676;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe676;</div>\n                    <div class=\"fontclass\">.add1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe816;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe816;</div>\n                    <div class=\"fontclass\">.trophy</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe6fc;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe6fc;</div>\n                    <div class=\"fontclass\">.trophy1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe80b;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe80b;</div>\n                    <div class=\"fontclass\">.trophy2</div>\n                </li>\n            \n        </ul>\n\n\n        <div class=\"helps\">\n            第一步：使用font-face声明字体\n            <pre>\n@font-face {font-family: 'iconfont';\n    src: url('iconfont.eot'); /* IE9*/\n    src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('iconfont.woff') format('woff'), /* chrome、firefox */\n    url('iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n</pre>\n第二步：定义使用iconfont的样式\n            <pre>\n.iconfont{\n    font-family:\"iconfont\" !important;\n    font-size:16px;font-style:normal;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;}\n</pre>\n第三步：挑选相应图标并获取字体编码，应用于页面\n<pre>\n&lt;i class=\"iconfont\"&gt;&amp;#x33;&lt;/i&gt;\n</pre>\n        </div>\n\n    </div>\n</body>\n</html>\n","excerpt":"","more":"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>IconFont</title>\n    <link rel=\"stylesheet\" href=\"demo.css\">\n    <link rel=\"stylesheet\" href=\"iconfont.css\">\n</head>\n<body>\n    <div class=\"main\">\n        <h1>IconFont 图标</h1>\n        <ul class=\"icon_lists clear\">\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea39;</i>\n                    <div class=\"name\">account_circle</div>\n                    <div class=\"code\">&amp;#xea39;</div>\n                    <div class=\"fontclass\">.accountcircle</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeac9;</i>\n                    <div class=\"name\">card_travel</div>\n                    <div class=\"code\">&amp;#xeac9;</div>\n                    <div class=\"fontclass\">.cardtravel</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf4;</i>\n                    <div class=\"name\">content_paste</div>\n                    <div class=\"code\">&amp;#xeaf4;</div>\n                    <div class=\"fontclass\">.contentpaste</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7a;</i>\n                    <div class=\"name\">phone</div>\n                    <div class=\"code\">&amp;#xec7a;</div>\n                    <div class=\"fontclass\">.phone</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec7b;</i>\n                    <div class=\"name\">phone_android</div>\n                    <div class=\"code\">&amp;#xec7b;</div>\n                    <div class=\"fontclass\">.phoneandroid</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed32;</i>\n                    <div class=\"name\">stars</div>\n                    <div class=\"code\">&amp;#xed32;</div>\n                    <div class=\"fontclass\">.stars</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1d;</i>\n                    <div class=\"name\">star_outline</div>\n                    <div class=\"code\">&amp;#xed1d;</div>\n                    <div class=\"fontclass\">.staroutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xed1b;</i>\n                    <div class=\"name\">star</div>\n                    <div class=\"code\">&amp;#xed1b;</div>\n                    <div class=\"fontclass\">.star</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec88;</i>\n                    <div class=\"name\">person</div>\n                    <div class=\"code\">&amp;#xec88;</div>\n                    <div class=\"fontclass\">.person</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xedac;</i>\n                    <div class=\"name\">work</div>\n                    <div class=\"code\">&amp;#xedac;</div>\n                    <div class=\"fontclass\">.work</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebf9;</i>\n                    <div class=\"name\">library_books</div>\n                    <div class=\"code\">&amp;#xebf9;</div>\n                    <div class=\"fontclass\">.librarybooks</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebca;</i>\n                    <div class=\"name\">import_contacts</div>\n                    <div class=\"code\">&amp;#xebca;</div>\n                    <div class=\"fontclass\">.importcontacts</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaf8;</i>\n                    <div class=\"name\">create</div>\n                    <div class=\"code\">&amp;#xeaf8;</div>\n                    <div class=\"fontclass\">.create</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead7;</i>\n                    <div class=\"name\">comment</div>\n                    <div class=\"code\">&amp;#xead7;</div>\n                    <div class=\"fontclass\">.comment</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeab6;</i>\n                    <div class=\"name\">call</div>\n                    <div class=\"code\">&amp;#xeab6;</div>\n                    <div class=\"fontclass\">.call</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#x3488;</i>\n                    <div class=\"name\">微信</div>\n                    <div class=\"code\">&amp;#x3488;</div>\n                    <div class=\"fontclass\">.weixin</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeabe;</i>\n                    <div class=\"name\">camera</div>\n                    <div class=\"code\">&amp;#xeabe;</div>\n                    <div class=\"fontclass\">.camera</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeaa2;</i>\n                    <div class=\"name\">build</div>\n                    <div class=\"code\">&amp;#xeaa2;</div>\n                    <div class=\"fontclass\">.build</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea38;</i>\n                    <div class=\"name\">account_box</div>\n                    <div class=\"code\">&amp;#xea38;</div>\n                    <div class=\"fontclass\">.accountbox</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea7d;</i>\n                    <div class=\"name\">attach_money</div>\n                    <div class=\"code\">&amp;#xea7d;</div>\n                    <div class=\"fontclass\">.attachmoney</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xea95;</i>\n                    <div class=\"name\">bookmark_outline</div>\n                    <div class=\"code\">&amp;#xea95;</div>\n                    <div class=\"fontclass\">.bookmarkoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead2;</i>\n                    <div class=\"name\">chat_bubble_outline</div>\n                    <div class=\"code\">&amp;#xead2;</div>\n                    <div class=\"fontclass\">.chatbubbleoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xead0;</i>\n                    <div class=\"name\">chat</div>\n                    <div class=\"code\">&amp;#xead0;</div>\n                    <div class=\"fontclass\">.chat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeadf;</i>\n                    <div class=\"name\">cloud</div>\n                    <div class=\"code\">&amp;#xeadf;</div>\n                    <div class=\"fontclass\">.cloud</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0f;</i>\n                    <div class=\"name\">desktop_windows</div>\n                    <div class=\"code\">&amp;#xeb0f;</div>\n                    <div class=\"fontclass\">.desktopwindows</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb0e;</i>\n                    <div class=\"name\">desktop_mac</div>\n                    <div class=\"code\">&amp;#xeb0e;</div>\n                    <div class=\"fontclass\">.desktopmac</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb31;</i>\n                    <div class=\"name\">edit</div>\n                    <div class=\"code\">&amp;#xeb31;</div>\n                    <div class=\"fontclass\">.edit</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4d;</i>\n                    <div class=\"name\">favorite_outline</div>\n                    <div class=\"code\">&amp;#xeb4d;</div>\n                    <div class=\"fontclass\">.favoriteoutline</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb4c;</i>\n                    <div class=\"name\">favorite</div>\n                    <div class=\"code\">&amp;#xeb4c;</div>\n                    <div class=\"fontclass\">.favorite</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb45;</i>\n                    <div class=\"name\">exposure_plus_1</div>\n                    <div class=\"code\">&amp;#xeb45;</div>\n                    <div class=\"fontclass\">.exposureplus1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb48;</i>\n                    <div class=\"name\">extension</div>\n                    <div class=\"code\">&amp;#xeb48;</div>\n                    <div class=\"fontclass\">.extension</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6f;</i>\n                    <div class=\"name\">flag</div>\n                    <div class=\"code\">&amp;#xeb6f;</div>\n                    <div class=\"fontclass\">.flag</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb6e;</i>\n                    <div class=\"name\">fitness_center</div>\n                    <div class=\"code\">&amp;#xeb6e;</div>\n                    <div class=\"fontclass\">.fitnesscenter</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb9c;</i>\n                    <div class=\"name\">free_breakfast</div>\n                    <div class=\"code\">&amp;#xeb9c;</div>\n                    <div class=\"fontclass\">.freebreakfast</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeb97;</i>\n                    <div class=\"name\">forum</div>\n                    <div class=\"code\">&amp;#xeb97;</div>\n                    <div class=\"fontclass\">.forum</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xeba3;</i>\n                    <div class=\"name\">goat</div>\n                    <div class=\"code\">&amp;#xeba3;</div>\n                    <div class=\"fontclass\">.goat</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc2;</i>\n                    <div class=\"name\">home</div>\n                    <div class=\"code\">&amp;#xebc2;</div>\n                    <div class=\"fontclass\">.home</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc5;</i>\n                    <div class=\"name\">hourglass_empty</div>\n                    <div class=\"code\">&amp;#xebc5;</div>\n                    <div class=\"fontclass\">.hourglassempty</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec0a;</i>\n                    <div class=\"name\">local_florist</div>\n                    <div class=\"code\">&amp;#xec0a;</div>\n                    <div class=\"fontclass\">.localflorist</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec24;</i>\n                    <div class=\"name\">location_on</div>\n                    <div class=\"code\">&amp;#xec24;</div>\n                    <div class=\"fontclass\">.locationon</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xec10;</i>\n                    <div class=\"name\">local_library</div>\n                    <div class=\"code\">&amp;#xec10;</div>\n                    <div class=\"fontclass\">.locallibrary</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xecae;</i>\n                    <div class=\"name\">playlist_add</div>\n                    <div class=\"code\">&amp;#xecae;</div>\n                    <div class=\"fontclass\">.playlistadd</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xebc0;</i>\n                    <div class=\"name\">highlight_remove</div>\n                    <div class=\"code\">&amp;#xebc0;</div>\n                    <div class=\"fontclass\">.highlightremove</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe61b;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe61b;</div>\n                    <div class=\"fontclass\">.delete</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe610;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe610;</div>\n                    <div class=\"fontclass\">.delete1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe643;</i>\n                    <div class=\"name\">delete</div>\n                    <div class=\"code\">&amp;#xe643;</div>\n                    <div class=\"fontclass\">.delete2</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe620;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe620;</div>\n                    <div class=\"fontclass\">.add</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe676;</i>\n                    <div class=\"name\">add</div>\n                    <div class=\"code\">&amp;#xe676;</div>\n                    <div class=\"fontclass\">.add1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe816;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe816;</div>\n                    <div class=\"fontclass\">.trophy</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe6fc;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe6fc;</div>\n                    <div class=\"fontclass\">.trophy1</div>\n                </li>\n            \n                <li>\n                <i class=\"icon iconfont\">&#xe80b;</i>\n                    <div class=\"name\">trophy</div>\n                    <div class=\"code\">&amp;#xe80b;</div>\n                    <div class=\"fontclass\">.trophy2</div>\n                </li>\n            \n        </ul>\n\n\n        <div class=\"helps\">\n            第一步：使用font-face声明字体\n            <pre>\n@font-face {font-family: 'iconfont';\n    src: url('iconfont.eot'); /* IE9*/\n    src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('iconfont.woff') format('woff'), /* chrome、firefox */\n    url('iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n    url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */\n}\n</pre>\n第二步：定义使用iconfont的样式\n            <pre>\n.iconfont{\n    font-family:\"iconfont\" !important;\n    font-size:16px;font-style:normal;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;}\n</pre>\n第三步：挑选相应图标并获取字体编码，应用于页面\n<pre>\n&lt;i class=\"iconfont\"&gt;&amp;#x33;&lt;/i&gt;\n</pre>\n        </div>\n\n    </div>\n</body>\n</html>\n"},{"_content":"$(document).ready(function($){\n    $(\"*\").removeAttr('contenteditable');        \n})","source":"about/static/js/script.js","raw":"$(document).ready(function($){\n    $(\"*\").removeAttr('contenteditable');        \n})","date":"2016-11-10T11:28:16.360Z","updated":"2016-11-10T11:28:16.360Z","path":"about/static/js/script.js","layout":"false","title":"","comments":1,"_id":"cjbvt9n5q008mbkw1wottk28a","content":"$(document).ready(function($){\n    $(\"*\").removeAttr('contenteditable');        \n})","excerpt":"","more":"$(document).ready(function($){\n    $(\"*\").removeAttr('contenteditable');        \n})"},{"_content":"/* =========================================================\n * bootstrap-modal.js v1.4.0\n * http://twitter.github.com/bootstrap/javascript.html#modal\n * =========================================================\n * Copyright 2011 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n\n!function( $ ){\n\n  \"use strict\"\n\n /* CSS TRANSITION SUPPORT (https://gist.github.com/373874)\n  * ======================================================= */\n\n  var transitionEnd\n\n  $(document).ready(function () {\n\n    $.support.transition = (function () {\n      var thisBody = document.body || document.documentElement\n        , thisStyle = thisBody.style\n        , support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined\n      return support\n    })()\n\n    // set CSS transition event type\n    if ( $.support.transition ) {\n      transitionEnd = \"TransitionEnd\"\n      if ( $.browser.webkit ) {\n        transitionEnd = \"webkitTransitionEnd\"\n      } else if ( $.browser.mozilla ) {\n        transitionEnd = \"transitionend\"\n      } else if ( $.browser.opera ) {\n        transitionEnd = \"oTransitionEnd\"\n      }\n    }\n\n  })\n\n\n /* MODAL PUBLIC CLASS DEFINITION\n  * ============================= */\n\n  var Modal = function ( content, options ) {\n    this.settings = $.extend({}, $.fn.modal.defaults, options)\n    this.$element = $(content)\n      .delegate('.close', 'click.modal', $.proxy(this.hide, this))\n\n    if ( this.settings.show ) {\n      this.show()\n    }\n\n    return this\n  }\n\n  Modal.prototype = {\n\n      toggle: function () {\n        return this[!this.isShown ? 'show' : 'hide']()\n      }\n\n    , show: function () {\n        var that = this\n        this.isShown = true\n        this.$element.trigger('show')\n\n        escape.call(this)\n        backdrop.call(this, function () {\n          var transition = $.support.transition && that.$element.hasClass('fade')\n\n          that.$element\n            .appendTo(document.body)\n            .show()\n\n          if (transition) {\n            that.$element[0].offsetWidth // force reflow\n          }\n\n          that.$element.addClass('in')\n\n          transition ?\n            that.$element.one(transitionEnd, function () { that.$element.trigger('shown') }) :\n            that.$element.trigger('shown')\n\n        })\n\n        return this\n      }\n\n    , hide: function (e) {\n        e && e.preventDefault()\n\n        if ( !this.isShown ) {\n          return this\n        }\n\n        var that = this\n        this.isShown = false\n\n        escape.call(this)\n\n        this.$element\n          .trigger('hide')\n          .removeClass('in')\n\n        $.support.transition && this.$element.hasClass('fade') ?\n          hideWithTransition.call(this) :\n          hideModal.call(this)\n\n        return this\n      }\n\n  }\n\n\n /* MODAL PRIVATE METHODS\n  * ===================== */\n\n  function hideWithTransition() {\n    // firefox drops transitionEnd events :{o\n    var that = this\n      , timeout = setTimeout(function () {\n          that.$element.unbind(transitionEnd)\n          hideModal.call(that)\n        }, 500)\n\n    this.$element.one(transitionEnd, function () {\n      clearTimeout(timeout)\n      hideModal.call(that)\n    })\n  }\n\n  function hideModal (that) {\n    this.$element\n      .hide()\n      .trigger('hidden')\n\n    backdrop.call(this)\n  }\n\n  function backdrop ( callback ) {\n    var that = this\n      , animate = this.$element.hasClass('fade') ? 'fade' : ''\n    if ( this.isShown && this.settings.backdrop ) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\n        .appendTo(document.body)\n\n      if ( this.settings.backdrop != 'static' ) {\n        this.$backdrop.click($.proxy(this.hide, this))\n      }\n\n      if ( doAnimate ) {\n        this.$backdrop[0].offsetWidth // force reflow\n      }\n\n      this.$backdrop.addClass('in')\n\n      doAnimate ?\n        this.$backdrop.one(transitionEnd, callback) :\n        callback()\n\n    } else if ( !this.isShown && this.$backdrop ) {\n      this.$backdrop.removeClass('in')\n\n      $.support.transition && this.$element.hasClass('fade')?\n        this.$backdrop.one(transitionEnd, $.proxy(removeBackdrop, this)) :\n        removeBackdrop.call(this)\n\n    } else if ( callback ) {\n       callback()\n    }\n  }\n\n  function removeBackdrop() {\n    this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  function escape() {\n    var that = this\n    if ( this.isShown && this.settings.keyboard ) {\n      $(document).bind('keyup.modal', function ( e ) {\n        if ( e.which == 27 ) {\n          that.hide()\n        }\n      })\n    } else if ( !this.isShown ) {\n      $(document).unbind('keyup.modal')\n    }\n  }\n\n\n /* MODAL PLUGIN DEFINITION\n  * ======================= */\n\n  $.fn.modal = function ( options ) {\n    var modal = this.data('modal')\n\n    if (!modal) {\n\n      if (typeof options == 'string') {\n        options = {\n          show: /show|toggle/.test(options)\n        }\n      }\n\n      return this.each(function () {\n        $(this).data('modal', new Modal(this, options))\n      })\n    }\n\n    if ( options === true ) {\n      return modal\n    }\n\n    if ( typeof options == 'string' ) {\n      modal[options]()\n    } else if ( modal ) {\n      modal.toggle()\n    }\n\n    return this\n  }\n\n  $.fn.modal.Modal = Modal\n\n  $.fn.modal.defaults = {\n    backdrop: false\n  , keyboard: false\n  , show: false\n  }\n\n\n /* MODAL DATA- IMPLEMENTATION\n  * ========================== */\n\n  $(document).ready(function () {\n    $('body').delegate('[data-controls-modal]', 'click', function (e) {\n      e.preventDefault()\n      var $this = $(this).data('show', true)\n      $('#' + $this.attr('data-controls-modal')).modal( $this.data() )\n    })\n  })\n\n}( window.jQuery || window.ender );","source":"about/static/js/modal.js","raw":"/* =========================================================\n * bootstrap-modal.js v1.4.0\n * http://twitter.github.com/bootstrap/javascript.html#modal\n * =========================================================\n * Copyright 2011 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n\n!function( $ ){\n\n  \"use strict\"\n\n /* CSS TRANSITION SUPPORT (https://gist.github.com/373874)\n  * ======================================================= */\n\n  var transitionEnd\n\n  $(document).ready(function () {\n\n    $.support.transition = (function () {\n      var thisBody = document.body || document.documentElement\n        , thisStyle = thisBody.style\n        , support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined\n      return support\n    })()\n\n    // set CSS transition event type\n    if ( $.support.transition ) {\n      transitionEnd = \"TransitionEnd\"\n      if ( $.browser.webkit ) {\n        transitionEnd = \"webkitTransitionEnd\"\n      } else if ( $.browser.mozilla ) {\n        transitionEnd = \"transitionend\"\n      } else if ( $.browser.opera ) {\n        transitionEnd = \"oTransitionEnd\"\n      }\n    }\n\n  })\n\n\n /* MODAL PUBLIC CLASS DEFINITION\n  * ============================= */\n\n  var Modal = function ( content, options ) {\n    this.settings = $.extend({}, $.fn.modal.defaults, options)\n    this.$element = $(content)\n      .delegate('.close', 'click.modal', $.proxy(this.hide, this))\n\n    if ( this.settings.show ) {\n      this.show()\n    }\n\n    return this\n  }\n\n  Modal.prototype = {\n\n      toggle: function () {\n        return this[!this.isShown ? 'show' : 'hide']()\n      }\n\n    , show: function () {\n        var that = this\n        this.isShown = true\n        this.$element.trigger('show')\n\n        escape.call(this)\n        backdrop.call(this, function () {\n          var transition = $.support.transition && that.$element.hasClass('fade')\n\n          that.$element\n            .appendTo(document.body)\n            .show()\n\n          if (transition) {\n            that.$element[0].offsetWidth // force reflow\n          }\n\n          that.$element.addClass('in')\n\n          transition ?\n            that.$element.one(transitionEnd, function () { that.$element.trigger('shown') }) :\n            that.$element.trigger('shown')\n\n        })\n\n        return this\n      }\n\n    , hide: function (e) {\n        e && e.preventDefault()\n\n        if ( !this.isShown ) {\n          return this\n        }\n\n        var that = this\n        this.isShown = false\n\n        escape.call(this)\n\n        this.$element\n          .trigger('hide')\n          .removeClass('in')\n\n        $.support.transition && this.$element.hasClass('fade') ?\n          hideWithTransition.call(this) :\n          hideModal.call(this)\n\n        return this\n      }\n\n  }\n\n\n /* MODAL PRIVATE METHODS\n  * ===================== */\n\n  function hideWithTransition() {\n    // firefox drops transitionEnd events :{o\n    var that = this\n      , timeout = setTimeout(function () {\n          that.$element.unbind(transitionEnd)\n          hideModal.call(that)\n        }, 500)\n\n    this.$element.one(transitionEnd, function () {\n      clearTimeout(timeout)\n      hideModal.call(that)\n    })\n  }\n\n  function hideModal (that) {\n    this.$element\n      .hide()\n      .trigger('hidden')\n\n    backdrop.call(this)\n  }\n\n  function backdrop ( callback ) {\n    var that = this\n      , animate = this.$element.hasClass('fade') ? 'fade' : ''\n    if ( this.isShown && this.settings.backdrop ) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\n        .appendTo(document.body)\n\n      if ( this.settings.backdrop != 'static' ) {\n        this.$backdrop.click($.proxy(this.hide, this))\n      }\n\n      if ( doAnimate ) {\n        this.$backdrop[0].offsetWidth // force reflow\n      }\n\n      this.$backdrop.addClass('in')\n\n      doAnimate ?\n        this.$backdrop.one(transitionEnd, callback) :\n        callback()\n\n    } else if ( !this.isShown && this.$backdrop ) {\n      this.$backdrop.removeClass('in')\n\n      $.support.transition && this.$element.hasClass('fade')?\n        this.$backdrop.one(transitionEnd, $.proxy(removeBackdrop, this)) :\n        removeBackdrop.call(this)\n\n    } else if ( callback ) {\n       callback()\n    }\n  }\n\n  function removeBackdrop() {\n    this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  function escape() {\n    var that = this\n    if ( this.isShown && this.settings.keyboard ) {\n      $(document).bind('keyup.modal', function ( e ) {\n        if ( e.which == 27 ) {\n          that.hide()\n        }\n      })\n    } else if ( !this.isShown ) {\n      $(document).unbind('keyup.modal')\n    }\n  }\n\n\n /* MODAL PLUGIN DEFINITION\n  * ======================= */\n\n  $.fn.modal = function ( options ) {\n    var modal = this.data('modal')\n\n    if (!modal) {\n\n      if (typeof options == 'string') {\n        options = {\n          show: /show|toggle/.test(options)\n        }\n      }\n\n      return this.each(function () {\n        $(this).data('modal', new Modal(this, options))\n      })\n    }\n\n    if ( options === true ) {\n      return modal\n    }\n\n    if ( typeof options == 'string' ) {\n      modal[options]()\n    } else if ( modal ) {\n      modal.toggle()\n    }\n\n    return this\n  }\n\n  $.fn.modal.Modal = Modal\n\n  $.fn.modal.defaults = {\n    backdrop: false\n  , keyboard: false\n  , show: false\n  }\n\n\n /* MODAL DATA- IMPLEMENTATION\n  * ========================== */\n\n  $(document).ready(function () {\n    $('body').delegate('[data-controls-modal]', 'click', function (e) {\n      e.preventDefault()\n      var $this = $(this).data('show', true)\n      $('#' + $this.attr('data-controls-modal')).modal( $this.data() )\n    })\n  })\n\n}( window.jQuery || window.ender );","date":"2016-11-10T07:20:45.343Z","updated":"2016-11-10T07:20:45.343Z","path":"about/static/js/modal.js","layout":"false","title":"","comments":1,"_id":"cjbvt9n5q008nbkw1oa5y2dah","content":"/* =========================================================\n * bootstrap-modal.js v1.4.0\n * http://twitter.github.com/bootstrap/javascript.html#modal\n * =========================================================\n * Copyright 2011 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n\n!function( $ ){\n\n  \"use strict\"\n\n /* CSS TRANSITION SUPPORT (https://gist.github.com/373874)\n  * ======================================================= */\n\n  var transitionEnd\n\n  $(document).ready(function () {\n\n    $.support.transition = (function () {\n      var thisBody = document.body || document.documentElement\n        , thisStyle = thisBody.style\n        , support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined\n      return support\n    })()\n\n    // set CSS transition event type\n    if ( $.support.transition ) {\n      transitionEnd = \"TransitionEnd\"\n      if ( $.browser.webkit ) {\n        transitionEnd = \"webkitTransitionEnd\"\n      } else if ( $.browser.mozilla ) {\n        transitionEnd = \"transitionend\"\n      } else if ( $.browser.opera ) {\n        transitionEnd = \"oTransitionEnd\"\n      }\n    }\n\n  })\n\n\n /* MODAL PUBLIC CLASS DEFINITION\n  * ============================= */\n\n  var Modal = function ( content, options ) {\n    this.settings = $.extend({}, $.fn.modal.defaults, options)\n    this.$element = $(content)\n      .delegate('.close', 'click.modal', $.proxy(this.hide, this))\n\n    if ( this.settings.show ) {\n      this.show()\n    }\n\n    return this\n  }\n\n  Modal.prototype = {\n\n      toggle: function () {\n        return this[!this.isShown ? 'show' : 'hide']()\n      }\n\n    , show: function () {\n        var that = this\n        this.isShown = true\n        this.$element.trigger('show')\n\n        escape.call(this)\n        backdrop.call(this, function () {\n          var transition = $.support.transition && that.$element.hasClass('fade')\n\n          that.$element\n            .appendTo(document.body)\n            .show()\n\n          if (transition) {\n            that.$element[0].offsetWidth // force reflow\n          }\n\n          that.$element.addClass('in')\n\n          transition ?\n            that.$element.one(transitionEnd, function () { that.$element.trigger('shown') }) :\n            that.$element.trigger('shown')\n\n        })\n\n        return this\n      }\n\n    , hide: function (e) {\n        e && e.preventDefault()\n\n        if ( !this.isShown ) {\n          return this\n        }\n\n        var that = this\n        this.isShown = false\n\n        escape.call(this)\n\n        this.$element\n          .trigger('hide')\n          .removeClass('in')\n\n        $.support.transition && this.$element.hasClass('fade') ?\n          hideWithTransition.call(this) :\n          hideModal.call(this)\n\n        return this\n      }\n\n  }\n\n\n /* MODAL PRIVATE METHODS\n  * ===================== */\n\n  function hideWithTransition() {\n    // firefox drops transitionEnd events :{o\n    var that = this\n      , timeout = setTimeout(function () {\n          that.$element.unbind(transitionEnd)\n          hideModal.call(that)\n        }, 500)\n\n    this.$element.one(transitionEnd, function () {\n      clearTimeout(timeout)\n      hideModal.call(that)\n    })\n  }\n\n  function hideModal (that) {\n    this.$element\n      .hide()\n      .trigger('hidden')\n\n    backdrop.call(this)\n  }\n\n  function backdrop ( callback ) {\n    var that = this\n      , animate = this.$element.hasClass('fade') ? 'fade' : ''\n    if ( this.isShown && this.settings.backdrop ) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\">')\n        .appendTo(document.body)\n\n      if ( this.settings.backdrop != 'static' ) {\n        this.$backdrop.click($.proxy(this.hide, this))\n      }\n\n      if ( doAnimate ) {\n        this.$backdrop[0].offsetWidth // force reflow\n      }\n\n      this.$backdrop.addClass('in')\n\n      doAnimate ?\n        this.$backdrop.one(transitionEnd, callback) :\n        callback()\n\n    } else if ( !this.isShown && this.$backdrop ) {\n      this.$backdrop.removeClass('in')\n\n      $.support.transition && this.$element.hasClass('fade')?\n        this.$backdrop.one(transitionEnd, $.proxy(removeBackdrop, this)) :\n        removeBackdrop.call(this)\n\n    } else if ( callback ) {\n       callback()\n    }\n  }\n\n  function removeBackdrop() {\n    this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  function escape() {\n    var that = this\n    if ( this.isShown && this.settings.keyboard ) {\n      $(document).bind('keyup.modal', function ( e ) {\n        if ( e.which == 27 ) {\n          that.hide()\n        }\n      })\n    } else if ( !this.isShown ) {\n      $(document).unbind('keyup.modal')\n    }\n  }\n\n\n /* MODAL PLUGIN DEFINITION\n  * ======================= */\n\n  $.fn.modal = function ( options ) {\n    var modal = this.data('modal')\n\n    if (!modal) {\n\n      if (typeof options == 'string') {\n        options = {\n          show: /show|toggle/.test(options)\n        }\n      }\n\n      return this.each(function () {\n        $(this).data('modal', new Modal(this, options))\n      })\n    }\n\n    if ( options === true ) {\n      return modal\n    }\n\n    if ( typeof options == 'string' ) {\n      modal[options]()\n    } else if ( modal ) {\n      modal.toggle()\n    }\n\n    return this\n  }\n\n  $.fn.modal.Modal = Modal\n\n  $.fn.modal.defaults = {\n    backdrop: false\n  , keyboard: false\n  , show: false\n  }\n\n\n /* MODAL DATA- IMPLEMENTATION\n  * ========================== */\n\n  $(document).ready(function () {\n    $('body').delegate('[data-controls-modal]', 'click', function (e) {\n      e.preventDefault()\n      var $this = $(this).data('show', true)\n      $('#' + $this.attr('data-controls-modal')).modal( $this.data() )\n    })\n  })\n\n}( window.jQuery || window.ender );</div>","excerpt":"","more":"/* =========================================================\n * bootstrap-modal.js v1.4.0\n * http://twitter.github.com/bootstrap/javascript.html#modal\n * =========================================================\n * Copyright 2011 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n\n!function( $ ){\n\n  \"use strict\"\n\n /* CSS TRANSITION SUPPORT (https://gist.github.com/373874)\n  * ======================================================= */\n\n  var transitionEnd\n\n  $(document).ready(function () {\n\n    $.support.transition = (function () {\n      var thisBody = document.body || document.documentElement\n        , thisStyle = thisBody.style\n        , support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined\n      return support\n    })()\n\n    // set CSS transition event type\n    if ( $.support.transition ) {\n      transitionEnd = \"TransitionEnd\"\n      if ( $.browser.webkit ) {\n        transitionEnd = \"webkitTransitionEnd\"\n      } else if ( $.browser.mozilla ) {\n        transitionEnd = \"transitionend\"\n      } else if ( $.browser.opera ) {\n        transitionEnd = \"oTransitionEnd\"\n      }\n    }\n\n  })\n\n\n /* MODAL PUBLIC CLASS DEFINITION\n  * ============================= */\n\n  var Modal = function ( content, options ) {\n    this.settings = $.extend({}, $.fn.modal.defaults, options)\n    this.$element = $(content)\n      .delegate('.close', 'click.modal', $.proxy(this.hide, this))\n\n    if ( this.settings.show ) {\n      this.show()\n    }\n\n    return this\n  }\n\n  Modal.prototype = {\n\n      toggle: function () {\n        return this[!this.isShown ? 'show' : 'hide']()\n      }\n\n    , show: function () {\n        var that = this\n        this.isShown = true\n        this.$element.trigger('show')\n\n        escape.call(this)\n        backdrop.call(this, function () {\n          var transition = $.support.transition && that.$element.hasClass('fade')\n\n          that.$element\n            .appendTo(document.body)\n            .show()\n\n          if (transition) {\n            that.$element[0].offsetWidth // force reflow\n          }\n\n          that.$element.addClass('in')\n\n          transition ?\n            that.$element.one(transitionEnd, function () { that.$element.trigger('shown') }) :\n            that.$element.trigger('shown')\n\n        })\n\n        return this\n      }\n\n    , hide: function (e) {\n        e && e.preventDefault()\n\n        if ( !this.isShown ) {\n          return this\n        }\n\n        var that = this\n        this.isShown = false\n\n        escape.call(this)\n\n        this.$element\n          .trigger('hide')\n          .removeClass('in')\n\n        $.support.transition && this.$element.hasClass('fade') ?\n          hideWithTransition.call(this) :\n          hideModal.call(this)\n\n        return this\n      }\n\n  }\n\n\n /* MODAL PRIVATE METHODS\n  * ===================== */\n\n  function hideWithTransition() {\n    // firefox drops transitionEnd events :{o\n    var that = this\n      , timeout = setTimeout(function () {\n          that.$element.unbind(transitionEnd)\n          hideModal.call(that)\n        }, 500)\n\n    this.$element.one(transitionEnd, function () {\n      clearTimeout(timeout)\n      hideModal.call(that)\n    })\n  }\n\n  function hideModal (that) {\n    this.$element\n      .hide()\n      .trigger('hidden')\n\n    backdrop.call(this)\n  }\n\n  function backdrop ( callback ) {\n    var that = this\n      , animate = this.$element.hasClass('fade') ? 'fade' : ''\n    if ( this.isShown && this.settings.backdrop ) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\n        .appendTo(document.body)\n\n      if ( this.settings.backdrop != 'static' ) {\n        this.$backdrop.click($.proxy(this.hide, this))\n      }\n\n      if ( doAnimate ) {\n        this.$backdrop[0].offsetWidth // force reflow\n      }\n\n      this.$backdrop.addClass('in')\n\n      doAnimate ?\n        this.$backdrop.one(transitionEnd, callback) :\n        callback()\n\n    } else if ( !this.isShown && this.$backdrop ) {\n      this.$backdrop.removeClass('in')\n\n      $.support.transition && this.$element.hasClass('fade')?\n        this.$backdrop.one(transitionEnd, $.proxy(removeBackdrop, this)) :\n        removeBackdrop.call(this)\n\n    } else if ( callback ) {\n       callback()\n    }\n  }\n\n  function removeBackdrop() {\n    this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  function escape() {\n    var that = this\n    if ( this.isShown && this.settings.keyboard ) {\n      $(document).bind('keyup.modal', function ( e ) {\n        if ( e.which == 27 ) {\n          that.hide()\n        }\n      })\n    } else if ( !this.isShown ) {\n      $(document).unbind('keyup.modal')\n    }\n  }\n\n\n /* MODAL PLUGIN DEFINITION\n  * ======================= */\n\n  $.fn.modal = function ( options ) {\n    var modal = this.data('modal')\n\n    if (!modal) {\n\n      if (typeof options == 'string') {\n        options = {\n          show: /show|toggle/.test(options)\n        }\n      }\n\n      return this.each(function () {\n        $(this).data('modal', new Modal(this, options))\n      })\n    }\n\n    if ( options === true ) {\n      return modal\n    }\n\n    if ( typeof options == 'string' ) {\n      modal[options]()\n    } else if ( modal ) {\n      modal.toggle()\n    }\n\n    return this\n  }\n\n  $.fn.modal.Modal = Modal\n\n  $.fn.modal.defaults = {\n    backdrop: false\n  , keyboard: false\n  , show: false\n  }\n\n\n /* MODAL DATA- IMPLEMENTATION\n  * ========================== */\n\n  $(document).ready(function () {\n    $('body').delegate('[data-controls-modal]', 'click', function (e) {\n      e.preventDefault()\n      var $this = $(this).data('show', true)\n      $('#' + $this.attr('data-controls-modal')).modal( $this.data() )\n    })\n  })\n\n}( window.jQuery || window.ender );"}],"Post":[{"title":"BOA服务器移植","date":"2017-12-20T06:47:26.000Z","_content":"在很多场合内，我们需要在嵌入式设备中集成 Web 服务器，来方便我们对设备的配置更改。这边文章对嵌入式服务器之——**Boa**服务器的移植和使用进行简单说明。\n<!-- more -->\n## 原理介绍\nBOA是一款小巧的Web服务器，支持CGI通用网关接口技术，特别适合应用在嵌入式系统中。BOA服务器是基于HTTP超文本传输协议的，Web网页是Web服务最基本的传输单元。嵌入式Web服务的工作基于客户机/服务器计算模型，由Web浏览器(客户机)和Web服务器(服务器)构成。\n\n由于嵌入式设备资源一般都比较有限，并且也不需要能同时处理很多用户的请求，因此不会使用Linux下最常用的如Apache 等服务器，而需要使用一些专门为嵌入式设备设计的Web服务器，这些Web服务器在存贮空间和运行时所占有的内存空间上都会非常适合于嵌入式应用场合。典型的嵌入式Web服务器有[Boa](http://www.boa.org)、[thttpd](http://www.acme.com/software/thttpd)、 lighttpd、shttpd、mathopd、minihttpd、appweb、goahead等，它们和Apache等高性能的Web服务器主要的区别在于它们一般是 单进程服务器，只有在完成一个用户请求后才能响应另一个用户的请求，而无法并发响应，但这在嵌入式设备的应用场合里已经足够了。\n\nBOA的工作原理是运行于客户端的浏览器首先要与嵌入式Web服务器BOA端建立连接，打开一个套接字虚拟文件，此文件建立标志着SOCKET连接建立成功然后客户端浏览器通过套接字SOCKET以GET或者POST参数传递方式向Web服务器提交请求，Web浏览器提交请求后，通过HTTP协议传送给Web服务器。Web服务器接到请求后，根据请求的不同进行事务处理，返回HTML文件或者通过CGI调用外部应用程序，返回处理结果。服务器通过CGI与外部应用程序和脚本之间进行交互，根据客户端浏览器在请求时所采用的方法，服务器会搜集客户所提供的信息，并将该部分信息发送给指定的CGI扩展程序，CGI扩展程序进行信息处理并将结果返回给服务器，然后服务器对信息进行分析，并将结果发送回客户端在浏览器上显示出来。\n\n## 移植\n### 1、下载源码\nBOA官方网址：http://www.boa.org/\n从官网下载源码包后解压，进行下一步。\n\n### 2、支持工具下载\n在BOA安装的过程中需要用到 `yacc` 和 `lex`，因此，需要安装 `bison` 和 `flex`。执行以下命令：\n````\nyacc——sudo apt-get install bison\nlex——sudo apt-get install flex\n````\n\n### 3、修改文件\n#### 1、修改 `src/compat.h`\n找到\n````\n#define TIMEZONE_OFFSET(foo) foo##->tm_gmtoff\n````\n修改成\n````\n#define TIMEZONE_OFFSET(foo) (foo)->tm_gmtoff\n````\n \n#### 2、修改 `src/log.c`\n如果不需要保存错误日志，可以将错误日志设置为`/dev/null`，或直接注释掉，这时候需要注释以下代码：\n\n````\nif (dup2(error_log, STDERR_FILENO) == -1) {\n                         DIE(\"unable to dup2 the error log\");\n                   }\n````\n\n否则会出现错误：\n````\nlog.c:73 unable to dup2 the error log:bad file descriptor\n````\n\n### 4、生成\n执行`./config`生成 Makefile 文件，执行`make`，生成可执行文件。\n\n## 参数配置\n在下载目录下已有一个示例boa.conf，可以在其基础上进行修改。如下：\n\n|内容|配置项|\n|---|----|\n|1 端口|Port 80\n|2 客户端身份|User nobody\n|3 客户端组|Group nogroup\n|4 错误日志|ErrorLog /var/log/boa/error_log\n|5 存取日志|AccessLog /var/log/boa/access_log\n|6 HTML根文件|  DocumentRoot /var/www\n|7 用户目录|UserDir public_html\n|8 预生成目录|DirectoryIndex index.html\n|9 生成目录的程序|DirectoryMaker /usr/lib/boa/boa_indexer\n|10 请求数量|KeepAliveMax 1000\n|11 等待时间|KeepAliveTimeout 10\n|12 mimetypes文件|MimeTypes /etc/mime.types\n|13 mimetypes类型|DefaultType text/plain\n|14 CGI $path变量|CGIPath /bin:/usr/bin:/usr/local/bin\n|15 路径别名|Alias /doc /usr/doc\n|16 脚本虚拟路径|ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/\n","source":"_posts/BOA服务器移植.md","raw":"---\ntitle: BOA服务器移植\ndate: 2017-12-20 14:47:26\ncategories: Linux 应用\ntags: [Boa]\n---\n在很多场合内，我们需要在嵌入式设备中集成 Web 服务器，来方便我们对设备的配置更改。这边文章对嵌入式服务器之——**Boa**服务器的移植和使用进行简单说明。\n<!-- more -->\n## 原理介绍\nBOA是一款小巧的Web服务器，支持CGI通用网关接口技术，特别适合应用在嵌入式系统中。BOA服务器是基于HTTP超文本传输协议的，Web网页是Web服务最基本的传输单元。嵌入式Web服务的工作基于客户机/服务器计算模型，由Web浏览器(客户机)和Web服务器(服务器)构成。\n\n由于嵌入式设备资源一般都比较有限，并且也不需要能同时处理很多用户的请求，因此不会使用Linux下最常用的如Apache 等服务器，而需要使用一些专门为嵌入式设备设计的Web服务器，这些Web服务器在存贮空间和运行时所占有的内存空间上都会非常适合于嵌入式应用场合。典型的嵌入式Web服务器有[Boa](http://www.boa.org)、[thttpd](http://www.acme.com/software/thttpd)、 lighttpd、shttpd、mathopd、minihttpd、appweb、goahead等，它们和Apache等高性能的Web服务器主要的区别在于它们一般是 单进程服务器，只有在完成一个用户请求后才能响应另一个用户的请求，而无法并发响应，但这在嵌入式设备的应用场合里已经足够了。\n\nBOA的工作原理是运行于客户端的浏览器首先要与嵌入式Web服务器BOA端建立连接，打开一个套接字虚拟文件，此文件建立标志着SOCKET连接建立成功然后客户端浏览器通过套接字SOCKET以GET或者POST参数传递方式向Web服务器提交请求，Web浏览器提交请求后，通过HTTP协议传送给Web服务器。Web服务器接到请求后，根据请求的不同进行事务处理，返回HTML文件或者通过CGI调用外部应用程序，返回处理结果。服务器通过CGI与外部应用程序和脚本之间进行交互，根据客户端浏览器在请求时所采用的方法，服务器会搜集客户所提供的信息，并将该部分信息发送给指定的CGI扩展程序，CGI扩展程序进行信息处理并将结果返回给服务器，然后服务器对信息进行分析，并将结果发送回客户端在浏览器上显示出来。\n\n## 移植\n### 1、下载源码\nBOA官方网址：http://www.boa.org/\n从官网下载源码包后解压，进行下一步。\n\n### 2、支持工具下载\n在BOA安装的过程中需要用到 `yacc` 和 `lex`，因此，需要安装 `bison` 和 `flex`。执行以下命令：\n````\nyacc——sudo apt-get install bison\nlex——sudo apt-get install flex\n````\n\n### 3、修改文件\n#### 1、修改 `src/compat.h`\n找到\n````\n#define TIMEZONE_OFFSET(foo) foo##->tm_gmtoff\n````\n修改成\n````\n#define TIMEZONE_OFFSET(foo) (foo)->tm_gmtoff\n````\n \n#### 2、修改 `src/log.c`\n如果不需要保存错误日志，可以将错误日志设置为`/dev/null`，或直接注释掉，这时候需要注释以下代码：\n\n````\nif (dup2(error_log, STDERR_FILENO) == -1) {\n                         DIE(\"unable to dup2 the error log\");\n                   }\n````\n\n否则会出现错误：\n````\nlog.c:73 unable to dup2 the error log:bad file descriptor\n````\n\n### 4、生成\n执行`./config`生成 Makefile 文件，执行`make`，生成可执行文件。\n\n## 参数配置\n在下载目录下已有一个示例boa.conf，可以在其基础上进行修改。如下：\n\n|内容|配置项|\n|---|----|\n|1 端口|Port 80\n|2 客户端身份|User nobody\n|3 客户端组|Group nogroup\n|4 错误日志|ErrorLog /var/log/boa/error_log\n|5 存取日志|AccessLog /var/log/boa/access_log\n|6 HTML根文件|  DocumentRoot /var/www\n|7 用户目录|UserDir public_html\n|8 预生成目录|DirectoryIndex index.html\n|9 生成目录的程序|DirectoryMaker /usr/lib/boa/boa_indexer\n|10 请求数量|KeepAliveMax 1000\n|11 等待时间|KeepAliveTimeout 10\n|12 mimetypes文件|MimeTypes /etc/mime.types\n|13 mimetypes类型|DefaultType text/plain\n|14 CGI $path变量|CGIPath /bin:/usr/bin:/usr/local/bin\n|15 路径别名|Alias /doc /usr/doc\n|16 脚本虚拟路径|ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/\n","slug":"BOA服务器移植","published":1,"updated":"2017-12-20T07:28:00.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9myw0000bkw1o3bvouv7","content":"<p>在很多场合内，我们需要在嵌入式设备中集成 Web 服务器，来方便我们对设备的配置更改。这边文章对嵌入式服务器之——<strong>Boa</strong>服务器的移植和使用进行简单说明。<br><a id=\"more\"></a></p>\n<h2 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a>原理介绍</h2><p>BOA是一款小巧的Web服务器，支持CGI通用网关接口技术，特别适合应用在嵌入式系统中。BOA服务器是基于HTTP超文本传输协议的，Web网页是Web服务最基本的传输单元。嵌入式Web服务的工作基于客户机/服务器计算模型，由Web浏览器(客户机)和Web服务器(服务器)构成。</p>\n<p>由于嵌入式设备资源一般都比较有限，并且也不需要能同时处理很多用户的请求，因此不会使用Linux下最常用的如Apache 等服务器，而需要使用一些专门为嵌入式设备设计的Web服务器，这些Web服务器在存贮空间和运行时所占有的内存空间上都会非常适合于嵌入式应用场合。典型的嵌入式Web服务器有<a href=\"http://www.boa.org\" target=\"_blank\" rel=\"external\">Boa</a>、<a href=\"http://www.acme.com/software/thttpd\" target=\"_blank\" rel=\"external\">thttpd</a>、 lighttpd、shttpd、mathopd、minihttpd、appweb、goahead等，它们和Apache等高性能的Web服务器主要的区别在于它们一般是 单进程服务器，只有在完成一个用户请求后才能响应另一个用户的请求，而无法并发响应，但这在嵌入式设备的应用场合里已经足够了。</p>\n<p>BOA的工作原理是运行于客户端的浏览器首先要与嵌入式Web服务器BOA端建立连接，打开一个套接字虚拟文件，此文件建立标志着SOCKET连接建立成功然后客户端浏览器通过套接字SOCKET以GET或者POST参数传递方式向Web服务器提交请求，Web浏览器提交请求后，通过HTTP协议传送给Web服务器。Web服务器接到请求后，根据请求的不同进行事务处理，返回HTML文件或者通过CGI调用外部应用程序，返回处理结果。服务器通过CGI与外部应用程序和脚本之间进行交互，根据客户端浏览器在请求时所采用的方法，服务器会搜集客户所提供的信息，并将该部分信息发送给指定的CGI扩展程序，CGI扩展程序进行信息处理并将结果返回给服务器，然后服务器对信息进行分析，并将结果发送回客户端在浏览器上显示出来。</p>\n<h2 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h2><h3 id=\"1、下载源码\"><a href=\"#1、下载源码\" class=\"headerlink\" title=\"1、下载源码\"></a>1、下载源码</h3><p>BOA官方网址：<a href=\"http://www.boa.org/\" target=\"_blank\" rel=\"external\">http://www.boa.org/</a><br>从官网下载源码包后解压，进行下一步。</p>\n<h3 id=\"2、支持工具下载\"><a href=\"#2、支持工具下载\" class=\"headerlink\" title=\"2、支持工具下载\"></a>2、支持工具下载</h3><p>在BOA安装的过程中需要用到 <code>yacc</code> 和 <code>lex</code>，因此，需要安装 <code>bison</code> 和 <code>flex</code>。执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yacc——sudo apt-get install bison</div><div class=\"line\">lex——sudo apt-get install flex</div></pre></td></tr></table></figure></p>\n<h3 id=\"3、修改文件\"><a href=\"#3、修改文件\" class=\"headerlink\" title=\"3、修改文件\"></a>3、修改文件</h3><h4 id=\"1、修改-src-compat-h\"><a href=\"#1、修改-src-compat-h\" class=\"headerlink\" title=\"1、修改 src/compat.h\"></a>1、修改 <code>src/compat.h</code></h4><p>找到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff</div></pre></td></tr></table></figure></p>\n<p>修改成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff</div></pre></td></tr></table></figure></p>\n<h4 id=\"2、修改-src-log-c\"><a href=\"#2、修改-src-log-c\" class=\"headerlink\" title=\"2、修改 src/log.c\"></a>2、修改 <code>src/log.c</code></h4><p>如果不需要保存错误日志，可以将错误日志设置为<code>/dev/null</code>，或直接注释掉，这时候需要注释以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (dup2(error_log, STDERR_FILENO) == -1) &#123;</div><div class=\"line\">                         DIE(&quot;unable to dup2 the error log&quot;);</div><div class=\"line\">                   &#125;</div></pre></td></tr></table></figure>\n<p>否则会出现错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">log.c:73 unable to dup2 the error log:bad file descriptor</div></pre></td></tr></table></figure></p>\n<h3 id=\"4、生成\"><a href=\"#4、生成\" class=\"headerlink\" title=\"4、生成\"></a>4、生成</h3><p>执行<code>./config</code>生成 Makefile 文件，执行<code>make</code>，生成可执行文件。</p>\n<h2 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h2><p>在下载目录下已有一个示例boa.conf，可以在其基础上进行修改。如下：</p>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>配置项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 端口</td>\n<td>Port 80</td>\n</tr>\n<tr>\n<td>2 客户端身份</td>\n<td>User nobody</td>\n</tr>\n<tr>\n<td>3 客户端组</td>\n<td>Group nogroup</td>\n</tr>\n<tr>\n<td>4 错误日志</td>\n<td>ErrorLog /var/log/boa/error_log</td>\n</tr>\n<tr>\n<td>5 存取日志</td>\n<td>AccessLog /var/log/boa/access_log</td>\n</tr>\n<tr>\n<td>6 HTML根文件</td>\n<td>DocumentRoot /var/www</td>\n</tr>\n<tr>\n<td>7 用户目录</td>\n<td>UserDir public_html</td>\n</tr>\n<tr>\n<td>8 预生成目录</td>\n<td>DirectoryIndex index.html</td>\n</tr>\n<tr>\n<td>9 生成目录的程序</td>\n<td>DirectoryMaker /usr/lib/boa/boa_indexer</td>\n</tr>\n<tr>\n<td>10 请求数量</td>\n<td>KeepAliveMax 1000</td>\n</tr>\n<tr>\n<td>11 等待时间</td>\n<td>KeepAliveTimeout 10</td>\n</tr>\n<tr>\n<td>12 mimetypes文件</td>\n<td>MimeTypes /etc/mime.types</td>\n</tr>\n<tr>\n<td>13 mimetypes类型</td>\n<td>DefaultType text/plain</td>\n</tr>\n<tr>\n<td>14 CGI $path变量</td>\n<td>CGIPath /bin:/usr/bin:/usr/local/bin</td>\n</tr>\n<tr>\n<td>15 路径别名</td>\n<td>Alias /doc /usr/doc</td>\n</tr>\n<tr>\n<td>16 脚本虚拟路径</td>\n<td>ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"<p>在很多场合内，我们需要在嵌入式设备中集成 Web 服务器，来方便我们对设备的配置更改。这边文章对嵌入式服务器之——<strong>Boa</strong>服务器的移植和使用进行简单说明。<br>","more":"</p>\n<h2 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a>原理介绍</h2><p>BOA是一款小巧的Web服务器，支持CGI通用网关接口技术，特别适合应用在嵌入式系统中。BOA服务器是基于HTTP超文本传输协议的，Web网页是Web服务最基本的传输单元。嵌入式Web服务的工作基于客户机/服务器计算模型，由Web浏览器(客户机)和Web服务器(服务器)构成。</p>\n<p>由于嵌入式设备资源一般都比较有限，并且也不需要能同时处理很多用户的请求，因此不会使用Linux下最常用的如Apache 等服务器，而需要使用一些专门为嵌入式设备设计的Web服务器，这些Web服务器在存贮空间和运行时所占有的内存空间上都会非常适合于嵌入式应用场合。典型的嵌入式Web服务器有<a href=\"http://www.boa.org\">Boa</a>、<a href=\"http://www.acme.com/software/thttpd\">thttpd</a>、 lighttpd、shttpd、mathopd、minihttpd、appweb、goahead等，它们和Apache等高性能的Web服务器主要的区别在于它们一般是 单进程服务器，只有在完成一个用户请求后才能响应另一个用户的请求，而无法并发响应，但这在嵌入式设备的应用场合里已经足够了。</p>\n<p>BOA的工作原理是运行于客户端的浏览器首先要与嵌入式Web服务器BOA端建立连接，打开一个套接字虚拟文件，此文件建立标志着SOCKET连接建立成功然后客户端浏览器通过套接字SOCKET以GET或者POST参数传递方式向Web服务器提交请求，Web浏览器提交请求后，通过HTTP协议传送给Web服务器。Web服务器接到请求后，根据请求的不同进行事务处理，返回HTML文件或者通过CGI调用外部应用程序，返回处理结果。服务器通过CGI与外部应用程序和脚本之间进行交互，根据客户端浏览器在请求时所采用的方法，服务器会搜集客户所提供的信息，并将该部分信息发送给指定的CGI扩展程序，CGI扩展程序进行信息处理并将结果返回给服务器，然后服务器对信息进行分析，并将结果发送回客户端在浏览器上显示出来。</p>\n<h2 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h2><h3 id=\"1、下载源码\"><a href=\"#1、下载源码\" class=\"headerlink\" title=\"1、下载源码\"></a>1、下载源码</h3><p>BOA官方网址：<a href=\"http://www.boa.org/\">http://www.boa.org/</a><br>从官网下载源码包后解压，进行下一步。</p>\n<h3 id=\"2、支持工具下载\"><a href=\"#2、支持工具下载\" class=\"headerlink\" title=\"2、支持工具下载\"></a>2、支持工具下载</h3><p>在BOA安装的过程中需要用到 <code>yacc</code> 和 <code>lex</code>，因此，需要安装 <code>bison</code> 和 <code>flex</code>。执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yacc——sudo apt-get install bison</div><div class=\"line\">lex——sudo apt-get install flex</div></pre></td></tr></table></figure></p>\n<h3 id=\"3、修改文件\"><a href=\"#3、修改文件\" class=\"headerlink\" title=\"3、修改文件\"></a>3、修改文件</h3><h4 id=\"1、修改-src-compat-h\"><a href=\"#1、修改-src-compat-h\" class=\"headerlink\" title=\"1、修改 src/compat.h\"></a>1、修改 <code>src/compat.h</code></h4><p>找到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff</div></pre></td></tr></table></figure></p>\n<p>修改成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff</div></pre></td></tr></table></figure></p>\n<h4 id=\"2、修改-src-log-c\"><a href=\"#2、修改-src-log-c\" class=\"headerlink\" title=\"2、修改 src/log.c\"></a>2、修改 <code>src/log.c</code></h4><p>如果不需要保存错误日志，可以将错误日志设置为<code>/dev/null</code>，或直接注释掉，这时候需要注释以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (dup2(error_log, STDERR_FILENO) == -1) &#123;</div><div class=\"line\">                         DIE(&quot;unable to dup2 the error log&quot;);</div><div class=\"line\">                   &#125;</div></pre></td></tr></table></figure>\n<p>否则会出现错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">log.c:73 unable to dup2 the error log:bad file descriptor</div></pre></td></tr></table></figure></p>\n<h3 id=\"4、生成\"><a href=\"#4、生成\" class=\"headerlink\" title=\"4、生成\"></a>4、生成</h3><p>执行<code>./config</code>生成 Makefile 文件，执行<code>make</code>，生成可执行文件。</p>\n<h2 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h2><p>在下载目录下已有一个示例boa.conf，可以在其基础上进行修改。如下：</p>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>配置项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 端口</td>\n<td>Port 80</td>\n</tr>\n<tr>\n<td>2 客户端身份</td>\n<td>User nobody</td>\n</tr>\n<tr>\n<td>3 客户端组</td>\n<td>Group nogroup</td>\n</tr>\n<tr>\n<td>4 错误日志</td>\n<td>ErrorLog /var/log/boa/error_log</td>\n</tr>\n<tr>\n<td>5 存取日志</td>\n<td>AccessLog /var/log/boa/access_log</td>\n</tr>\n<tr>\n<td>6 HTML根文件</td>\n<td>DocumentRoot /var/www</td>\n</tr>\n<tr>\n<td>7 用户目录</td>\n<td>UserDir public_html</td>\n</tr>\n<tr>\n<td>8 预生成目录</td>\n<td>DirectoryIndex index.html</td>\n</tr>\n<tr>\n<td>9 生成目录的程序</td>\n<td>DirectoryMaker /usr/lib/boa/boa_indexer</td>\n</tr>\n<tr>\n<td>10 请求数量</td>\n<td>KeepAliveMax 1000</td>\n</tr>\n<tr>\n<td>11 等待时间</td>\n<td>KeepAliveTimeout 10</td>\n</tr>\n<tr>\n<td>12 mimetypes文件</td>\n<td>MimeTypes /etc/mime.types</td>\n</tr>\n<tr>\n<td>13 mimetypes类型</td>\n<td>DefaultType text/plain</td>\n</tr>\n<tr>\n<td>14 CGI $path变量</td>\n<td>CGIPath /bin:/usr/bin:/usr/local/bin</td>\n</tr>\n<tr>\n<td>15 路径别名</td>\n<td>Alias /doc /usr/doc</td>\n</tr>\n<tr>\n<td>16 脚本虚拟路径</td>\n<td>ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/</td>\n</tr>\n</tbody>\n</table>"},{"title":"C++学习笔记（三）——C++标准库","date":"2017-03-01T10:14:44.000Z","_content":"\nC++的标准库的内容在50个头文件中定义。其中最重要的一部分是有关容器类和泛型算法的--------即 STL(Standard Template Library)。\n\n<!-- more -->\n包括STL在内的C++头文件大致可以分为10类：\n\n类型         | 头文件名\n---------- | ------------------------------------------------------------------------------------\n语言支持功能|&lt;cstddef&gt;&lt;limits&gt;&lt;climits&gt;&lt;cfloat&gt;&lt;cstdlib&gt;&lt;new&gt;&lt;typeinfo&gt;&lt;exception&gt;&lt;cstdarg&gt;&lt;csetjmp&gt;&lt;csignal&gt;\n流输入/输出 |&lt;iostream&gt;&lt;iomanip&gt;&lt;iOS&gt;&lt;istream&gt;&lt;ostream&gt;&lt;sstream&gt;&lt;fstream&gt;&lt;iosfwd&gt;&lt;streambuf&gt;&lt;cstdio&gt;&lt;cwchar&gt;\n诊断功能相关|&lt;stdexcept&gt;&lt;cassert&gt;&lt;cerrno&gt;\n定义工具函数|&lt;utility&gt;&lt;functional&gt;&lt;memory&gt;&lt;ctime&gt;\n字符串处理|&lt;string&gt;&lt;cctype&gt;&lt;cwctype&gt;&lt;cstring&gt;&lt;cwchar&gt;&lt;cstdlib&gt;\nSTL----容器|&lt;vector&gt;&lt;list&gt;&lt;deque&gt;&lt;queue&gt;&lt;stack&gt;&lt;map&gt;&lt;set&gt;&lt;bitset&gt;\nSTL----迭代器|&lt;iterator&gt;\nSTL----算法|&lt;algorithm&gt;&lt;cstdlib&gt;&lt;ciso646&gt;\n数值操作|&lt;complex&gt;&lt;valarray&gt;&lt;numeric&gt;&lt;cmath&gt;&lt;cstdlib&gt;\n本地化|&lt;locale&gt;&lt;clocale&gt;\n\n\n # 一、IO库\n\nC++对输入输出的处理是通过一组定义在标准库中的类型来处理的。这些类型分别定义在三个头文件中：\n\n- `iostream` 包括 `istream` `ostream` `iostream`\n- `fstream` 包括 `ifstream` `ofstream` `fstream`\n- `sstream` 包括 `istringstream` `ostingstream` `stringstream` 对 `fstream` 和 `sstream` 的处理和 `iostream` 基本是一致的。需要注意的是：**IO对象是不能进行拷贝或者赋值的**。\n\n## 1.1条件状态\n\n条件状态用来帮助我们访问和操纵流的状态：\n\n函数              | 标志      | 作用\n--------------- | ------- | -------------------\nbad()           | badbit  | 如果流崩溃返回真\nfail()          | failbit | IO操作失败返回真\neof()           | eofbit  | 到达文件结束返回真\ngood()          | goodbit | 流状态正常返回真\nclear()         |         | 清除条件状态，设置为goodbit\nclear(flags)    |         | 根据指定的标志位，将对应的条件状态复位\nsetstate(flags) |         | 根据指定的标志位，将对应的条件状态置位\nrdstate()       |         | 返回当前的条件状态\n\n## 1.2输出缓冲\n\n每个输出流都管理一个缓冲区，用来保存程序读写的数据。导致缓冲刷新（即将数据真正的写入到设备文件）的原因有：\n\n- 程序正常结束\n- 缓冲区满\n- 使用操纵符如 `endl`，来显示的刷新缓冲区\n- 使用 `unitbuf` 设置流的内部状态，来清空缓冲区\n- **当一个输出流关联到另外一个流时**，当读写关联流时，相应的输出流的缓冲区被刷新\n\n`unitbuf`使用后，所有的输出操作后都会立即刷新缓冲区，此时可以使用 `nounitbuf` 回到正常的缓冲方式。 使用 `tie` 方法可以关联两个流，使用无参版本的 `tie` 会返回当前流管理按的流指针，如果没有关联流则返回空指针。使用带参数的版本绑定相应的流到当前流。\n\n## 1.3 文件输入输出\n\n与标准输入输出流相比， `fstream` 新增了几个操作：\n\n操作                     | 含义\n---------------------- | -------------------\nfstream fstrm(s)       | 创建fstream，并打开s指定的文件\nfstream fstrm(s, mode) | 和上个类似，mode指打开的文件模式\nfstrm.open(s)          | 打开s指定的文件\nfstrm.close()          | 关闭fastream绑定的文件\nfstrm.is_open()        | 返回当前文件是否成功打开\n\n当构造一个fstream对象时，指定了文件，则 `open()` 方法自动被调用，而对象析构的时候， `close()` 方法自动被调用。\n\n上面提到了 fstream 的文件模式：\n\n模式     | 含义            | 备注\n------ | ------------- | --------------------------------------\nin     | 以只读方式打开       | 只可以对ifstream和fstream对象指定in模式\nout    | 以写方式打开        | 只可以对ofstream和fstream对象指定out模式\ntrunc  | 截断文件          | 只有当out也被设定的时候，才可以设定trunc模式\napp    | 每次写操作均定位到文件末尾 | 只要trunc没被设定，就可以设定app模式，且app模式默认打开out模式\nate    | 打开后定位到文件末尾    | 可以和任何搭配\nbinary | 以二进制方式打开      | 可以和任何搭配\n\n需要注意的是：\n\n1. 以 out 模式打开文件会丢弃已有数据\n2. 每次调用 open 都会确定文件模式\n\n## 1.3 string流\n\nstring流用于字符串的处理，通常可用于格式化输入输出。\n\n# 二、容器\n\nC++中的容器类包括\"顺序存储结构\"和\"关联存储结构\"，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。 有一些操作是所有容器都可以使用的：\n\n操作                  | 含义\n------------------- | ---------------------------\nC c;                | 默认构造函数，构造空容器\nC c(c2)             | 构造c2的拷贝c1\nC c(b, e)           | 构造c，将迭代器b和e之间的元素拷贝至c\nc1 = c2             | 将c1中的元素替换为c2\nc1 = ｛a, b, c...｝   | 将c1中的元素替换为列表中的元素\na.swap(b)/swap(a,b) | 交换a和b的元素\nc.size()            | 返回c中的元素数目（不支持forward_list）\nc.max_size()        | 返回c可以保存的最大元素数目\nc.empty()           | 如果c中存储了元素，返回false，否则返回 true\nc.begin()           | 返回指向c的第一个元素的迭代器\nc.end()             | 返回指向c的超尾的迭代器\n\n## 2.1 顺序容器\n\n顺序容器提供了快速顺序访问元素的能力，但是对与增删操作和非顺序访问操作有所性能折中。标准库中的顺序容器有：\n\n容器名          | 定义\n------------ | -------------------\nvector       | 可变大小数组\ndeque        | 双端队列\nlist         | 双向链表\nforward_list | 单向链表\narray        | 固定大小数组\nstring       | 与vector相似，但专门用来保存字符\n\n顺序容器共有的方法有:\n\n- `emplace(C++11 新增)`， 插入一个对象\n- `insert`, 插入一个拷贝\n- `resize(n)`, 重新设置大小\n- `assign`，替换\n- `erase`， 删除\n- `clear`，清除所有元素\n- `front`，返回第一个元素\n\n`vector`, `forward_list`, `list`, `deque` 共有的方法有：\n\n- `back`， 返回最后一个元素\n- `push_back`， 插入到末尾\n- `pop_back`， 删除最后一个元素\n- `emplace_back`， 追加到末尾\n- `push_front`，插入到队首\n- `pop_front`，删除队首\n- `emplace_front`，追加到队首\n- `at`，返回相应的对象\n\n`vector` 独有的操作有：\n\n- `capacity`， 返回能够存储的总量\n- `reserver`， 提醒至少需要存储相应个元素的空间\n\n`list` 独有的操作有：\n\n- `splice`， 移动指定的元素\n- `remove`， 删除相应值的所有元素\n- `unique`，删除连续的相同元素，仅保留一个\n- `merge`，合并两个链表，并排序\n- `sort`，排序\n- `reverse`,反转\n\n## 2.2 关联容器\n\n关联容器和顺序容器不同，关联容器中的元素是按照元素关键字来保存和访问的。关联容器有两个主要类型： `map` 和 `set`。\n\n- `map` 中的元素是一些关键字-值的对，关键字起到索引的作用，而值为对应索引的数据\n- `set` 中的元素只包含一个关键字。\n\n除了 `map` 和 `set`， 还有对应的 `multimap`和 `multiset`。此外， c++ 还定义了相应的无序集合 `unordered _map`等。\n\n相应的关联容器的操作有\n\n- `key_comp`, 返回比较对象\n- `value_comp`，返回 `value_comp` 对象\n- `insert`， 插入\n- `emplace`， 插入对象\n- `erase`， 擦除\n- `clear`， 清空\n- `find`， 寻找相应的键\n- `count`， 返回相应键的数量\n- `lower_bound`, 返回不小于指定键的元素迭代器\n- `upper_bound`， 返回大于k的元素迭代器\n- `equal_range`， 返回第一个成员为 `a.lower_bound(k)` 第二个成员为 `a.upper_bound(k)` 的值对\n- `operator`， 返回一个指向yu指定的键关联的值的引用\n\n无序容器的操作有\n\n- `hash_function` 返回使用的哈希函数\n- `key_eq` 返回创建时使用的键值相等谓词\n- `bucket_count`， 返回桶数\n\n# 三、泛型算法\n\n对于算法，算法本身不执行容器的操作，它们只会运行在迭代器之上，执行迭代器的操作。所以：算法永远不会改变底层容器的大小。\n\n## 3.1 算法分类\n\n1. **查找对象的算法** 相应的算法有 `find`， `count`， `adjacent_find`, `search_n`, `search`, `find_first_of`, `find_end`\n2. **其它只读算法** `for_each`, `mismatch`, `equal`\n3. **二分搜索算法** `lower_bound`， `upper_bount`， `equal_range`， `binary_search`\n4. **写容器操作** `fill`， `generate`， `copy`， `move`， `transform`， `replace_copy`， `merge`， `iter_swap`， `swap_ranges`， `replace`， `copy_backward`， `move_backward`， `inplace`\n5. **划分算法** `is_partitionedis`， `partitioned_copy`， `partition_point`， `stable_partition`， `partition`\n6. **排序算法** `sort`, `is_sorted`, `partial_sort`, `partial_sort_copy`, `nth_element`\n7. **通用重排算法** `remove`， `unique`， `rotate`， `reverse`， `random_shuffle`， `shuffle`\n8. **排列算法** `is_permutation`, `next_permutation`, `prev_permutation`\n9. **有序序列的集合算法** `set_inion`, `set_intersection`, `set_symmetric_difference`\n10. **最小值和最大值** `min`， `minmax`， `max`，\n11. **数值算法** `accumulate`， `inner_product`， `partial_sum`， `adjacent_difference`， `itoa`\n\n## 3.2 lambda\n\n一个lambda表示一个可调用的代码单元。他的形式如下： [capture list] (parameter list) -> return type {function body} `capture list` 是lambda所在的函数中定义的局部变量的列表 `return type` `parameter list` `function body` 表示相应的返回值，参数列表，函数体\n\nlambda可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体。\n\n# 四、智能指针\n\n通常我们使用 `new` 和 `delete` 来管理动态内存的。但是，这样的使用很容易出现问题：我们有可能会忘记释放内存造成内存泄漏；或者我们有可能使用了已释放的指针，导致非法访问。因为C++中定义了智能指针。 智能指针其实也是模版，C++中定义了三个相关的类：\n\n- `shared_ptr` 允许多个指针指向同一个对象\n- `unique_ptr` 仅允许一个指针指向对象\n- `weak_ptr` 弱引用，指向 `shared_ptr` 所管理的对象\n\n智能指针的相应操作有：\n\n函数名                                  | 含义\n------------------------------------ | --------------------------------\nshared_ptr <T> sp / unique_ptr<T> up | 空智能指针，可以指向类型为T的对象\np                                    | 可以把智能指针本身作为判断，如果p指向了一个对象，则返回true\n*p                                   | 解引用，获得指向的对象\np->mem                               | 等价于(*p).mem\nswap(p, q) / p.swap(q)               | 交换\nmake_shared <T>(args)                | 返回一个shared_ptr\nshared_ptr<T>p (q)                   | p 是 q 的拷贝\np = q                                | 拷贝\np.use_count()                        | 返回与p共享对象的智能指针对象\np.unique()                           | 如果p.use_count()为1，返回true\n\n当智能指针创建之后，每对shared_ptr的拷贝和赋值，都会使 shared_ptr 的引用计数加一。 当一个shared_ptr被销毁时，shared_ptr 的引用计数会递减。 当动态内存的引用计数为0时， shared_ptr 的析构函数会自动销毁所管理的对象。 我们可能会在下面的三种情况下使用智能指针：\n\n- 程序不知道自己需要使用多少对象\n- 程序不知道所需对象的准确类型\n- 程序需要在多个对象间共享数据\n","source":"_posts/C-学习笔记（三）——STL.md","raw":"---\ntitle: C++学习笔记（三）——C++标准库\ndate: 2017-03-01T18:14:44.000Z\ncategories: C++学习笔记\ntags:\n  - C++\n  - STL\n  - 标准库\n---\n\nC++的标准库的内容在50个头文件中定义。其中最重要的一部分是有关容器类和泛型算法的--------即 STL(Standard Template Library)。\n\n<!-- more -->\n包括STL在内的C++头文件大致可以分为10类：\n\n类型         | 头文件名\n---------- | ------------------------------------------------------------------------------------\n语言支持功能|&lt;cstddef&gt;&lt;limits&gt;&lt;climits&gt;&lt;cfloat&gt;&lt;cstdlib&gt;&lt;new&gt;&lt;typeinfo&gt;&lt;exception&gt;&lt;cstdarg&gt;&lt;csetjmp&gt;&lt;csignal&gt;\n流输入/输出 |&lt;iostream&gt;&lt;iomanip&gt;&lt;iOS&gt;&lt;istream&gt;&lt;ostream&gt;&lt;sstream&gt;&lt;fstream&gt;&lt;iosfwd&gt;&lt;streambuf&gt;&lt;cstdio&gt;&lt;cwchar&gt;\n诊断功能相关|&lt;stdexcept&gt;&lt;cassert&gt;&lt;cerrno&gt;\n定义工具函数|&lt;utility&gt;&lt;functional&gt;&lt;memory&gt;&lt;ctime&gt;\n字符串处理|&lt;string&gt;&lt;cctype&gt;&lt;cwctype&gt;&lt;cstring&gt;&lt;cwchar&gt;&lt;cstdlib&gt;\nSTL----容器|&lt;vector&gt;&lt;list&gt;&lt;deque&gt;&lt;queue&gt;&lt;stack&gt;&lt;map&gt;&lt;set&gt;&lt;bitset&gt;\nSTL----迭代器|&lt;iterator&gt;\nSTL----算法|&lt;algorithm&gt;&lt;cstdlib&gt;&lt;ciso646&gt;\n数值操作|&lt;complex&gt;&lt;valarray&gt;&lt;numeric&gt;&lt;cmath&gt;&lt;cstdlib&gt;\n本地化|&lt;locale&gt;&lt;clocale&gt;\n\n\n # 一、IO库\n\nC++对输入输出的处理是通过一组定义在标准库中的类型来处理的。这些类型分别定义在三个头文件中：\n\n- `iostream` 包括 `istream` `ostream` `iostream`\n- `fstream` 包括 `ifstream` `ofstream` `fstream`\n- `sstream` 包括 `istringstream` `ostingstream` `stringstream` 对 `fstream` 和 `sstream` 的处理和 `iostream` 基本是一致的。需要注意的是：**IO对象是不能进行拷贝或者赋值的**。\n\n## 1.1条件状态\n\n条件状态用来帮助我们访问和操纵流的状态：\n\n函数              | 标志      | 作用\n--------------- | ------- | -------------------\nbad()           | badbit  | 如果流崩溃返回真\nfail()          | failbit | IO操作失败返回真\neof()           | eofbit  | 到达文件结束返回真\ngood()          | goodbit | 流状态正常返回真\nclear()         |         | 清除条件状态，设置为goodbit\nclear(flags)    |         | 根据指定的标志位，将对应的条件状态复位\nsetstate(flags) |         | 根据指定的标志位，将对应的条件状态置位\nrdstate()       |         | 返回当前的条件状态\n\n## 1.2输出缓冲\n\n每个输出流都管理一个缓冲区，用来保存程序读写的数据。导致缓冲刷新（即将数据真正的写入到设备文件）的原因有：\n\n- 程序正常结束\n- 缓冲区满\n- 使用操纵符如 `endl`，来显示的刷新缓冲区\n- 使用 `unitbuf` 设置流的内部状态，来清空缓冲区\n- **当一个输出流关联到另外一个流时**，当读写关联流时，相应的输出流的缓冲区被刷新\n\n`unitbuf`使用后，所有的输出操作后都会立即刷新缓冲区，此时可以使用 `nounitbuf` 回到正常的缓冲方式。 使用 `tie` 方法可以关联两个流，使用无参版本的 `tie` 会返回当前流管理按的流指针，如果没有关联流则返回空指针。使用带参数的版本绑定相应的流到当前流。\n\n## 1.3 文件输入输出\n\n与标准输入输出流相比， `fstream` 新增了几个操作：\n\n操作                     | 含义\n---------------------- | -------------------\nfstream fstrm(s)       | 创建fstream，并打开s指定的文件\nfstream fstrm(s, mode) | 和上个类似，mode指打开的文件模式\nfstrm.open(s)          | 打开s指定的文件\nfstrm.close()          | 关闭fastream绑定的文件\nfstrm.is_open()        | 返回当前文件是否成功打开\n\n当构造一个fstream对象时，指定了文件，则 `open()` 方法自动被调用，而对象析构的时候， `close()` 方法自动被调用。\n\n上面提到了 fstream 的文件模式：\n\n模式     | 含义            | 备注\n------ | ------------- | --------------------------------------\nin     | 以只读方式打开       | 只可以对ifstream和fstream对象指定in模式\nout    | 以写方式打开        | 只可以对ofstream和fstream对象指定out模式\ntrunc  | 截断文件          | 只有当out也被设定的时候，才可以设定trunc模式\napp    | 每次写操作均定位到文件末尾 | 只要trunc没被设定，就可以设定app模式，且app模式默认打开out模式\nate    | 打开后定位到文件末尾    | 可以和任何搭配\nbinary | 以二进制方式打开      | 可以和任何搭配\n\n需要注意的是：\n\n1. 以 out 模式打开文件会丢弃已有数据\n2. 每次调用 open 都会确定文件模式\n\n## 1.3 string流\n\nstring流用于字符串的处理，通常可用于格式化输入输出。\n\n# 二、容器\n\nC++中的容器类包括\"顺序存储结构\"和\"关联存储结构\"，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。 有一些操作是所有容器都可以使用的：\n\n操作                  | 含义\n------------------- | ---------------------------\nC c;                | 默认构造函数，构造空容器\nC c(c2)             | 构造c2的拷贝c1\nC c(b, e)           | 构造c，将迭代器b和e之间的元素拷贝至c\nc1 = c2             | 将c1中的元素替换为c2\nc1 = ｛a, b, c...｝   | 将c1中的元素替换为列表中的元素\na.swap(b)/swap(a,b) | 交换a和b的元素\nc.size()            | 返回c中的元素数目（不支持forward_list）\nc.max_size()        | 返回c可以保存的最大元素数目\nc.empty()           | 如果c中存储了元素，返回false，否则返回 true\nc.begin()           | 返回指向c的第一个元素的迭代器\nc.end()             | 返回指向c的超尾的迭代器\n\n## 2.1 顺序容器\n\n顺序容器提供了快速顺序访问元素的能力，但是对与增删操作和非顺序访问操作有所性能折中。标准库中的顺序容器有：\n\n容器名          | 定义\n------------ | -------------------\nvector       | 可变大小数组\ndeque        | 双端队列\nlist         | 双向链表\nforward_list | 单向链表\narray        | 固定大小数组\nstring       | 与vector相似，但专门用来保存字符\n\n顺序容器共有的方法有:\n\n- `emplace(C++11 新增)`， 插入一个对象\n- `insert`, 插入一个拷贝\n- `resize(n)`, 重新设置大小\n- `assign`，替换\n- `erase`， 删除\n- `clear`，清除所有元素\n- `front`，返回第一个元素\n\n`vector`, `forward_list`, `list`, `deque` 共有的方法有：\n\n- `back`， 返回最后一个元素\n- `push_back`， 插入到末尾\n- `pop_back`， 删除最后一个元素\n- `emplace_back`， 追加到末尾\n- `push_front`，插入到队首\n- `pop_front`，删除队首\n- `emplace_front`，追加到队首\n- `at`，返回相应的对象\n\n`vector` 独有的操作有：\n\n- `capacity`， 返回能够存储的总量\n- `reserver`， 提醒至少需要存储相应个元素的空间\n\n`list` 独有的操作有：\n\n- `splice`， 移动指定的元素\n- `remove`， 删除相应值的所有元素\n- `unique`，删除连续的相同元素，仅保留一个\n- `merge`，合并两个链表，并排序\n- `sort`，排序\n- `reverse`,反转\n\n## 2.2 关联容器\n\n关联容器和顺序容器不同，关联容器中的元素是按照元素关键字来保存和访问的。关联容器有两个主要类型： `map` 和 `set`。\n\n- `map` 中的元素是一些关键字-值的对，关键字起到索引的作用，而值为对应索引的数据\n- `set` 中的元素只包含一个关键字。\n\n除了 `map` 和 `set`， 还有对应的 `multimap`和 `multiset`。此外， c++ 还定义了相应的无序集合 `unordered _map`等。\n\n相应的关联容器的操作有\n\n- `key_comp`, 返回比较对象\n- `value_comp`，返回 `value_comp` 对象\n- `insert`， 插入\n- `emplace`， 插入对象\n- `erase`， 擦除\n- `clear`， 清空\n- `find`， 寻找相应的键\n- `count`， 返回相应键的数量\n- `lower_bound`, 返回不小于指定键的元素迭代器\n- `upper_bound`， 返回大于k的元素迭代器\n- `equal_range`， 返回第一个成员为 `a.lower_bound(k)` 第二个成员为 `a.upper_bound(k)` 的值对\n- `operator`， 返回一个指向yu指定的键关联的值的引用\n\n无序容器的操作有\n\n- `hash_function` 返回使用的哈希函数\n- `key_eq` 返回创建时使用的键值相等谓词\n- `bucket_count`， 返回桶数\n\n# 三、泛型算法\n\n对于算法，算法本身不执行容器的操作，它们只会运行在迭代器之上，执行迭代器的操作。所以：算法永远不会改变底层容器的大小。\n\n## 3.1 算法分类\n\n1. **查找对象的算法** 相应的算法有 `find`， `count`， `adjacent_find`, `search_n`, `search`, `find_first_of`, `find_end`\n2. **其它只读算法** `for_each`, `mismatch`, `equal`\n3. **二分搜索算法** `lower_bound`， `upper_bount`， `equal_range`， `binary_search`\n4. **写容器操作** `fill`， `generate`， `copy`， `move`， `transform`， `replace_copy`， `merge`， `iter_swap`， `swap_ranges`， `replace`， `copy_backward`， `move_backward`， `inplace`\n5. **划分算法** `is_partitionedis`， `partitioned_copy`， `partition_point`， `stable_partition`， `partition`\n6. **排序算法** `sort`, `is_sorted`, `partial_sort`, `partial_sort_copy`, `nth_element`\n7. **通用重排算法** `remove`， `unique`， `rotate`， `reverse`， `random_shuffle`， `shuffle`\n8. **排列算法** `is_permutation`, `next_permutation`, `prev_permutation`\n9. **有序序列的集合算法** `set_inion`, `set_intersection`, `set_symmetric_difference`\n10. **最小值和最大值** `min`， `minmax`， `max`，\n11. **数值算法** `accumulate`， `inner_product`， `partial_sum`， `adjacent_difference`， `itoa`\n\n## 3.2 lambda\n\n一个lambda表示一个可调用的代码单元。他的形式如下： [capture list] (parameter list) -> return type {function body} `capture list` 是lambda所在的函数中定义的局部变量的列表 `return type` `parameter list` `function body` 表示相应的返回值，参数列表，函数体\n\nlambda可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体。\n\n# 四、智能指针\n\n通常我们使用 `new` 和 `delete` 来管理动态内存的。但是，这样的使用很容易出现问题：我们有可能会忘记释放内存造成内存泄漏；或者我们有可能使用了已释放的指针，导致非法访问。因为C++中定义了智能指针。 智能指针其实也是模版，C++中定义了三个相关的类：\n\n- `shared_ptr` 允许多个指针指向同一个对象\n- `unique_ptr` 仅允许一个指针指向对象\n- `weak_ptr` 弱引用，指向 `shared_ptr` 所管理的对象\n\n智能指针的相应操作有：\n\n函数名                                  | 含义\n------------------------------------ | --------------------------------\nshared_ptr <T> sp / unique_ptr<T> up | 空智能指针，可以指向类型为T的对象\np                                    | 可以把智能指针本身作为判断，如果p指向了一个对象，则返回true\n*p                                   | 解引用，获得指向的对象\np->mem                               | 等价于(*p).mem\nswap(p, q) / p.swap(q)               | 交换\nmake_shared <T>(args)                | 返回一个shared_ptr\nshared_ptr<T>p (q)                   | p 是 q 的拷贝\np = q                                | 拷贝\np.use_count()                        | 返回与p共享对象的智能指针对象\np.unique()                           | 如果p.use_count()为1，返回true\n\n当智能指针创建之后，每对shared_ptr的拷贝和赋值，都会使 shared_ptr 的引用计数加一。 当一个shared_ptr被销毁时，shared_ptr 的引用计数会递减。 当动态内存的引用计数为0时， shared_ptr 的析构函数会自动销毁所管理的对象。 我们可能会在下面的三种情况下使用智能指针：\n\n- 程序不知道自己需要使用多少对象\n- 程序不知道所需对象的准确类型\n- 程序需要在多个对象间共享数据\n","slug":"C-学习笔记（三）——STL","published":1,"updated":"2017-12-06T13:34:46.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9myw0002bkw1suqooyaa","content":"<p>C++的标准库的内容在50个头文件中定义。其中最重要的一部分是有关容器类和泛型算法的——–即 STL(Standard Template Library)。</p>\n<a id=\"more\"></a>\n<p>包括STL在内的C++头文件大致可以分为10类：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>头文件名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语言支持功能</td>\n<td>&lt;cstddef&gt;&lt;limits&gt;&lt;climits&gt;&lt;cfloat&gt;&lt;cstdlib&gt;&lt;new&gt;&lt;typeinfo&gt;&lt;exception&gt;&lt;cstdarg&gt;&lt;csetjmp&gt;&lt;csignal&gt;</td>\n</tr>\n<tr>\n<td>流输入/输出</td>\n<td>&lt;iostream&gt;&lt;iomanip&gt;&lt;iOS&gt;&lt;istream&gt;&lt;ostream&gt;&lt;sstream&gt;&lt;fstream&gt;&lt;iosfwd&gt;&lt;streambuf&gt;&lt;cstdio&gt;&lt;cwchar&gt;</td>\n</tr>\n<tr>\n<td>诊断功能相关</td>\n<td>&lt;stdexcept&gt;&lt;cassert&gt;&lt;cerrno&gt;</td>\n</tr>\n<tr>\n<td>定义工具函数</td>\n<td>&lt;utility&gt;&lt;functional&gt;&lt;memory&gt;&lt;ctime&gt;</td>\n</tr>\n<tr>\n<td>字符串处理</td>\n<td>&lt;string&gt;&lt;cctype&gt;&lt;cwctype&gt;&lt;cstring&gt;&lt;cwchar&gt;&lt;cstdlib&gt;</td>\n</tr>\n<tr>\n<td>STL—-容器</td>\n<td>&lt;vector&gt;&lt;list&gt;&lt;deque&gt;&lt;queue&gt;&lt;stack&gt;&lt;map&gt;&lt;set&gt;&lt;bitset&gt;</td>\n</tr>\n<tr>\n<td>STL—-迭代器</td>\n<td>&lt;iterator&gt;</td>\n</tr>\n<tr>\n<td>STL—-算法</td>\n<td>&lt;algorithm&gt;&lt;cstdlib&gt;&lt;ciso646&gt;</td>\n</tr>\n<tr>\n<td>数值操作</td>\n<td>&lt;complex&gt;&lt;valarray&gt;&lt;numeric&gt;&lt;cmath&gt;&lt;cstdlib&gt;</td>\n</tr>\n<tr>\n<td>本地化</td>\n<td>&lt;locale&gt;&lt;clocale&gt;</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"一、IO库\"><a href=\"#一、IO库\" class=\"headerlink\" title=\"一、IO库\"></a>一、IO库</h1><p>C++对输入输出的处理是通过一组定义在标准库中的类型来处理的。这些类型分别定义在三个头文件中：</p>\n<ul>\n<li><code>iostream</code> 包括 <code>istream</code> <code>ostream</code> <code>iostream</code></li>\n<li><code>fstream</code> 包括 <code>ifstream</code> <code>ofstream</code> <code>fstream</code></li>\n<li><code>sstream</code> 包括 <code>istringstream</code> <code>ostingstream</code> <code>stringstream</code> 对 <code>fstream</code> 和 <code>sstream</code> 的处理和 <code>iostream</code> 基本是一致的。需要注意的是：<strong>IO对象是不能进行拷贝或者赋值的</strong>。</li>\n</ul>\n<h2 id=\"1-1条件状态\"><a href=\"#1-1条件状态\" class=\"headerlink\" title=\"1.1条件状态\"></a>1.1条件状态</h2><p>条件状态用来帮助我们访问和操纵流的状态：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>标志</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bad()</td>\n<td>badbit</td>\n<td>如果流崩溃返回真</td>\n</tr>\n<tr>\n<td>fail()</td>\n<td>failbit</td>\n<td>IO操作失败返回真</td>\n</tr>\n<tr>\n<td>eof()</td>\n<td>eofbit</td>\n<td>到达文件结束返回真</td>\n</tr>\n<tr>\n<td>good()</td>\n<td>goodbit</td>\n<td>流状态正常返回真</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td></td>\n<td>清除条件状态，设置为goodbit</td>\n</tr>\n<tr>\n<td>clear(flags)</td>\n<td></td>\n<td>根据指定的标志位，将对应的条件状态复位</td>\n</tr>\n<tr>\n<td>setstate(flags)</td>\n<td></td>\n<td>根据指定的标志位，将对应的条件状态置位</td>\n</tr>\n<tr>\n<td>rdstate()</td>\n<td></td>\n<td>返回当前的条件状态</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-2输出缓冲\"><a href=\"#1-2输出缓冲\" class=\"headerlink\" title=\"1.2输出缓冲\"></a>1.2输出缓冲</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。导致缓冲刷新（即将数据真正的写入到设备文件）的原因有：</p>\n<ul>\n<li>程序正常结束</li>\n<li>缓冲区满</li>\n<li>使用操纵符如 <code>endl</code>，来显示的刷新缓冲区</li>\n<li>使用 <code>unitbuf</code> 设置流的内部状态，来清空缓冲区</li>\n<li><strong>当一个输出流关联到另外一个流时</strong>，当读写关联流时，相应的输出流的缓冲区被刷新</li>\n</ul>\n<p><code>unitbuf</code>使用后，所有的输出操作后都会立即刷新缓冲区，此时可以使用 <code>nounitbuf</code> 回到正常的缓冲方式。 使用 <code>tie</code> 方法可以关联两个流，使用无参版本的 <code>tie</code> 会返回当前流管理按的流指针，如果没有关联流则返回空指针。使用带参数的版本绑定相应的流到当前流。</p>\n<h2 id=\"1-3-文件输入输出\"><a href=\"#1-3-文件输入输出\" class=\"headerlink\" title=\"1.3 文件输入输出\"></a>1.3 文件输入输出</h2><p>与标准输入输出流相比， <code>fstream</code> 新增了几个操作：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fstream fstrm(s)</td>\n<td>创建fstream，并打开s指定的文件</td>\n</tr>\n<tr>\n<td>fstream fstrm(s, mode)</td>\n<td>和上个类似，mode指打开的文件模式</td>\n</tr>\n<tr>\n<td>fstrm.open(s)</td>\n<td>打开s指定的文件</td>\n</tr>\n<tr>\n<td>fstrm.close()</td>\n<td>关闭fastream绑定的文件</td>\n</tr>\n<tr>\n<td>fstrm.is_open()</td>\n<td>返回当前文件是否成功打开</td>\n</tr>\n</tbody>\n</table>\n<p>当构造一个fstream对象时，指定了文件，则 <code>open()</code> 方法自动被调用，而对象析构的时候， <code>close()</code> 方法自动被调用。</p>\n<p>上面提到了 fstream 的文件模式：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>以只读方式打开</td>\n<td>只可以对ifstream和fstream对象指定in模式</td>\n</tr>\n<tr>\n<td>out</td>\n<td>以写方式打开</td>\n<td>只可以对ofstream和fstream对象指定out模式</td>\n</tr>\n<tr>\n<td>trunc</td>\n<td>截断文件</td>\n<td>只有当out也被设定的时候，才可以设定trunc模式</td>\n</tr>\n<tr>\n<td>app</td>\n<td>每次写操作均定位到文件末尾</td>\n<td>只要trunc没被设定，就可以设定app模式，且app模式默认打开out模式</td>\n</tr>\n<tr>\n<td>ate</td>\n<td>打开后定位到文件末尾</td>\n<td>可以和任何搭配</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>以二进制方式打开</td>\n<td>可以和任何搭配</td>\n</tr>\n</tbody>\n</table>\n<p>需要注意的是：</p>\n<ol>\n<li>以 out 模式打开文件会丢弃已有数据</li>\n<li>每次调用 open 都会确定文件模式</li>\n</ol>\n<h2 id=\"1-3-string流\"><a href=\"#1-3-string流\" class=\"headerlink\" title=\"1.3 string流\"></a>1.3 string流</h2><p>string流用于字符串的处理，通常可用于格式化输入输出。</p>\n<h1 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h1><p>C++中的容器类包括”顺序存储结构”和”关联存储结构”，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。 有一些操作是所有容器都可以使用的：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C c;</td>\n<td>默认构造函数，构造空容器</td>\n</tr>\n<tr>\n<td>C c(c2)</td>\n<td>构造c2的拷贝c1</td>\n</tr>\n<tr>\n<td>C c(b, e)</td>\n<td>构造c，将迭代器b和e之间的元素拷贝至c</td>\n</tr>\n<tr>\n<td>c1 = c2</td>\n<td>将c1中的元素替换为c2</td>\n</tr>\n<tr>\n<td>c1 = ｛a, b, c…｝</td>\n<td>将c1中的元素替换为列表中的元素</td>\n</tr>\n<tr>\n<td>a.swap(b)/swap(a,b)</td>\n<td>交换a和b的元素</td>\n</tr>\n<tr>\n<td>c.size()</td>\n<td>返回c中的元素数目（不支持forward_list）</td>\n</tr>\n<tr>\n<td>c.max_size()</td>\n<td>返回c可以保存的最大元素数目</td>\n</tr>\n<tr>\n<td>c.empty()</td>\n<td>如果c中存储了元素，返回false，否则返回 true</td>\n</tr>\n<tr>\n<td>c.begin()</td>\n<td>返回指向c的第一个元素的迭代器</td>\n</tr>\n<tr>\n<td>c.end()</td>\n<td>返回指向c的超尾的迭代器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-1-顺序容器\"><a href=\"#2-1-顺序容器\" class=\"headerlink\" title=\"2.1 顺序容器\"></a>2.1 顺序容器</h2><p>顺序容器提供了快速顺序访问元素的能力，但是对与增删操作和非顺序访问操作有所性能折中。标准库中的顺序容器有：</p>\n<table>\n<thead>\n<tr>\n<th>容器名</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vector</td>\n<td>可变大小数组</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>双端队列</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双向链表</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单向链表</td>\n</tr>\n<tr>\n<td>array</td>\n<td>固定大小数组</td>\n</tr>\n<tr>\n<td>string</td>\n<td>与vector相似，但专门用来保存字符</td>\n</tr>\n</tbody>\n</table>\n<p>顺序容器共有的方法有:</p>\n<ul>\n<li><code>emplace(C++11 新增)</code>， 插入一个对象</li>\n<li><code>insert</code>, 插入一个拷贝</li>\n<li><code>resize(n)</code>, 重新设置大小</li>\n<li><code>assign</code>，替换</li>\n<li><code>erase</code>， 删除</li>\n<li><code>clear</code>，清除所有元素</li>\n<li><code>front</code>，返回第一个元素</li>\n</ul>\n<p><code>vector</code>, <code>forward_list</code>, <code>list</code>, <code>deque</code> 共有的方法有：</p>\n<ul>\n<li><code>back</code>， 返回最后一个元素</li>\n<li><code>push_back</code>， 插入到末尾</li>\n<li><code>pop_back</code>， 删除最后一个元素</li>\n<li><code>emplace_back</code>， 追加到末尾</li>\n<li><code>push_front</code>，插入到队首</li>\n<li><code>pop_front</code>，删除队首</li>\n<li><code>emplace_front</code>，追加到队首</li>\n<li><code>at</code>，返回相应的对象</li>\n</ul>\n<p><code>vector</code> 独有的操作有：</p>\n<ul>\n<li><code>capacity</code>， 返回能够存储的总量</li>\n<li><code>reserver</code>， 提醒至少需要存储相应个元素的空间</li>\n</ul>\n<p><code>list</code> 独有的操作有：</p>\n<ul>\n<li><code>splice</code>， 移动指定的元素</li>\n<li><code>remove</code>， 删除相应值的所有元素</li>\n<li><code>unique</code>，删除连续的相同元素，仅保留一个</li>\n<li><code>merge</code>，合并两个链表，并排序</li>\n<li><code>sort</code>，排序</li>\n<li><code>reverse</code>,反转</li>\n</ul>\n<h2 id=\"2-2-关联容器\"><a href=\"#2-2-关联容器\" class=\"headerlink\" title=\"2.2 关联容器\"></a>2.2 关联容器</h2><p>关联容器和顺序容器不同，关联容器中的元素是按照元素关键字来保存和访问的。关联容器有两个主要类型： <code>map</code> 和 <code>set</code>。</p>\n<ul>\n<li><code>map</code> 中的元素是一些关键字-值的对，关键字起到索引的作用，而值为对应索引的数据</li>\n<li><code>set</code> 中的元素只包含一个关键字。</li>\n</ul>\n<p>除了 <code>map</code> 和 <code>set</code>， 还有对应的 <code>multimap</code>和 <code>multiset</code>。此外， c++ 还定义了相应的无序集合 <code>unordered _map</code>等。</p>\n<p>相应的关联容器的操作有</p>\n<ul>\n<li><code>key_comp</code>, 返回比较对象</li>\n<li><code>value_comp</code>，返回 <code>value_comp</code> 对象</li>\n<li><code>insert</code>， 插入</li>\n<li><code>emplace</code>， 插入对象</li>\n<li><code>erase</code>， 擦除</li>\n<li><code>clear</code>， 清空</li>\n<li><code>find</code>， 寻找相应的键</li>\n<li><code>count</code>， 返回相应键的数量</li>\n<li><code>lower_bound</code>, 返回不小于指定键的元素迭代器</li>\n<li><code>upper_bound</code>， 返回大于k的元素迭代器</li>\n<li><code>equal_range</code>， 返回第一个成员为 <code>a.lower_bound(k)</code> 第二个成员为 <code>a.upper_bound(k)</code> 的值对</li>\n<li><code>operator</code>， 返回一个指向yu指定的键关联的值的引用</li>\n</ul>\n<p>无序容器的操作有</p>\n<ul>\n<li><code>hash_function</code> 返回使用的哈希函数</li>\n<li><code>key_eq</code> 返回创建时使用的键值相等谓词</li>\n<li><code>bucket_count</code>， 返回桶数</li>\n</ul>\n<h1 id=\"三、泛型算法\"><a href=\"#三、泛型算法\" class=\"headerlink\" title=\"三、泛型算法\"></a>三、泛型算法</h1><p>对于算法，算法本身不执行容器的操作，它们只会运行在迭代器之上，执行迭代器的操作。所以：算法永远不会改变底层容器的大小。</p>\n<h2 id=\"3-1-算法分类\"><a href=\"#3-1-算法分类\" class=\"headerlink\" title=\"3.1 算法分类\"></a>3.1 算法分类</h2><ol>\n<li><strong>查找对象的算法</strong> 相应的算法有 <code>find</code>， <code>count</code>， <code>adjacent_find</code>, <code>search_n</code>, <code>search</code>, <code>find_first_of</code>, <code>find_end</code></li>\n<li><strong>其它只读算法</strong> <code>for_each</code>, <code>mismatch</code>, <code>equal</code></li>\n<li><strong>二分搜索算法</strong> <code>lower_bound</code>， <code>upper_bount</code>， <code>equal_range</code>， <code>binary_search</code></li>\n<li><strong>写容器操作</strong> <code>fill</code>， <code>generate</code>， <code>copy</code>， <code>move</code>， <code>transform</code>， <code>replace_copy</code>， <code>merge</code>， <code>iter_swap</code>， <code>swap_ranges</code>， <code>replace</code>， <code>copy_backward</code>， <code>move_backward</code>， <code>inplace</code></li>\n<li><strong>划分算法</strong> <code>is_partitionedis</code>， <code>partitioned_copy</code>， <code>partition_point</code>， <code>stable_partition</code>， <code>partition</code></li>\n<li><strong>排序算法</strong> <code>sort</code>, <code>is_sorted</code>, <code>partial_sort</code>, <code>partial_sort_copy</code>, <code>nth_element</code></li>\n<li><strong>通用重排算法</strong> <code>remove</code>， <code>unique</code>， <code>rotate</code>， <code>reverse</code>， <code>random_shuffle</code>， <code>shuffle</code></li>\n<li><strong>排列算法</strong> <code>is_permutation</code>, <code>next_permutation</code>, <code>prev_permutation</code></li>\n<li><strong>有序序列的集合算法</strong> <code>set_inion</code>, <code>set_intersection</code>, <code>set_symmetric_difference</code></li>\n<li><strong>最小值和最大值</strong> <code>min</code>， <code>minmax</code>， <code>max</code>，</li>\n<li><strong>数值算法</strong> <code>accumulate</code>， <code>inner_product</code>， <code>partial_sum</code>， <code>adjacent_difference</code>， <code>itoa</code></li>\n</ol>\n<h2 id=\"3-2-lambda\"><a href=\"#3-2-lambda\" class=\"headerlink\" title=\"3.2 lambda\"></a>3.2 lambda</h2><p>一个lambda表示一个可调用的代码单元。他的形式如下： [capture list] (parameter list) -&gt; return type {function body} <code>capture list</code> 是lambda所在的函数中定义的局部变量的列表 <code>return type</code> <code>parameter list</code> <code>function body</code> 表示相应的返回值，参数列表，函数体</p>\n<p>lambda可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体。</p>\n<h1 id=\"四、智能指针\"><a href=\"#四、智能指针\" class=\"headerlink\" title=\"四、智能指针\"></a>四、智能指针</h1><p>通常我们使用 <code>new</code> 和 <code>delete</code> 来管理动态内存的。但是，这样的使用很容易出现问题：我们有可能会忘记释放内存造成内存泄漏；或者我们有可能使用了已释放的指针，导致非法访问。因为C++中定义了智能指针。 智能指针其实也是模版，C++中定义了三个相关的类：</p>\n<ul>\n<li><code>shared_ptr</code> 允许多个指针指向同一个对象</li>\n<li><code>unique_ptr</code> 仅允许一个指针指向对象</li>\n<li><code>weak_ptr</code> 弱引用，指向 <code>shared_ptr</code> 所管理的对象</li>\n</ul>\n<p>智能指针的相应操作有：</p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shared_ptr <t> sp / unique_ptr<t> up</t></t></td>\n<td>空智能指针，可以指向类型为T的对象</td>\n</tr>\n<tr>\n<td>p</td>\n<td>可以把智能指针本身作为判断，如果p指向了一个对象，则返回true</td>\n</tr>\n<tr>\n<td>*p</td>\n<td>解引用，获得指向的对象</td>\n</tr>\n<tr>\n<td>p-&gt;mem</td>\n<td>等价于(*p).mem</td>\n</tr>\n<tr>\n<td>swap(p, q) / p.swap(q)</td>\n<td>交换</td>\n</tr>\n<tr>\n<td>make_shared <t>(args)</t></td>\n<td>返回一个shared_ptr</td>\n</tr>\n<tr>\n<td>shared_ptr<t>p (q)</t></td>\n<td>p 是 q 的拷贝</td>\n</tr>\n<tr>\n<td>p = q</td>\n<td>拷贝</td>\n</tr>\n<tr>\n<td>p.use_count()</td>\n<td>返回与p共享对象的智能指针对象</td>\n</tr>\n<tr>\n<td>p.unique()</td>\n<td>如果p.use_count()为1，返回true</td>\n</tr>\n</tbody>\n</table>\n<p>当智能指针创建之后，每对shared_ptr的拷贝和赋值，都会使 shared_ptr 的引用计数加一。 当一个shared_ptr被销毁时，shared_ptr 的引用计数会递减。 当动态内存的引用计数为0时， shared_ptr 的析构函数会自动销毁所管理的对象。 我们可能会在下面的三种情况下使用智能指针：</p>\n<ul>\n<li>程序不知道自己需要使用多少对象</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象间共享数据</li>\n</ul>\n","excerpt":"<p>C++的标准库的内容在50个头文件中定义。其中最重要的一部分是有关容器类和泛型算法的——–即 STL(Standard Template Library)。</p>","more":"<p>包括STL在内的C++头文件大致可以分为10类：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>头文件名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语言支持功能</td>\n<td>&lt;cstddef&gt;&lt;limits&gt;&lt;climits&gt;&lt;cfloat&gt;&lt;cstdlib&gt;&lt;new&gt;&lt;typeinfo&gt;&lt;exception&gt;&lt;cstdarg&gt;&lt;csetjmp&gt;&lt;csignal&gt;</td>\n</tr>\n<tr>\n<td>流输入/输出</td>\n<td>&lt;iostream&gt;&lt;iomanip&gt;&lt;iOS&gt;&lt;istream&gt;&lt;ostream&gt;&lt;sstream&gt;&lt;fstream&gt;&lt;iosfwd&gt;&lt;streambuf&gt;&lt;cstdio&gt;&lt;cwchar&gt;</td>\n</tr>\n<tr>\n<td>诊断功能相关</td>\n<td>&lt;stdexcept&gt;&lt;cassert&gt;&lt;cerrno&gt;</td>\n</tr>\n<tr>\n<td>定义工具函数</td>\n<td>&lt;utility&gt;&lt;functional&gt;&lt;memory&gt;&lt;ctime&gt;</td>\n</tr>\n<tr>\n<td>字符串处理</td>\n<td>&lt;string&gt;&lt;cctype&gt;&lt;cwctype&gt;&lt;cstring&gt;&lt;cwchar&gt;&lt;cstdlib&gt;</td>\n</tr>\n<tr>\n<td>STL—-容器</td>\n<td>&lt;vector&gt;&lt;list&gt;&lt;deque&gt;&lt;queue&gt;&lt;stack&gt;&lt;map&gt;&lt;set&gt;&lt;bitset&gt;</td>\n</tr>\n<tr>\n<td>STL—-迭代器</td>\n<td>&lt;iterator&gt;</td>\n</tr>\n<tr>\n<td>STL—-算法</td>\n<td>&lt;algorithm&gt;&lt;cstdlib&gt;&lt;ciso646&gt;</td>\n</tr>\n<tr>\n<td>数值操作</td>\n<td>&lt;complex&gt;&lt;valarray&gt;&lt;numeric&gt;&lt;cmath&gt;&lt;cstdlib&gt;</td>\n</tr>\n<tr>\n<td>本地化</td>\n<td>&lt;locale&gt;&lt;clocale&gt;</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"一、IO库\"><a href=\"#一、IO库\" class=\"headerlink\" title=\"一、IO库\"></a>一、IO库</h1><p>C++对输入输出的处理是通过一组定义在标准库中的类型来处理的。这些类型分别定义在三个头文件中：</p>\n<ul>\n<li><code>iostream</code> 包括 <code>istream</code> <code>ostream</code> <code>iostream</code></li>\n<li><code>fstream</code> 包括 <code>ifstream</code> <code>ofstream</code> <code>fstream</code></li>\n<li><code>sstream</code> 包括 <code>istringstream</code> <code>ostingstream</code> <code>stringstream</code> 对 <code>fstream</code> 和 <code>sstream</code> 的处理和 <code>iostream</code> 基本是一致的。需要注意的是：<strong>IO对象是不能进行拷贝或者赋值的</strong>。</li>\n</ul>\n<h2 id=\"1-1条件状态\"><a href=\"#1-1条件状态\" class=\"headerlink\" title=\"1.1条件状态\"></a>1.1条件状态</h2><p>条件状态用来帮助我们访问和操纵流的状态：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>标志</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bad()</td>\n<td>badbit</td>\n<td>如果流崩溃返回真</td>\n</tr>\n<tr>\n<td>fail()</td>\n<td>failbit</td>\n<td>IO操作失败返回真</td>\n</tr>\n<tr>\n<td>eof()</td>\n<td>eofbit</td>\n<td>到达文件结束返回真</td>\n</tr>\n<tr>\n<td>good()</td>\n<td>goodbit</td>\n<td>流状态正常返回真</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td></td>\n<td>清除条件状态，设置为goodbit</td>\n</tr>\n<tr>\n<td>clear(flags)</td>\n<td></td>\n<td>根据指定的标志位，将对应的条件状态复位</td>\n</tr>\n<tr>\n<td>setstate(flags)</td>\n<td></td>\n<td>根据指定的标志位，将对应的条件状态置位</td>\n</tr>\n<tr>\n<td>rdstate()</td>\n<td></td>\n<td>返回当前的条件状态</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-2输出缓冲\"><a href=\"#1-2输出缓冲\" class=\"headerlink\" title=\"1.2输出缓冲\"></a>1.2输出缓冲</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。导致缓冲刷新（即将数据真正的写入到设备文件）的原因有：</p>\n<ul>\n<li>程序正常结束</li>\n<li>缓冲区满</li>\n<li>使用操纵符如 <code>endl</code>，来显示的刷新缓冲区</li>\n<li>使用 <code>unitbuf</code> 设置流的内部状态，来清空缓冲区</li>\n<li><strong>当一个输出流关联到另外一个流时</strong>，当读写关联流时，相应的输出流的缓冲区被刷新</li>\n</ul>\n<p><code>unitbuf</code>使用后，所有的输出操作后都会立即刷新缓冲区，此时可以使用 <code>nounitbuf</code> 回到正常的缓冲方式。 使用 <code>tie</code> 方法可以关联两个流，使用无参版本的 <code>tie</code> 会返回当前流管理按的流指针，如果没有关联流则返回空指针。使用带参数的版本绑定相应的流到当前流。</p>\n<h2 id=\"1-3-文件输入输出\"><a href=\"#1-3-文件输入输出\" class=\"headerlink\" title=\"1.3 文件输入输出\"></a>1.3 文件输入输出</h2><p>与标准输入输出流相比， <code>fstream</code> 新增了几个操作：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fstream fstrm(s)</td>\n<td>创建fstream，并打开s指定的文件</td>\n</tr>\n<tr>\n<td>fstream fstrm(s, mode)</td>\n<td>和上个类似，mode指打开的文件模式</td>\n</tr>\n<tr>\n<td>fstrm.open(s)</td>\n<td>打开s指定的文件</td>\n</tr>\n<tr>\n<td>fstrm.close()</td>\n<td>关闭fastream绑定的文件</td>\n</tr>\n<tr>\n<td>fstrm.is_open()</td>\n<td>返回当前文件是否成功打开</td>\n</tr>\n</tbody>\n</table>\n<p>当构造一个fstream对象时，指定了文件，则 <code>open()</code> 方法自动被调用，而对象析构的时候， <code>close()</code> 方法自动被调用。</p>\n<p>上面提到了 fstream 的文件模式：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>in</td>\n<td>以只读方式打开</td>\n<td>只可以对ifstream和fstream对象指定in模式</td>\n</tr>\n<tr>\n<td>out</td>\n<td>以写方式打开</td>\n<td>只可以对ofstream和fstream对象指定out模式</td>\n</tr>\n<tr>\n<td>trunc</td>\n<td>截断文件</td>\n<td>只有当out也被设定的时候，才可以设定trunc模式</td>\n</tr>\n<tr>\n<td>app</td>\n<td>每次写操作均定位到文件末尾</td>\n<td>只要trunc没被设定，就可以设定app模式，且app模式默认打开out模式</td>\n</tr>\n<tr>\n<td>ate</td>\n<td>打开后定位到文件末尾</td>\n<td>可以和任何搭配</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>以二进制方式打开</td>\n<td>可以和任何搭配</td>\n</tr>\n</tbody>\n</table>\n<p>需要注意的是：</p>\n<ol>\n<li>以 out 模式打开文件会丢弃已有数据</li>\n<li>每次调用 open 都会确定文件模式</li>\n</ol>\n<h2 id=\"1-3-string流\"><a href=\"#1-3-string流\" class=\"headerlink\" title=\"1.3 string流\"></a>1.3 string流</h2><p>string流用于字符串的处理，通常可用于格式化输入输出。</p>\n<h1 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h1><p>C++中的容器类包括”顺序存储结构”和”关联存储结构”，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。 有一些操作是所有容器都可以使用的：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C c;</td>\n<td>默认构造函数，构造空容器</td>\n</tr>\n<tr>\n<td>C c(c2)</td>\n<td>构造c2的拷贝c1</td>\n</tr>\n<tr>\n<td>C c(b, e)</td>\n<td>构造c，将迭代器b和e之间的元素拷贝至c</td>\n</tr>\n<tr>\n<td>c1 = c2</td>\n<td>将c1中的元素替换为c2</td>\n</tr>\n<tr>\n<td>c1 = ｛a, b, c…｝</td>\n<td>将c1中的元素替换为列表中的元素</td>\n</tr>\n<tr>\n<td>a.swap(b)/swap(a,b)</td>\n<td>交换a和b的元素</td>\n</tr>\n<tr>\n<td>c.size()</td>\n<td>返回c中的元素数目（不支持forward_list）</td>\n</tr>\n<tr>\n<td>c.max_size()</td>\n<td>返回c可以保存的最大元素数目</td>\n</tr>\n<tr>\n<td>c.empty()</td>\n<td>如果c中存储了元素，返回false，否则返回 true</td>\n</tr>\n<tr>\n<td>c.begin()</td>\n<td>返回指向c的第一个元素的迭代器</td>\n</tr>\n<tr>\n<td>c.end()</td>\n<td>返回指向c的超尾的迭代器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-1-顺序容器\"><a href=\"#2-1-顺序容器\" class=\"headerlink\" title=\"2.1 顺序容器\"></a>2.1 顺序容器</h2><p>顺序容器提供了快速顺序访问元素的能力，但是对与增删操作和非顺序访问操作有所性能折中。标准库中的顺序容器有：</p>\n<table>\n<thead>\n<tr>\n<th>容器名</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vector</td>\n<td>可变大小数组</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>双端队列</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双向链表</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单向链表</td>\n</tr>\n<tr>\n<td>array</td>\n<td>固定大小数组</td>\n</tr>\n<tr>\n<td>string</td>\n<td>与vector相似，但专门用来保存字符</td>\n</tr>\n</tbody>\n</table>\n<p>顺序容器共有的方法有:</p>\n<ul>\n<li><code>emplace(C++11 新增)</code>， 插入一个对象</li>\n<li><code>insert</code>, 插入一个拷贝</li>\n<li><code>resize(n)</code>, 重新设置大小</li>\n<li><code>assign</code>，替换</li>\n<li><code>erase</code>， 删除</li>\n<li><code>clear</code>，清除所有元素</li>\n<li><code>front</code>，返回第一个元素</li>\n</ul>\n<p><code>vector</code>, <code>forward_list</code>, <code>list</code>, <code>deque</code> 共有的方法有：</p>\n<ul>\n<li><code>back</code>， 返回最后一个元素</li>\n<li><code>push_back</code>， 插入到末尾</li>\n<li><code>pop_back</code>， 删除最后一个元素</li>\n<li><code>emplace_back</code>， 追加到末尾</li>\n<li><code>push_front</code>，插入到队首</li>\n<li><code>pop_front</code>，删除队首</li>\n<li><code>emplace_front</code>，追加到队首</li>\n<li><code>at</code>，返回相应的对象</li>\n</ul>\n<p><code>vector</code> 独有的操作有：</p>\n<ul>\n<li><code>capacity</code>， 返回能够存储的总量</li>\n<li><code>reserver</code>， 提醒至少需要存储相应个元素的空间</li>\n</ul>\n<p><code>list</code> 独有的操作有：</p>\n<ul>\n<li><code>splice</code>， 移动指定的元素</li>\n<li><code>remove</code>， 删除相应值的所有元素</li>\n<li><code>unique</code>，删除连续的相同元素，仅保留一个</li>\n<li><code>merge</code>，合并两个链表，并排序</li>\n<li><code>sort</code>，排序</li>\n<li><code>reverse</code>,反转</li>\n</ul>\n<h2 id=\"2-2-关联容器\"><a href=\"#2-2-关联容器\" class=\"headerlink\" title=\"2.2 关联容器\"></a>2.2 关联容器</h2><p>关联容器和顺序容器不同，关联容器中的元素是按照元素关键字来保存和访问的。关联容器有两个主要类型： <code>map</code> 和 <code>set</code>。</p>\n<ul>\n<li><code>map</code> 中的元素是一些关键字-值的对，关键字起到索引的作用，而值为对应索引的数据</li>\n<li><code>set</code> 中的元素只包含一个关键字。</li>\n</ul>\n<p>除了 <code>map</code> 和 <code>set</code>， 还有对应的 <code>multimap</code>和 <code>multiset</code>。此外， c++ 还定义了相应的无序集合 <code>unordered _map</code>等。</p>\n<p>相应的关联容器的操作有</p>\n<ul>\n<li><code>key_comp</code>, 返回比较对象</li>\n<li><code>value_comp</code>，返回 <code>value_comp</code> 对象</li>\n<li><code>insert</code>， 插入</li>\n<li><code>emplace</code>， 插入对象</li>\n<li><code>erase</code>， 擦除</li>\n<li><code>clear</code>， 清空</li>\n<li><code>find</code>， 寻找相应的键</li>\n<li><code>count</code>， 返回相应键的数量</li>\n<li><code>lower_bound</code>, 返回不小于指定键的元素迭代器</li>\n<li><code>upper_bound</code>， 返回大于k的元素迭代器</li>\n<li><code>equal_range</code>， 返回第一个成员为 <code>a.lower_bound(k)</code> 第二个成员为 <code>a.upper_bound(k)</code> 的值对</li>\n<li><code>operator</code>， 返回一个指向yu指定的键关联的值的引用</li>\n</ul>\n<p>无序容器的操作有</p>\n<ul>\n<li><code>hash_function</code> 返回使用的哈希函数</li>\n<li><code>key_eq</code> 返回创建时使用的键值相等谓词</li>\n<li><code>bucket_count</code>， 返回桶数</li>\n</ul>\n<h1 id=\"三、泛型算法\"><a href=\"#三、泛型算法\" class=\"headerlink\" title=\"三、泛型算法\"></a>三、泛型算法</h1><p>对于算法，算法本身不执行容器的操作，它们只会运行在迭代器之上，执行迭代器的操作。所以：算法永远不会改变底层容器的大小。</p>\n<h2 id=\"3-1-算法分类\"><a href=\"#3-1-算法分类\" class=\"headerlink\" title=\"3.1 算法分类\"></a>3.1 算法分类</h2><ol>\n<li><strong>查找对象的算法</strong> 相应的算法有 <code>find</code>， <code>count</code>， <code>adjacent_find</code>, <code>search_n</code>, <code>search</code>, <code>find_first_of</code>, <code>find_end</code></li>\n<li><strong>其它只读算法</strong> <code>for_each</code>, <code>mismatch</code>, <code>equal</code></li>\n<li><strong>二分搜索算法</strong> <code>lower_bound</code>， <code>upper_bount</code>， <code>equal_range</code>， <code>binary_search</code></li>\n<li><strong>写容器操作</strong> <code>fill</code>， <code>generate</code>， <code>copy</code>， <code>move</code>， <code>transform</code>， <code>replace_copy</code>， <code>merge</code>， <code>iter_swap</code>， <code>swap_ranges</code>， <code>replace</code>， <code>copy_backward</code>， <code>move_backward</code>， <code>inplace</code></li>\n<li><strong>划分算法</strong> <code>is_partitionedis</code>， <code>partitioned_copy</code>， <code>partition_point</code>， <code>stable_partition</code>， <code>partition</code></li>\n<li><strong>排序算法</strong> <code>sort</code>, <code>is_sorted</code>, <code>partial_sort</code>, <code>partial_sort_copy</code>, <code>nth_element</code></li>\n<li><strong>通用重排算法</strong> <code>remove</code>， <code>unique</code>， <code>rotate</code>， <code>reverse</code>， <code>random_shuffle</code>， <code>shuffle</code></li>\n<li><strong>排列算法</strong> <code>is_permutation</code>, <code>next_permutation</code>, <code>prev_permutation</code></li>\n<li><strong>有序序列的集合算法</strong> <code>set_inion</code>, <code>set_intersection</code>, <code>set_symmetric_difference</code></li>\n<li><strong>最小值和最大值</strong> <code>min</code>， <code>minmax</code>， <code>max</code>，</li>\n<li><strong>数值算法</strong> <code>accumulate</code>， <code>inner_product</code>， <code>partial_sum</code>， <code>adjacent_difference</code>， <code>itoa</code></li>\n</ol>\n<h2 id=\"3-2-lambda\"><a href=\"#3-2-lambda\" class=\"headerlink\" title=\"3.2 lambda\"></a>3.2 lambda</h2><p>一个lambda表示一个可调用的代码单元。他的形式如下： [capture list] (parameter list) -&gt; return type {function body} <code>capture list</code> 是lambda所在的函数中定义的局部变量的列表 <code>return type</code> <code>parameter list</code> <code>function body</code> 表示相应的返回值，参数列表，函数体</p>\n<p>lambda可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体。</p>\n<h1 id=\"四、智能指针\"><a href=\"#四、智能指针\" class=\"headerlink\" title=\"四、智能指针\"></a>四、智能指针</h1><p>通常我们使用 <code>new</code> 和 <code>delete</code> 来管理动态内存的。但是，这样的使用很容易出现问题：我们有可能会忘记释放内存造成内存泄漏；或者我们有可能使用了已释放的指针，导致非法访问。因为C++中定义了智能指针。 智能指针其实也是模版，C++中定义了三个相关的类：</p>\n<ul>\n<li><code>shared_ptr</code> 允许多个指针指向同一个对象</li>\n<li><code>unique_ptr</code> 仅允许一个指针指向对象</li>\n<li><code>weak_ptr</code> 弱引用，指向 <code>shared_ptr</code> 所管理的对象</li>\n</ul>\n<p>智能指针的相应操作有：</p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shared_ptr <T> sp / unique_ptr<T> up</td>\n<td>空智能指针，可以指向类型为T的对象</td>\n</tr>\n<tr>\n<td>p</td>\n<td>可以把智能指针本身作为判断，如果p指向了一个对象，则返回true</td>\n</tr>\n<tr>\n<td>*p</td>\n<td>解引用，获得指向的对象</td>\n</tr>\n<tr>\n<td>p-&gt;mem</td>\n<td>等价于(*p).mem</td>\n</tr>\n<tr>\n<td>swap(p, q) / p.swap(q)</td>\n<td>交换</td>\n</tr>\n<tr>\n<td>make_shared <T>(args)</td>\n<td>返回一个shared_ptr</td>\n</tr>\n<tr>\n<td>shared_ptr<T>p (q)</td>\n<td>p 是 q 的拷贝</td>\n</tr>\n<tr>\n<td>p = q</td>\n<td>拷贝</td>\n</tr>\n<tr>\n<td>p.use_count()</td>\n<td>返回与p共享对象的智能指针对象</td>\n</tr>\n<tr>\n<td>p.unique()</td>\n<td>如果p.use_count()为1，返回true</td>\n</tr>\n</tbody>\n</table>\n<p>当智能指针创建之后，每对shared_ptr的拷贝和赋值，都会使 shared_ptr 的引用计数加一。 当一个shared_ptr被销毁时，shared_ptr 的引用计数会递减。 当动态内存的引用计数为0时， shared_ptr 的析构函数会自动销毁所管理的对象。 我们可能会在下面的三种情况下使用智能指针：</p>\n<ul>\n<li>程序不知道自己需要使用多少对象</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象间共享数据</li>\n</ul>"},{"title":"C++学习笔记（二）——面向对象","date":"2017-02-23T02:27:24.000Z","_content":"今天在这里总结下 C++ 面向对象（OOP）的基本知识。\n<!--more-->\nOOP 的最重要的特性是：\n1.  抽象\n2.  封装和数据隐藏\n3.  多态\n4.  继承\n\n本篇博客将会从什么是类开始讲，随后说一说C++的访问控制和封装，随后是继承。\n## 一、类的构成\n首先，我们明确什么是类，或者扩大来说什么是类型。我们先来看一下基本类型，如 `int`，指定一个变量为整形其实完成了三项工作：\n* 决定数据对象需要的内存数量\n* 决定了如何解释内存中的位\n* 决定了可使用数据对象执行的操作和方法\n\n类的基本思想是数据抽象和封装。它类似于基本类型，是用户定义并完成了上述功能。一个规范的类由两个部分组成：\n* 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口\n* 类方法定义：描述如何实现类成员函数\n\n### 1.1 类的声明\n如上面所说，类的声明是完成了类的数据成员和成员函数的定义。数据成员不必过多解释，我们需要注意的是两个概念：\n* 常数据成员\n* 静态数据成员\n\n1. 常数据成员是指在类中定义的不能修改其值的一些数据成员，类似于我们以前学过的常变量，虽然是变量，也有自己的地址，但是一经赋初值，便不能再被修改。他有两个要点：\n * 类中的常数据成员**只能通过构造函数的初始化参数列表**进行初始化。\n * 常数据成员是实例化对象的一部分，可以用this指针访问。\n\n2. 静态数据成员存储空间不同于普通的数据成员，它不属于类的任何一个对象，是独立于对象存储的，因此：\n * 不可以通过对象的this指针来访问。\n * 静态数据成员不可以用参数初始化表进行初始化操作。\n\n另一方面，类的成员函数就比较复杂了，除了一般的成员函数，有一些特殊的成员函数需要注意：\n1. 构造函数\n  构造函数的任务是初始化类对象的数据成员。\n2. 析构函数\n  与构造函数对应，析构函数负责类对象的销毁。尤其需要注意的是：对于构造函数中使用 `new` 创建的类型在析构函数中必须使用 `delete` 来销毁。\n3. 自动成员函数\n  编译器会在需要的时候自动为类生成6个默认成员函数，它们分别是：\n  * 默认构造函数\n  * 默认析构函数\n  * 默认复制构造函数\n     其中需要注意的是默认复制构造函数，C++提供的默认复制构造函数工作的方法是：完成一个成员一个成员的复制，如果成员是类对象，则调用其复制构造函数或者默认复制构造函数。\n    在默认复制构造函数中，复制的策略是逐个成员依次复制，但是，一个类可能会拥有资源，如果复制构造函数简单地制作了一个该资源的复制，而不对它本身分配，就得面临一个麻烦的局面：两个对象都拥有同一个资源。当对象析构时，该资源将经历两次资源返还。\n    因此，对于在构造函数中进行了资源申请（`new` 申请堆空间、打开文件、占用硬件）的类，必须显式定义复制构造函数。\n  * 赋值运算符\n  * 地址运算符（一对）\n4. 静态成员函数\n  静态成员函数的使用是：静态成员函数只能访问静态成员\n5. 友元函数\n  友元函数在类中声明——在函数前加 `friend`，但是友元函数并不是成员函数。\n  友元函数可以访问类成员。\n6. 运算符重载\n7. 自动类型转换\n   当构造函数只接受一个参数时，则该类可以与该参数类型相同的值转换。\n8. 类型转换函数\n   C++提供类型转换函数来解决这个问题。类型转换函数的作用是将一个类的对象转换成另一类型的数据。\n\n### 1.2 类定义\n类的定义在这里不展开介绍，简单理解概念：\n* 类的定义是类成员函数实现\n* 应使用私有函数来处理不属于公有接口的实现细节\n* 定义位于类声明中的函数自动成为内联函数\n* 同一个类的所有对象共享同一组类方法\n\n## 二、访问控制和封装\n我们在类中使用访问说明符来加强类的封装型：\n  * `private` 定义在 `private` 之后的成员可以呗类成员访问，但不能被使用该类的代码访问。\n  * `public` 定义在 `public` 之后的成员在整个程序空间内可以被访问。\n  * `protected` 定义在 `protected` 之后的是受保护变量，类内和子类可直接访问，也就是说，基类中有 `protected` 成员，子类继承于基类，那么也可以访问基类的 `protected` 成员，要是基类是 `private` 成员，则对于子类也是隐藏的，不可访问\n\n## 三、继承\n面向对象程序设计的核心思想是数据抽象、继承和动态绑定。使用上面的数据抽象，我们可以将类的接口和实现分离。而使用继承，我们可以定义相似的类型，并对其相似部分建模，通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，称之为**派生类**。\n\n* 派生类继承了基类的实现\n* 派生类继承了基类的接口\n* 派生类需要自己的构造函数\n* 派生类可以根据需要添加额外的数据成员和成员函数\n* 派生类不可以直接访问基类的私有成员\n* 基类指针可以在不进行显式类型转换的情况下指向派生类对象\n* 基类引用可以在不进行显式类型转换的情况下引用派生类对象\n\n\nC++有三种继承关系：**公有继承**、**保护继承**和**私有继承**。\n* 公有继承：公有继承建立一种 `is-a` 关系，即派生类也是一个基类的对象，可以对基类对象执行的任何操作，都可以对派生类对象执行。\n* 保护继承：\n* 私有继承：使用私有继承，基类的公有方法将成为派生类的私有方法。在派生类中使用类名和作用域运算符来调用基类方法。\n\n保护继承、私有继承和包含、组合都用于实现 `has-a` 关系，即新的类将包含另外一个类的对象。\n\n### 3.1 基类的定义\nC++中，基类将类型相关的函数和派生类不加改变直接继承的函数区别对待，对于需要派生类各自定义适合自己的版本的函数，基类将这些函数声明为**虚函数**：\n````C\nvirtual double function();````\n任何构造函数之外的非静态函数都可以是虚函数，如果一个函数在基类中定义为虚函数，则在派生类中该函数隐式的也是虚函数。\n基类中定义为`protect`的成员，可以被派生类直接访问，而不能被外部成员访问。\n\nC++可以通过使用**纯虚函数**来提供未实现的函数：\n````C\nvirtual double function() = 0;````\n当类声明中包含有纯虚函数的时候，不能创建该类的对象。包含纯虚函数的类只能用作基类。\n当我们需要一种必须实施的接口，我们可以定义**ABC（abstract base class）**———**抽象基类**，ABC要求具体派生类覆盖其纯虚函数，迫使派生类遵循ABC设置的接口规则。\n\n### 3.2 派生类的定义\n派生类使用**类派生列表**明确自己是从哪个（哪些）基类继承而来的：\n````C\nclass ClassA : public ClassB{\n}````\n因为派生类不能直接访问基类的私有成员，所以派生类的构造函数必须使用基类的构造函数，在定义派生类的构造函数时：\n1. 首先创建基类对象\n2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数\n3. 派生类构造函数应初始化派生类新增的数据成员\n\n### 3.3 私有继承与保护继承\n进行私有继承时，使用关键字 `private` 而不是 `public` 来声明基类。派生类会包含两个无名称的对象成员。派生类对基类的使用是：\n* 构造函数中，使用基类类名来初始化相应的成员；\n* 派生类的方法中使用基类名和作用域解析符来调用基类方法；\n* 派生类中使用强制类型转换来访问基类对象\n*　私有继承可以访问保护成员\n* 私有继承可以重定义虚函数（非公开）\n* 使用using可以定义继承的方法为公开方法\n\n保护继承与私有继承类似，区别是保护继承中，基类的公有办法将成为派生类的保护方法。这样,保护继承继承的方法可以在后续的派生中使用\n\n### 3.4 多重继承\n**MI**——**多重继承**，描述的是有多个直接基类的类。\n* 为了让派生类从多个基类相同的类继承时只继承一个基类对象，C++定义了虚基类：在类声明时使用 `virtual` 关键字。\n* 使用虚基类的时候，编译器会隐式调用虚基类的默认构造函数，或显式的调用虚基类的相应构造函数。\n* 使用虚基类时，需要使用作用域运算符标明使用的方法的类型。\n\n\n","source":"_posts/02C-学习笔记（二）——面向对象.md","raw":"---\ntitle: C++学习笔记（二）——面向对象\ndate: 2017-02-23 10:27:24\ncategories: C++学习笔记\ntags:\n---\n今天在这里总结下 C++ 面向对象（OOP）的基本知识。\n<!--more-->\nOOP 的最重要的特性是：\n1.  抽象\n2.  封装和数据隐藏\n3.  多态\n4.  继承\n\n本篇博客将会从什么是类开始讲，随后说一说C++的访问控制和封装，随后是继承。\n## 一、类的构成\n首先，我们明确什么是类，或者扩大来说什么是类型。我们先来看一下基本类型，如 `int`，指定一个变量为整形其实完成了三项工作：\n* 决定数据对象需要的内存数量\n* 决定了如何解释内存中的位\n* 决定了可使用数据对象执行的操作和方法\n\n类的基本思想是数据抽象和封装。它类似于基本类型，是用户定义并完成了上述功能。一个规范的类由两个部分组成：\n* 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口\n* 类方法定义：描述如何实现类成员函数\n\n### 1.1 类的声明\n如上面所说，类的声明是完成了类的数据成员和成员函数的定义。数据成员不必过多解释，我们需要注意的是两个概念：\n* 常数据成员\n* 静态数据成员\n\n1. 常数据成员是指在类中定义的不能修改其值的一些数据成员，类似于我们以前学过的常变量，虽然是变量，也有自己的地址，但是一经赋初值，便不能再被修改。他有两个要点：\n * 类中的常数据成员**只能通过构造函数的初始化参数列表**进行初始化。\n * 常数据成员是实例化对象的一部分，可以用this指针访问。\n\n2. 静态数据成员存储空间不同于普通的数据成员，它不属于类的任何一个对象，是独立于对象存储的，因此：\n * 不可以通过对象的this指针来访问。\n * 静态数据成员不可以用参数初始化表进行初始化操作。\n\n另一方面，类的成员函数就比较复杂了，除了一般的成员函数，有一些特殊的成员函数需要注意：\n1. 构造函数\n  构造函数的任务是初始化类对象的数据成员。\n2. 析构函数\n  与构造函数对应，析构函数负责类对象的销毁。尤其需要注意的是：对于构造函数中使用 `new` 创建的类型在析构函数中必须使用 `delete` 来销毁。\n3. 自动成员函数\n  编译器会在需要的时候自动为类生成6个默认成员函数，它们分别是：\n  * 默认构造函数\n  * 默认析构函数\n  * 默认复制构造函数\n     其中需要注意的是默认复制构造函数，C++提供的默认复制构造函数工作的方法是：完成一个成员一个成员的复制，如果成员是类对象，则调用其复制构造函数或者默认复制构造函数。\n    在默认复制构造函数中，复制的策略是逐个成员依次复制，但是，一个类可能会拥有资源，如果复制构造函数简单地制作了一个该资源的复制，而不对它本身分配，就得面临一个麻烦的局面：两个对象都拥有同一个资源。当对象析构时，该资源将经历两次资源返还。\n    因此，对于在构造函数中进行了资源申请（`new` 申请堆空间、打开文件、占用硬件）的类，必须显式定义复制构造函数。\n  * 赋值运算符\n  * 地址运算符（一对）\n4. 静态成员函数\n  静态成员函数的使用是：静态成员函数只能访问静态成员\n5. 友元函数\n  友元函数在类中声明——在函数前加 `friend`，但是友元函数并不是成员函数。\n  友元函数可以访问类成员。\n6. 运算符重载\n7. 自动类型转换\n   当构造函数只接受一个参数时，则该类可以与该参数类型相同的值转换。\n8. 类型转换函数\n   C++提供类型转换函数来解决这个问题。类型转换函数的作用是将一个类的对象转换成另一类型的数据。\n\n### 1.2 类定义\n类的定义在这里不展开介绍，简单理解概念：\n* 类的定义是类成员函数实现\n* 应使用私有函数来处理不属于公有接口的实现细节\n* 定义位于类声明中的函数自动成为内联函数\n* 同一个类的所有对象共享同一组类方法\n\n## 二、访问控制和封装\n我们在类中使用访问说明符来加强类的封装型：\n  * `private` 定义在 `private` 之后的成员可以呗类成员访问，但不能被使用该类的代码访问。\n  * `public` 定义在 `public` 之后的成员在整个程序空间内可以被访问。\n  * `protected` 定义在 `protected` 之后的是受保护变量，类内和子类可直接访问，也就是说，基类中有 `protected` 成员，子类继承于基类，那么也可以访问基类的 `protected` 成员，要是基类是 `private` 成员，则对于子类也是隐藏的，不可访问\n\n## 三、继承\n面向对象程序设计的核心思想是数据抽象、继承和动态绑定。使用上面的数据抽象，我们可以将类的接口和实现分离。而使用继承，我们可以定义相似的类型，并对其相似部分建模，通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，称之为**派生类**。\n\n* 派生类继承了基类的实现\n* 派生类继承了基类的接口\n* 派生类需要自己的构造函数\n* 派生类可以根据需要添加额外的数据成员和成员函数\n* 派生类不可以直接访问基类的私有成员\n* 基类指针可以在不进行显式类型转换的情况下指向派生类对象\n* 基类引用可以在不进行显式类型转换的情况下引用派生类对象\n\n\nC++有三种继承关系：**公有继承**、**保护继承**和**私有继承**。\n* 公有继承：公有继承建立一种 `is-a` 关系，即派生类也是一个基类的对象，可以对基类对象执行的任何操作，都可以对派生类对象执行。\n* 保护继承：\n* 私有继承：使用私有继承，基类的公有方法将成为派生类的私有方法。在派生类中使用类名和作用域运算符来调用基类方法。\n\n保护继承、私有继承和包含、组合都用于实现 `has-a` 关系，即新的类将包含另外一个类的对象。\n\n### 3.1 基类的定义\nC++中，基类将类型相关的函数和派生类不加改变直接继承的函数区别对待，对于需要派生类各自定义适合自己的版本的函数，基类将这些函数声明为**虚函数**：\n````C\nvirtual double function();````\n任何构造函数之外的非静态函数都可以是虚函数，如果一个函数在基类中定义为虚函数，则在派生类中该函数隐式的也是虚函数。\n基类中定义为`protect`的成员，可以被派生类直接访问，而不能被外部成员访问。\n\nC++可以通过使用**纯虚函数**来提供未实现的函数：\n````C\nvirtual double function() = 0;````\n当类声明中包含有纯虚函数的时候，不能创建该类的对象。包含纯虚函数的类只能用作基类。\n当我们需要一种必须实施的接口，我们可以定义**ABC（abstract base class）**———**抽象基类**，ABC要求具体派生类覆盖其纯虚函数，迫使派生类遵循ABC设置的接口规则。\n\n### 3.2 派生类的定义\n派生类使用**类派生列表**明确自己是从哪个（哪些）基类继承而来的：\n````C\nclass ClassA : public ClassB{\n}````\n因为派生类不能直接访问基类的私有成员，所以派生类的构造函数必须使用基类的构造函数，在定义派生类的构造函数时：\n1. 首先创建基类对象\n2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数\n3. 派生类构造函数应初始化派生类新增的数据成员\n\n### 3.3 私有继承与保护继承\n进行私有继承时，使用关键字 `private` 而不是 `public` 来声明基类。派生类会包含两个无名称的对象成员。派生类对基类的使用是：\n* 构造函数中，使用基类类名来初始化相应的成员；\n* 派生类的方法中使用基类名和作用域解析符来调用基类方法；\n* 派生类中使用强制类型转换来访问基类对象\n*　私有继承可以访问保护成员\n* 私有继承可以重定义虚函数（非公开）\n* 使用using可以定义继承的方法为公开方法\n\n保护继承与私有继承类似，区别是保护继承中，基类的公有办法将成为派生类的保护方法。这样,保护继承继承的方法可以在后续的派生中使用\n\n### 3.4 多重继承\n**MI**——**多重继承**，描述的是有多个直接基类的类。\n* 为了让派生类从多个基类相同的类继承时只继承一个基类对象，C++定义了虚基类：在类声明时使用 `virtual` 关键字。\n* 使用虚基类的时候，编译器会隐式调用虚基类的默认构造函数，或显式的调用虚基类的相应构造函数。\n* 使用虚基类时，需要使用作用域运算符标明使用的方法的类型。\n\n\n","slug":"02C-学习笔记（二）——面向对象","published":1,"updated":"2017-12-06T13:32:14.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9mzj0006bkw1rip2f13m","content":"<p>今天在这里总结下 C++ 面向对象（OOP）的基本知识。<br><a id=\"more\"></a><br>OOP 的最重要的特性是：</p>\n<ol>\n<li>抽象</li>\n<li>封装和数据隐藏</li>\n<li>多态</li>\n<li>继承</li>\n</ol>\n<p>本篇博客将会从什么是类开始讲，随后说一说C++的访问控制和封装，随后是继承。</p>\n<h2 id=\"一、类的构成\"><a href=\"#一、类的构成\" class=\"headerlink\" title=\"一、类的构成\"></a>一、类的构成</h2><p>首先，我们明确什么是类，或者扩大来说什么是类型。我们先来看一下基本类型，如 <code>int</code>，指定一个变量为整形其实完成了三项工作：</p>\n<ul>\n<li>决定数据对象需要的内存数量</li>\n<li>决定了如何解释内存中的位</li>\n<li>决定了可使用数据对象执行的操作和方法</li>\n</ul>\n<p>类的基本思想是数据抽象和封装。它类似于基本类型，是用户定义并完成了上述功能。一个规范的类由两个部分组成：</p>\n<ul>\n<li>类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口</li>\n<li>类方法定义：描述如何实现类成员函数</li>\n</ul>\n<h3 id=\"1-1-类的声明\"><a href=\"#1-1-类的声明\" class=\"headerlink\" title=\"1.1 类的声明\"></a>1.1 类的声明</h3><p>如上面所说，类的声明是完成了类的数据成员和成员函数的定义。数据成员不必过多解释，我们需要注意的是两个概念：</p>\n<ul>\n<li>常数据成员</li>\n<li>静态数据成员</li>\n</ul>\n<ol>\n<li><p>常数据成员是指在类中定义的不能修改其值的一些数据成员，类似于我们以前学过的常变量，虽然是变量，也有自己的地址，但是一经赋初值，便不能再被修改。他有两个要点：</p>\n<ul>\n<li>类中的常数据成员<strong>只能通过构造函数的初始化参数列表</strong>进行初始化。</li>\n<li>常数据成员是实例化对象的一部分，可以用this指针访问。</li>\n</ul>\n</li>\n<li><p>静态数据成员存储空间不同于普通的数据成员，它不属于类的任何一个对象，是独立于对象存储的，因此：</p>\n<ul>\n<li>不可以通过对象的this指针来访问。</li>\n<li>静态数据成员不可以用参数初始化表进行初始化操作。</li>\n</ul>\n</li>\n</ol>\n<p>另一方面，类的成员函数就比较复杂了，除了一般的成员函数，有一些特殊的成员函数需要注意：</p>\n<ol>\n<li>构造函数<br>构造函数的任务是初始化类对象的数据成员。</li>\n<li>析构函数<br>与构造函数对应，析构函数负责类对象的销毁。尤其需要注意的是：对于构造函数中使用 <code>new</code> 创建的类型在析构函数中必须使用 <code>delete</code> 来销毁。</li>\n<li>自动成员函数<br>编译器会在需要的时候自动为类生成6个默认成员函数，它们分别是：<ul>\n<li>默认构造函数</li>\n<li>默认析构函数</li>\n<li>默认复制构造函数<br>其中需要注意的是默认复制构造函数，C++提供的默认复制构造函数工作的方法是：完成一个成员一个成员的复制，如果成员是类对象，则调用其复制构造函数或者默认复制构造函数。<br>在默认复制构造函数中，复制的策略是逐个成员依次复制，但是，一个类可能会拥有资源，如果复制构造函数简单地制作了一个该资源的复制，而不对它本身分配，就得面临一个麻烦的局面：两个对象都拥有同一个资源。当对象析构时，该资源将经历两次资源返还。<br>因此，对于在构造函数中进行了资源申请（<code>new</code> 申请堆空间、打开文件、占用硬件）的类，必须显式定义复制构造函数。</li>\n<li>赋值运算符</li>\n<li>地址运算符（一对）</li>\n</ul>\n</li>\n<li>静态成员函数<br>静态成员函数的使用是：静态成员函数只能访问静态成员</li>\n<li>友元函数<br>友元函数在类中声明——在函数前加 <code>friend</code>，但是友元函数并不是成员函数。<br>友元函数可以访问类成员。</li>\n<li>运算符重载</li>\n<li>自动类型转换<br>当构造函数只接受一个参数时，则该类可以与该参数类型相同的值转换。</li>\n<li>类型转换函数<br>C++提供类型转换函数来解决这个问题。类型转换函数的作用是将一个类的对象转换成另一类型的数据。</li>\n</ol>\n<h3 id=\"1-2-类定义\"><a href=\"#1-2-类定义\" class=\"headerlink\" title=\"1.2 类定义\"></a>1.2 类定义</h3><p>类的定义在这里不展开介绍，简单理解概念：</p>\n<ul>\n<li>类的定义是类成员函数实现</li>\n<li>应使用私有函数来处理不属于公有接口的实现细节</li>\n<li>定义位于类声明中的函数自动成为内联函数</li>\n<li>同一个类的所有对象共享同一组类方法</li>\n</ul>\n<h2 id=\"二、访问控制和封装\"><a href=\"#二、访问控制和封装\" class=\"headerlink\" title=\"二、访问控制和封装\"></a>二、访问控制和封装</h2><p>我们在类中使用访问说明符来加强类的封装型：</p>\n<ul>\n<li><code>private</code> 定义在 <code>private</code> 之后的成员可以呗类成员访问，但不能被使用该类的代码访问。</li>\n<li><code>public</code> 定义在 <code>public</code> 之后的成员在整个程序空间内可以被访问。</li>\n<li><code>protected</code> 定义在 <code>protected</code> 之后的是受保护变量，类内和子类可直接访问，也就是说，基类中有 <code>protected</code> 成员，子类继承于基类，那么也可以访问基类的 <code>protected</code> 成员，要是基类是 <code>private</code> 成员，则对于子类也是隐藏的，不可访问</li>\n</ul>\n<h2 id=\"三、继承\"><a href=\"#三、继承\" class=\"headerlink\" title=\"三、继承\"></a>三、继承</h2><p>面向对象程序设计的核心思想是数据抽象、继承和动态绑定。使用上面的数据抽象，我们可以将类的接口和实现分离。而使用继承，我们可以定义相似的类型，并对其相似部分建模，通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>，其他类则直接或间接地从基类继承而来，称之为<strong>派生类</strong>。</p>\n<ul>\n<li>派生类继承了基类的实现</li>\n<li>派生类继承了基类的接口</li>\n<li>派生类需要自己的构造函数</li>\n<li>派生类可以根据需要添加额外的数据成员和成员函数</li>\n<li>派生类不可以直接访问基类的私有成员</li>\n<li>基类指针可以在不进行显式类型转换的情况下指向派生类对象</li>\n<li>基类引用可以在不进行显式类型转换的情况下引用派生类对象</li>\n</ul>\n<p>C++有三种继承关系：<strong>公有继承</strong>、<strong>保护继承</strong>和<strong>私有继承</strong>。</p>\n<ul>\n<li>公有继承：公有继承建立一种 <code>is-a</code> 关系，即派生类也是一个基类的对象，可以对基类对象执行的任何操作，都可以对派生类对象执行。</li>\n<li>保护继承：</li>\n<li>私有继承：使用私有继承，基类的公有方法将成为派生类的私有方法。在派生类中使用类名和作用域运算符来调用基类方法。</li>\n</ul>\n<p>保护继承、私有继承和包含、组合都用于实现 <code>has-a</code> 关系，即新的类将包含另外一个类的对象。</p>\n<h3 id=\"3-1-基类的定义\"><a href=\"#3-1-基类的定义\" class=\"headerlink\" title=\"3.1 基类的定义\"></a>3.1 基类的定义</h3><p>C++中，基类将类型相关的函数和派生类不加改变直接继承的函数区别对待，对于需要派生类各自定义适合自己的版本的函数，基类将这些函数声明为<strong>虚函数</strong>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure></p>\n<p>任何构造函数之外的非静态函数都可以是虚函数，如果一个函数在基类中定义为虚函数，则在派生类中该函数隐式的也是虚函数。<br>基类中定义为<code>protect</code>的成员，可以被派生类直接访问，而不能被外部成员访问。</p>\n<p>C++可以通过使用<strong>纯虚函数</strong>来提供未实现的函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">function</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</div></pre></td></tr></table></figure></p>\n<p>当类声明中包含有纯虚函数的时候，不能创建该类的对象。包含纯虚函数的类只能用作基类。<br>当我们需要一种必须实施的接口，我们可以定义<strong>ABC（abstract base class）</strong>———<strong>抽象基类</strong>，ABC要求具体派生类覆盖其纯虚函数，迫使派生类遵循ABC设置的接口规则。</p>\n<h3 id=\"3-2-派生类的定义\"><a href=\"#3-2-派生类的定义\" class=\"headerlink\" title=\"3.2 派生类的定义\"></a>3.2 派生类的定义</h3><p>派生类使用<strong>类派生列表</strong>明确自己是从哪个（哪些）基类继承而来的：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> ClassA : <span class=\"keyword\">public</span> ClassB&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>因为派生类不能直接访问基类的私有成员，所以派生类的构造函数必须使用基类的构造函数，在定义派生类的构造函数时：</p>\n<ol>\n<li>首先创建基类对象</li>\n<li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数</li>\n<li>派生类构造函数应初始化派生类新增的数据成员</li>\n</ol>\n<h3 id=\"3-3-私有继承与保护继承\"><a href=\"#3-3-私有继承与保护继承\" class=\"headerlink\" title=\"3.3 私有继承与保护继承\"></a>3.3 私有继承与保护继承</h3><p>进行私有继承时，使用关键字 <code>private</code> 而不是 <code>public</code> 来声明基类。派生类会包含两个无名称的对象成员。派生类对基类的使用是：</p>\n<ul>\n<li>构造函数中，使用基类类名来初始化相应的成员；</li>\n<li>派生类的方法中使用基类名和作用域解析符来调用基类方法；</li>\n<li>派生类中使用强制类型转换来访问基类对象<br>*　私有继承可以访问保护成员</li>\n<li>私有继承可以重定义虚函数（非公开）</li>\n<li>使用using可以定义继承的方法为公开方法</li>\n</ul>\n<p>保护继承与私有继承类似，区别是保护继承中，基类的公有办法将成为派生类的保护方法。这样,保护继承继承的方法可以在后续的派生中使用</p>\n<h3 id=\"3-4-多重继承\"><a href=\"#3-4-多重继承\" class=\"headerlink\" title=\"3.4 多重继承\"></a>3.4 多重继承</h3><p><strong>MI</strong>——<strong>多重继承</strong>，描述的是有多个直接基类的类。</p>\n<ul>\n<li>为了让派生类从多个基类相同的类继承时只继承一个基类对象，C++定义了虚基类：在类声明时使用 <code>virtual</code> 关键字。</li>\n<li>使用虚基类的时候，编译器会隐式调用虚基类的默认构造函数，或显式的调用虚基类的相应构造函数。</li>\n<li>使用虚基类时，需要使用作用域运算符标明使用的方法的类型。</li>\n</ul>\n","excerpt":"<p>今天在这里总结下 C++ 面向对象（OOP）的基本知识。<br>","more":"<br>OOP 的最重要的特性是：</p>\n<ol>\n<li>抽象</li>\n<li>封装和数据隐藏</li>\n<li>多态</li>\n<li>继承</li>\n</ol>\n<p>本篇博客将会从什么是类开始讲，随后说一说C++的访问控制和封装，随后是继承。</p>\n<h2 id=\"一、类的构成\"><a href=\"#一、类的构成\" class=\"headerlink\" title=\"一、类的构成\"></a>一、类的构成</h2><p>首先，我们明确什么是类，或者扩大来说什么是类型。我们先来看一下基本类型，如 <code>int</code>，指定一个变量为整形其实完成了三项工作：</p>\n<ul>\n<li>决定数据对象需要的内存数量</li>\n<li>决定了如何解释内存中的位</li>\n<li>决定了可使用数据对象执行的操作和方法</li>\n</ul>\n<p>类的基本思想是数据抽象和封装。它类似于基本类型，是用户定义并完成了上述功能。一个规范的类由两个部分组成：</p>\n<ul>\n<li>类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口</li>\n<li>类方法定义：描述如何实现类成员函数</li>\n</ul>\n<h3 id=\"1-1-类的声明\"><a href=\"#1-1-类的声明\" class=\"headerlink\" title=\"1.1 类的声明\"></a>1.1 类的声明</h3><p>如上面所说，类的声明是完成了类的数据成员和成员函数的定义。数据成员不必过多解释，我们需要注意的是两个概念：</p>\n<ul>\n<li>常数据成员</li>\n<li>静态数据成员</li>\n</ul>\n<ol>\n<li><p>常数据成员是指在类中定义的不能修改其值的一些数据成员，类似于我们以前学过的常变量，虽然是变量，也有自己的地址，但是一经赋初值，便不能再被修改。他有两个要点：</p>\n<ul>\n<li>类中的常数据成员<strong>只能通过构造函数的初始化参数列表</strong>进行初始化。</li>\n<li>常数据成员是实例化对象的一部分，可以用this指针访问。</li>\n</ul>\n</li>\n<li><p>静态数据成员存储空间不同于普通的数据成员，它不属于类的任何一个对象，是独立于对象存储的，因此：</p>\n<ul>\n<li>不可以通过对象的this指针来访问。</li>\n<li>静态数据成员不可以用参数初始化表进行初始化操作。</li>\n</ul>\n</li>\n</ol>\n<p>另一方面，类的成员函数就比较复杂了，除了一般的成员函数，有一些特殊的成员函数需要注意：</p>\n<ol>\n<li>构造函数<br>构造函数的任务是初始化类对象的数据成员。</li>\n<li>析构函数<br>与构造函数对应，析构函数负责类对象的销毁。尤其需要注意的是：对于构造函数中使用 <code>new</code> 创建的类型在析构函数中必须使用 <code>delete</code> 来销毁。</li>\n<li>自动成员函数<br>编译器会在需要的时候自动为类生成6个默认成员函数，它们分别是：<ul>\n<li>默认构造函数</li>\n<li>默认析构函数</li>\n<li>默认复制构造函数<br>其中需要注意的是默认复制构造函数，C++提供的默认复制构造函数工作的方法是：完成一个成员一个成员的复制，如果成员是类对象，则调用其复制构造函数或者默认复制构造函数。<br>在默认复制构造函数中，复制的策略是逐个成员依次复制，但是，一个类可能会拥有资源，如果复制构造函数简单地制作了一个该资源的复制，而不对它本身分配，就得面临一个麻烦的局面：两个对象都拥有同一个资源。当对象析构时，该资源将经历两次资源返还。<br>因此，对于在构造函数中进行了资源申请（<code>new</code> 申请堆空间、打开文件、占用硬件）的类，必须显式定义复制构造函数。</li>\n<li>赋值运算符</li>\n<li>地址运算符（一对）</li>\n</ul>\n</li>\n<li>静态成员函数<br>静态成员函数的使用是：静态成员函数只能访问静态成员</li>\n<li>友元函数<br>友元函数在类中声明——在函数前加 <code>friend</code>，但是友元函数并不是成员函数。<br>友元函数可以访问类成员。</li>\n<li>运算符重载</li>\n<li>自动类型转换<br>当构造函数只接受一个参数时，则该类可以与该参数类型相同的值转换。</li>\n<li>类型转换函数<br>C++提供类型转换函数来解决这个问题。类型转换函数的作用是将一个类的对象转换成另一类型的数据。</li>\n</ol>\n<h3 id=\"1-2-类定义\"><a href=\"#1-2-类定义\" class=\"headerlink\" title=\"1.2 类定义\"></a>1.2 类定义</h3><p>类的定义在这里不展开介绍，简单理解概念：</p>\n<ul>\n<li>类的定义是类成员函数实现</li>\n<li>应使用私有函数来处理不属于公有接口的实现细节</li>\n<li>定义位于类声明中的函数自动成为内联函数</li>\n<li>同一个类的所有对象共享同一组类方法</li>\n</ul>\n<h2 id=\"二、访问控制和封装\"><a href=\"#二、访问控制和封装\" class=\"headerlink\" title=\"二、访问控制和封装\"></a>二、访问控制和封装</h2><p>我们在类中使用访问说明符来加强类的封装型：</p>\n<ul>\n<li><code>private</code> 定义在 <code>private</code> 之后的成员可以呗类成员访问，但不能被使用该类的代码访问。</li>\n<li><code>public</code> 定义在 <code>public</code> 之后的成员在整个程序空间内可以被访问。</li>\n<li><code>protected</code> 定义在 <code>protected</code> 之后的是受保护变量，类内和子类可直接访问，也就是说，基类中有 <code>protected</code> 成员，子类继承于基类，那么也可以访问基类的 <code>protected</code> 成员，要是基类是 <code>private</code> 成员，则对于子类也是隐藏的，不可访问</li>\n</ul>\n<h2 id=\"三、继承\"><a href=\"#三、继承\" class=\"headerlink\" title=\"三、继承\"></a>三、继承</h2><p>面向对象程序设计的核心思想是数据抽象、继承和动态绑定。使用上面的数据抽象，我们可以将类的接口和实现分离。而使用继承，我们可以定义相似的类型，并对其相似部分建模，通过继承联系在一起的类构成了一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>，其他类则直接或间接地从基类继承而来，称之为<strong>派生类</strong>。</p>\n<ul>\n<li>派生类继承了基类的实现</li>\n<li>派生类继承了基类的接口</li>\n<li>派生类需要自己的构造函数</li>\n<li>派生类可以根据需要添加额外的数据成员和成员函数</li>\n<li>派生类不可以直接访问基类的私有成员</li>\n<li>基类指针可以在不进行显式类型转换的情况下指向派生类对象</li>\n<li>基类引用可以在不进行显式类型转换的情况下引用派生类对象</li>\n</ul>\n<p>C++有三种继承关系：<strong>公有继承</strong>、<strong>保护继承</strong>和<strong>私有继承</strong>。</p>\n<ul>\n<li>公有继承：公有继承建立一种 <code>is-a</code> 关系，即派生类也是一个基类的对象，可以对基类对象执行的任何操作，都可以对派生类对象执行。</li>\n<li>保护继承：</li>\n<li>私有继承：使用私有继承，基类的公有方法将成为派生类的私有方法。在派生类中使用类名和作用域运算符来调用基类方法。</li>\n</ul>\n<p>保护继承、私有继承和包含、组合都用于实现 <code>has-a</code> 关系，即新的类将包含另外一个类的对象。</p>\n<h3 id=\"3-1-基类的定义\"><a href=\"#3-1-基类的定义\" class=\"headerlink\" title=\"3.1 基类的定义\"></a>3.1 基类的定义</h3><p>C++中，基类将类型相关的函数和派生类不加改变直接继承的函数区别对待，对于需要派生类各自定义适合自己的版本的函数，基类将这些函数声明为<strong>虚函数</strong>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure></p>\n<p>任何构造函数之外的非静态函数都可以是虚函数，如果一个函数在基类中定义为虚函数，则在派生类中该函数隐式的也是虚函数。<br>基类中定义为<code>protect</code>的成员，可以被派生类直接访问，而不能被外部成员访问。</p>\n<p>C++可以通过使用<strong>纯虚函数</strong>来提供未实现的函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">function</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</div></pre></td></tr></table></figure></p>\n<p>当类声明中包含有纯虚函数的时候，不能创建该类的对象。包含纯虚函数的类只能用作基类。<br>当我们需要一种必须实施的接口，我们可以定义<strong>ABC（abstract base class）</strong>———<strong>抽象基类</strong>，ABC要求具体派生类覆盖其纯虚函数，迫使派生类遵循ABC设置的接口规则。</p>\n<h3 id=\"3-2-派生类的定义\"><a href=\"#3-2-派生类的定义\" class=\"headerlink\" title=\"3.2 派生类的定义\"></a>3.2 派生类的定义</h3><p>派生类使用<strong>类派生列表</strong>明确自己是从哪个（哪些）基类继承而来的：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> ClassA : <span class=\"keyword\">public</span> ClassB&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>因为派生类不能直接访问基类的私有成员，所以派生类的构造函数必须使用基类的构造函数，在定义派生类的构造函数时：</p>\n<ol>\n<li>首先创建基类对象</li>\n<li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数</li>\n<li>派生类构造函数应初始化派生类新增的数据成员</li>\n</ol>\n<h3 id=\"3-3-私有继承与保护继承\"><a href=\"#3-3-私有继承与保护继承\" class=\"headerlink\" title=\"3.3 私有继承与保护继承\"></a>3.3 私有继承与保护继承</h3><p>进行私有继承时，使用关键字 <code>private</code> 而不是 <code>public</code> 来声明基类。派生类会包含两个无名称的对象成员。派生类对基类的使用是：</p>\n<ul>\n<li>构造函数中，使用基类类名来初始化相应的成员；</li>\n<li>派生类的方法中使用基类名和作用域解析符来调用基类方法；</li>\n<li>派生类中使用强制类型转换来访问基类对象<br>*　私有继承可以访问保护成员</li>\n<li>私有继承可以重定义虚函数（非公开）</li>\n<li>使用using可以定义继承的方法为公开方法</li>\n</ul>\n<p>保护继承与私有继承类似，区别是保护继承中，基类的公有办法将成为派生类的保护方法。这样,保护继承继承的方法可以在后续的派生中使用</p>\n<h3 id=\"3-4-多重继承\"><a href=\"#3-4-多重继承\" class=\"headerlink\" title=\"3.4 多重继承\"></a>3.4 多重继承</h3><p><strong>MI</strong>——<strong>多重继承</strong>，描述的是有多个直接基类的类。</p>\n<ul>\n<li>为了让派生类从多个基类相同的类继承时只继承一个基类对象，C++定义了虚基类：在类声明时使用 <code>virtual</code> 关键字。</li>\n<li>使用虚基类的时候，编译器会隐式调用虚基类的默认构造函数，或显式的调用虚基类的相应构造函数。</li>\n<li>使用虚基类时，需要使用作用域运算符标明使用的方法的类型。</li>\n</ul>"},{"title":"C++学习笔记（一）——基础知识","date":"2017-02-21T11:17:24.000Z","_content":"因为 C++ 的很多东西还是从 C 语言中来的，所以可能这个地方相对总结的比较简单。第一篇是基础知识。\n\n<!--more-->\nC++的总体知识大致分为五类：\n\n 1. 算术类型\n 2. 复合类型\n 3. 函数使用\n 4. 逻辑关系\n 5. 内存空间\n 6. 标准类库\n    \n## 一、算术类型\nC++ 的基本类型只有两类：**整数** 和 **浮点数**。\n\n* **整型**有下面几类`short`， `int`， `long`， `long long`， `char`， `wchar_t`， `char16_t`， `char32_t`\n* **浮点型**有下面几类`float`， `double`， `long double`\n\n### 1.1 整形和浮点型\n1. 相应的整形宽度设置为：\n * `short` 至少16位\n * `int` 至少与 `short` 一样长\n * `long` 至少32位，且至少与 `int` 一样长\n * `long long` 至少64位，且至少与 `long` 一样长\n\n2. `wchar_t` 用来处理无法用8位来表示的字符集，它的长度由系统的选择决定。\n3. `char16_t` 和 `char32_t` 和 `wchar_t` 一样是用来处理无法用8位来表示的字符集的。\n4. `bool`是一种新的类型，任何非零数值可以被隐式转换为`true`，0被隐式转换为`false`。\n\n### 1.2 算术运算符\n算术运算符包含我们常用的加减乘除，另外还有一个取模。其中需要注意的知识点有：\n\n1. 自动转换，C++ 会自动执行很多的自动转换：\n * 将一种算术类型的值赋给另一种算数类型时，C++将对值进行转换\n * 表达式中包含不同类型的时候，C++将对值进行转换\n * 将参数传递给函数的时候，C++将对值进行转换\n * 较大的浮点型转换为较小的浮点型或整形的时候，如果超出目标类型的取值范围，结果是不确定的\n * 较大的整形转换为较小的整形，超出目标类型的取值范围，通常只复制右边的字节\n\n2. 使用`{}`进行初始化称为**列表初始化（list-initialization）**，列表初始化不允许缩窄，如将 `int` 型赋值给 `char` 型\n3. 在计算表达式时，C++自动将 `bool`， `char`， `short` 的值转换为 `int`。\n4. 强制类型转换可以使用两种方式，还有四个强制类型转换符 `dynamic_cast`, `const_cast`, `static_cast`, `reinterpret_cast`，具体的介绍在这里不详细描述。\n * (typeName) value\n * typeName (value)\n \n## 二、复合类型\nC++中的复合类型既包括 C 中的数组、字符串、结构体、共用体、枚举、指针，又包含新的类等。\n### 2.1 数组\n数组的初始化有以下规则\n\n * 只有在定义数组的时候才可以使用初始化\n * 初始化数组的时候，提供的值可以小于数组的元素数目\n * 如果只对数组的一部分进行初始化，则其他部分初始化为0\n * 如果初始化的时候没有标明数组的元素个数，则自动计算提供的值的数目为数组元素个数\n * 可以使用列表初始化来初始化数组，此时可以省略等号，当列表为空时，自动把所有元素设为0\n\n### 2.2 字符串\nC++中的字符串有两种：C-风格字符串和 `string` 类。\n\n* C-风格字符串以`\\0`结尾\n* 任何两个由空白分割的字符串会自动拼接成一个\n* C-风格字符串和 `string` 对象都可以使用列表初始化\n* `string` 可以使用 + += 等运算符，并可以直接将一个 `string` 对象赋给另一个 `string` 对象。\n* 进行行读取的时候，C-风格字符串使用 `cin.getline(str, 20)`，而 `string` 类使用 `getling(cin, str)`;\n\n字符串的输入:\n\n * `cin`使用空白（空格、制表符和换行符）来确定字符串结束的位置。\n * `getline()`通过回车键来确定输入结尾但不保存并丢弃回车符。\n * `get()`带参数通过回车键来确定输入结尾，但将回车符留在输入队列中。\n * `get()`不带参数读取一个字符。\n * 混合输入数字和字符的时候，`<<`读取数字后会把回车留在输入队列中。\n\n### 2.3 结构、共用体、枚举\n* C++中结构声明定义了一种新的类型，使用时可以省略 `struct`，但 C 中不行。\n* C++允许指定占用特定位数的结构成员，可以使用没有名称的字段来提供间距。\n* 可以将一个结构赋给另一个结构\n* 枚举提供了一种创建符号常量的方式，可以替代`const`。\n* 枚举没有算术运算符\n* 枚举默认情况下第一个元素为0，后续累加\n\n### 2.4 指针\n* 使用 `new` 来分配内存\n* 只能使用 `delete` 来释放使用 `new` 分配的内存\n* 使用 `new` 创建动态数组，需要使用 `delete[]` 来释放\n* 指针的其他使用方式和C指针一致\n\n## 三、逻辑关系\n和C一样，C++的逻辑关系也有循环和分支两种，其中的注意点有：\n* C++允许在循环中定义变量，且变量只在循环内有效。\n* 递增和递减使用前缀格式的效率更高\n\n## 四、函数使用\n创建自己的函数，需要处理三个方面：\n\n* 提供函数定义\n* 提供函数原型\n* 调用函数\n\n### 4.1 函数参数\n* 数组（当且仅当）作为参数使用，和指针含义一样\n* `const` 尽可能多的使用\n* 使用数组名和超尾作为参数，来表示一个数组\n\n### 4.2 函数指针\n对于一个函数`double pam(int)`\n相应的函数指针定义为 `double (*pf)(int)`\n使用函数指针调用函数为 `double ret = (*pf)(5)` 或 `double ret pf(5)`\n\n### 4.3 内联函数\n内联函数运行速度稍快，但是占用内存较多\n使用内联函数：\n\n* 在函数声明前加 `inline`\n* 在函数定义前加 `inline`\n\n### 4.4 引用变量\n引用变量是已定义变量的别名。\n\n\n使用引用参数的原因：\n\n* 能够修改函数中的数据对象\n* 能够提高程序的运行速度\n\n使用时需要注意以下要点：\n\n* 必须在声明引用的同时初始化\n* 使用 `const` 进行常量引用，避免在函数中修改原有信息\n* 引用变量不能使用表达式传参\n* 引用参数是 `const` 的时候，在下面的两种情况下，将生成临时变量\n  * 实参的类型正确，但不是左值\n  * 实参的类型不正确，但可以转换成正确的类型\n* 返回引用类型能够提高效率\n* 不能返回指向临时变量的引用\n* 引用返回值可以作为左值，而常规返回值不能作为左值\n* C++11允许右值引用（&&）\n常见的函数参数的传递指导原则如下：\n\n* 使用传递的值，不修改数据对象的函数：\n * 数据对象很小，使用值传递\n * 对象是数组，使用指针，并声明为 `const`\n * 对象较大，使用 `const` 引用或 `const` 指针\n\n* 对于修改数据对象的函数：\n * 对象是常规数据，使用指针\n * 对象是数组，使用指针\n * 对象是结构，使用指针或引用\n * 对象是类对象，使用引用\n\n### 4.5 默认参数\n默认参数是指当函数调用中省略了实参时自动使用的一个值。需要注意的点为：\n\n* 必须在原型中将可能的默认参数告知程序\n* 必须从右向左添加默认值\n\n### 4.6 函数重载\n函数重载指可以有多个同名的函数，可以通过函数重载设计一系列的函数，他们完成相同的工作，但是使用不同的参数列表。\n\n* 重载引用参数时的最佳匹配：\n * `void function(double & arg)` 匹配：\n    可修改的左值参数（如 double变量），同时也是最优匹配\n * `void function(const double & arg)` 匹配：\n     * 可修改的左值参数（如 double变量），\n     * 不可修改的左值参数(如const double常量)，最佳匹配\n     *  右值参数（如 double + double），\n * `coid function(double && arg)`匹配：\n    右值参数（如 double + double），同时也是最优匹配\n\n### 4.7 函数模板\n函数模板是通用的函数描述，它们使用泛型来定义函数，其中的泛型可以使用具体的类型替换。\n建立函数模板的方式为：\n````C\ntemplate <typename AnyType>\nvoid function(AnyType a, AnyType b)````\n\n* 显式具体化\n * 对于给定的函数名，可以有非模板函数、模板函数、和显式具体化函数以及它们的重载版本\n * 显式具体化的原型和定义应以 `template<>` 开头，并通过名称来指定类型\n * 具体化优先于常规模板。\n* 显式实例化：\n * 显式实例化命令编译器创建特定的实例\n * 显式实例化不能和显式具体化共存\n * 显式实例化可以将参数强制转换为相应的类型\n \n相应的代码示例为：\n````C\n//非模板函数：\nvoid function(type a);\n//模板函数：\ntemplate <typename T>\nvoid function(T a);\n//显式具体化函数\ntemplate<> function<type>(type a);\n//显式实例化\ntemplate function<type>(type a)````\n\n编译器选择函数版本的流程为：\n\n1. 创建候选列表\n  所有函数名相同的模板和函数\n2. 创建可行函数列表\n  所有参数匹配的函数\n3. 选择最佳函数\n  * 完全匹配 常规函数优先于模板\n  * 提升转换  char -> int   float -> double\n  * 标准转换 int -> char double -> float\n  * 定义转换\n\n针对无法确定的参数类型，C++11定义了关键字 `decltype`\n\n * 使用方法为： `decltype (ecpression) var`\n  * `ecpression` 为标识符\n    var类型为标识符类型\n  * `ecpression` 为函数调用\n    var类型为函数返回值类型\n  * `ecpression` 为左值\n    var类型为指向类型的引用类型\n  * `ecpression` 为什么都不是\n    var类型为experssion的类型\n\n同时针对返回值的类型，C++新增了后置返回类型\n`auto function(int a) ->double;`\n\n## 五、内存空间\n### 5.1 文件结构\n程序可以分为三个部分：\n\n* 头文件：包含结构声明和使用这些结构的函数的原型，主要包括：\n  * 函数原型\n  * 符号常量\n  * 结构声明\n  * 类声明\n  * 模板声明\n  * 内联函数\n* 源代码文件：包含与结构相关的函数的代码\n  * 实现相关函数代码\n* 源代码文件：包含调用与结构相关的函数的代码\n  * 业务逻辑调用相关函数代码\n\n### 5.2 存储持续性\nC++使用三种不同的方式来存储数据：\n\n* 自动存储\n * 存储时间:函数存在时\n * 作用域为:局部\n * 链接性为:无\n * 内存区域:栈(后进先出)\n* 静态存储\n * 存储时间:整个程序运行时间\n * 作用域为:局部或全局\n * 链接性为:三种\n     * 外部链接性——全局变量，可以在一个文件中定义全局变量,其他文件使用extern声明\n     * 内部链接性——使用static修饰的全局变量\n     * 无链接性——使用static修饰的局部变量\n * 内存区域:静态区域\n* 动态存储\n * 存储时间:new 分配的内存持续存在直至使用delete删除\n * 作用域为:使用地址均可以访问\n * 链接性为:使用地址访问\n * 内存区域:堆\n* 线程存储(C++11)\n * 存储时间为线程周期\n","source":"_posts/C-学习笔记（一）——基础知识.md","raw":"---\ntitle: C++学习笔记（一）——基础知识\ndate: 2017-02-21 19:17:24\ncategories: C++学习笔记\ntags: [C++, 模板, 函数重载]\n---\n因为 C++ 的很多东西还是从 C 语言中来的，所以可能这个地方相对总结的比较简单。第一篇是基础知识。\n\n<!--more-->\nC++的总体知识大致分为五类：\n\n 1. 算术类型\n 2. 复合类型\n 3. 函数使用\n 4. 逻辑关系\n 5. 内存空间\n 6. 标准类库\n    \n## 一、算术类型\nC++ 的基本类型只有两类：**整数** 和 **浮点数**。\n\n* **整型**有下面几类`short`， `int`， `long`， `long long`， `char`， `wchar_t`， `char16_t`， `char32_t`\n* **浮点型**有下面几类`float`， `double`， `long double`\n\n### 1.1 整形和浮点型\n1. 相应的整形宽度设置为：\n * `short` 至少16位\n * `int` 至少与 `short` 一样长\n * `long` 至少32位，且至少与 `int` 一样长\n * `long long` 至少64位，且至少与 `long` 一样长\n\n2. `wchar_t` 用来处理无法用8位来表示的字符集，它的长度由系统的选择决定。\n3. `char16_t` 和 `char32_t` 和 `wchar_t` 一样是用来处理无法用8位来表示的字符集的。\n4. `bool`是一种新的类型，任何非零数值可以被隐式转换为`true`，0被隐式转换为`false`。\n\n### 1.2 算术运算符\n算术运算符包含我们常用的加减乘除，另外还有一个取模。其中需要注意的知识点有：\n\n1. 自动转换，C++ 会自动执行很多的自动转换：\n * 将一种算术类型的值赋给另一种算数类型时，C++将对值进行转换\n * 表达式中包含不同类型的时候，C++将对值进行转换\n * 将参数传递给函数的时候，C++将对值进行转换\n * 较大的浮点型转换为较小的浮点型或整形的时候，如果超出目标类型的取值范围，结果是不确定的\n * 较大的整形转换为较小的整形，超出目标类型的取值范围，通常只复制右边的字节\n\n2. 使用`{}`进行初始化称为**列表初始化（list-initialization）**，列表初始化不允许缩窄，如将 `int` 型赋值给 `char` 型\n3. 在计算表达式时，C++自动将 `bool`， `char`， `short` 的值转换为 `int`。\n4. 强制类型转换可以使用两种方式，还有四个强制类型转换符 `dynamic_cast`, `const_cast`, `static_cast`, `reinterpret_cast`，具体的介绍在这里不详细描述。\n * (typeName) value\n * typeName (value)\n \n## 二、复合类型\nC++中的复合类型既包括 C 中的数组、字符串、结构体、共用体、枚举、指针，又包含新的类等。\n### 2.1 数组\n数组的初始化有以下规则\n\n * 只有在定义数组的时候才可以使用初始化\n * 初始化数组的时候，提供的值可以小于数组的元素数目\n * 如果只对数组的一部分进行初始化，则其他部分初始化为0\n * 如果初始化的时候没有标明数组的元素个数，则自动计算提供的值的数目为数组元素个数\n * 可以使用列表初始化来初始化数组，此时可以省略等号，当列表为空时，自动把所有元素设为0\n\n### 2.2 字符串\nC++中的字符串有两种：C-风格字符串和 `string` 类。\n\n* C-风格字符串以`\\0`结尾\n* 任何两个由空白分割的字符串会自动拼接成一个\n* C-风格字符串和 `string` 对象都可以使用列表初始化\n* `string` 可以使用 + += 等运算符，并可以直接将一个 `string` 对象赋给另一个 `string` 对象。\n* 进行行读取的时候，C-风格字符串使用 `cin.getline(str, 20)`，而 `string` 类使用 `getling(cin, str)`;\n\n字符串的输入:\n\n * `cin`使用空白（空格、制表符和换行符）来确定字符串结束的位置。\n * `getline()`通过回车键来确定输入结尾但不保存并丢弃回车符。\n * `get()`带参数通过回车键来确定输入结尾，但将回车符留在输入队列中。\n * `get()`不带参数读取一个字符。\n * 混合输入数字和字符的时候，`<<`读取数字后会把回车留在输入队列中。\n\n### 2.3 结构、共用体、枚举\n* C++中结构声明定义了一种新的类型，使用时可以省略 `struct`，但 C 中不行。\n* C++允许指定占用特定位数的结构成员，可以使用没有名称的字段来提供间距。\n* 可以将一个结构赋给另一个结构\n* 枚举提供了一种创建符号常量的方式，可以替代`const`。\n* 枚举没有算术运算符\n* 枚举默认情况下第一个元素为0，后续累加\n\n### 2.4 指针\n* 使用 `new` 来分配内存\n* 只能使用 `delete` 来释放使用 `new` 分配的内存\n* 使用 `new` 创建动态数组，需要使用 `delete[]` 来释放\n* 指针的其他使用方式和C指针一致\n\n## 三、逻辑关系\n和C一样，C++的逻辑关系也有循环和分支两种，其中的注意点有：\n* C++允许在循环中定义变量，且变量只在循环内有效。\n* 递增和递减使用前缀格式的效率更高\n\n## 四、函数使用\n创建自己的函数，需要处理三个方面：\n\n* 提供函数定义\n* 提供函数原型\n* 调用函数\n\n### 4.1 函数参数\n* 数组（当且仅当）作为参数使用，和指针含义一样\n* `const` 尽可能多的使用\n* 使用数组名和超尾作为参数，来表示一个数组\n\n### 4.2 函数指针\n对于一个函数`double pam(int)`\n相应的函数指针定义为 `double (*pf)(int)`\n使用函数指针调用函数为 `double ret = (*pf)(5)` 或 `double ret pf(5)`\n\n### 4.3 内联函数\n内联函数运行速度稍快，但是占用内存较多\n使用内联函数：\n\n* 在函数声明前加 `inline`\n* 在函数定义前加 `inline`\n\n### 4.4 引用变量\n引用变量是已定义变量的别名。\n\n\n使用引用参数的原因：\n\n* 能够修改函数中的数据对象\n* 能够提高程序的运行速度\n\n使用时需要注意以下要点：\n\n* 必须在声明引用的同时初始化\n* 使用 `const` 进行常量引用，避免在函数中修改原有信息\n* 引用变量不能使用表达式传参\n* 引用参数是 `const` 的时候，在下面的两种情况下，将生成临时变量\n  * 实参的类型正确，但不是左值\n  * 实参的类型不正确，但可以转换成正确的类型\n* 返回引用类型能够提高效率\n* 不能返回指向临时变量的引用\n* 引用返回值可以作为左值，而常规返回值不能作为左值\n* C++11允许右值引用（&&）\n常见的函数参数的传递指导原则如下：\n\n* 使用传递的值，不修改数据对象的函数：\n * 数据对象很小，使用值传递\n * 对象是数组，使用指针，并声明为 `const`\n * 对象较大，使用 `const` 引用或 `const` 指针\n\n* 对于修改数据对象的函数：\n * 对象是常规数据，使用指针\n * 对象是数组，使用指针\n * 对象是结构，使用指针或引用\n * 对象是类对象，使用引用\n\n### 4.5 默认参数\n默认参数是指当函数调用中省略了实参时自动使用的一个值。需要注意的点为：\n\n* 必须在原型中将可能的默认参数告知程序\n* 必须从右向左添加默认值\n\n### 4.6 函数重载\n函数重载指可以有多个同名的函数，可以通过函数重载设计一系列的函数，他们完成相同的工作，但是使用不同的参数列表。\n\n* 重载引用参数时的最佳匹配：\n * `void function(double & arg)` 匹配：\n    可修改的左值参数（如 double变量），同时也是最优匹配\n * `void function(const double & arg)` 匹配：\n     * 可修改的左值参数（如 double变量），\n     * 不可修改的左值参数(如const double常量)，最佳匹配\n     *  右值参数（如 double + double），\n * `coid function(double && arg)`匹配：\n    右值参数（如 double + double），同时也是最优匹配\n\n### 4.7 函数模板\n函数模板是通用的函数描述，它们使用泛型来定义函数，其中的泛型可以使用具体的类型替换。\n建立函数模板的方式为：\n````C\ntemplate <typename AnyType>\nvoid function(AnyType a, AnyType b)````\n\n* 显式具体化\n * 对于给定的函数名，可以有非模板函数、模板函数、和显式具体化函数以及它们的重载版本\n * 显式具体化的原型和定义应以 `template<>` 开头，并通过名称来指定类型\n * 具体化优先于常规模板。\n* 显式实例化：\n * 显式实例化命令编译器创建特定的实例\n * 显式实例化不能和显式具体化共存\n * 显式实例化可以将参数强制转换为相应的类型\n \n相应的代码示例为：\n````C\n//非模板函数：\nvoid function(type a);\n//模板函数：\ntemplate <typename T>\nvoid function(T a);\n//显式具体化函数\ntemplate<> function<type>(type a);\n//显式实例化\ntemplate function<type>(type a)````\n\n编译器选择函数版本的流程为：\n\n1. 创建候选列表\n  所有函数名相同的模板和函数\n2. 创建可行函数列表\n  所有参数匹配的函数\n3. 选择最佳函数\n  * 完全匹配 常规函数优先于模板\n  * 提升转换  char -> int   float -> double\n  * 标准转换 int -> char double -> float\n  * 定义转换\n\n针对无法确定的参数类型，C++11定义了关键字 `decltype`\n\n * 使用方法为： `decltype (ecpression) var`\n  * `ecpression` 为标识符\n    var类型为标识符类型\n  * `ecpression` 为函数调用\n    var类型为函数返回值类型\n  * `ecpression` 为左值\n    var类型为指向类型的引用类型\n  * `ecpression` 为什么都不是\n    var类型为experssion的类型\n\n同时针对返回值的类型，C++新增了后置返回类型\n`auto function(int a) ->double;`\n\n## 五、内存空间\n### 5.1 文件结构\n程序可以分为三个部分：\n\n* 头文件：包含结构声明和使用这些结构的函数的原型，主要包括：\n  * 函数原型\n  * 符号常量\n  * 结构声明\n  * 类声明\n  * 模板声明\n  * 内联函数\n* 源代码文件：包含与结构相关的函数的代码\n  * 实现相关函数代码\n* 源代码文件：包含调用与结构相关的函数的代码\n  * 业务逻辑调用相关函数代码\n\n### 5.2 存储持续性\nC++使用三种不同的方式来存储数据：\n\n* 自动存储\n * 存储时间:函数存在时\n * 作用域为:局部\n * 链接性为:无\n * 内存区域:栈(后进先出)\n* 静态存储\n * 存储时间:整个程序运行时间\n * 作用域为:局部或全局\n * 链接性为:三种\n     * 外部链接性——全局变量，可以在一个文件中定义全局变量,其他文件使用extern声明\n     * 内部链接性——使用static修饰的全局变量\n     * 无链接性——使用static修饰的局部变量\n * 内存区域:静态区域\n* 动态存储\n * 存储时间:new 分配的内存持续存在直至使用delete删除\n * 作用域为:使用地址均可以访问\n * 链接性为:使用地址访问\n * 内存区域:堆\n* 线程存储(C++11)\n * 存储时间为线程周期\n","slug":"C-学习笔记（一）——基础知识","published":1,"updated":"2017-12-06T13:47:12.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9mzl0007bkw1hutlh7gd","content":"<p>因为 C++ 的很多东西还是从 C 语言中来的，所以可能这个地方相对总结的比较简单。第一篇是基础知识。</p>\n<a id=\"more\"></a>\n<p>C++的总体知识大致分为五类：</p>\n<ol>\n<li>算术类型</li>\n<li>复合类型</li>\n<li>函数使用</li>\n<li>逻辑关系</li>\n<li>内存空间</li>\n<li>标准类库</li>\n</ol>\n<h2 id=\"一、算术类型\"><a href=\"#一、算术类型\" class=\"headerlink\" title=\"一、算术类型\"></a>一、算术类型</h2><p>C++ 的基本类型只有两类：<strong>整数</strong> 和 <strong>浮点数</strong>。</p>\n<ul>\n<li><strong>整型</strong>有下面几类<code>short</code>， <code>int</code>， <code>long</code>， <code>long long</code>， <code>char</code>， <code>wchar_t</code>， <code>char16_t</code>， <code>char32_t</code></li>\n<li><strong>浮点型</strong>有下面几类<code>float</code>， <code>double</code>， <code>long double</code></li>\n</ul>\n<h3 id=\"1-1-整形和浮点型\"><a href=\"#1-1-整形和浮点型\" class=\"headerlink\" title=\"1.1 整形和浮点型\"></a>1.1 整形和浮点型</h3><ol>\n<li><p>相应的整形宽度设置为：</p>\n<ul>\n<li><code>short</code> 至少16位</li>\n<li><code>int</code> 至少与 <code>short</code> 一样长</li>\n<li><code>long</code> 至少32位，且至少与 <code>int</code> 一样长</li>\n<li><code>long long</code> 至少64位，且至少与 <code>long</code> 一样长</li>\n</ul>\n</li>\n<li><p><code>wchar_t</code> 用来处理无法用8位来表示的字符集，它的长度由系统的选择决定。</p>\n</li>\n<li><code>char16_t</code> 和 <code>char32_t</code> 和 <code>wchar_t</code> 一样是用来处理无法用8位来表示的字符集的。</li>\n<li><code>bool</code>是一种新的类型，任何非零数值可以被隐式转换为<code>true</code>，0被隐式转换为<code>false</code>。</li>\n</ol>\n<h3 id=\"1-2-算术运算符\"><a href=\"#1-2-算术运算符\" class=\"headerlink\" title=\"1.2 算术运算符\"></a>1.2 算术运算符</h3><p>算术运算符包含我们常用的加减乘除，另外还有一个取模。其中需要注意的知识点有：</p>\n<ol>\n<li><p>自动转换，C++ 会自动执行很多的自动转换：</p>\n<ul>\n<li>将一种算术类型的值赋给另一种算数类型时，C++将对值进行转换</li>\n<li>表达式中包含不同类型的时候，C++将对值进行转换</li>\n<li>将参数传递给函数的时候，C++将对值进行转换</li>\n<li>较大的浮点型转换为较小的浮点型或整形的时候，如果超出目标类型的取值范围，结果是不确定的</li>\n<li>较大的整形转换为较小的整形，超出目标类型的取值范围，通常只复制右边的字节</li>\n</ul>\n</li>\n<li><p>使用<code>{}</code>进行初始化称为<strong>列表初始化（list-initialization）</strong>，列表初始化不允许缩窄，如将 <code>int</code> 型赋值给 <code>char</code> 型</p>\n</li>\n<li>在计算表达式时，C++自动将 <code>bool</code>， <code>char</code>， <code>short</code> 的值转换为 <code>int</code>。</li>\n<li>强制类型转换可以使用两种方式，还有四个强制类型转换符 <code>dynamic_cast</code>, <code>const_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>，具体的介绍在这里不详细描述。<ul>\n<li>(typeName) value</li>\n<li>typeName (value)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"二、复合类型\"><a href=\"#二、复合类型\" class=\"headerlink\" title=\"二、复合类型\"></a>二、复合类型</h2><p>C++中的复合类型既包括 C 中的数组、字符串、结构体、共用体、枚举、指针，又包含新的类等。</p>\n<h3 id=\"2-1-数组\"><a href=\"#2-1-数组\" class=\"headerlink\" title=\"2.1 数组\"></a>2.1 数组</h3><p>数组的初始化有以下规则</p>\n<ul>\n<li>只有在定义数组的时候才可以使用初始化</li>\n<li>初始化数组的时候，提供的值可以小于数组的元素数目</li>\n<li>如果只对数组的一部分进行初始化，则其他部分初始化为0</li>\n<li>如果初始化的时候没有标明数组的元素个数，则自动计算提供的值的数目为数组元素个数</li>\n<li>可以使用列表初始化来初始化数组，此时可以省略等号，当列表为空时，自动把所有元素设为0</li>\n</ul>\n<h3 id=\"2-2-字符串\"><a href=\"#2-2-字符串\" class=\"headerlink\" title=\"2.2 字符串\"></a>2.2 字符串</h3><p>C++中的字符串有两种：C-风格字符串和 <code>string</code> 类。</p>\n<ul>\n<li>C-风格字符串以<code>\\0</code>结尾</li>\n<li>任何两个由空白分割的字符串会自动拼接成一个</li>\n<li>C-风格字符串和 <code>string</code> 对象都可以使用列表初始化</li>\n<li><code>string</code> 可以使用 + += 等运算符，并可以直接将一个 <code>string</code> 对象赋给另一个 <code>string</code> 对象。</li>\n<li>进行行读取的时候，C-风格字符串使用 <code>cin.getline(str, 20)</code>，而 <code>string</code> 类使用 <code>getling(cin, str)</code>;</li>\n</ul>\n<p>字符串的输入:</p>\n<ul>\n<li><code>cin</code>使用空白（空格、制表符和换行符）来确定字符串结束的位置。</li>\n<li><code>getline()</code>通过回车键来确定输入结尾但不保存并丢弃回车符。</li>\n<li><code>get()</code>带参数通过回车键来确定输入结尾，但将回车符留在输入队列中。</li>\n<li><code>get()</code>不带参数读取一个字符。</li>\n<li>混合输入数字和字符的时候，<code>&lt;&lt;</code>读取数字后会把回车留在输入队列中。</li>\n</ul>\n<h3 id=\"2-3-结构、共用体、枚举\"><a href=\"#2-3-结构、共用体、枚举\" class=\"headerlink\" title=\"2.3 结构、共用体、枚举\"></a>2.3 结构、共用体、枚举</h3><ul>\n<li>C++中结构声明定义了一种新的类型，使用时可以省略 <code>struct</code>，但 C 中不行。</li>\n<li>C++允许指定占用特定位数的结构成员，可以使用没有名称的字段来提供间距。</li>\n<li>可以将一个结构赋给另一个结构</li>\n<li>枚举提供了一种创建符号常量的方式，可以替代<code>const</code>。</li>\n<li>枚举没有算术运算符</li>\n<li>枚举默认情况下第一个元素为0，后续累加</li>\n</ul>\n<h3 id=\"2-4-指针\"><a href=\"#2-4-指针\" class=\"headerlink\" title=\"2.4 指针\"></a>2.4 指针</h3><ul>\n<li>使用 <code>new</code> 来分配内存</li>\n<li>只能使用 <code>delete</code> 来释放使用 <code>new</code> 分配的内存</li>\n<li>使用 <code>new</code> 创建动态数组，需要使用 <code>delete[]</code> 来释放</li>\n<li>指针的其他使用方式和C指针一致</li>\n</ul>\n<h2 id=\"三、逻辑关系\"><a href=\"#三、逻辑关系\" class=\"headerlink\" title=\"三、逻辑关系\"></a>三、逻辑关系</h2><p>和C一样，C++的逻辑关系也有循环和分支两种，其中的注意点有：</p>\n<ul>\n<li>C++允许在循环中定义变量，且变量只在循环内有效。</li>\n<li>递增和递减使用前缀格式的效率更高</li>\n</ul>\n<h2 id=\"四、函数使用\"><a href=\"#四、函数使用\" class=\"headerlink\" title=\"四、函数使用\"></a>四、函数使用</h2><p>创建自己的函数，需要处理三个方面：</p>\n<ul>\n<li>提供函数定义</li>\n<li>提供函数原型</li>\n<li>调用函数</li>\n</ul>\n<h3 id=\"4-1-函数参数\"><a href=\"#4-1-函数参数\" class=\"headerlink\" title=\"4.1 函数参数\"></a>4.1 函数参数</h3><ul>\n<li>数组（当且仅当）作为参数使用，和指针含义一样</li>\n<li><code>const</code> 尽可能多的使用</li>\n<li>使用数组名和超尾作为参数，来表示一个数组</li>\n</ul>\n<h3 id=\"4-2-函数指针\"><a href=\"#4-2-函数指针\" class=\"headerlink\" title=\"4.2 函数指针\"></a>4.2 函数指针</h3><p>对于一个函数<code>double pam(int)</code><br>相应的函数指针定义为 <code>double (*pf)(int)</code><br>使用函数指针调用函数为 <code>double ret = (*pf)(5)</code> 或 <code>double ret pf(5)</code></p>\n<h3 id=\"4-3-内联函数\"><a href=\"#4-3-内联函数\" class=\"headerlink\" title=\"4.3 内联函数\"></a>4.3 内联函数</h3><p>内联函数运行速度稍快，但是占用内存较多<br>使用内联函数：</p>\n<ul>\n<li>在函数声明前加 <code>inline</code></li>\n<li>在函数定义前加 <code>inline</code></li>\n</ul>\n<h3 id=\"4-4-引用变量\"><a href=\"#4-4-引用变量\" class=\"headerlink\" title=\"4.4 引用变量\"></a>4.4 引用变量</h3><p>引用变量是已定义变量的别名。</p>\n<p>使用引用参数的原因：</p>\n<ul>\n<li>能够修改函数中的数据对象</li>\n<li>能够提高程序的运行速度</li>\n</ul>\n<p>使用时需要注意以下要点：</p>\n<ul>\n<li>必须在声明引用的同时初始化</li>\n<li>使用 <code>const</code> 进行常量引用，避免在函数中修改原有信息</li>\n<li>引用变量不能使用表达式传参</li>\n<li>引用参数是 <code>const</code> 的时候，在下面的两种情况下，将生成临时变量<ul>\n<li>实参的类型正确，但不是左值</li>\n<li>实参的类型不正确，但可以转换成正确的类型</li>\n</ul>\n</li>\n<li>返回引用类型能够提高效率</li>\n<li>不能返回指向临时变量的引用</li>\n<li>引用返回值可以作为左值，而常规返回值不能作为左值</li>\n<li><p>C++11允许右值引用（&amp;&amp;）<br>常见的函数参数的传递指导原则如下：</p>\n</li>\n<li><p>使用传递的值，不修改数据对象的函数：</p>\n<ul>\n<li>数据对象很小，使用值传递</li>\n<li>对象是数组，使用指针，并声明为 <code>const</code></li>\n<li>对象较大，使用 <code>const</code> 引用或 <code>const</code> 指针</li>\n</ul>\n</li>\n<li><p>对于修改数据对象的函数：</p>\n<ul>\n<li>对象是常规数据，使用指针</li>\n<li>对象是数组，使用指针</li>\n<li>对象是结构，使用指针或引用</li>\n<li>对象是类对象，使用引用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-默认参数\"><a href=\"#4-5-默认参数\" class=\"headerlink\" title=\"4.5 默认参数\"></a>4.5 默认参数</h3><p>默认参数是指当函数调用中省略了实参时自动使用的一个值。需要注意的点为：</p>\n<ul>\n<li>必须在原型中将可能的默认参数告知程序</li>\n<li>必须从右向左添加默认值</li>\n</ul>\n<h3 id=\"4-6-函数重载\"><a href=\"#4-6-函数重载\" class=\"headerlink\" title=\"4.6 函数重载\"></a>4.6 函数重载</h3><p>函数重载指可以有多个同名的函数，可以通过函数重载设计一系列的函数，他们完成相同的工作，但是使用不同的参数列表。</p>\n<ul>\n<li>重载引用参数时的最佳匹配：<ul>\n<li><code>void function(double &amp; arg)</code> 匹配：<br>可修改的左值参数（如 double变量），同时也是最优匹配</li>\n<li><code>void function(const double &amp; arg)</code> 匹配：<ul>\n<li>可修改的左值参数（如 double变量），</li>\n<li>不可修改的左值参数(如const double常量)，最佳匹配</li>\n<li>右值参数（如 double + double），</li>\n</ul>\n</li>\n<li><code>coid function(double &amp;&amp; arg)</code>匹配：<br>右值参数（如 double + double），同时也是最优匹配</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-7-函数模板\"><a href=\"#4-7-函数模板\" class=\"headerlink\" title=\"4.7 函数模板\"></a>4.7 函数模板</h3><p>函数模板是通用的函数描述，它们使用泛型来定义函数，其中的泛型可以使用具体的类型替换。<br>建立函数模板的方式为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> AnyType&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(AnyType a, AnyType b)</span></span></div></pre></td></tr></table></figure></p>\n<ul>\n<li>显式具体化<ul>\n<li>对于给定的函数名，可以有非模板函数、模板函数、和显式具体化函数以及它们的重载版本</li>\n<li>显式具体化的原型和定义应以 <code>template&lt;&gt;</code> 开头，并通过名称来指定类型</li>\n<li>具体化优先于常规模板。</li>\n</ul>\n</li>\n<li>显式实例化：<ul>\n<li>显式实例化命令编译器创建特定的实例</li>\n<li>显式实例化不能和显式具体化共存</li>\n<li>显式实例化可以将参数强制转换为相应的类型</li>\n</ul>\n</li>\n</ul>\n<p>相应的代码示例为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//非模板函数：</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(type a)</span></span>;</div><div class=\"line\"><span class=\"comment\">//模板函数：</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(T a)</span></span>;</div><div class=\"line\"><span class=\"comment\">//显式具体化函数</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; function&lt;type&gt;(type a);</div><div class=\"line\"><span class=\"comment\">//显式实例化</span></div><div class=\"line\"><span class=\"keyword\">template</span> function&lt;type&gt;(type a)</div></pre></td></tr></table></figure></p>\n<p>编译器选择函数版本的流程为：</p>\n<ol>\n<li>创建候选列表<br>所有函数名相同的模板和函数</li>\n<li>创建可行函数列表<br>所有参数匹配的函数</li>\n<li>选择最佳函数<ul>\n<li>完全匹配 常规函数优先于模板</li>\n<li>提升转换  char -&gt; int   float -&gt; double</li>\n<li>标准转换 int -&gt; char double -&gt; float</li>\n<li>定义转换</li>\n</ul>\n</li>\n</ol>\n<p>针对无法确定的参数类型，C++11定义了关键字 <code>decltype</code></p>\n<ul>\n<li>使用方法为： <code>decltype (ecpression) var</code><ul>\n<li><code>ecpression</code> 为标识符<br>var类型为标识符类型</li>\n<li><code>ecpression</code> 为函数调用<br>var类型为函数返回值类型</li>\n<li><code>ecpression</code> 为左值<br>var类型为指向类型的引用类型</li>\n<li><code>ecpression</code> 为什么都不是<br>var类型为experssion的类型</li>\n</ul>\n</li>\n</ul>\n<p>同时针对返回值的类型，C++新增了后置返回类型<br><code>auto function(int a) -&gt;double;</code></p>\n<h2 id=\"五、内存空间\"><a href=\"#五、内存空间\" class=\"headerlink\" title=\"五、内存空间\"></a>五、内存空间</h2><h3 id=\"5-1-文件结构\"><a href=\"#5-1-文件结构\" class=\"headerlink\" title=\"5.1 文件结构\"></a>5.1 文件结构</h3><p>程序可以分为三个部分：</p>\n<ul>\n<li>头文件：包含结构声明和使用这些结构的函数的原型，主要包括：<ul>\n<li>函数原型</li>\n<li>符号常量</li>\n<li>结构声明</li>\n<li>类声明</li>\n<li>模板声明</li>\n<li>内联函数</li>\n</ul>\n</li>\n<li>源代码文件：包含与结构相关的函数的代码<ul>\n<li>实现相关函数代码</li>\n</ul>\n</li>\n<li>源代码文件：包含调用与结构相关的函数的代码<ul>\n<li>业务逻辑调用相关函数代码</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-存储持续性\"><a href=\"#5-2-存储持续性\" class=\"headerlink\" title=\"5.2 存储持续性\"></a>5.2 存储持续性</h3><p>C++使用三种不同的方式来存储数据：</p>\n<ul>\n<li>自动存储<ul>\n<li>存储时间:函数存在时</li>\n<li>作用域为:局部</li>\n<li>链接性为:无</li>\n<li>内存区域:栈(后进先出)</li>\n</ul>\n</li>\n<li>静态存储<ul>\n<li>存储时间:整个程序运行时间</li>\n<li>作用域为:局部或全局</li>\n<li>链接性为:三种<ul>\n<li>外部链接性——全局变量，可以在一个文件中定义全局变量,其他文件使用extern声明</li>\n<li>内部链接性——使用static修饰的全局变量</li>\n<li>无链接性——使用static修饰的局部变量</li>\n</ul>\n</li>\n<li>内存区域:静态区域</li>\n</ul>\n</li>\n<li>动态存储<ul>\n<li>存储时间:new 分配的内存持续存在直至使用delete删除</li>\n<li>作用域为:使用地址均可以访问</li>\n<li>链接性为:使用地址访问</li>\n<li>内存区域:堆</li>\n</ul>\n</li>\n<li>线程存储(C++11)<ul>\n<li>存储时间为线程周期</li>\n</ul>\n</li>\n</ul>\n","excerpt":"<p>因为 C++ 的很多东西还是从 C 语言中来的，所以可能这个地方相对总结的比较简单。第一篇是基础知识。</p>","more":"<p>C++的总体知识大致分为五类：</p>\n<ol>\n<li>算术类型</li>\n<li>复合类型</li>\n<li>函数使用</li>\n<li>逻辑关系</li>\n<li>内存空间</li>\n<li>标准类库</li>\n</ol>\n<h2 id=\"一、算术类型\"><a href=\"#一、算术类型\" class=\"headerlink\" title=\"一、算术类型\"></a>一、算术类型</h2><p>C++ 的基本类型只有两类：<strong>整数</strong> 和 <strong>浮点数</strong>。</p>\n<ul>\n<li><strong>整型</strong>有下面几类<code>short</code>， <code>int</code>， <code>long</code>， <code>long long</code>， <code>char</code>， <code>wchar_t</code>， <code>char16_t</code>， <code>char32_t</code></li>\n<li><strong>浮点型</strong>有下面几类<code>float</code>， <code>double</code>， <code>long double</code></li>\n</ul>\n<h3 id=\"1-1-整形和浮点型\"><a href=\"#1-1-整形和浮点型\" class=\"headerlink\" title=\"1.1 整形和浮点型\"></a>1.1 整形和浮点型</h3><ol>\n<li><p>相应的整形宽度设置为：</p>\n<ul>\n<li><code>short</code> 至少16位</li>\n<li><code>int</code> 至少与 <code>short</code> 一样长</li>\n<li><code>long</code> 至少32位，且至少与 <code>int</code> 一样长</li>\n<li><code>long long</code> 至少64位，且至少与 <code>long</code> 一样长</li>\n</ul>\n</li>\n<li><p><code>wchar_t</code> 用来处理无法用8位来表示的字符集，它的长度由系统的选择决定。</p>\n</li>\n<li><code>char16_t</code> 和 <code>char32_t</code> 和 <code>wchar_t</code> 一样是用来处理无法用8位来表示的字符集的。</li>\n<li><code>bool</code>是一种新的类型，任何非零数值可以被隐式转换为<code>true</code>，0被隐式转换为<code>false</code>。</li>\n</ol>\n<h3 id=\"1-2-算术运算符\"><a href=\"#1-2-算术运算符\" class=\"headerlink\" title=\"1.2 算术运算符\"></a>1.2 算术运算符</h3><p>算术运算符包含我们常用的加减乘除，另外还有一个取模。其中需要注意的知识点有：</p>\n<ol>\n<li><p>自动转换，C++ 会自动执行很多的自动转换：</p>\n<ul>\n<li>将一种算术类型的值赋给另一种算数类型时，C++将对值进行转换</li>\n<li>表达式中包含不同类型的时候，C++将对值进行转换</li>\n<li>将参数传递给函数的时候，C++将对值进行转换</li>\n<li>较大的浮点型转换为较小的浮点型或整形的时候，如果超出目标类型的取值范围，结果是不确定的</li>\n<li>较大的整形转换为较小的整形，超出目标类型的取值范围，通常只复制右边的字节</li>\n</ul>\n</li>\n<li><p>使用<code>{}</code>进行初始化称为<strong>列表初始化（list-initialization）</strong>，列表初始化不允许缩窄，如将 <code>int</code> 型赋值给 <code>char</code> 型</p>\n</li>\n<li>在计算表达式时，C++自动将 <code>bool</code>， <code>char</code>， <code>short</code> 的值转换为 <code>int</code>。</li>\n<li>强制类型转换可以使用两种方式，还有四个强制类型转换符 <code>dynamic_cast</code>, <code>const_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>，具体的介绍在这里不详细描述。<ul>\n<li>(typeName) value</li>\n<li>typeName (value)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"二、复合类型\"><a href=\"#二、复合类型\" class=\"headerlink\" title=\"二、复合类型\"></a>二、复合类型</h2><p>C++中的复合类型既包括 C 中的数组、字符串、结构体、共用体、枚举、指针，又包含新的类等。</p>\n<h3 id=\"2-1-数组\"><a href=\"#2-1-数组\" class=\"headerlink\" title=\"2.1 数组\"></a>2.1 数组</h3><p>数组的初始化有以下规则</p>\n<ul>\n<li>只有在定义数组的时候才可以使用初始化</li>\n<li>初始化数组的时候，提供的值可以小于数组的元素数目</li>\n<li>如果只对数组的一部分进行初始化，则其他部分初始化为0</li>\n<li>如果初始化的时候没有标明数组的元素个数，则自动计算提供的值的数目为数组元素个数</li>\n<li>可以使用列表初始化来初始化数组，此时可以省略等号，当列表为空时，自动把所有元素设为0</li>\n</ul>\n<h3 id=\"2-2-字符串\"><a href=\"#2-2-字符串\" class=\"headerlink\" title=\"2.2 字符串\"></a>2.2 字符串</h3><p>C++中的字符串有两种：C-风格字符串和 <code>string</code> 类。</p>\n<ul>\n<li>C-风格字符串以<code>\\0</code>结尾</li>\n<li>任何两个由空白分割的字符串会自动拼接成一个</li>\n<li>C-风格字符串和 <code>string</code> 对象都可以使用列表初始化</li>\n<li><code>string</code> 可以使用 + += 等运算符，并可以直接将一个 <code>string</code> 对象赋给另一个 <code>string</code> 对象。</li>\n<li>进行行读取的时候，C-风格字符串使用 <code>cin.getline(str, 20)</code>，而 <code>string</code> 类使用 <code>getling(cin, str)</code>;</li>\n</ul>\n<p>字符串的输入:</p>\n<ul>\n<li><code>cin</code>使用空白（空格、制表符和换行符）来确定字符串结束的位置。</li>\n<li><code>getline()</code>通过回车键来确定输入结尾但不保存并丢弃回车符。</li>\n<li><code>get()</code>带参数通过回车键来确定输入结尾，但将回车符留在输入队列中。</li>\n<li><code>get()</code>不带参数读取一个字符。</li>\n<li>混合输入数字和字符的时候，<code>&lt;&lt;</code>读取数字后会把回车留在输入队列中。</li>\n</ul>\n<h3 id=\"2-3-结构、共用体、枚举\"><a href=\"#2-3-结构、共用体、枚举\" class=\"headerlink\" title=\"2.3 结构、共用体、枚举\"></a>2.3 结构、共用体、枚举</h3><ul>\n<li>C++中结构声明定义了一种新的类型，使用时可以省略 <code>struct</code>，但 C 中不行。</li>\n<li>C++允许指定占用特定位数的结构成员，可以使用没有名称的字段来提供间距。</li>\n<li>可以将一个结构赋给另一个结构</li>\n<li>枚举提供了一种创建符号常量的方式，可以替代<code>const</code>。</li>\n<li>枚举没有算术运算符</li>\n<li>枚举默认情况下第一个元素为0，后续累加</li>\n</ul>\n<h3 id=\"2-4-指针\"><a href=\"#2-4-指针\" class=\"headerlink\" title=\"2.4 指针\"></a>2.4 指针</h3><ul>\n<li>使用 <code>new</code> 来分配内存</li>\n<li>只能使用 <code>delete</code> 来释放使用 <code>new</code> 分配的内存</li>\n<li>使用 <code>new</code> 创建动态数组，需要使用 <code>delete[]</code> 来释放</li>\n<li>指针的其他使用方式和C指针一致</li>\n</ul>\n<h2 id=\"三、逻辑关系\"><a href=\"#三、逻辑关系\" class=\"headerlink\" title=\"三、逻辑关系\"></a>三、逻辑关系</h2><p>和C一样，C++的逻辑关系也有循环和分支两种，其中的注意点有：</p>\n<ul>\n<li>C++允许在循环中定义变量，且变量只在循环内有效。</li>\n<li>递增和递减使用前缀格式的效率更高</li>\n</ul>\n<h2 id=\"四、函数使用\"><a href=\"#四、函数使用\" class=\"headerlink\" title=\"四、函数使用\"></a>四、函数使用</h2><p>创建自己的函数，需要处理三个方面：</p>\n<ul>\n<li>提供函数定义</li>\n<li>提供函数原型</li>\n<li>调用函数</li>\n</ul>\n<h3 id=\"4-1-函数参数\"><a href=\"#4-1-函数参数\" class=\"headerlink\" title=\"4.1 函数参数\"></a>4.1 函数参数</h3><ul>\n<li>数组（当且仅当）作为参数使用，和指针含义一样</li>\n<li><code>const</code> 尽可能多的使用</li>\n<li>使用数组名和超尾作为参数，来表示一个数组</li>\n</ul>\n<h3 id=\"4-2-函数指针\"><a href=\"#4-2-函数指针\" class=\"headerlink\" title=\"4.2 函数指针\"></a>4.2 函数指针</h3><p>对于一个函数<code>double pam(int)</code><br>相应的函数指针定义为 <code>double (*pf)(int)</code><br>使用函数指针调用函数为 <code>double ret = (*pf)(5)</code> 或 <code>double ret pf(5)</code></p>\n<h3 id=\"4-3-内联函数\"><a href=\"#4-3-内联函数\" class=\"headerlink\" title=\"4.3 内联函数\"></a>4.3 内联函数</h3><p>内联函数运行速度稍快，但是占用内存较多<br>使用内联函数：</p>\n<ul>\n<li>在函数声明前加 <code>inline</code></li>\n<li>在函数定义前加 <code>inline</code></li>\n</ul>\n<h3 id=\"4-4-引用变量\"><a href=\"#4-4-引用变量\" class=\"headerlink\" title=\"4.4 引用变量\"></a>4.4 引用变量</h3><p>引用变量是已定义变量的别名。</p>\n<p>使用引用参数的原因：</p>\n<ul>\n<li>能够修改函数中的数据对象</li>\n<li>能够提高程序的运行速度</li>\n</ul>\n<p>使用时需要注意以下要点：</p>\n<ul>\n<li>必须在声明引用的同时初始化</li>\n<li>使用 <code>const</code> 进行常量引用，避免在函数中修改原有信息</li>\n<li>引用变量不能使用表达式传参</li>\n<li>引用参数是 <code>const</code> 的时候，在下面的两种情况下，将生成临时变量<ul>\n<li>实参的类型正确，但不是左值</li>\n<li>实参的类型不正确，但可以转换成正确的类型</li>\n</ul>\n</li>\n<li>返回引用类型能够提高效率</li>\n<li>不能返回指向临时变量的引用</li>\n<li>引用返回值可以作为左值，而常规返回值不能作为左值</li>\n<li><p>C++11允许右值引用（&amp;&amp;）<br>常见的函数参数的传递指导原则如下：</p>\n</li>\n<li><p>使用传递的值，不修改数据对象的函数：</p>\n<ul>\n<li>数据对象很小，使用值传递</li>\n<li>对象是数组，使用指针，并声明为 <code>const</code></li>\n<li>对象较大，使用 <code>const</code> 引用或 <code>const</code> 指针</li>\n</ul>\n</li>\n<li><p>对于修改数据对象的函数：</p>\n<ul>\n<li>对象是常规数据，使用指针</li>\n<li>对象是数组，使用指针</li>\n<li>对象是结构，使用指针或引用</li>\n<li>对象是类对象，使用引用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-默认参数\"><a href=\"#4-5-默认参数\" class=\"headerlink\" title=\"4.5 默认参数\"></a>4.5 默认参数</h3><p>默认参数是指当函数调用中省略了实参时自动使用的一个值。需要注意的点为：</p>\n<ul>\n<li>必须在原型中将可能的默认参数告知程序</li>\n<li>必须从右向左添加默认值</li>\n</ul>\n<h3 id=\"4-6-函数重载\"><a href=\"#4-6-函数重载\" class=\"headerlink\" title=\"4.6 函数重载\"></a>4.6 函数重载</h3><p>函数重载指可以有多个同名的函数，可以通过函数重载设计一系列的函数，他们完成相同的工作，但是使用不同的参数列表。</p>\n<ul>\n<li>重载引用参数时的最佳匹配：<ul>\n<li><code>void function(double &amp; arg)</code> 匹配：<br>可修改的左值参数（如 double变量），同时也是最优匹配</li>\n<li><code>void function(const double &amp; arg)</code> 匹配：<ul>\n<li>可修改的左值参数（如 double变量），</li>\n<li>不可修改的左值参数(如const double常量)，最佳匹配</li>\n<li>右值参数（如 double + double），</li>\n</ul>\n</li>\n<li><code>coid function(double &amp;&amp; arg)</code>匹配：<br>右值参数（如 double + double），同时也是最优匹配</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-7-函数模板\"><a href=\"#4-7-函数模板\" class=\"headerlink\" title=\"4.7 函数模板\"></a>4.7 函数模板</h3><p>函数模板是通用的函数描述，它们使用泛型来定义函数，其中的泛型可以使用具体的类型替换。<br>建立函数模板的方式为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> AnyType&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(AnyType a, AnyType b)</span></span></div></pre></td></tr></table></figure></p>\n<ul>\n<li>显式具体化<ul>\n<li>对于给定的函数名，可以有非模板函数、模板函数、和显式具体化函数以及它们的重载版本</li>\n<li>显式具体化的原型和定义应以 <code>template&lt;&gt;</code> 开头，并通过名称来指定类型</li>\n<li>具体化优先于常规模板。</li>\n</ul>\n</li>\n<li>显式实例化：<ul>\n<li>显式实例化命令编译器创建特定的实例</li>\n<li>显式实例化不能和显式具体化共存</li>\n<li>显式实例化可以将参数强制转换为相应的类型</li>\n</ul>\n</li>\n</ul>\n<p>相应的代码示例为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//非模板函数：</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(type a)</span></span>;</div><div class=\"line\"><span class=\"comment\">//模板函数：</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(T a)</span></span>;</div><div class=\"line\"><span class=\"comment\">//显式具体化函数</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;&gt; function&lt;type&gt;(type a);</div><div class=\"line\"><span class=\"comment\">//显式实例化</span></div><div class=\"line\"><span class=\"keyword\">template</span> function&lt;type&gt;(type a)</div></pre></td></tr></table></figure></p>\n<p>编译器选择函数版本的流程为：</p>\n<ol>\n<li>创建候选列表<br>所有函数名相同的模板和函数</li>\n<li>创建可行函数列表<br>所有参数匹配的函数</li>\n<li>选择最佳函数<ul>\n<li>完全匹配 常规函数优先于模板</li>\n<li>提升转换  char -&gt; int   float -&gt; double</li>\n<li>标准转换 int -&gt; char double -&gt; float</li>\n<li>定义转换</li>\n</ul>\n</li>\n</ol>\n<p>针对无法确定的参数类型，C++11定义了关键字 <code>decltype</code></p>\n<ul>\n<li>使用方法为： <code>decltype (ecpression) var</code><ul>\n<li><code>ecpression</code> 为标识符<br>var类型为标识符类型</li>\n<li><code>ecpression</code> 为函数调用<br>var类型为函数返回值类型</li>\n<li><code>ecpression</code> 为左值<br>var类型为指向类型的引用类型</li>\n<li><code>ecpression</code> 为什么都不是<br>var类型为experssion的类型</li>\n</ul>\n</li>\n</ul>\n<p>同时针对返回值的类型，C++新增了后置返回类型<br><code>auto function(int a) -&gt;double;</code></p>\n<h2 id=\"五、内存空间\"><a href=\"#五、内存空间\" class=\"headerlink\" title=\"五、内存空间\"></a>五、内存空间</h2><h3 id=\"5-1-文件结构\"><a href=\"#5-1-文件结构\" class=\"headerlink\" title=\"5.1 文件结构\"></a>5.1 文件结构</h3><p>程序可以分为三个部分：</p>\n<ul>\n<li>头文件：包含结构声明和使用这些结构的函数的原型，主要包括：<ul>\n<li>函数原型</li>\n<li>符号常量</li>\n<li>结构声明</li>\n<li>类声明</li>\n<li>模板声明</li>\n<li>内联函数</li>\n</ul>\n</li>\n<li>源代码文件：包含与结构相关的函数的代码<ul>\n<li>实现相关函数代码</li>\n</ul>\n</li>\n<li>源代码文件：包含调用与结构相关的函数的代码<ul>\n<li>业务逻辑调用相关函数代码</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-存储持续性\"><a href=\"#5-2-存储持续性\" class=\"headerlink\" title=\"5.2 存储持续性\"></a>5.2 存储持续性</h3><p>C++使用三种不同的方式来存储数据：</p>\n<ul>\n<li>自动存储<ul>\n<li>存储时间:函数存在时</li>\n<li>作用域为:局部</li>\n<li>链接性为:无</li>\n<li>内存区域:栈(后进先出)</li>\n</ul>\n</li>\n<li>静态存储<ul>\n<li>存储时间:整个程序运行时间</li>\n<li>作用域为:局部或全局</li>\n<li>链接性为:三种<ul>\n<li>外部链接性——全局变量，可以在一个文件中定义全局变量,其他文件使用extern声明</li>\n<li>内部链接性——使用static修饰的全局变量</li>\n<li>无链接性——使用static修饰的局部变量</li>\n</ul>\n</li>\n<li>内存区域:静态区域</li>\n</ul>\n</li>\n<li>动态存储<ul>\n<li>存储时间:new 分配的内存持续存在直至使用delete删除</li>\n<li>作用域为:使用地址均可以访问</li>\n<li>链接性为:使用地址访问</li>\n<li>内存区域:堆</li>\n</ul>\n</li>\n<li>线程存储(C++11)<ul>\n<li>存储时间为线程周期</li>\n</ul>\n</li>\n</ul>"},{"title":"C语言学习总结（一）——开篇","date":"2016-11-18T05:18:04.000Z","_content":" 怎么去开始这个话题，我想从C语言的特性说起，其实，在刚刚开始进入嵌入式领域的时候，我就经常在想，为什么是C语言?\n<!--more-->\n \n![C语言知识脑图](http://img.blog.csdn.net/20161020212351257)\n- **C语言的独特性在哪里？**\n\n我已经听过太多关于*“C语言可以操作底层”，“C语言的指针是其它语言所不具备的”，“C语言是操作系统的唯一选择”*诸如此般的论调。但是，随着我对学习的深入，尤其是当涉及到Linux驱动的学习后，发现林纳斯他们很多时候用C语言去实现一些面向对象编程的思想。为什么会这样？\n\n- **C语言的局限性又在哪里？**\n\n个人的观点是：\n\n- **C语言的指针的设置可以让C语言方便的操作物理内存地址，所以更方便硬件操作；**\n- **C语言的语法设置和冯诺依曼体系架构很切合，容易模拟计算机的硬件操作。**\n- **很简单，因为之前的操作系统是用C写的。。。**\n\n当然这只是开篇的一些啰嗦，虽然对这个话题有很多的想法，但是的确，以我目前的开发经历还不足以解释这个问题，不再纠结这个问题，我们来看看C语言有什么：\n\n\n1. 首先是 GCC的学习，学习了如何开始一个C程序，及从程序到可执行文件的过程\n2. 其次是C的基本语法，从关键字，运算符，到指针、函数等的高级使用\n3. 然后学习了数据结构：顺序表、链表、栈、队列等\n4. 最后，是一些库函数，主要是总结了标准C库中支持的一些接口。\n","source":"_posts/C语言学习总结（一）-开篇.md","raw":"---\ntitle: C语言学习总结（一）——开篇\ndate: 2016-11-18 13:18:04\ncategories: C语言学习总结\ntags: C语言 \n---\n 怎么去开始这个话题，我想从C语言的特性说起，其实，在刚刚开始进入嵌入式领域的时候，我就经常在想，为什么是C语言?\n<!--more-->\n \n![C语言知识脑图](http://img.blog.csdn.net/20161020212351257)\n- **C语言的独特性在哪里？**\n\n我已经听过太多关于*“C语言可以操作底层”，“C语言的指针是其它语言所不具备的”，“C语言是操作系统的唯一选择”*诸如此般的论调。但是，随着我对学习的深入，尤其是当涉及到Linux驱动的学习后，发现林纳斯他们很多时候用C语言去实现一些面向对象编程的思想。为什么会这样？\n\n- **C语言的局限性又在哪里？**\n\n个人的观点是：\n\n- **C语言的指针的设置可以让C语言方便的操作物理内存地址，所以更方便硬件操作；**\n- **C语言的语法设置和冯诺依曼体系架构很切合，容易模拟计算机的硬件操作。**\n- **很简单，因为之前的操作系统是用C写的。。。**\n\n当然这只是开篇的一些啰嗦，虽然对这个话题有很多的想法，但是的确，以我目前的开发经历还不足以解释这个问题，不再纠结这个问题，我们来看看C语言有什么：\n\n\n1. 首先是 GCC的学习，学习了如何开始一个C程序，及从程序到可执行文件的过程\n2. 其次是C的基本语法，从关键字，运算符，到指针、函数等的高级使用\n3. 然后学习了数据结构：顺序表、链表、栈、队列等\n4. 最后，是一些库函数，主要是总结了标准C库中支持的一些接口。\n","slug":"C语言学习总结（一）-开篇","published":1,"updated":"2017-12-06T13:35:12.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9mzr0008bkw1hiil316a","content":"<p> 怎么去开始这个话题，我想从C语言的特性说起，其实，在刚刚开始进入嵌入式领域的时候，我就经常在想，为什么是C语言?<br><a id=\"more\"></a></p>\n<p><img src=\"http://img.blog.csdn.net/20161020212351257\" alt=\"C语言知识脑图\"></p>\n<ul>\n<li><strong>C语言的独特性在哪里？</strong></li>\n</ul>\n<p>我已经听过太多关于<em>“C语言可以操作底层”，“C语言的指针是其它语言所不具备的”，“C语言是操作系统的唯一选择”</em>诸如此般的论调。但是，随着我对学习的深入，尤其是当涉及到Linux驱动的学习后，发现林纳斯他们很多时候用C语言去实现一些面向对象编程的思想。为什么会这样？</p>\n<ul>\n<li><strong>C语言的局限性又在哪里？</strong></li>\n</ul>\n<p>个人的观点是：</p>\n<ul>\n<li><strong>C语言的指针的设置可以让C语言方便的操作物理内存地址，所以更方便硬件操作；</strong></li>\n<li><strong>C语言的语法设置和冯诺依曼体系架构很切合，容易模拟计算机的硬件操作。</strong></li>\n<li><strong>很简单，因为之前的操作系统是用C写的。。。</strong></li>\n</ul>\n<p>当然这只是开篇的一些啰嗦，虽然对这个话题有很多的想法，但是的确，以我目前的开发经历还不足以解释这个问题，不再纠结这个问题，我们来看看C语言有什么：</p>\n<ol>\n<li>首先是 GCC的学习，学习了如何开始一个C程序，及从程序到可执行文件的过程</li>\n<li>其次是C的基本语法，从关键字，运算符，到指针、函数等的高级使用</li>\n<li>然后学习了数据结构：顺序表、链表、栈、队列等</li>\n<li>最后，是一些库函数，主要是总结了标准C库中支持的一些接口。</li>\n</ol>\n","excerpt":"<p> 怎么去开始这个话题，我想从C语言的特性说起，其实，在刚刚开始进入嵌入式领域的时候，我就经常在想，为什么是C语言?<br>","more":"</p>\n<p><img src=\"http://img.blog.csdn.net/20161020212351257\" alt=\"C语言知识脑图\"></p>\n<ul>\n<li><strong>C语言的独特性在哪里？</strong></li>\n</ul>\n<p>我已经听过太多关于<em>“C语言可以操作底层”，“C语言的指针是其它语言所不具备的”，“C语言是操作系统的唯一选择”</em>诸如此般的论调。但是，随着我对学习的深入，尤其是当涉及到Linux驱动的学习后，发现林纳斯他们很多时候用C语言去实现一些面向对象编程的思想。为什么会这样？</p>\n<ul>\n<li><strong>C语言的局限性又在哪里？</strong></li>\n</ul>\n<p>个人的观点是：</p>\n<ul>\n<li><strong>C语言的指针的设置可以让C语言方便的操作物理内存地址，所以更方便硬件操作；</strong></li>\n<li><strong>C语言的语法设置和冯诺依曼体系架构很切合，容易模拟计算机的硬件操作。</strong></li>\n<li><strong>很简单，因为之前的操作系统是用C写的。。。</strong></li>\n</ul>\n<p>当然这只是开篇的一些啰嗦，虽然对这个话题有很多的想法，但是的确，以我目前的开发经历还不足以解释这个问题，不再纠结这个问题，我们来看看C语言有什么：</p>\n<ol>\n<li>首先是 GCC的学习，学习了如何开始一个C程序，及从程序到可执行文件的过程</li>\n<li>其次是C的基本语法，从关键字，运算符，到指针、函数等的高级使用</li>\n<li>然后学习了数据结构：顺序表、链表、栈、队列等</li>\n<li>最后，是一些库函数，主要是总结了标准C库中支持的一些接口。</li>\n</ol>"},{"title":"C++ string、char *和int的转换","date":"2017-02-28T01:52:26.000Z","_content":"工作中多次遇到 `string` `char *` 和 `int` 类型的互相转换，现在把自己掌握的相关转换方法记录在这里。\n<!--more-->\n## 一、`int` 类型转换其它类型\n### 1.1 `int` 转 `char *`\n\n* 第一种方法：使用 `itoa()` 函数\n 这个很简单，但是不幸的是这并不是一个标准函数。\n\n* 第二种方法：利用 ASCII 码进行转换\n  这个需要自己编写相应的转换函数：\n  ````C \n  const char* intToChar(char* buf, int m)\n  {\n    char temp[16];      //建立存储的空间,32位系统最大值为2147483647，所以不会超过16位。\n    int isNegtive = 0;  //设置正负值\n    int index;          //保存相应的位数\n    if (m < 0)\n    {\n        isNegtive = 1;\n        m = -m;\n    }                    //判断正负值\n    tmp[15] = '\\0';      //字符串尾部为0\n    index = 14;\n    do \n    {\n        tmp[index--] = m % 10 + '0';\n        m /= 10;\n    } while (m > 0);     //依次取出int的每一位。\n    if(isNegtive)\n        tmp[index--] = '-'; //加相应的符号\n    strcpy(buf, tmp + index + 1);  //拷贝\n    return buf;\n  }````\n\n* 第三种方法：使用spritf()\n  这种方法最简单，也最普遍使用。\n  ````C\n  #include <stdio.h>\n  int sprintf( char *buffer, const char *format, [ argument] … );````\n  实例：\n  ````C\n  char buff[16];\n  int m = 1234;\n  sprintf(buff, \"%d\", m);````\n\n### 1.2 `int` 转 `string`\n\n* 第一种方法：使用 `to_string()`\n  这个函数使用很方便，但是是 C++11 加入的。\n* 第二种方法：使用 `sstream`\n  这种方式也很方便，但是对格式的控制上不是那么严格，示例代码如下：\n  ````C\n  #include <sstream>\n  #include <string>\n  using namespace std;\n  string intToString(int ss)\n  {\n    string str;\n    stringstream st;\n    st << ss;\n    st >> str;\n    return str;\n  }````\n\n## 二、`char *` 类型转换为其它类型\n### 2.1 `char *` 转 `int`\n\n* 第一种方法：使用 `atoi()` 函数\n  和上面说的 `itoa()` 不同，这个函数是C库中的标准函数，所以，可以正常使用。\n  ````C\n  #include <stdlib.h>\n  int atoi(const char *nptr);````\n* 第二种方法：使用 ASCII码转换\n  和上述类似，但是想必没有人在实际工程中这么做吧\n* 第三种方法：使用 `sscanf()` 函数\n  ````C\n  #include <stdio.h>\n  int sscanf(const char *buffer,const char *format,[argument ]...);````\n\n### 2.2 `char *` 转 `string`\n这个很简单，C风格字符串可以直接赋值给string类型。\n\n## 三、`string` 类型转换为其它类型\n\n### 3.1 `string` 类型转换为 `int` 类型\n\n* 使用 `sstream`\n  和上面的 `int` 转 `string` 类似，也可以相应转换。\n* 使用 `stoi`\n  这个函数和 `to_string` 类似，也是 C++11 独有的。\n\n### 3.2 `string` 类型转换为 `char *` 类型\n\n* 使用 `data()` 函数\n* 使用 `c_str()` 函数\n上述两个函数使用方法类似，需要注意两个函数返回的类型是`const char *`的，另外，相应的字符数组中的内容是会随着 `string` 调用其它方法改变的。\n* 使用 `copy()` 函数\n\n## 四、总结\n上述分别讲了相应的直接转换，但是使用过程中很多情况下我们会使用 `char *` 作为中间量，来进行 `string` 和 `int` 的转换，同时 `ssprintf` 和 `sscanf` 是最推荐使用的。\n","source":"_posts/C-整形和字符串的转换.md","raw":"---\ntitle: C++ string、char *和int的转换\ndate: 2017-02-28 09:52:26\ncategories: 工作总结\ntags: [string, int, char *, 类型转换]\n---\n工作中多次遇到 `string` `char *` 和 `int` 类型的互相转换，现在把自己掌握的相关转换方法记录在这里。\n<!--more-->\n## 一、`int` 类型转换其它类型\n### 1.1 `int` 转 `char *`\n\n* 第一种方法：使用 `itoa()` 函数\n 这个很简单，但是不幸的是这并不是一个标准函数。\n\n* 第二种方法：利用 ASCII 码进行转换\n  这个需要自己编写相应的转换函数：\n  ````C \n  const char* intToChar(char* buf, int m)\n  {\n    char temp[16];      //建立存储的空间,32位系统最大值为2147483647，所以不会超过16位。\n    int isNegtive = 0;  //设置正负值\n    int index;          //保存相应的位数\n    if (m < 0)\n    {\n        isNegtive = 1;\n        m = -m;\n    }                    //判断正负值\n    tmp[15] = '\\0';      //字符串尾部为0\n    index = 14;\n    do \n    {\n        tmp[index--] = m % 10 + '0';\n        m /= 10;\n    } while (m > 0);     //依次取出int的每一位。\n    if(isNegtive)\n        tmp[index--] = '-'; //加相应的符号\n    strcpy(buf, tmp + index + 1);  //拷贝\n    return buf;\n  }````\n\n* 第三种方法：使用spritf()\n  这种方法最简单，也最普遍使用。\n  ````C\n  #include <stdio.h>\n  int sprintf( char *buffer, const char *format, [ argument] … );````\n  实例：\n  ````C\n  char buff[16];\n  int m = 1234;\n  sprintf(buff, \"%d\", m);````\n\n### 1.2 `int` 转 `string`\n\n* 第一种方法：使用 `to_string()`\n  这个函数使用很方便，但是是 C++11 加入的。\n* 第二种方法：使用 `sstream`\n  这种方式也很方便，但是对格式的控制上不是那么严格，示例代码如下：\n  ````C\n  #include <sstream>\n  #include <string>\n  using namespace std;\n  string intToString(int ss)\n  {\n    string str;\n    stringstream st;\n    st << ss;\n    st >> str;\n    return str;\n  }````\n\n## 二、`char *` 类型转换为其它类型\n### 2.1 `char *` 转 `int`\n\n* 第一种方法：使用 `atoi()` 函数\n  和上面说的 `itoa()` 不同，这个函数是C库中的标准函数，所以，可以正常使用。\n  ````C\n  #include <stdlib.h>\n  int atoi(const char *nptr);````\n* 第二种方法：使用 ASCII码转换\n  和上述类似，但是想必没有人在实际工程中这么做吧\n* 第三种方法：使用 `sscanf()` 函数\n  ````C\n  #include <stdio.h>\n  int sscanf(const char *buffer,const char *format,[argument ]...);````\n\n### 2.2 `char *` 转 `string`\n这个很简单，C风格字符串可以直接赋值给string类型。\n\n## 三、`string` 类型转换为其它类型\n\n### 3.1 `string` 类型转换为 `int` 类型\n\n* 使用 `sstream`\n  和上面的 `int` 转 `string` 类似，也可以相应转换。\n* 使用 `stoi`\n  这个函数和 `to_string` 类似，也是 C++11 独有的。\n\n### 3.2 `string` 类型转换为 `char *` 类型\n\n* 使用 `data()` 函数\n* 使用 `c_str()` 函数\n上述两个函数使用方法类似，需要注意两个函数返回的类型是`const char *`的，另外，相应的字符数组中的内容是会随着 `string` 调用其它方法改变的。\n* 使用 `copy()` 函数\n\n## 四、总结\n上述分别讲了相应的直接转换，但是使用过程中很多情况下我们会使用 `char *` 作为中间量，来进行 `string` 和 `int` 的转换，同时 `ssprintf` 和 `sscanf` 是最推荐使用的。\n","slug":"C-整形和字符串的转换","published":1,"updated":"2017-02-28T02:48:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9mzw000cbkw1ouzatoxn","content":"<p>工作中多次遇到 <code>string</code> <code>char *</code> 和 <code>int</code> 类型的互相转换，现在把自己掌握的相关转换方法记录在这里。<br><a id=\"more\"></a></p>\n<h2 id=\"一、int-类型转换其它类型\"><a href=\"#一、int-类型转换其它类型\" class=\"headerlink\" title=\"一、int 类型转换其它类型\"></a>一、<code>int</code> 类型转换其它类型</h2><h3 id=\"1-1-int-转-char\"><a href=\"#1-1-int-转-char\" class=\"headerlink\" title=\"1.1 int 转 char *\"></a>1.1 <code>int</code> 转 <code>char *</code></h3><ul>\n<li><p>第一种方法：使用 <code>itoa()</code> 函数<br>这个很简单，但是不幸的是这并不是一个标准函数。</p>\n</li>\n<li><p>第二种方法：利用 ASCII 码进行转换<br>这个需要自己编写相应的转换函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">intToChar</span><span class=\"params\">(<span class=\"keyword\">char</span>* buf, <span class=\"keyword\">int</span> m)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> temp[<span class=\"number\">16</span>];      <span class=\"comment\">//建立存储的空间,32位系统最大值为2147483647，所以不会超过16位。</span></div><div class=\"line\">  <span class=\"keyword\">int</span> isNegtive = <span class=\"number\">0</span>;  <span class=\"comment\">//设置正负值</span></div><div class=\"line\">  <span class=\"keyword\">int</span> index;          <span class=\"comment\">//保存相应的位数</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (m &lt; <span class=\"number\">0</span>)</div><div class=\"line\">  &#123;</div><div class=\"line\">      isNegtive = <span class=\"number\">1</span>;</div><div class=\"line\">      m = -m;</div><div class=\"line\">  &#125;                    <span class=\"comment\">//判断正负值</span></div><div class=\"line\">  tmp[<span class=\"number\">15</span>] = <span class=\"string\">'\\0'</span>;      <span class=\"comment\">//字符串尾部为0</span></div><div class=\"line\">  index = <span class=\"number\">14</span>;</div><div class=\"line\">  <span class=\"keyword\">do</span> </div><div class=\"line\">  &#123;</div><div class=\"line\">      tmp[index--] = m % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>;</div><div class=\"line\">      m /= <span class=\"number\">10</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span>);     <span class=\"comment\">//依次取出int的每一位。</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(isNegtive)</div><div class=\"line\">      tmp[index--] = <span class=\"string\">'-'</span>; <span class=\"comment\">//加相应的符号</span></div><div class=\"line\">  <span class=\"built_in\">strcpy</span>(buf, tmp + index + <span class=\"number\">1</span>);  <span class=\"comment\">//拷贝</span></div><div class=\"line\">  <span class=\"keyword\">return</span> buf;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>第三种方法：使用spritf()<br>这种方法最简单，也最普遍使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sprintf</span><span class=\"params\">( <span class=\"keyword\">char</span> *buffer, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format, [ argument] … )</span></span>;</div></pre></td></tr></table></figure>\n<p>实例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> buff[<span class=\"number\">16</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> m = <span class=\"number\">1234</span>;</div><div class=\"line\"><span class=\"built_in\">sprintf</span>(buff, <span class=\"string\">\"%d\"</span>, m);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"1-2-int-转-string\"><a href=\"#1-2-int-转-string\" class=\"headerlink\" title=\"1.2 int 转 string\"></a>1.2 <code>int</code> 转 <code>string</code></h3><ul>\n<li>第一种方法：使用 <code>to_string()</code><br>这个函数使用很方便，但是是 C++11 加入的。</li>\n<li>第二种方法：使用 <code>sstream</code><br>这种方式也很方便，但是对格式的控制上不是那么严格，示例代码如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">intToString</span><span class=\"params\">(<span class=\"keyword\">int</span> ss)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">string</span> str;</div><div class=\"line\">  <span class=\"built_in\">stringstream</span> st;</div><div class=\"line\">  st &lt;&lt; ss;</div><div class=\"line\">  st &gt;&gt; str;</div><div class=\"line\">  <span class=\"keyword\">return</span> str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二、char-类型转换为其它类型\"><a href=\"#二、char-类型转换为其它类型\" class=\"headerlink\" title=\"二、char * 类型转换为其它类型\"></a>二、<code>char *</code> 类型转换为其它类型</h2><h3 id=\"2-1-char-转-int\"><a href=\"#2-1-char-转-int\" class=\"headerlink\" title=\"2.1 char * 转 int\"></a>2.1 <code>char *</code> 转 <code>int</code></h3><ul>\n<li><p>第一种方法：使用 <code>atoi()</code> 函数<br>和上面说的 <code>itoa()</code> 不同，这个函数是C库中的标准函数，所以，可以正常使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atoi</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *nptr)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>第二种方法：使用 ASCII码转换<br>和上述类似，但是想必没有人在实际工程中这么做吧</p>\n</li>\n<li>第三种方法：使用 <code>sscanf()</code> 函数<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sscanf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buffer,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format,[argument ]...)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-2-char-转-string\"><a href=\"#2-2-char-转-string\" class=\"headerlink\" title=\"2.2 char * 转 string\"></a>2.2 <code>char *</code> 转 <code>string</code></h3><p>这个很简单，C风格字符串可以直接赋值给string类型。</p>\n<h2 id=\"三、string-类型转换为其它类型\"><a href=\"#三、string-类型转换为其它类型\" class=\"headerlink\" title=\"三、string 类型转换为其它类型\"></a>三、<code>string</code> 类型转换为其它类型</h2><h3 id=\"3-1-string-类型转换为-int-类型\"><a href=\"#3-1-string-类型转换为-int-类型\" class=\"headerlink\" title=\"3.1 string 类型转换为 int 类型\"></a>3.1 <code>string</code> 类型转换为 <code>int</code> 类型</h3><ul>\n<li>使用 <code>sstream</code><br>和上面的 <code>int</code> 转 <code>string</code> 类似，也可以相应转换。</li>\n<li>使用 <code>stoi</code><br>这个函数和 <code>to_string</code> 类似，也是 C++11 独有的。</li>\n</ul>\n<h3 id=\"3-2-string-类型转换为-char-类型\"><a href=\"#3-2-string-类型转换为-char-类型\" class=\"headerlink\" title=\"3.2 string 类型转换为 char * 类型\"></a>3.2 <code>string</code> 类型转换为 <code>char *</code> 类型</h3><ul>\n<li>使用 <code>data()</code> 函数</li>\n<li>使用 <code>c_str()</code> 函数<br>上述两个函数使用方法类似，需要注意两个函数返回的类型是<code>const char *</code>的，另外，相应的字符数组中的内容是会随着 <code>string</code> 调用其它方法改变的。</li>\n<li>使用 <code>copy()</code> 函数</li>\n</ul>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>上述分别讲了相应的直接转换，但是使用过程中很多情况下我们会使用 <code>char *</code> 作为中间量，来进行 <code>string</code> 和 <code>int</code> 的转换，同时 <code>ssprintf</code> 和 <code>sscanf</code> 是最推荐使用的。</p>\n","excerpt":"<p>工作中多次遇到 <code>string</code> <code>char *</code> 和 <code>int</code> 类型的互相转换，现在把自己掌握的相关转换方法记录在这里。<br>","more":"</p>\n<h2 id=\"一、int-类型转换其它类型\"><a href=\"#一、int-类型转换其它类型\" class=\"headerlink\" title=\"一、int 类型转换其它类型\"></a>一、<code>int</code> 类型转换其它类型</h2><h3 id=\"1-1-int-转-char\"><a href=\"#1-1-int-转-char\" class=\"headerlink\" title=\"1.1 int 转 char *\"></a>1.1 <code>int</code> 转 <code>char *</code></h3><ul>\n<li><p>第一种方法：使用 <code>itoa()</code> 函数<br>这个很简单，但是不幸的是这并不是一个标准函数。</p>\n</li>\n<li><p>第二种方法：利用 ASCII 码进行转换<br>这个需要自己编写相应的转换函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">intToChar</span><span class=\"params\">(<span class=\"keyword\">char</span>* buf, <span class=\"keyword\">int</span> m)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> temp[<span class=\"number\">16</span>];      <span class=\"comment\">//建立存储的空间,32位系统最大值为2147483647，所以不会超过16位。</span></div><div class=\"line\">  <span class=\"keyword\">int</span> isNegtive = <span class=\"number\">0</span>;  <span class=\"comment\">//设置正负值</span></div><div class=\"line\">  <span class=\"keyword\">int</span> index;          <span class=\"comment\">//保存相应的位数</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (m &lt; <span class=\"number\">0</span>)</div><div class=\"line\">  &#123;</div><div class=\"line\">      isNegtive = <span class=\"number\">1</span>;</div><div class=\"line\">      m = -m;</div><div class=\"line\">  &#125;                    <span class=\"comment\">//判断正负值</span></div><div class=\"line\">  tmp[<span class=\"number\">15</span>] = <span class=\"string\">'\\0'</span>;      <span class=\"comment\">//字符串尾部为0</span></div><div class=\"line\">  index = <span class=\"number\">14</span>;</div><div class=\"line\">  <span class=\"keyword\">do</span> </div><div class=\"line\">  &#123;</div><div class=\"line\">      tmp[index--] = m % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>;</div><div class=\"line\">      m /= <span class=\"number\">10</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span>);     <span class=\"comment\">//依次取出int的每一位。</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(isNegtive)</div><div class=\"line\">      tmp[index--] = <span class=\"string\">'-'</span>; <span class=\"comment\">//加相应的符号</span></div><div class=\"line\">  <span class=\"built_in\">strcpy</span>(buf, tmp + index + <span class=\"number\">1</span>);  <span class=\"comment\">//拷贝</span></div><div class=\"line\">  <span class=\"keyword\">return</span> buf;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>第三种方法：使用spritf()<br>这种方法最简单，也最普遍使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sprintf</span><span class=\"params\">( <span class=\"keyword\">char</span> *buffer, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format, [ argument] … )</span></span>;</div></pre></td></tr></table></figure>\n<p>实例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> buff[<span class=\"number\">16</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> m = <span class=\"number\">1234</span>;</div><div class=\"line\"><span class=\"built_in\">sprintf</span>(buff, <span class=\"string\">\"%d\"</span>, m);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"1-2-int-转-string\"><a href=\"#1-2-int-转-string\" class=\"headerlink\" title=\"1.2 int 转 string\"></a>1.2 <code>int</code> 转 <code>string</code></h3><ul>\n<li>第一种方法：使用 <code>to_string()</code><br>这个函数使用很方便，但是是 C++11 加入的。</li>\n<li>第二种方法：使用 <code>sstream</code><br>这种方式也很方便，但是对格式的控制上不是那么严格，示例代码如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">intToString</span><span class=\"params\">(<span class=\"keyword\">int</span> ss)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">  <span class=\"built_in\">string</span> str;</div><div class=\"line\">  <span class=\"built_in\">stringstream</span> st;</div><div class=\"line\">  st &lt;&lt; ss;</div><div class=\"line\">  st &gt;&gt; str;</div><div class=\"line\">  <span class=\"keyword\">return</span> str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二、char-类型转换为其它类型\"><a href=\"#二、char-类型转换为其它类型\" class=\"headerlink\" title=\"二、char * 类型转换为其它类型\"></a>二、<code>char *</code> 类型转换为其它类型</h2><h3 id=\"2-1-char-转-int\"><a href=\"#2-1-char-转-int\" class=\"headerlink\" title=\"2.1 char * 转 int\"></a>2.1 <code>char *</code> 转 <code>int</code></h3><ul>\n<li><p>第一种方法：使用 <code>atoi()</code> 函数<br>和上面说的 <code>itoa()</code> 不同，这个函数是C库中的标准函数，所以，可以正常使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atoi</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *nptr)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>第二种方法：使用 ASCII码转换<br>和上述类似，但是想必没有人在实际工程中这么做吧</p>\n</li>\n<li>第三种方法：使用 <code>sscanf()</code> 函数<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sscanf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buffer,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *format,[argument ]...)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-2-char-转-string\"><a href=\"#2-2-char-转-string\" class=\"headerlink\" title=\"2.2 char * 转 string\"></a>2.2 <code>char *</code> 转 <code>string</code></h3><p>这个很简单，C风格字符串可以直接赋值给string类型。</p>\n<h2 id=\"三、string-类型转换为其它类型\"><a href=\"#三、string-类型转换为其它类型\" class=\"headerlink\" title=\"三、string 类型转换为其它类型\"></a>三、<code>string</code> 类型转换为其它类型</h2><h3 id=\"3-1-string-类型转换为-int-类型\"><a href=\"#3-1-string-类型转换为-int-类型\" class=\"headerlink\" title=\"3.1 string 类型转换为 int 类型\"></a>3.1 <code>string</code> 类型转换为 <code>int</code> 类型</h3><ul>\n<li>使用 <code>sstream</code><br>和上面的 <code>int</code> 转 <code>string</code> 类似，也可以相应转换。</li>\n<li>使用 <code>stoi</code><br>这个函数和 <code>to_string</code> 类似，也是 C++11 独有的。</li>\n</ul>\n<h3 id=\"3-2-string-类型转换为-char-类型\"><a href=\"#3-2-string-类型转换为-char-类型\" class=\"headerlink\" title=\"3.2 string 类型转换为 char * 类型\"></a>3.2 <code>string</code> 类型转换为 <code>char *</code> 类型</h3><ul>\n<li>使用 <code>data()</code> 函数</li>\n<li>使用 <code>c_str()</code> 函数<br>上述两个函数使用方法类似，需要注意两个函数返回的类型是<code>const char *</code>的，另外，相应的字符数组中的内容是会随着 <code>string</code> 调用其它方法改变的。</li>\n<li>使用 <code>copy()</code> 函数</li>\n</ul>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>上述分别讲了相应的直接转换，但是使用过程中很多情况下我们会使用 <code>char *</code> 作为中间量，来进行 <code>string</code> 和 <code>int</code> 的转换，同时 <code>ssprintf</code> 和 <code>sscanf</code> 是最推荐使用的。</p>"},{"title":"C语言学习总结（三）——C语言的基本语法","date":"2016-11-21T07:38:03.000Z","_content":"\n我喜欢从关键字开始构建自己心中一门编程语言的轮廓，今天主要总结下C语言的关键字。\n<!--more-->\n# 一、C语言的关键字\nC语言的关键字是一些编译器预先定义的具有一定具体含义的字符串。关键字共有32个，分为五大类：\n## 1. 基本数据类型——（9个）\n\n|关键字|含义|\n|---------|-----|\n|char|\t软件操作的最小数据单元\t8bit|\n|int\t|系统单周期最大数据处理单元\t32bit/64bit\n|short\t|特殊长度的限制符（不能大于int）\t通常16bit\n|long\t|特殊长度的限制符（不能小于int）\t通常32bit\n|float\t|浮点型数据，带小数点\t通常32bit\n|double\t|浮点型数据，带小数点\t通常64bit\n|void\t|空类型\t\n|signed\t|带符号类型，用作数值\t\n|unsigned\t|不带符号，用作内存\t\n### 原码/补码/反码\n**机器数**\n\n\t一个数在计算机中的二进制表示形式带符号，正数为0, 负数为1，叫做这个数的机器数\n\t例：十进制中的数 +3 ，机器数是00000011。-3 ，机器数是 10000011 \n\t\n**真值**\n\n\t带符号位的机器数对应的真正数值称为机器数的真值。\n\t例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1\n\t\n**原码**\n\n\t原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。\n\n**反码**\n\n\t正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n\n**补码**\n\t\n\t正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\n\n**为什么会有原码反码补码？**\n计算机无法判断符号（硬件难于实现），因此使用符号位参与运算。\n\n* 首先来看原码:\n计算十进制的表达式: `1-1=0`\n          1 - 1 \n        = 1 + (-1) \n        = [00000001]原 + [10000001]原 \n        = [10000010]原 \n        = -2\t`\t\n如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是**不正确的**。\n* 为了解决原码做减法的问题, 出现了反码:\n计算十进制的表达式: `1-1=0`\n          1 - 1 \n        = 1 + (-1) \n        = [0000 0001]原 + [1000 0001]原\n        = [0000 0001]反 + [1111 1110]反 \n        = [1111 1111]反 = [1000 0000]原 \n        = -0\n会有[0000 0000]原和[1000 0000]原两个编码表示0.\n* 于是补码的出现, 解决了0的符号以及两个编码的问题:\n          1-1 = 1 + (-1) \n        = [0000 0001]原 + [1000 0001]原 \n        = [0000 0001]补 + [1111 1111]补 \n        = [0000 0000]补\n        =[0000 0000]原\n这样**0用[0000 0000]表示**, 而以前出现问题的-0则不存在了.而且可以用**[1000 0000]表示-128**。\n\n### ASCII码表\n\n|Bin\t|Dec\t|Hex\t|缩写/字符|\t解释|\n|----|---------|--|-------|-----|\n|0000 0000|\t0\t|00\t|NUL(null)\t|空字符|\t\t\n|0000 1000|\t8\t|08\t|BS (backspace)\t|退格\n|0000 1001|\t9\t|09\t|HT (horizontal tab)\t|水平制表符\n|0000 1010|\t10\t|0A\t|LF (NL line feed, new line)\t|换行键\n|0000 1101|\t13\t|0D\t|CR (carriage return)\t|回车键\t\t\n|0010 0000|\t32\t|20\t|(space)\t|空格\t\t\n|00110000|\t48-57|\t30-39|\t0-9|\t数字\t\t\n|01000001|\t65-90|\t41-5A\t|A-Z\t|大写字母\t同字母大小写相差32\n|01100001\t|97-122|\t61-7A\t|a-z\t|小写字母\t\t\n|01111111\t|127\t|7F|\tDEL (delete)\t|删除\n\n## 2.自定义数据类型——（4个）\n自定义数据类型相当于基本数据类型的集合。\n\n|关键字|含义|注意事项|\n|---------|-----|--|\n|struct\t|结构体\t|内存占用2字节或4字节对齐\n|union\t|共用体（联合体）\t|以最大的元素占用内存\n|enum\t|枚举常量\t|枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。枚举元素不是字符常量也不是字符串常量，使用时不要加单、双引号\n|typedef\t|数据类型别名\t|- |\n\n## 3.逻辑结构——（11个）\nC语言的逻辑结构有三种：顺序，分支，循环\n\n|关键字|含义|\n|---------|-----|\n|if、else\t|分支结构\t\n|switch、case、default|\t分支结构\tswitch条件只能是整形数字\n|do、while\t|循环结构\t先后顺序 条件循环\n|for|\t循环结构\t次数循环\n|continue\t|跳转\t跳出本次循环继续进行下次循环\n|break\t|跳转\t跳出当前循环进入下个语句\n|goto\t|不建议使用\t\n\n## 4.类型修饰符——（6个）\n类型修饰符是对资源存放位置的限定\n\n|关键字|含义|\n|---------|-----|\n|auto\t|默认情况\t局部变量存放于栈空间\n|register\t|限制变量定义在寄存器上的修饰符\t存放在寄存器，无法用&取地址\n|static\t|静态\t\n|const\t|定义为常量,防止被修改\t\n|extern\t|外部引用\t外部文件\n|volatile\t|编译优化选项\t\n\n**static详解**\n\n\n- 修饰全局变量：定义全局变量为静态全局变量\n存放在.data（初始化）和.bss（未初始化）\n外部文件无法引用\n- 修饰局部变量：定义为静态局部变量\n存放区域为.data\n生命周期为整个程序的生命周期，但依旧只有定义他的函数能够使用\n值，初始化为0，每次调用会读取上次的值。\n- 修饰函数：定义为静态函数\n只能在本文件调用\n\n**const详解**\n\n- 修饰变量\n    定义变量为不可改变的。\n- 修饰指针\n    const char *p \t修饰的是*p，p指向的内容不能被更改\n    char * const p \t修饰的是p，指针不能被更改\n    const char * const p\t指针和内容都不能被更改\n- 修饰函数\n- 修饰输入参数\n    值传递\t无需const保护\n    指针传递\t防止更改原有指针指向的内容，对参数内容只读不写\n\n## 5.其它\n\n|关键字|含义|\n|---------|-----|\n|return| 返回。\n|sizeof| 查看内存容量\n\n# 二、运算符\n## 1. 运算符的分类\n\n|类别|符号|\n|---------|-----|\n|算术运算符\t|加 `+` 减 `-` 乘 `*` 除 `/` 取余 `%`\n|逻辑运算符\t|与 `&&` 或  非 `！` \n|问号运算 |`？` `：`\n|关系运算 \t|小于 `<`   小于等于 `<=`   大于 `>`  大于等于 `>=`   等于 `==`   不等于 !`=`\n|位运算\t|左移 `<<`      右移`>>`    按位与 `&`    按位或    按位异或 `^`\n|赋值运算\t|等于 `= `   加等于 `+= `    剪等于 `-=`   等等\n|三目运算\t|表达式A`？`表达式B`：`表达式C      如果表达式A为真，那么表达式B为整个表达式的值；为假 ， 那么表达式C为整个表达式的值。\n|逗号运算\t|从左到右依次计算，最后表达式的值，作为整个表达式的值。\n\n## 2. 运算优先级\n\n|优先级\t|运算符\t|结合方向|\n|---------|-----|\n|1成员包含|\t[]数组下标            ()圆括号                             .成员选择（对象）      ->成员选择（指针）\t|左到右\n|2单目运算\t|-负号运算符        (类型)强制类型转换      ++自增运算符               --自减运算符\t|右到左\n||*取值运算符         &取地址运算符              !逻辑非运算符                ~按位取反运算符           sizeof长度运算符| |\n|3算术运算|\t加减乘除取余\t|左到右\n|4位移\t|<< 左移               >> 右移\t|左到右\n|5比较\t|\\> 大于>=大于等于                        < 小于  <=小于等于        \t|左到右\n||==等于                !=不等于| |\n|6位比较\t|&按位与             ^按位异或                            按位或 |\t左到右\n|7逻辑运算|\t&&逻辑与         逻辑或\t|左到右\n|8条件运算\t|?:条件运算符\t|右到左\n|9赋值运算\t|=赋值运算符       /=除后赋值                       *=乘后赋值                     %=取模后赋值\t|右到左\n|10逗号|\t,逗号运算符\t|左到右\n\n## 3. 神奇的运算\n**取余运算：**\n\t\n\t取一个范围的数(m% 100)+1 ===> res；得到M进制的一个个位数；循环数据结构的下标\n**逻辑运算：**\n\n\t返回值0与1                           !与~不同\n**位运算：**\n\n\t<< 左移相当于乘以2 >> 右移相当于除以2\n\t& 与0屏蔽用于清零  与1用于取出          | 或0保留用于取出 或1用于设置\n\n# 三、C语言的内存使用\n## 1. 指针\n**指针：**内存类型资源地址\n**指针变量 ：**存放指针这个概念的盒子。所有的指针在32位系统中都是4字节。\n**指针的类型：**去掉变量后的内容\n**指针所指向的类型：**去掉\\*后的内容\n**指针的值/叫指针所指向的内存区：**指向内容的首地址\n**指针本身所占据的内存区：**在32位系统中都是4字节\n**指针的加减N：**将现有指针指向的内存区加减 指针指向类型的大小 * N\n\n### 常见的指针类型：\n\n|表达式|含义|\n|--|--|\n|int p;\t|这是一个普通的整型变量\n|int \\*p; \t|首先从 P 处开始,先与\\*结合,所以说明 P 是一个指针,<br>然后再与 int 结合,说明指针所指向的内容的类型为 int 型.<br>所以 P 是一个返回整型数据的指针\n|int p[3];\t|首先从 P 处开始,先与[]结合,说明 P 是一个数组,<br>然后与 int 结合,说明数组里的元素是整型的,<br>所以 P 是一个由整型数据组成的数组\n|int \\*p[3]; \t|首先从 P 处开始,先与[]结合,因为其优先级比\\*高,所以 P 是一个数组,<br>然后再与*结合,说明数组里的元素是指针类型,<br>然后再与 int 结合,说明指针所指向的内容的类型是整型的.<br>所以P 是一个由返回整型数据的指针所组成的数组\n|int (\\*p)[3];|\t首先从 P 处开始,先与\\*结合,说明 P 是一个指针<br>然后再与[]结合,说明指针所指向的内容是一个数组,<br>然后再与 int 结合,说明数组里的元素是整型的.<br>所以 P 是一个指向由整型数据组成的数组的指针\n|int \\*\\*p; \t|首先从 P 开始,先与\\*结合,说明是 P 是一个指针,<br>然后再与*结合,说明指针所指向的元素是指针,<br>然后再与 int 结合,说明该指针所指向的元素是整型数据.\n|int p(int);|\t从 P 处起,先与()结合,说明 P 是一个函数,<br>然后进入//()里分析,说明该函数有一个整型变量的参数<br>然后再与外面的 int 结合,说明函数的返回值是一个整型数据\n|Int (*p)(int); \t|从 P 处开始,先与指针结合,说明 P 是一个指针,<br>然后与()结合,说明指针指向的是一个函数,<br>然后再与()里的int 结合,说明函数有一个 int 型的参数,<br>再与最外层的int 结合,说明函数的返回类型是整型,<br>所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针\n|int \\*(\\*p(int))[3]; \t|从 P 开始,先与()结合,说明 P 是一个函数,<br>然后进入()里面,与 int 结合,说明函数有一个整型变量参数,<br>然后再与外面的\\*结合,说明函数返回的是一个指针,<br>然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,<br>然后再与\\*结合,说明数组里的元素是指针,<br>然后再与 int 结合,说明指针指向的内容是整型数据.<br>所以 P 是一个参数为一个整数且返回一个指向由整型指针变量组成的数组的指针变量的函数.\n|int \\*(\\*p[3])(void\\*); \t|首先和[]结合，说明p是一个数组,<br>然后和\\*结合，说明数组中的每个元素都是一个指针，<br>然后和()结合，说明指针指向的是一个函数，<br>最后，与外层相结合说明这个函数的输入参数为void\\*型，返回值为int * 型，<br>所以p是一个含有三个元素的数组，每个数组元素都是一个参数为一个整数且返回一个指向整型指针的函数.\n\n## 2. 数组\n数组是具有一定顺序关系的若干个变量的集合，组成数组的各个变量称为数组的元素。\n数组的元素地址空间是连续的。\n\n  `<存储类型>   <数据类型 >    <数组名>[<表达式>] `\n\n数组是内存的一种分配方式，数组名是一个常量符号，一定不要放到=的左边。\n**数组的赋值**\n\n1. 按照标签逐一处理\n`int a[10];     [ 0 - 9 ]`\n`a[0] = xx`\n`a[1] = yy;`\n2. 空间定义时，就告知编译器的初始化情况，空间的第一次赋值，初始化操作\n  ` int a[10] = 空间;`\n3. C语言本身，CPU内部本身一般不支持空间和空间的拷贝\n`int a[10] = {10,20,30}; ====> a[0] = 10; a[1] = 20; a[2] = 30; a[3]=0;`\n\n## 3. 内存分布\n内存的属性： 1、**大小**       2、**在哪里**\n### 运行时\n\n|名称|含义|访问权限|备注|\n|---|---|\n|内核空间\t|应用程序不许访问（3G-4G）|\n|栈空间\t|局部变量  |RW    |向下增长|\n|运行时的堆空间 \t|malloc      |RW  | 向上增长|\n|全局的数据空间 （未初始化） 0\t|static    |    RW   |bss|\n|全局的数据空间（初始化的） \t|static       | RW  | data  |\n|只读数据段   |\"hello world\" 字符串常量   |\t R   |   TEXT|\n|代码段      |code              | R            |       \tTEXT\n\n### 存储时：\n|名称|标识|访问权限|备注|\n|---|---|\n|数据区（未初始化） | bss|\tRW\n|数据区（初始化的）|  data  |\tRW\n|代码段      |code      |R  | TEXT\n\n**栈空间：**运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内\n**堆空间：**运行时，可以自由，自我管理的分配和释放的空间，生存周期是由程序员来决定\n\n# 四、函数\n## 1. 函数概述\n一堆代码的集合，用一个标签去描述它，为了实现代码的复用化 \n标签 ----- 函数名，函数具备3要素：\n**1、函数名   （地址）**\n**2、输入参数**\n**3、返回值**\n在定义函数时，必须将3要素告知编译器。\n\n## 2. 输入参数 \n承上启下的功能 \n\n- 调用者：\n  函数名（要传递的数据）                //实参\n- 被调者：\n 函数的具体实现\n 函数的返回值  函数名（接收的数据）        //形参\n\n**值传递**\n上层调用者 保护自己空间值不被修改的能力 \n**地址传递**\n上层，调用者 让下层 子函数 修改自己空间值的方式\n\n- 子函数看看空间里的情况       const  *\n- 子函数反向修改上层空间里的内容     char * \n\n## 3. 返回值\n提供启下功能的一种表现形式\n","source":"_posts/C语言学习总结（三）——C语言的基本语法.md","raw":"---\ntitle: C语言学习总结（三）——C语言的基本语法\ndate: 2016-11-21 15:38:03\ncategories: C语言学习总结\ntags: [C语言,指针]\n---\n\n我喜欢从关键字开始构建自己心中一门编程语言的轮廓，今天主要总结下C语言的关键字。\n<!--more-->\n# 一、C语言的关键字\nC语言的关键字是一些编译器预先定义的具有一定具体含义的字符串。关键字共有32个，分为五大类：\n## 1. 基本数据类型——（9个）\n\n|关键字|含义|\n|---------|-----|\n|char|\t软件操作的最小数据单元\t8bit|\n|int\t|系统单周期最大数据处理单元\t32bit/64bit\n|short\t|特殊长度的限制符（不能大于int）\t通常16bit\n|long\t|特殊长度的限制符（不能小于int）\t通常32bit\n|float\t|浮点型数据，带小数点\t通常32bit\n|double\t|浮点型数据，带小数点\t通常64bit\n|void\t|空类型\t\n|signed\t|带符号类型，用作数值\t\n|unsigned\t|不带符号，用作内存\t\n### 原码/补码/反码\n**机器数**\n\n\t一个数在计算机中的二进制表示形式带符号，正数为0, 负数为1，叫做这个数的机器数\n\t例：十进制中的数 +3 ，机器数是00000011。-3 ，机器数是 10000011 \n\t\n**真值**\n\n\t带符号位的机器数对应的真正数值称为机器数的真值。\n\t例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1\n\t\n**原码**\n\n\t原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。\n\n**反码**\n\n\t正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n\n**补码**\n\t\n\t正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\n\n**为什么会有原码反码补码？**\n计算机无法判断符号（硬件难于实现），因此使用符号位参与运算。\n\n* 首先来看原码:\n计算十进制的表达式: `1-1=0`\n          1 - 1 \n        = 1 + (-1) \n        = [00000001]原 + [10000001]原 \n        = [10000010]原 \n        = -2\t`\t\n如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是**不正确的**。\n* 为了解决原码做减法的问题, 出现了反码:\n计算十进制的表达式: `1-1=0`\n          1 - 1 \n        = 1 + (-1) \n        = [0000 0001]原 + [1000 0001]原\n        = [0000 0001]反 + [1111 1110]反 \n        = [1111 1111]反 = [1000 0000]原 \n        = -0\n会有[0000 0000]原和[1000 0000]原两个编码表示0.\n* 于是补码的出现, 解决了0的符号以及两个编码的问题:\n          1-1 = 1 + (-1) \n        = [0000 0001]原 + [1000 0001]原 \n        = [0000 0001]补 + [1111 1111]补 \n        = [0000 0000]补\n        =[0000 0000]原\n这样**0用[0000 0000]表示**, 而以前出现问题的-0则不存在了.而且可以用**[1000 0000]表示-128**。\n\n### ASCII码表\n\n|Bin\t|Dec\t|Hex\t|缩写/字符|\t解释|\n|----|---------|--|-------|-----|\n|0000 0000|\t0\t|00\t|NUL(null)\t|空字符|\t\t\n|0000 1000|\t8\t|08\t|BS (backspace)\t|退格\n|0000 1001|\t9\t|09\t|HT (horizontal tab)\t|水平制表符\n|0000 1010|\t10\t|0A\t|LF (NL line feed, new line)\t|换行键\n|0000 1101|\t13\t|0D\t|CR (carriage return)\t|回车键\t\t\n|0010 0000|\t32\t|20\t|(space)\t|空格\t\t\n|00110000|\t48-57|\t30-39|\t0-9|\t数字\t\t\n|01000001|\t65-90|\t41-5A\t|A-Z\t|大写字母\t同字母大小写相差32\n|01100001\t|97-122|\t61-7A\t|a-z\t|小写字母\t\t\n|01111111\t|127\t|7F|\tDEL (delete)\t|删除\n\n## 2.自定义数据类型——（4个）\n自定义数据类型相当于基本数据类型的集合。\n\n|关键字|含义|注意事项|\n|---------|-----|--|\n|struct\t|结构体\t|内存占用2字节或4字节对齐\n|union\t|共用体（联合体）\t|以最大的元素占用内存\n|enum\t|枚举常量\t|枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。枚举元素不是字符常量也不是字符串常量，使用时不要加单、双引号\n|typedef\t|数据类型别名\t|- |\n\n## 3.逻辑结构——（11个）\nC语言的逻辑结构有三种：顺序，分支，循环\n\n|关键字|含义|\n|---------|-----|\n|if、else\t|分支结构\t\n|switch、case、default|\t分支结构\tswitch条件只能是整形数字\n|do、while\t|循环结构\t先后顺序 条件循环\n|for|\t循环结构\t次数循环\n|continue\t|跳转\t跳出本次循环继续进行下次循环\n|break\t|跳转\t跳出当前循环进入下个语句\n|goto\t|不建议使用\t\n\n## 4.类型修饰符——（6个）\n类型修饰符是对资源存放位置的限定\n\n|关键字|含义|\n|---------|-----|\n|auto\t|默认情况\t局部变量存放于栈空间\n|register\t|限制变量定义在寄存器上的修饰符\t存放在寄存器，无法用&取地址\n|static\t|静态\t\n|const\t|定义为常量,防止被修改\t\n|extern\t|外部引用\t外部文件\n|volatile\t|编译优化选项\t\n\n**static详解**\n\n\n- 修饰全局变量：定义全局变量为静态全局变量\n存放在.data（初始化）和.bss（未初始化）\n外部文件无法引用\n- 修饰局部变量：定义为静态局部变量\n存放区域为.data\n生命周期为整个程序的生命周期，但依旧只有定义他的函数能够使用\n值，初始化为0，每次调用会读取上次的值。\n- 修饰函数：定义为静态函数\n只能在本文件调用\n\n**const详解**\n\n- 修饰变量\n    定义变量为不可改变的。\n- 修饰指针\n    const char *p \t修饰的是*p，p指向的内容不能被更改\n    char * const p \t修饰的是p，指针不能被更改\n    const char * const p\t指针和内容都不能被更改\n- 修饰函数\n- 修饰输入参数\n    值传递\t无需const保护\n    指针传递\t防止更改原有指针指向的内容，对参数内容只读不写\n\n## 5.其它\n\n|关键字|含义|\n|---------|-----|\n|return| 返回。\n|sizeof| 查看内存容量\n\n# 二、运算符\n## 1. 运算符的分类\n\n|类别|符号|\n|---------|-----|\n|算术运算符\t|加 `+` 减 `-` 乘 `*` 除 `/` 取余 `%`\n|逻辑运算符\t|与 `&&` 或  非 `！` \n|问号运算 |`？` `：`\n|关系运算 \t|小于 `<`   小于等于 `<=`   大于 `>`  大于等于 `>=`   等于 `==`   不等于 !`=`\n|位运算\t|左移 `<<`      右移`>>`    按位与 `&`    按位或    按位异或 `^`\n|赋值运算\t|等于 `= `   加等于 `+= `    剪等于 `-=`   等等\n|三目运算\t|表达式A`？`表达式B`：`表达式C      如果表达式A为真，那么表达式B为整个表达式的值；为假 ， 那么表达式C为整个表达式的值。\n|逗号运算\t|从左到右依次计算，最后表达式的值，作为整个表达式的值。\n\n## 2. 运算优先级\n\n|优先级\t|运算符\t|结合方向|\n|---------|-----|\n|1成员包含|\t[]数组下标            ()圆括号                             .成员选择（对象）      ->成员选择（指针）\t|左到右\n|2单目运算\t|-负号运算符        (类型)强制类型转换      ++自增运算符               --自减运算符\t|右到左\n||*取值运算符         &取地址运算符              !逻辑非运算符                ~按位取反运算符           sizeof长度运算符| |\n|3算术运算|\t加减乘除取余\t|左到右\n|4位移\t|<< 左移               >> 右移\t|左到右\n|5比较\t|\\> 大于>=大于等于                        < 小于  <=小于等于        \t|左到右\n||==等于                !=不等于| |\n|6位比较\t|&按位与             ^按位异或                            按位或 |\t左到右\n|7逻辑运算|\t&&逻辑与         逻辑或\t|左到右\n|8条件运算\t|?:条件运算符\t|右到左\n|9赋值运算\t|=赋值运算符       /=除后赋值                       *=乘后赋值                     %=取模后赋值\t|右到左\n|10逗号|\t,逗号运算符\t|左到右\n\n## 3. 神奇的运算\n**取余运算：**\n\t\n\t取一个范围的数(m% 100)+1 ===> res；得到M进制的一个个位数；循环数据结构的下标\n**逻辑运算：**\n\n\t返回值0与1                           !与~不同\n**位运算：**\n\n\t<< 左移相当于乘以2 >> 右移相当于除以2\n\t& 与0屏蔽用于清零  与1用于取出          | 或0保留用于取出 或1用于设置\n\n# 三、C语言的内存使用\n## 1. 指针\n**指针：**内存类型资源地址\n**指针变量 ：**存放指针这个概念的盒子。所有的指针在32位系统中都是4字节。\n**指针的类型：**去掉变量后的内容\n**指针所指向的类型：**去掉\\*后的内容\n**指针的值/叫指针所指向的内存区：**指向内容的首地址\n**指针本身所占据的内存区：**在32位系统中都是4字节\n**指针的加减N：**将现有指针指向的内存区加减 指针指向类型的大小 * N\n\n### 常见的指针类型：\n\n|表达式|含义|\n|--|--|\n|int p;\t|这是一个普通的整型变量\n|int \\*p; \t|首先从 P 处开始,先与\\*结合,所以说明 P 是一个指针,<br>然后再与 int 结合,说明指针所指向的内容的类型为 int 型.<br>所以 P 是一个返回整型数据的指针\n|int p[3];\t|首先从 P 处开始,先与[]结合,说明 P 是一个数组,<br>然后与 int 结合,说明数组里的元素是整型的,<br>所以 P 是一个由整型数据组成的数组\n|int \\*p[3]; \t|首先从 P 处开始,先与[]结合,因为其优先级比\\*高,所以 P 是一个数组,<br>然后再与*结合,说明数组里的元素是指针类型,<br>然后再与 int 结合,说明指针所指向的内容的类型是整型的.<br>所以P 是一个由返回整型数据的指针所组成的数组\n|int (\\*p)[3];|\t首先从 P 处开始,先与\\*结合,说明 P 是一个指针<br>然后再与[]结合,说明指针所指向的内容是一个数组,<br>然后再与 int 结合,说明数组里的元素是整型的.<br>所以 P 是一个指向由整型数据组成的数组的指针\n|int \\*\\*p; \t|首先从 P 开始,先与\\*结合,说明是 P 是一个指针,<br>然后再与*结合,说明指针所指向的元素是指针,<br>然后再与 int 结合,说明该指针所指向的元素是整型数据.\n|int p(int);|\t从 P 处起,先与()结合,说明 P 是一个函数,<br>然后进入//()里分析,说明该函数有一个整型变量的参数<br>然后再与外面的 int 结合,说明函数的返回值是一个整型数据\n|Int (*p)(int); \t|从 P 处开始,先与指针结合,说明 P 是一个指针,<br>然后与()结合,说明指针指向的是一个函数,<br>然后再与()里的int 结合,说明函数有一个 int 型的参数,<br>再与最外层的int 结合,说明函数的返回类型是整型,<br>所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针\n|int \\*(\\*p(int))[3]; \t|从 P 开始,先与()结合,说明 P 是一个函数,<br>然后进入()里面,与 int 结合,说明函数有一个整型变量参数,<br>然后再与外面的\\*结合,说明函数返回的是一个指针,<br>然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,<br>然后再与\\*结合,说明数组里的元素是指针,<br>然后再与 int 结合,说明指针指向的内容是整型数据.<br>所以 P 是一个参数为一个整数且返回一个指向由整型指针变量组成的数组的指针变量的函数.\n|int \\*(\\*p[3])(void\\*); \t|首先和[]结合，说明p是一个数组,<br>然后和\\*结合，说明数组中的每个元素都是一个指针，<br>然后和()结合，说明指针指向的是一个函数，<br>最后，与外层相结合说明这个函数的输入参数为void\\*型，返回值为int * 型，<br>所以p是一个含有三个元素的数组，每个数组元素都是一个参数为一个整数且返回一个指向整型指针的函数.\n\n## 2. 数组\n数组是具有一定顺序关系的若干个变量的集合，组成数组的各个变量称为数组的元素。\n数组的元素地址空间是连续的。\n\n  `<存储类型>   <数据类型 >    <数组名>[<表达式>] `\n\n数组是内存的一种分配方式，数组名是一个常量符号，一定不要放到=的左边。\n**数组的赋值**\n\n1. 按照标签逐一处理\n`int a[10];     [ 0 - 9 ]`\n`a[0] = xx`\n`a[1] = yy;`\n2. 空间定义时，就告知编译器的初始化情况，空间的第一次赋值，初始化操作\n  ` int a[10] = 空间;`\n3. C语言本身，CPU内部本身一般不支持空间和空间的拷贝\n`int a[10] = {10,20,30}; ====> a[0] = 10; a[1] = 20; a[2] = 30; a[3]=0;`\n\n## 3. 内存分布\n内存的属性： 1、**大小**       2、**在哪里**\n### 运行时\n\n|名称|含义|访问权限|备注|\n|---|---|\n|内核空间\t|应用程序不许访问（3G-4G）|\n|栈空间\t|局部变量  |RW    |向下增长|\n|运行时的堆空间 \t|malloc      |RW  | 向上增长|\n|全局的数据空间 （未初始化） 0\t|static    |    RW   |bss|\n|全局的数据空间（初始化的） \t|static       | RW  | data  |\n|只读数据段   |\"hello world\" 字符串常量   |\t R   |   TEXT|\n|代码段      |code              | R            |       \tTEXT\n\n### 存储时：\n|名称|标识|访问权限|备注|\n|---|---|\n|数据区（未初始化） | bss|\tRW\n|数据区（初始化的）|  data  |\tRW\n|代码段      |code      |R  | TEXT\n\n**栈空间：**运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内\n**堆空间：**运行时，可以自由，自我管理的分配和释放的空间，生存周期是由程序员来决定\n\n# 四、函数\n## 1. 函数概述\n一堆代码的集合，用一个标签去描述它，为了实现代码的复用化 \n标签 ----- 函数名，函数具备3要素：\n**1、函数名   （地址）**\n**2、输入参数**\n**3、返回值**\n在定义函数时，必须将3要素告知编译器。\n\n## 2. 输入参数 \n承上启下的功能 \n\n- 调用者：\n  函数名（要传递的数据）                //实参\n- 被调者：\n 函数的具体实现\n 函数的返回值  函数名（接收的数据）        //形参\n\n**值传递**\n上层调用者 保护自己空间值不被修改的能力 \n**地址传递**\n上层，调用者 让下层 子函数 修改自己空间值的方式\n\n- 子函数看看空间里的情况       const  *\n- 子函数反向修改上层空间里的内容     char * \n\n## 3. 返回值\n提供启下功能的一种表现形式\n","slug":"C语言学习总结（三）——C语言的基本语法","published":1,"updated":"2016-12-21T14:08:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9mzy000ebkw1xdj4zkyz","content":"<p>我喜欢从关键字开始构建自己心中一门编程语言的轮廓，今天主要总结下C语言的关键字。<br><a id=\"more\"></a></p>\n<h1 id=\"一、C语言的关键字\"><a href=\"#一、C语言的关键字\" class=\"headerlink\" title=\"一、C语言的关键字\"></a>一、C语言的关键字</h1><p>C语言的关键字是一些编译器预先定义的具有一定具体含义的字符串。关键字共有32个，分为五大类：</p>\n<h2 id=\"1-基本数据类型——（9个）\"><a href=\"#1-基本数据类型——（9个）\" class=\"headerlink\" title=\"1. 基本数据类型——（9个）\"></a>1. 基本数据类型——（9个）</h2><table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>软件操作的最小数据单元    8bit</td>\n</tr>\n<tr>\n<td>int</td>\n<td>系统单周期最大数据处理单元    32bit/64bit</td>\n</tr>\n<tr>\n<td>short</td>\n<td>特殊长度的限制符（不能大于int）    通常16bit</td>\n</tr>\n<tr>\n<td>long</td>\n<td>特殊长度的限制符（不能小于int）    通常32bit</td>\n</tr>\n<tr>\n<td>float</td>\n<td>浮点型数据，带小数点    通常32bit</td>\n</tr>\n<tr>\n<td>double</td>\n<td>浮点型数据，带小数点    通常64bit</td>\n</tr>\n<tr>\n<td>void</td>\n<td>空类型    </td>\n</tr>\n<tr>\n<td>signed</td>\n<td>带符号类型，用作数值    </td>\n</tr>\n<tr>\n<td>unsigned</td>\n<td>不带符号，用作内存    </td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"原码-补码-反码\"><a href=\"#原码-补码-反码\" class=\"headerlink\" title=\"原码/补码/反码\"></a>原码/补码/反码</h3><p><strong>机器数</strong></p>\n<pre><code>一个数在计算机中的二进制表示形式带符号，正数为0, 负数为1，叫做这个数的机器数\n例：十进制中的数 +3 ，机器数是00000011。-3 ，机器数是 10000011 \n</code></pre><p><strong>真值</strong></p>\n<pre><code>带符号位的机器数对应的真正数值称为机器数的真值。\n例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1\n</code></pre><p><strong>原码</strong></p>\n<pre><code>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。\n</code></pre><p><strong>反码</strong></p>\n<pre><code>正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n</code></pre><p><strong>补码</strong></p>\n<pre><code>正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\n</code></pre><p><strong>为什么会有原码反码补码？</strong><br>计算机无法判断符号（硬件难于实现），因此使用符号位参与运算。</p>\n<ul>\n<li>首先来看原码:<br>计算十进制的表达式: <code>1-1=0</code><pre><code>  1 - 1 \n= 1 + (-1) \n= [00000001]原 + [10000001]原 \n= [10000010]原 \n= -2    `    \n</code></pre>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是<strong>不正确的</strong>。</li>\n<li>为了解决原码做减法的问题, 出现了反码:<br>计算十进制的表达式: <code>1-1=0</code><pre><code>  1 - 1 \n= 1 + (-1) \n= [0000 0001]原 + [1000 0001]原\n= [0000 0001]反 + [1111 1110]反 \n= [1111 1111]反 = [1000 0000]原 \n= -0\n</code></pre>会有[0000 0000]原和[1000 0000]原两个编码表示0.</li>\n<li>于是补码的出现, 解决了0的符号以及两个编码的问题:<pre><code>  1-1 = 1 + (-1) \n= [0000 0001]原 + [1000 0001]原 \n= [0000 0001]补 + [1111 1111]补 \n= [0000 0000]补\n=[0000 0000]原\n</code></pre>这样<strong>0用[0000 0000]表示</strong>, 而以前出现问题的-0则不存在了.而且可以用<strong>[1000 0000]表示-128</strong>。</li>\n</ul>\n<h3 id=\"ASCII码表\"><a href=\"#ASCII码表\" class=\"headerlink\" title=\"ASCII码表\"></a>ASCII码表</h3><table>\n<thead>\n<tr>\n<th>Bin</th>\n<th>Dec</th>\n<th>Hex</th>\n<th>缩写/字符</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0000 0000</td>\n<td>0</td>\n<td>00</td>\n<td>NUL(null)</td>\n<td>空字符</td>\n</tr>\n<tr>\n<td>0000 1000</td>\n<td>8</td>\n<td>08</td>\n<td>BS (backspace)</td>\n<td>退格</td>\n</tr>\n<tr>\n<td>0000 1001</td>\n<td>9</td>\n<td>09</td>\n<td>HT (horizontal tab)</td>\n<td>水平制表符</td>\n</tr>\n<tr>\n<td>0000 1010</td>\n<td>10</td>\n<td>0A</td>\n<td>LF (NL line feed, new line)</td>\n<td>换行键</td>\n</tr>\n<tr>\n<td>0000 1101</td>\n<td>13</td>\n<td>0D</td>\n<td>CR (carriage return)</td>\n<td>回车键        </td>\n</tr>\n<tr>\n<td>0010 0000</td>\n<td>32</td>\n<td>20</td>\n<td>(space)</td>\n<td>空格        </td>\n</tr>\n<tr>\n<td>00110000</td>\n<td>48-57</td>\n<td>30-39</td>\n<td>0-9</td>\n<td>数字        </td>\n</tr>\n<tr>\n<td>01000001</td>\n<td>65-90</td>\n<td>41-5A</td>\n<td>A-Z</td>\n<td>大写字母    同字母大小写相差32</td>\n</tr>\n<tr>\n<td>01100001</td>\n<td>97-122</td>\n<td>61-7A</td>\n<td>a-z</td>\n<td>小写字母        </td>\n</tr>\n<tr>\n<td>01111111</td>\n<td>127</td>\n<td>7F</td>\n<td>DEL (delete)</td>\n<td>删除</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-自定义数据类型——（4个）\"><a href=\"#2-自定义数据类型——（4个）\" class=\"headerlink\" title=\"2.自定义数据类型——（4个）\"></a>2.自定义数据类型——（4个）</h2><p>自定义数据类型相当于基本数据类型的集合。</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>struct</td>\n<td>结构体</td>\n<td>内存占用2字节或4字节对齐</td>\n</tr>\n<tr>\n<td>union</td>\n<td>共用体（联合体）</td>\n<td>以最大的元素占用内存</td>\n</tr>\n<tr>\n<td>enum</td>\n<td>枚举常量</td>\n<td>枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。枚举元素不是字符常量也不是字符串常量，使用时不要加单、双引号</td>\n</tr>\n<tr>\n<td>typedef</td>\n<td>数据类型别名</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-逻辑结构——（11个）\"><a href=\"#3-逻辑结构——（11个）\" class=\"headerlink\" title=\"3.逻辑结构——（11个）\"></a>3.逻辑结构——（11个）</h2><p>C语言的逻辑结构有三种：顺序，分支，循环</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if、else</td>\n<td>分支结构    </td>\n</tr>\n<tr>\n<td>switch、case、default</td>\n<td>分支结构    switch条件只能是整形数字</td>\n</tr>\n<tr>\n<td>do、while</td>\n<td>循环结构    先后顺序 条件循环</td>\n</tr>\n<tr>\n<td>for</td>\n<td>循环结构    次数循环</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>跳转    跳出本次循环继续进行下次循环</td>\n</tr>\n<tr>\n<td>break</td>\n<td>跳转    跳出当前循环进入下个语句</td>\n</tr>\n<tr>\n<td>goto</td>\n<td>不建议使用    </td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-类型修饰符——（6个）\"><a href=\"#4-类型修饰符——（6个）\" class=\"headerlink\" title=\"4.类型修饰符——（6个）\"></a>4.类型修饰符——（6个）</h2><p>类型修饰符是对资源存放位置的限定</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>默认情况    局部变量存放于栈空间</td>\n</tr>\n<tr>\n<td>register</td>\n<td>限制变量定义在寄存器上的修饰符    存放在寄存器，无法用&amp;取地址</td>\n</tr>\n<tr>\n<td>static</td>\n<td>静态    </td>\n</tr>\n<tr>\n<td>const</td>\n<td>定义为常量,防止被修改    </td>\n</tr>\n<tr>\n<td>extern</td>\n<td>外部引用    外部文件</td>\n</tr>\n<tr>\n<td>volatile</td>\n<td>编译优化选项    </td>\n</tr>\n</tbody>\n</table>\n<p><strong>static详解</strong></p>\n<ul>\n<li>修饰全局变量：定义全局变量为静态全局变量<br>存放在.data（初始化）和.bss（未初始化）<br>外部文件无法引用</li>\n<li>修饰局部变量：定义为静态局部变量<br>存放区域为.data<br>生命周期为整个程序的生命周期，但依旧只有定义他的函数能够使用<br>值，初始化为0，每次调用会读取上次的值。</li>\n<li>修饰函数：定义为静态函数<br>只能在本文件调用</li>\n</ul>\n<p><strong>const详解</strong></p>\n<ul>\n<li>修饰变量<br>  定义变量为不可改变的。</li>\n<li>修饰指针<br>  const char <em>p     修饰的是</em>p，p指向的内容不能被更改<br>  char <em> const p     修饰的是p，指针不能被更改<br>  const char </em> const p    指针和内容都不能被更改</li>\n<li>修饰函数</li>\n<li>修饰输入参数<br>  值传递    无需const保护<br>  指针传递    防止更改原有指针指向的内容，对参数内容只读不写</li>\n</ul>\n<h2 id=\"5-其它\"><a href=\"#5-其它\" class=\"headerlink\" title=\"5.其它\"></a>5.其它</h2><table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>return</td>\n<td>返回。</td>\n</tr>\n<tr>\n<td>sizeof</td>\n<td>查看内存容量</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"二、运算符\"><a href=\"#二、运算符\" class=\"headerlink\" title=\"二、运算符\"></a>二、运算符</h1><h2 id=\"1-运算符的分类\"><a href=\"#1-运算符的分类\" class=\"headerlink\" title=\"1. 运算符的分类\"></a>1. 运算符的分类</h2><table>\n<thead>\n<tr>\n<th>类别</th>\n<th>符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>算术运算符</td>\n<td>加 <code>+</code> 减 <code>-</code> 乘 <code>*</code> 除 <code>/</code> 取余 <code>%</code></td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>与 <code>&amp;&amp;</code> 或  非 <code>！</code> </td>\n</tr>\n<tr>\n<td>问号运算</td>\n<td><code>？</code> <code>：</code></td>\n</tr>\n<tr>\n<td>关系运算</td>\n<td>小于 <code>&lt;</code>   小于等于 <code>&lt;=</code>   大于 <code>&gt;</code>  大于等于 <code>&gt;=</code>   等于 <code>==</code>   不等于 !<code>=</code></td>\n</tr>\n<tr>\n<td>位运算</td>\n<td>左移 <code>&lt;&lt;</code>      右移<code>&gt;&gt;</code>    按位与 <code>&amp;</code>    按位或    按位异或 <code>^</code></td>\n</tr>\n<tr>\n<td>赋值运算</td>\n<td>等于 <code>=</code>   加等于 <code>+=</code>    剪等于 <code>-=</code>   等等</td>\n</tr>\n<tr>\n<td>三目运算</td>\n<td>表达式A<code>？</code>表达式B<code>：</code>表达式C      如果表达式A为真，那么表达式B为整个表达式的值；为假 ， 那么表达式C为整个表达式的值。</td>\n</tr>\n<tr>\n<td>逗号运算</td>\n<td>从左到右依次计算，最后表达式的值，作为整个表达式的值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-运算优先级\"><a href=\"#2-运算优先级\" class=\"headerlink\" title=\"2. 运算优先级\"></a>2. 运算优先级</h2><table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>运算符</th>\n<th>结合方向</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1成员包含</td>\n<td>[]数组下标            ()圆括号                             .成员选择（对象）      -&gt;成员选择（指针）</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>2单目运算</td>\n<td>-负号运算符        (类型)强制类型转换      ++自增运算符               –自减运算符</td>\n<td>右到左</td>\n</tr>\n<tr>\n<td></td>\n<td>*取值运算符         &amp;取地址运算符              !逻辑非运算符                ~按位取反运算符           sizeof长度运算符</td>\n<td></td>\n</tr>\n<tr>\n<td>3算术运算</td>\n<td>加减乘除取余</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>4位移</td>\n<td>&lt;&lt; 左移               &gt;&gt; 右移</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>5比较</td>\n<td>> 大于&gt;=大于等于                        &lt; 小于  &lt;=小于等于</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td></td>\n<td>==等于                !=不等于</td>\n<td></td>\n</tr>\n<tr>\n<td>6位比较</td>\n<td>&amp;按位与             ^按位异或                            按位或</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>7逻辑运算</td>\n<td>&amp;&amp;逻辑与         逻辑或</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>8条件运算</td>\n<td>?:条件运算符</td>\n<td>右到左</td>\n</tr>\n<tr>\n<td>9赋值运算</td>\n<td>=赋值运算符       /=除后赋值                       *=乘后赋值                     %=取模后赋值</td>\n<td>右到左</td>\n</tr>\n<tr>\n<td>10逗号</td>\n<td>,逗号运算符</td>\n<td>左到右</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-神奇的运算\"><a href=\"#3-神奇的运算\" class=\"headerlink\" title=\"3. 神奇的运算\"></a>3. 神奇的运算</h2><p><strong>取余运算：</strong></p>\n<pre><code>取一个范围的数(m% 100)+1 ===&gt; res；得到M进制的一个个位数；循环数据结构的下标\n</code></pre><p><strong>逻辑运算：</strong></p>\n<pre><code>返回值0与1                           !与~不同\n</code></pre><p><strong>位运算：</strong></p>\n<pre><code>&lt;&lt; 左移相当于乘以2 &gt;&gt; 右移相当于除以2\n&amp; 与0屏蔽用于清零  与1用于取出          | 或0保留用于取出 或1用于设置\n</code></pre><h1 id=\"三、C语言的内存使用\"><a href=\"#三、C语言的内存使用\" class=\"headerlink\" title=\"三、C语言的内存使用\"></a>三、C语言的内存使用</h1><h2 id=\"1-指针\"><a href=\"#1-指针\" class=\"headerlink\" title=\"1. 指针\"></a>1. 指针</h2><p><strong>指针：</strong>内存类型资源地址<br><strong>指针变量 ：</strong>存放指针这个概念的盒子。所有的指针在32位系统中都是4字节。<br><strong>指针的类型：</strong>去掉变量后的内容<br><strong>指针所指向的类型：</strong>去掉*后的内容<br><strong>指针的值/叫指针所指向的内存区：</strong>指向内容的首地址<br><strong>指针本身所占据的内存区：</strong>在32位系统中都是4字节<br><strong>指针的加减N：</strong>将现有指针指向的内存区加减 指针指向类型的大小 * N</p>\n<h3 id=\"常见的指针类型：\"><a href=\"#常见的指针类型：\" class=\"headerlink\" title=\"常见的指针类型：\"></a>常见的指针类型：</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int p;</td>\n<td>这是一个普通的整型变量</td>\n</tr>\n<tr>\n<td>int *p;</td>\n<td>首先从 P 处开始,先与*结合,所以说明 P 是一个指针,<br>然后再与 int 结合,说明指针所指向的内容的类型为 int 型.<br>所以 P 是一个返回整型数据的指针</td>\n</tr>\n<tr>\n<td>int p[3];</td>\n<td>首先从 P 处开始,先与[]结合,说明 P 是一个数组,<br>然后与 int 结合,说明数组里的元素是整型的,<br>所以 P 是一个由整型数据组成的数组</td>\n</tr>\n<tr>\n<td>int *p[3];</td>\n<td>首先从 P 处开始,先与[]结合,因为其优先级比*高,所以 P 是一个数组,<br>然后再与*结合,说明数组里的元素是指针类型,<br>然后再与 int 结合,说明指针所指向的内容的类型是整型的.<br>所以P 是一个由返回整型数据的指针所组成的数组</td>\n</tr>\n<tr>\n<td>int (*p)[3];</td>\n<td>首先从 P 处开始,先与*结合,说明 P 是一个指针<br>然后再与[]结合,说明指针所指向的内容是一个数组,<br>然后再与 int 结合,说明数组里的元素是整型的.<br>所以 P 是一个指向由整型数据组成的数组的指针</td>\n</tr>\n<tr>\n<td>int **p;</td>\n<td>首先从 P 开始,先与*结合,说明是 P 是一个指针,<br>然后再与*结合,说明指针所指向的元素是指针,<br>然后再与 int 结合,说明该指针所指向的元素是整型数据.</td>\n</tr>\n<tr>\n<td>int p(int);</td>\n<td>从 P 处起,先与()结合,说明 P 是一个函数,<br>然后进入//()里分析,说明该函数有一个整型变量的参数<br>然后再与外面的 int 结合,说明函数的返回值是一个整型数据</td>\n</tr>\n<tr>\n<td>Int (*p)(int);</td>\n<td>从 P 处开始,先与指针结合,说明 P 是一个指针,<br>然后与()结合,说明指针指向的是一个函数,<br>然后再与()里的int 结合,说明函数有一个 int 型的参数,<br>再与最外层的int 结合,说明函数的返回类型是整型,<br>所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针</td>\n</tr>\n<tr>\n<td>int *(*p(int))[3];</td>\n<td>从 P 开始,先与()结合,说明 P 是一个函数,<br>然后进入()里面,与 int 结合,说明函数有一个整型变量参数,<br>然后再与外面的*结合,说明函数返回的是一个指针,<br>然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,<br>然后再与*结合,说明数组里的元素是指针,<br>然后再与 int 结合,说明指针指向的内容是整型数据.<br>所以 P 是一个参数为一个整数且返回一个指向由整型指针变量组成的数组的指针变量的函数.</td>\n</tr>\n<tr>\n<td>int *(*p[3])(void*);</td>\n<td>首先和[]结合，说明p是一个数组,<br>然后和*结合，说明数组中的每个元素都是一个指针，<br>然后和()结合，说明指针指向的是一个函数，<br>最后，与外层相结合说明这个函数的输入参数为void*型，返回值为int * 型，<br>所以p是一个含有三个元素的数组，每个数组元素都是一个参数为一个整数且返回一个指向整型指针的函数.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-数组\"><a href=\"#2-数组\" class=\"headerlink\" title=\"2. 数组\"></a>2. 数组</h2><p>数组是具有一定顺序关系的若干个变量的集合，组成数组的各个变量称为数组的元素。<br>数组的元素地址空间是连续的。</p>\n<p>  <code>&lt;存储类型&gt;   &lt;数据类型 &gt;    &lt;数组名&gt;[&lt;表达式&gt;]</code></p>\n<p>数组是内存的一种分配方式，数组名是一个常量符号，一定不要放到=的左边。<br><strong>数组的赋值</strong></p>\n<ol>\n<li>按照标签逐一处理<br><code>int a[10];     [ 0 - 9 ]</code><br><code>a[0] = xx</code><br><code>a[1] = yy;</code></li>\n<li>空间定义时，就告知编译器的初始化情况，空间的第一次赋值，初始化操作<br><code>int a[10] = 空间;</code></li>\n<li>C语言本身，CPU内部本身一般不支持空间和空间的拷贝<br><code>int a[10] = {10,20,30}; ====&gt; a[0] = 10; a[1] = 20; a[2] = 30; a[3]=0;</code></li>\n</ol>\n<h2 id=\"3-内存分布\"><a href=\"#3-内存分布\" class=\"headerlink\" title=\"3. 内存分布\"></a>3. 内存分布</h2><p>内存的属性： 1、<strong>大小</strong>       2、<strong>在哪里</strong></p>\n<h3 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n<th>访问权限</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内核空间</td>\n<td>应用程序不许访问（3G-4G）</td>\n</tr>\n<tr>\n<td>栈空间</td>\n<td>局部变量</td>\n<td>RW</td>\n<td>向下增长</td>\n</tr>\n<tr>\n<td>运行时的堆空间</td>\n<td>malloc</td>\n<td>RW</td>\n<td>向上增长</td>\n</tr>\n<tr>\n<td>全局的数据空间 （未初始化） 0</td>\n<td>static</td>\n<td>RW</td>\n<td>bss</td>\n</tr>\n<tr>\n<td>全局的数据空间（初始化的）</td>\n<td>static</td>\n<td>RW</td>\n<td>data</td>\n</tr>\n<tr>\n<td>只读数据段</td>\n<td>“hello world” 字符串常量</td>\n<td>R</td>\n<td>TEXT</td>\n</tr>\n<tr>\n<td>代码段</td>\n<td>code</td>\n<td>R</td>\n<td>TEXT</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"存储时：\"><a href=\"#存储时：\" class=\"headerlink\" title=\"存储时：\"></a>存储时：</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>标识</th>\n<th>访问权限</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据区（未初始化）</td>\n<td>bss</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>数据区（初始化的）</td>\n<td>data</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>代码段</td>\n<td>code</td>\n<td>R</td>\n<td>TEXT</td>\n</tr>\n</tbody>\n</table>\n<p><strong>栈空间：</strong>运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内<br><strong>堆空间：</strong>运行时，可以自由，自我管理的分配和释放的空间，生存周期是由程序员来决定</p>\n<h1 id=\"四、函数\"><a href=\"#四、函数\" class=\"headerlink\" title=\"四、函数\"></a>四、函数</h1><h2 id=\"1-函数概述\"><a href=\"#1-函数概述\" class=\"headerlink\" title=\"1. 函数概述\"></a>1. 函数概述</h2><p>一堆代码的集合，用一个标签去描述它，为了实现代码的复用化<br>标签 —– 函数名，函数具备3要素：<br><strong>1、函数名   （地址）</strong><br><strong>2、输入参数</strong><br><strong>3、返回值</strong><br>在定义函数时，必须将3要素告知编译器。</p>\n<h2 id=\"2-输入参数\"><a href=\"#2-输入参数\" class=\"headerlink\" title=\"2. 输入参数\"></a>2. 输入参数</h2><p>承上启下的功能 </p>\n<ul>\n<li>调用者：<br>函数名（要传递的数据）                //实参</li>\n<li>被调者：<br>函数的具体实现<br>函数的返回值  函数名（接收的数据）        //形参</li>\n</ul>\n<p><strong>值传递</strong><br>上层调用者 保护自己空间值不被修改的能力<br><strong>地址传递</strong><br>上层，调用者 让下层 子函数 修改自己空间值的方式</p>\n<ul>\n<li>子函数看看空间里的情况       const  *</li>\n<li>子函数反向修改上层空间里的内容     char * </li>\n</ul>\n<h2 id=\"3-返回值\"><a href=\"#3-返回值\" class=\"headerlink\" title=\"3. 返回值\"></a>3. 返回值</h2><p>提供启下功能的一种表现形式</p>\n","excerpt":"<p>我喜欢从关键字开始构建自己心中一门编程语言的轮廓，今天主要总结下C语言的关键字。<br>","more":"</p>\n<h1 id=\"一、C语言的关键字\"><a href=\"#一、C语言的关键字\" class=\"headerlink\" title=\"一、C语言的关键字\"></a>一、C语言的关键字</h1><p>C语言的关键字是一些编译器预先定义的具有一定具体含义的字符串。关键字共有32个，分为五大类：</p>\n<h2 id=\"1-基本数据类型——（9个）\"><a href=\"#1-基本数据类型——（9个）\" class=\"headerlink\" title=\"1. 基本数据类型——（9个）\"></a>1. 基本数据类型——（9个）</h2><table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>软件操作的最小数据单元    8bit</td>\n</tr>\n<tr>\n<td>int</td>\n<td>系统单周期最大数据处理单元    32bit/64bit</td>\n</tr>\n<tr>\n<td>short</td>\n<td>特殊长度的限制符（不能大于int）    通常16bit</td>\n</tr>\n<tr>\n<td>long</td>\n<td>特殊长度的限制符（不能小于int）    通常32bit</td>\n</tr>\n<tr>\n<td>float</td>\n<td>浮点型数据，带小数点    通常32bit</td>\n</tr>\n<tr>\n<td>double</td>\n<td>浮点型数据，带小数点    通常64bit</td>\n</tr>\n<tr>\n<td>void</td>\n<td>空类型    </td>\n</tr>\n<tr>\n<td>signed</td>\n<td>带符号类型，用作数值    </td>\n</tr>\n<tr>\n<td>unsigned</td>\n<td>不带符号，用作内存    </td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"原码-补码-反码\"><a href=\"#原码-补码-反码\" class=\"headerlink\" title=\"原码/补码/反码\"></a>原码/补码/反码</h3><p><strong>机器数</strong></p>\n<pre><code>一个数在计算机中的二进制表示形式带符号，正数为0, 负数为1，叫做这个数的机器数\n例：十进制中的数 +3 ，机器数是00000011。-3 ，机器数是 10000011 \n</code></pre><p><strong>真值</strong></p>\n<pre><code>带符号位的机器数对应的真正数值称为机器数的真值。\n例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1\n</code></pre><p><strong>原码</strong></p>\n<pre><code>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。\n</code></pre><p><strong>反码</strong></p>\n<pre><code>正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n</code></pre><p><strong>补码</strong></p>\n<pre><code>正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\n</code></pre><p><strong>为什么会有原码反码补码？</strong><br>计算机无法判断符号（硬件难于实现），因此使用符号位参与运算。</p>\n<ul>\n<li>首先来看原码:<br>计算十进制的表达式: <code>1-1=0</code><pre><code>  1 - 1 \n= 1 + (-1) \n= [00000001]原 + [10000001]原 \n= [10000010]原 \n= -2    `    \n</code></pre>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是<strong>不正确的</strong>。</li>\n<li>为了解决原码做减法的问题, 出现了反码:<br>计算十进制的表达式: <code>1-1=0</code><pre><code>  1 - 1 \n= 1 + (-1) \n= [0000 0001]原 + [1000 0001]原\n= [0000 0001]反 + [1111 1110]反 \n= [1111 1111]反 = [1000 0000]原 \n= -0\n</code></pre>会有[0000 0000]原和[1000 0000]原两个编码表示0.</li>\n<li>于是补码的出现, 解决了0的符号以及两个编码的问题:<pre><code>  1-1 = 1 + (-1) \n= [0000 0001]原 + [1000 0001]原 \n= [0000 0001]补 + [1111 1111]补 \n= [0000 0000]补\n=[0000 0000]原\n</code></pre>这样<strong>0用[0000 0000]表示</strong>, 而以前出现问题的-0则不存在了.而且可以用<strong>[1000 0000]表示-128</strong>。</li>\n</ul>\n<h3 id=\"ASCII码表\"><a href=\"#ASCII码表\" class=\"headerlink\" title=\"ASCII码表\"></a>ASCII码表</h3><table>\n<thead>\n<tr>\n<th>Bin</th>\n<th>Dec</th>\n<th>Hex</th>\n<th>缩写/字符</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0000 0000</td>\n<td>0</td>\n<td>00</td>\n<td>NUL(null)</td>\n<td>空字符</td>\n</tr>\n<tr>\n<td>0000 1000</td>\n<td>8</td>\n<td>08</td>\n<td>BS (backspace)</td>\n<td>退格</td>\n</tr>\n<tr>\n<td>0000 1001</td>\n<td>9</td>\n<td>09</td>\n<td>HT (horizontal tab)</td>\n<td>水平制表符</td>\n</tr>\n<tr>\n<td>0000 1010</td>\n<td>10</td>\n<td>0A</td>\n<td>LF (NL line feed, new line)</td>\n<td>换行键</td>\n</tr>\n<tr>\n<td>0000 1101</td>\n<td>13</td>\n<td>0D</td>\n<td>CR (carriage return)</td>\n<td>回车键        </td>\n</tr>\n<tr>\n<td>0010 0000</td>\n<td>32</td>\n<td>20</td>\n<td>(space)</td>\n<td>空格        </td>\n</tr>\n<tr>\n<td>00110000</td>\n<td>48-57</td>\n<td>30-39</td>\n<td>0-9</td>\n<td>数字        </td>\n</tr>\n<tr>\n<td>01000001</td>\n<td>65-90</td>\n<td>41-5A</td>\n<td>A-Z</td>\n<td>大写字母    同字母大小写相差32</td>\n</tr>\n<tr>\n<td>01100001</td>\n<td>97-122</td>\n<td>61-7A</td>\n<td>a-z</td>\n<td>小写字母        </td>\n</tr>\n<tr>\n<td>01111111</td>\n<td>127</td>\n<td>7F</td>\n<td>DEL (delete)</td>\n<td>删除</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-自定义数据类型——（4个）\"><a href=\"#2-自定义数据类型——（4个）\" class=\"headerlink\" title=\"2.自定义数据类型——（4个）\"></a>2.自定义数据类型——（4个）</h2><p>自定义数据类型相当于基本数据类型的集合。</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>struct</td>\n<td>结构体</td>\n<td>内存占用2字节或4字节对齐</td>\n</tr>\n<tr>\n<td>union</td>\n<td>共用体（联合体）</td>\n<td>以最大的元素占用内存</td>\n</tr>\n<tr>\n<td>enum</td>\n<td>枚举常量</td>\n<td>枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。枚举元素不是字符常量也不是字符串常量，使用时不要加单、双引号</td>\n</tr>\n<tr>\n<td>typedef</td>\n<td>数据类型别名</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-逻辑结构——（11个）\"><a href=\"#3-逻辑结构——（11个）\" class=\"headerlink\" title=\"3.逻辑结构——（11个）\"></a>3.逻辑结构——（11个）</h2><p>C语言的逻辑结构有三种：顺序，分支，循环</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if、else</td>\n<td>分支结构    </td>\n</tr>\n<tr>\n<td>switch、case、default</td>\n<td>分支结构    switch条件只能是整形数字</td>\n</tr>\n<tr>\n<td>do、while</td>\n<td>循环结构    先后顺序 条件循环</td>\n</tr>\n<tr>\n<td>for</td>\n<td>循环结构    次数循环</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>跳转    跳出本次循环继续进行下次循环</td>\n</tr>\n<tr>\n<td>break</td>\n<td>跳转    跳出当前循环进入下个语句</td>\n</tr>\n<tr>\n<td>goto</td>\n<td>不建议使用    </td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-类型修饰符——（6个）\"><a href=\"#4-类型修饰符——（6个）\" class=\"headerlink\" title=\"4.类型修饰符——（6个）\"></a>4.类型修饰符——（6个）</h2><p>类型修饰符是对资源存放位置的限定</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>默认情况    局部变量存放于栈空间</td>\n</tr>\n<tr>\n<td>register</td>\n<td>限制变量定义在寄存器上的修饰符    存放在寄存器，无法用&amp;取地址</td>\n</tr>\n<tr>\n<td>static</td>\n<td>静态    </td>\n</tr>\n<tr>\n<td>const</td>\n<td>定义为常量,防止被修改    </td>\n</tr>\n<tr>\n<td>extern</td>\n<td>外部引用    外部文件</td>\n</tr>\n<tr>\n<td>volatile</td>\n<td>编译优化选项    </td>\n</tr>\n</tbody>\n</table>\n<p><strong>static详解</strong></p>\n<ul>\n<li>修饰全局变量：定义全局变量为静态全局变量<br>存放在.data（初始化）和.bss（未初始化）<br>外部文件无法引用</li>\n<li>修饰局部变量：定义为静态局部变量<br>存放区域为.data<br>生命周期为整个程序的生命周期，但依旧只有定义他的函数能够使用<br>值，初始化为0，每次调用会读取上次的值。</li>\n<li>修饰函数：定义为静态函数<br>只能在本文件调用</li>\n</ul>\n<p><strong>const详解</strong></p>\n<ul>\n<li>修饰变量<br>  定义变量为不可改变的。</li>\n<li>修饰指针<br>  const char <em>p     修饰的是</em>p，p指向的内容不能被更改<br>  char <em> const p     修饰的是p，指针不能被更改<br>  const char </em> const p    指针和内容都不能被更改</li>\n<li>修饰函数</li>\n<li>修饰输入参数<br>  值传递    无需const保护<br>  指针传递    防止更改原有指针指向的内容，对参数内容只读不写</li>\n</ul>\n<h2 id=\"5-其它\"><a href=\"#5-其它\" class=\"headerlink\" title=\"5.其它\"></a>5.其它</h2><table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>return</td>\n<td>返回。</td>\n</tr>\n<tr>\n<td>sizeof</td>\n<td>查看内存容量</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"二、运算符\"><a href=\"#二、运算符\" class=\"headerlink\" title=\"二、运算符\"></a>二、运算符</h1><h2 id=\"1-运算符的分类\"><a href=\"#1-运算符的分类\" class=\"headerlink\" title=\"1. 运算符的分类\"></a>1. 运算符的分类</h2><table>\n<thead>\n<tr>\n<th>类别</th>\n<th>符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>算术运算符</td>\n<td>加 <code>+</code> 减 <code>-</code> 乘 <code>*</code> 除 <code>/</code> 取余 <code>%</code></td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>与 <code>&amp;&amp;</code> 或  非 <code>！</code> </td>\n</tr>\n<tr>\n<td>问号运算</td>\n<td><code>？</code> <code>：</code></td>\n</tr>\n<tr>\n<td>关系运算</td>\n<td>小于 <code>&lt;</code>   小于等于 <code>&lt;=</code>   大于 <code>&gt;</code>  大于等于 <code>&gt;=</code>   等于 <code>==</code>   不等于 !<code>=</code></td>\n</tr>\n<tr>\n<td>位运算</td>\n<td>左移 <code>&lt;&lt;</code>      右移<code>&gt;&gt;</code>    按位与 <code>&amp;</code>    按位或    按位异或 <code>^</code></td>\n</tr>\n<tr>\n<td>赋值运算</td>\n<td>等于 <code>=</code>   加等于 <code>+=</code>    剪等于 <code>-=</code>   等等</td>\n</tr>\n<tr>\n<td>三目运算</td>\n<td>表达式A<code>？</code>表达式B<code>：</code>表达式C      如果表达式A为真，那么表达式B为整个表达式的值；为假 ， 那么表达式C为整个表达式的值。</td>\n</tr>\n<tr>\n<td>逗号运算</td>\n<td>从左到右依次计算，最后表达式的值，作为整个表达式的值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-运算优先级\"><a href=\"#2-运算优先级\" class=\"headerlink\" title=\"2. 运算优先级\"></a>2. 运算优先级</h2><table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>运算符</th>\n<th>结合方向</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1成员包含</td>\n<td>[]数组下标            ()圆括号                             .成员选择（对象）      -&gt;成员选择（指针）</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>2单目运算</td>\n<td>-负号运算符        (类型)强制类型转换      ++自增运算符               –自减运算符</td>\n<td>右到左</td>\n</tr>\n<tr>\n<td></td>\n<td>*取值运算符         &amp;取地址运算符              !逻辑非运算符                ~按位取反运算符           sizeof长度运算符</td>\n<td></td>\n</tr>\n<tr>\n<td>3算术运算</td>\n<td>加减乘除取余</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>4位移</td>\n<td>&lt;&lt; 左移               &gt;&gt; 右移</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>5比较</td>\n<td>> 大于&gt;=大于等于                        &lt; 小于  &lt;=小于等于</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td></td>\n<td>==等于                !=不等于</td>\n<td></td>\n</tr>\n<tr>\n<td>6位比较</td>\n<td>&amp;按位与             ^按位异或                            按位或</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>7逻辑运算</td>\n<td>&amp;&amp;逻辑与         逻辑或</td>\n<td>左到右</td>\n</tr>\n<tr>\n<td>8条件运算</td>\n<td>?:条件运算符</td>\n<td>右到左</td>\n</tr>\n<tr>\n<td>9赋值运算</td>\n<td>=赋值运算符       /=除后赋值                       *=乘后赋值                     %=取模后赋值</td>\n<td>右到左</td>\n</tr>\n<tr>\n<td>10逗号</td>\n<td>,逗号运算符</td>\n<td>左到右</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-神奇的运算\"><a href=\"#3-神奇的运算\" class=\"headerlink\" title=\"3. 神奇的运算\"></a>3. 神奇的运算</h2><p><strong>取余运算：</strong></p>\n<pre><code>取一个范围的数(m% 100)+1 ===&gt; res；得到M进制的一个个位数；循环数据结构的下标\n</code></pre><p><strong>逻辑运算：</strong></p>\n<pre><code>返回值0与1                           !与~不同\n</code></pre><p><strong>位运算：</strong></p>\n<pre><code>&lt;&lt; 左移相当于乘以2 &gt;&gt; 右移相当于除以2\n&amp; 与0屏蔽用于清零  与1用于取出          | 或0保留用于取出 或1用于设置\n</code></pre><h1 id=\"三、C语言的内存使用\"><a href=\"#三、C语言的内存使用\" class=\"headerlink\" title=\"三、C语言的内存使用\"></a>三、C语言的内存使用</h1><h2 id=\"1-指针\"><a href=\"#1-指针\" class=\"headerlink\" title=\"1. 指针\"></a>1. 指针</h2><p><strong>指针：</strong>内存类型资源地址<br><strong>指针变量 ：</strong>存放指针这个概念的盒子。所有的指针在32位系统中都是4字节。<br><strong>指针的类型：</strong>去掉变量后的内容<br><strong>指针所指向的类型：</strong>去掉*后的内容<br><strong>指针的值/叫指针所指向的内存区：</strong>指向内容的首地址<br><strong>指针本身所占据的内存区：</strong>在32位系统中都是4字节<br><strong>指针的加减N：</strong>将现有指针指向的内存区加减 指针指向类型的大小 * N</p>\n<h3 id=\"常见的指针类型：\"><a href=\"#常见的指针类型：\" class=\"headerlink\" title=\"常见的指针类型：\"></a>常见的指针类型：</h3><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int p;</td>\n<td>这是一个普通的整型变量</td>\n</tr>\n<tr>\n<td>int *p;</td>\n<td>首先从 P 处开始,先与*结合,所以说明 P 是一个指针,<br>然后再与 int 结合,说明指针所指向的内容的类型为 int 型.<br>所以 P 是一个返回整型数据的指针</td>\n</tr>\n<tr>\n<td>int p[3];</td>\n<td>首先从 P 处开始,先与[]结合,说明 P 是一个数组,<br>然后与 int 结合,说明数组里的元素是整型的,<br>所以 P 是一个由整型数据组成的数组</td>\n</tr>\n<tr>\n<td>int *p[3];</td>\n<td>首先从 P 处开始,先与[]结合,因为其优先级比*高,所以 P 是一个数组,<br>然后再与*结合,说明数组里的元素是指针类型,<br>然后再与 int 结合,说明指针所指向的内容的类型是整型的.<br>所以P 是一个由返回整型数据的指针所组成的数组</td>\n</tr>\n<tr>\n<td>int (*p)[3];</td>\n<td>首先从 P 处开始,先与*结合,说明 P 是一个指针<br>然后再与[]结合,说明指针所指向的内容是一个数组,<br>然后再与 int 结合,说明数组里的元素是整型的.<br>所以 P 是一个指向由整型数据组成的数组的指针</td>\n</tr>\n<tr>\n<td>int **p;</td>\n<td>首先从 P 开始,先与*结合,说明是 P 是一个指针,<br>然后再与*结合,说明指针所指向的元素是指针,<br>然后再与 int 结合,说明该指针所指向的元素是整型数据.</td>\n</tr>\n<tr>\n<td>int p(int);</td>\n<td>从 P 处起,先与()结合,说明 P 是一个函数,<br>然后进入//()里分析,说明该函数有一个整型变量的参数<br>然后再与外面的 int 结合,说明函数的返回值是一个整型数据</td>\n</tr>\n<tr>\n<td>Int (*p)(int);</td>\n<td>从 P 处开始,先与指针结合,说明 P 是一个指针,<br>然后与()结合,说明指针指向的是一个函数,<br>然后再与()里的int 结合,说明函数有一个 int 型的参数,<br>再与最外层的int 结合,说明函数的返回类型是整型,<br>所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针</td>\n</tr>\n<tr>\n<td>int *(*p(int))[3];</td>\n<td>从 P 开始,先与()结合,说明 P 是一个函数,<br>然后进入()里面,与 int 结合,说明函数有一个整型变量参数,<br>然后再与外面的*结合,说明函数返回的是一个指针,<br>然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,<br>然后再与*结合,说明数组里的元素是指针,<br>然后再与 int 结合,说明指针指向的内容是整型数据.<br>所以 P 是一个参数为一个整数且返回一个指向由整型指针变量组成的数组的指针变量的函数.</td>\n</tr>\n<tr>\n<td>int *(*p[3])(void*);</td>\n<td>首先和[]结合，说明p是一个数组,<br>然后和*结合，说明数组中的每个元素都是一个指针，<br>然后和()结合，说明指针指向的是一个函数，<br>最后，与外层相结合说明这个函数的输入参数为void*型，返回值为int * 型，<br>所以p是一个含有三个元素的数组，每个数组元素都是一个参数为一个整数且返回一个指向整型指针的函数.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-数组\"><a href=\"#2-数组\" class=\"headerlink\" title=\"2. 数组\"></a>2. 数组</h2><p>数组是具有一定顺序关系的若干个变量的集合，组成数组的各个变量称为数组的元素。<br>数组的元素地址空间是连续的。</p>\n<p>  <code>&lt;存储类型&gt;   &lt;数据类型 &gt;    &lt;数组名&gt;[&lt;表达式&gt;]</code></p>\n<p>数组是内存的一种分配方式，数组名是一个常量符号，一定不要放到=的左边。<br><strong>数组的赋值</strong></p>\n<ol>\n<li>按照标签逐一处理<br><code>int a[10];     [ 0 - 9 ]</code><br><code>a[0] = xx</code><br><code>a[1] = yy;</code></li>\n<li>空间定义时，就告知编译器的初始化情况，空间的第一次赋值，初始化操作<br><code>int a[10] = 空间;</code></li>\n<li>C语言本身，CPU内部本身一般不支持空间和空间的拷贝<br><code>int a[10] = {10,20,30}; ====&gt; a[0] = 10; a[1] = 20; a[2] = 30; a[3]=0;</code></li>\n</ol>\n<h2 id=\"3-内存分布\"><a href=\"#3-内存分布\" class=\"headerlink\" title=\"3. 内存分布\"></a>3. 内存分布</h2><p>内存的属性： 1、<strong>大小</strong>       2、<strong>在哪里</strong></p>\n<h3 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>含义</th>\n<th>访问权限</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内核空间</td>\n<td>应用程序不许访问（3G-4G）</td>\n</tr>\n<tr>\n<td>栈空间</td>\n<td>局部变量</td>\n<td>RW</td>\n<td>向下增长</td>\n</tr>\n<tr>\n<td>运行时的堆空间</td>\n<td>malloc</td>\n<td>RW</td>\n<td>向上增长</td>\n</tr>\n<tr>\n<td>全局的数据空间 （未初始化） 0</td>\n<td>static</td>\n<td>RW</td>\n<td>bss</td>\n</tr>\n<tr>\n<td>全局的数据空间（初始化的）</td>\n<td>static</td>\n<td>RW</td>\n<td>data</td>\n</tr>\n<tr>\n<td>只读数据段</td>\n<td>“hello world” 字符串常量</td>\n<td>R</td>\n<td>TEXT</td>\n</tr>\n<tr>\n<td>代码段</td>\n<td>code</td>\n<td>R</td>\n<td>TEXT</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"存储时：\"><a href=\"#存储时：\" class=\"headerlink\" title=\"存储时：\"></a>存储时：</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>标识</th>\n<th>访问权限</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据区（未初始化）</td>\n<td>bss</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>数据区（初始化的）</td>\n<td>data</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>代码段</td>\n<td>code</td>\n<td>R</td>\n<td>TEXT</td>\n</tr>\n</tbody>\n</table>\n<p><strong>栈空间：</strong>运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内<br><strong>堆空间：</strong>运行时，可以自由，自我管理的分配和释放的空间，生存周期是由程序员来决定</p>\n<h1 id=\"四、函数\"><a href=\"#四、函数\" class=\"headerlink\" title=\"四、函数\"></a>四、函数</h1><h2 id=\"1-函数概述\"><a href=\"#1-函数概述\" class=\"headerlink\" title=\"1. 函数概述\"></a>1. 函数概述</h2><p>一堆代码的集合，用一个标签去描述它，为了实现代码的复用化<br>标签 —– 函数名，函数具备3要素：<br><strong>1、函数名   （地址）</strong><br><strong>2、输入参数</strong><br><strong>3、返回值</strong><br>在定义函数时，必须将3要素告知编译器。</p>\n<h2 id=\"2-输入参数\"><a href=\"#2-输入参数\" class=\"headerlink\" title=\"2. 输入参数\"></a>2. 输入参数</h2><p>承上启下的功能 </p>\n<ul>\n<li>调用者：<br>函数名（要传递的数据）                //实参</li>\n<li>被调者：<br>函数的具体实现<br>函数的返回值  函数名（接收的数据）        //形参</li>\n</ul>\n<p><strong>值传递</strong><br>上层调用者 保护自己空间值不被修改的能力<br><strong>地址传递</strong><br>上层，调用者 让下层 子函数 修改自己空间值的方式</p>\n<ul>\n<li>子函数看看空间里的情况       const  *</li>\n<li>子函数反向修改上层空间里的内容     char * </li>\n</ul>\n<h2 id=\"3-返回值\"><a href=\"#3-返回值\" class=\"headerlink\" title=\"3. 返回值\"></a>3. 返回值</h2><p>提供启下功能的一种表现形式</p>"},{"title":"C语言学习总结（五）——C库函数总结","date":"2016-12-08T06:31:21.000Z","_content":"C 库函数主要指那些由美国国家标准协会（ANSI）或国际标准化组织(ISO)发布的标准中规定的库函数，按照标准 C 的要求来进行 C 语言编程是很重要的，因为这样你的代码才有可能跨平台使用。\n<!--more-->\n最早的 `C89` 中有15个标准头文件：\n>  assert.h   ctype.h   errno.h   float.h   limits.h    \n locale.h   math.h   setjmp.h   signal.h   stdarg.h   \n stddef.h   stdio.h   stdlib.h   string.h   time.h   \n\n随后的 `C95` 增加了3个标准头文件：\n> iso646.h   wchar.h   wctype.h \n\n其次 `C99` 增加了6个标准头文件：\n>  complex.h    fenv.h   inttypes.h    stdbool.h    stdint.h   tgmath.h \n\n最新的 `C11` 又增加了5个标准头文件：\n>  stdalign.h   stdatomic.h   stdnoreturn.h   threads.h   uchar.h \n\n所以目前总共有29个标准头文件，但是大部分的编译器并没有支持全部的C标注，所以目前我们在这里讨论的主要还是 `C89` 中的15个标准头文件。\n\n## 相关头文件的内容说明\n`C89` 的15个标准头文件的主要内容如下：\n\n|头文件|说明|头文件|说明|头文件|说明|\n|--|--|--|--|--|--|\n| assert.h |断言相关| ctype.h |字符类型判断| errno.h |标准错误机制|\n| float.h |浮点限制| limits.h |整形限制| locale.h |本地化接口|\n| math.h |数学函数| setjmp.h |非本地跳转| signal.h |信号相关|\n| stdarg.h |可变参数处理| stddef.h |宏和类型定义| stdio.h |标准I/O|\n| stdlib.h |标准工具库| string.h |字符串和内存处理| time.h |时间相关|\n\n有人说，标准库(C89)——也就是ISO C——可以分为3组，根据这3组可以分出三种层次的程序员：\n* 合格程序员： ctype.h 、 stdio.h 、 stdlib.h 、 string \n* 熟练程序员： assert.h 、 limits.h 、 stddef.h 、 time.h \n* 优秀程序员： float.h 、 math.h 、 errno.h 、 locale.h 、 setjmp.h 、 signal.h 、 stdarg.h \n作为一个走在优秀程序员路上的 XX 程序员，这里简单把三个层次分开说一下。\n\n## 合格程序员的层次\n###  ctype.h \n ctype.h 这个头文件主要定义了一批 C 语言字符分类函数，所有的函数都只有一个参数，且参数和返回值均为 `int` 类型。下面是简单的函数介绍：\n\n|函数名|说明|函数名|说明|函数名|说明|\n|-----|----|------|----|-----|----|\n|isalpha|是否为字母|isdigit|是否为数字|isalnum|是否为数字或字母|\n|iscntrl|是否为控制字符|isgraph|是否为图形文字|isupper|是否为大写字母|\n|islower|是否为小写字母|tolower|转换为小写字母|toupper|转换为大写字母|\n|isprintf|是否为可打印字符|ispunct|是否为标点符号|isspace|是否为空白|\n|isxdigit|是否为十六进制的数字||||||\n###  stdio.h \n stdio.h 这个头文件应该是大多数人接触 C 语言的时候第一个认识的 C 库函数。这个函数最常用，但是也很复杂。它定义了三种类型，一些宏和很多的输入输出函数。\n\n1. 定义的三种类型：  \n * `size_t` 是由 `sizeof` 关键字产生的无符号整类型。\n * `FILE` 是一个结构体类型，记录了控制流需要的所有信息，包括它的文件定位符、指向相关缓冲的指针、记录是否发生了读/写错误的错误提示符和记录文件是否结束的文件结束符。 \n * `fpos_t`包含可以唯一指定文件中的每一个位置所需的所有信息。\n2. 定义了一些常量：  \n * `NULL` 空值 \n * `_IOFBF` 表示完全缓冲 `_IOLBF` 表示线缓冲 `_IONBF` 表示无缓存\n * `BUFSIZ` 是`setbuf`函数所使用的缓冲区的大小\n * `EOF` 是负整数,该表达式由几个函数返回来说明文件的结束，即一个流输入结束了(END OF FILE)\n * `FOPEN_MAX` (20)同时打开的文件的最大数量\n * `FILENAME_MAX` 文件名的最大长度\n * `L_tmpnam`整数，最大长度的临时文件名\n * `SEEK_CUR`取得目前文件位置 `SEEK_END` 将读写位置移到文件尾时 `SEEK_SET` 将读写位置移到文件开头\n * `TMP_MAX` 表示`tmpnam`函数可以生成的单独文件名的最大数目\n * ``stderr`标准错误流，默认为屏幕, 可输出到文件 `stdin`标准输入流，默认为键盘 `stdout`标准输出流，默认为屏幕 \n3. 一些相关的函数\n * 文件操作函数 （4个）  \n `int remove(const char *filename);`  删除文件  \n `int rename(const char *old, const char *new);`  重命名文件  \n `FILE *tmpfile(void);` 创建一个临时的二进制文件，并通过模式“wb+”打开。  \n `char *tmpname（char *s）;` 生成一个字符串，这个字符串是一个有效的文件名。  \n * 文件访问函数 (6个)  \n `FILE* fopen(const char *filename, const char *mode);`打开名字为 `filename` 指向的文件，并且把这个文件和一个流相关联。    \n `FILE* freopen(const char *filename, const char *mode, FILE *stream);`打开名字为 `filename` 指向的文件，并且把它和 `stream` 指向的流关联在一起。  \n `int fclose(FILE *stream);`使 `stream` 指向的流被清空，并且和流相关联的文件被关闭。  \n `int fflush(FILE *stream);`对 `stream` 指向的流执行清空行为。  \n `void setbuf(FILE *stream, char *buf);`除了没有返回值，等价于函数 `setvbuf`。  \n `void setvbuf(FILE *stream, char *buf, int mode, size_t size);`设定 `stream` 缓冲的方式。   \n * 格式化的输入输出函数 （9个）  \n `int fprintf(FILE *stream, const char *format, ...);`  \n `int printf(const char *format, ...);`  \n `int sprintf(char *s, const char *format, ...);`  \n 返回传送的字符的数目。  \n `int fscanf(FILE *stream, const char *format, ...);`  \n `int scanf(const char *format, ...);`  \n `int sscanf(char *s, const char *format, ...);`  \n 如果在任何转换之前发生了输入失败，返回 `EOF`；否则返回赋值的输入项的数目。  \n `int vfprintf(FILE *stream, const char *format, va_list arg);`  \n `int vprintf(const char *format, va_list arg);`  \n `int vsprintf(char *s, const char *format, va_list arg);`  \n 等价于对应的 `printf` 函数，不过可变参数表用 `arg` 代替。   \n * 字符输入/输出函数 （11个）  \n `int fgetc(FILE *stream);`从 `stream` 指向的输入流中读取下一个字符。  \n `int getc(FILE *stream);`等价于函数 `fgetc`。  \n `int getchar(void);`等价于用参数 `stdin` 调用函数 `getc`。  \n `int fputc(int c, FILE *stream);`把字符写到指向的输出流中指定的位置处。  \n `int putc(int c, FILE *stream);`等价于 `fputc。`  \n `int putchar(int c);` 等价于把stdout作为第二个参数调用的 `putc。`  \n `char *fgets(char *s, int n, FILE *stream);`从 `stream`指向的流中读取字符。  \n `int fputs(const char *s, FILE *stream);`把 `s` 指向的串写入 `stream` 指向的流中。  \n `char *gets(char *s);`从 `stdin` 指向的输入流中读取若干个字符，并将其保留到 `s` 指向的数组中，直到遇到文件结束符或者读取一个换行符。  \n `int puts(const char *s);`把 `s` 指向的串写到 `stdout` 指向的流中，并且在输出最后添加一个换行符。  \n `int ungetc(int c, FILE *stream);` 把 `c` 指定的字符（转换为 `unsigned char` 类型）退回到 `stream` 指向的输入流中。  \n * 直接输入/输出函数 （2个）  \n `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`  \n 从 `stream` 指向的流中读取最多 `nmemb` 个元素到 `ptr` 指向的数组中 。  \n `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);`  \n 从 `ptr` 指向的数组中读取最多 `nmemb` 个元素并将其写到 `stream` 指向的流中。  \n * 文件定位函数 (5个)\n `int fgetpos(FILE *stream, fpos_t *pos);`\n 把 `stream` 指向的流的文件定位符的当前值存储到 `pos` 指向的对象中。\n `int fsetpos(FILE *stream, const fpos_t *pos);`\n 根据 `pos` 指向的对象的值来设置 `stream` 指向的流的文件定位符，\n `long int ftell(FILE *stream);`\n 获得 `stream` 指向的流的文件定位符的当前值。\n `int fseek(FILE *stream, long int offset, int whence);`\n 为 `stream` 指向的流设置文件定位符。\n `void rewind(FILE *stream);`\n 把 `stream` 指向的流的文件定位符设置在文件的开始位置，等价于 `(void)fseek(stream, 0L, SEEK_SET);`，只不过流的错误指示符也被清零。\n * 错误处理函数 (4个)\n `void clearerr(FILE *stream);`\n 清空 `stream` 指向的流的文件结束符和错误指示符。\n `int feof(FILE *stream);`\n 测试 `stream` 指向的流的文件结束符。当且仅当 `stream` 流设置了文件结束符时函数返回一个非0值。\n `int ferror(FILE *stream);`\n 测试 `stream` 指向的流的错误指示符。当且仅当 `stream` 流设置了错误指示符时函数返回一个非0值。\n `void perror(const char *s);`\n 把整数表达式 `errno` 中的错误编号转换为一条错误消息。\n\n### stdlib.h\n是标准工具库。包含了C语言的中最常用的系统函数\n\n1. 定义了五个宏\n * `NULL` 空\n * `EXIT_FAILURE` 失败状态码\n * `EXIT_SUCCESS` 成功状态码\n * `RAND_MAX rand` 的最大返回值\n * `MB_CUR_MAX` 多字节字符中的最大字节数\n2. 定义了四个类型：\n * `size_t` 是由 `sizeof` 关键字产生的无符号整类型。\n * `wchar_t` 是一个整型，标识一个宽字节字符，例如 `L’x’` 的类型就是 `wchar_t`。\n * `div_t` 是结构体类型 作为 `div` 函数的返回类型\n * `ldiv_t` 是一个结构类型，是函数 `ldiv` 的返回值类型。\n3. 定义了六类函数：\n * 字符串函数\n`double atof(const char *nptr);` 将字符串转换成浮点型数\n`int atoi(const char *nptr);` 将字符串转换成整型数\n`long int atol(const char *nptr);`将字符串转换成长整型数\n`double strtod(const char *nptr, char **endptr);`将字符串转换成浮点数\n`long int strtol(const char *nptr, char **endptr, int base);`将字符串转换成长整型数\n`unsigned long int strtoul(const char *nptr, char **endptr, int base);` 将字符串转换成无符号长整型数 \n * 内存控制函数\n`void *calloc(size_t nmemb, size_t size);` 配置内存空间\n`void free(void *ptr);` 释放原先配置的内存\n`void *malloc(size_t size);` 配置内存空间\n`void *realloc(void *ptr, size_t size);`重新分配主存\n * 环境函数\n`int atexit(void (*func)(void)); `\n注册func指向的函数，该函数在程序正常终止的时候被调用。\n`void exit(int status); `\n使程序正常终止。 \n`void abort(void);` \n使程序异常终止，除非捕获了信号SIGABRT且信号处理程序没有返回。\n`char *getenv(const char *name);` \n搜索宿主环境提供的环境表，来查找一个能和name指向的串匹配的串。\n`int system(const char *string); `\n把sring指向的串传递给宿主环境，然后命令处理程序按照实现定义的方式执行它。\n * 搜索和排序函数\n`void bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compare)(const void , const void *)); `\n搜索一个拥有 `nmemb` 个元素的数组，来查找与 `key` 指向的对象匹配的元素，\n`void qsort(void base, size_t nmemb, size_t size, int (*compare)(const void , const void *)); ` \n根据 `compare` 所指向的比较函数将数组内容排列成升序。\n * 数学函数\n`int abs(int j);`计算整型数的绝对值\n`long int labs(long int j);`将两个整数相除, 返回商和余数\n`div_t div(int number, int denom);`取长整型绝对值\n`ldiv_t ldiv(long int number, long int denom);`两个长整型数相除, 返回商和余数\n`int rand(void);` 随机数发生器\n`void srand(unsigned int seed);` 设置随机数种子\n * 多字节函数\n`int mblen(const char *s, size_t n); `根据locale的设置确定字符的字节数\n`int mbtowc(wchar_t *pwc, const char *s, size_t n); `把多字节字符转换为宽字符\n`int wctomb(char *s, wchar_t wchar); `把宽字符转换为多字节字符\n`size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n); `把多字节字符串转换为宽字符串\n`size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);`把宽字符串转换为多字节字符串\n\n### string \n包含了C语言的最常用的字符串操作函数\n\n1. 定义了一个宏： `NULL` 空\n2. 定义了一个变量： `size_t`\n3. 定义了五类函数：\n * 名字以mem开头的函数对任意的字符序列进行操作。其中一个参数指向字符串的起始位置，另一个参数对元素的个数尽行计数。 \n`void *memmove(void *s1, const void *s2, size_t n);`\n`void *memcpy(void *s1, const void *s2, size_t n);`\nmemmove和memcpy均从s2指向的对象中复制n个字符到s1指向的对象中，返回s1的值。不同之处在于，当复制发生在两个重叠的对象中，memcpy对这种行为未定义，memmove则可以正确执行。\n`int memcmp(const void *s1, const void *s2, size_t n);`\n比较s1和s2指向的对象中前n个字符。\n`void *memchr(const void *s, int c, size_t n);`\n返回指向定位的字符的指针，如果没有返回空指针。\n`void *memset(void *s, int c, size_t n);`\n把c的值复制到s指向的对象的前n个字符的每个字符中，返回s的值。\n * 名字以strn开头的函数对非空字符序列进行操作。 \n `char *strcpy(char *s1, const char *s2);`\n包括终止的空字符，返回s1的值\n`char *strcat(char *s1, const char *s2);`\n包括终止的空字符，返回s1的值。\n`int strcmp(const char *s1, const char *s2);`\n比较s1和s2指向的串。\n`char *strchr(const char *s, int c);`\n终止的空字符被认为串的一部分。\n`char *strrchr(cosnt char *s, int c);`\n确定c在s指向的串中最后一次出现的位置。r意为right一侧。\n`char *strstr(const char *s1, const char *s2);`\ns2指向的串的字符序列在s1指向的串中第一次出现的位置。\n`size_t strspn(const char *s1, const char *s2);`\n计算s1指向的字符串中完全由s2指向的字符串中的字符组成的最大初始段的长度。也就是说，它从s1的开头搜索一个和s2中的任意元素都不匹配的字符，返回此字符的下标。\n`size_t strcspn(const char *s1, const char *s2);`\n查找两个字符串第一个相同的字符在s1中的位置，也就是The first char both in s1 and s2，如果没有则返回终止的空字符的索引。\nstrcspn和strchr很相似，但它匹配的是任意一个字符集而不是一个字符。\n`char *strpbrk(const char *s1, const char *s2);`\n确定s2指向的串中的任意的字符在s1中第一次出现的位置。\n`char *strtok(char *s1, const char *s2);`\n分解字符串为一组字符串。s1为要分解的字符串，s2为分隔符字符串。\n * 名字以str开头的函数对空字符结尾的字符序列进行操作。\n`char *strncpy(char *s1, const char *s2, size_t n);`\n从s2指向的数组中复制最多n个字符（包括空字符），不会在s1的末尾自动添加空字符；如果达到n个字符之前遇到了空字符，则复制完空字符后停止，并在s1指向的数组后面添加空字符，直到写入了n个字符。\n简单来说，复制，直到遇到空字符或达到n个字符，如果此时复制的字符数未达到n，就填充空字符，直到字符数达到n。\n`char *strncat(char *s1, const char *s2, size_t n);`\n从s2指向的数组中将最多n个字符（空字符及其后面的字符不添加）添加到s1指向的串的结尾。在最后的结果后面加上一个空字符。\n简单来说，cat，直到遇到空字符或达到n个字符，最后的结果一定以空字符结尾。\n`int strncmp(const char *s1, const char *s2, size_t n);`\n对s1和s2指向的数组中的最多n个字符进行比较（空字符后面的字符不参加比较）。\n * 其他类\n`size_t strlen(const char *s);`\n计算s指向的串的长度，不包括结尾的空字符。\n`char *strerror(int errnum);`\n将errnum中的错误编号对应到一个错误信息串。\n * 与区域设置有关\n`int strcoll(const char *s1, const char *s2);`\n功能同strcmp，只是比较时串都被解释为适合当前区域设置的类别LC_COLLATE的形式。\n`size_t strxfrm(char *s1, const char *s2, size_t n);`\n如果区域选项是”POSIX”或者”C”，那么strxfrm()同用strncpy()来拷贝字符串是等价的。\n\n## 熟练程序员的层次：\n### assert.h \n这个头文件只定义了一个宏：`assert`\n如果条件为假，assert将输出一些信息并调用abort函数退出程序。 \n一个可能的实现：\n````C++\n#define NDEBUG\n#include <assert.h>\t\nint main(int argc, char* argv[]) {\n  int a = 12;\n  int b = 24;\n  assert( a > b );\n  printf(\"a is larger than b!\");\n  return 0;\n}````\n\n上面的程序会发现程序中止，`printf` 并未执行，且有这样的输出：` main: Assertion 'a > b' failed. `原因就是因为 `a` 其实小于 `b`，导致断言失败，`assert` 输出错误信息，并调用 `abort()`中止了程序执行。\n\n### limits.h \n头文件定义了整型变量的一些极限值和设置。\n\n`CHAR_BIT` 一个ASCII字符长度  `SCHAR_MIN` 字符型最小值  \n`SCHAR_MAX` 字符型最大值  `UCHAR_MAX` 无符号字符型最大值  \n`CHAR_MIN`/`CHAR_MAX` char字符的最大最小值，如果char字符正被表示有符号整数。它们的值就跟有符号整数一样。否则char字符的最小值就是0，最大值就是无符号char字符的最大值。\n`MB_LEN_MAX` 一个字符所占最大字节数`SHRT_MIN` 最小短整型\n`SHRT_MAX` 最大短整形 `USHRT_MAX` 最大无符号短整型\n`INT_MIN` 最小整型 `INT_MAX` 最大整形\n`UINT_MAX` 最大无符号整型 `LONG_MIN` 最小长整型\n`LONG_MAX` 最大长整型 `ULONG_MAX` 无符号长整型\n\n### stddef.h \n此头文件定义了3个类型和2个宏，其中一些在其他头文件中也有定义。\n\n * 定义了三个类型 \n `ptrdiff_t`两个指针相减的结果的类型，有符号整型，一般来说是int或long的typedef。 \n `size_t`是sizeof操作符的结果的类型，无符号整型。 \n `wchar_t`是一个整型，标识一个宽字节字符，例如L’x’的类型就是wchar_t。\n * 定义了两个宏\n `NULL` 空指针常量。 \n `offsetof(type, member-designator)` 展开为一个size_t类型的整值常量表达式。\n\n### time.h \n作时间的函数。 \n\n1. 定义了两个宏\n * `NULL`\n * `CLOCKS_PER_SEC` 使 `clock` 函数的返回值 `CLOCKS_PER_SEC` 的单位是秒\n\n2. 定义了四个类型\n声明的类型有size_t、clock_t、time_t和struct tm。 \n * `size_t` 在 `stddef.h` 中已介绍过。 \n * `clock_t` 是 `clock` 函数的返回值类型\n * `time_t` 是 `time` 函数的返回值类型，\n * `struct tm` 保存了一个日历时间的各组成部分，比如年月日时分秒等。\n\n3. 定义了两类函数\n  * 时间获取函数\n  `time_t time(time_t *timer);`\n  取得目前的时间\n  `clock_t clock(void);`\n  确定处理器使用的时间。\n  * 时间转换函数\n  `struct tm *gmtime(const time_t *timer);`把日期和时间转换为(GMT)时间\n  `struct tm *localtime(const time_t *timer);`取得当地目前时间和日期\n  `char *ctime(const time_t *timer);` 把日期和时间转换为字符串\n  `time_t mktime(struct tm *timeptr);`将时间结构数据转换成经过的秒数\n  `char *asctime(const struct tm *timeptr);`将时间和日期以字符串格式表示\n  `size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);`将时间格式化\n  * 其他函数 \n  `double difftime(time_t time1, time_t time0); `\n  计算两个日历时间之差：`time1-time0，`返回以秒为单位的差值。这个函数似乎简单到没有存在的必要，直接执行减法不就得了。\n\n\n## 优秀程序员的层次：\n### float.h \nfloat 头文件类似 limit 头文件，主要是浮点型数值的相关定义。\n\n在所有实例里`FLT`指的是`float`，`DBL`是`double`，`LDBL`指的是`long double`.\n\n|变量|定义|\n|---|---|\n|FLT_ROUNDS |定义浮点型数值四舍五入的方式，-1是不确定，0是向0，1是向最近，2是向正无穷大，3是负无穷大|\n|FLT_RADIX 2|定义指数的基本表示（比如base-2是二进制，base-10是十进制表示法，16是十六进制）|\n|FLT_MANT_DIG，DBL_MANT_DIG，LDBL_MANT_DIG|定义数值里数字的个数\n|FLT_DIG 6，DBL_DIG 10，LDBL_DIG 10|在四舍五入之后能不更改表示的最大小数位\n|FLT_MIN_EXP，DBL_MIN_EXP，LDBL_MIN_EXP|FLT_RADIX 的指数的最小负整数值\n|FLT_MIN_10_EXP -37，DBL_MIN_10_EXP -37，LDBL_MIN_10_EXP -37|10进制表示法的的指数的最小负整数值\n|FLT_MAX_EXP ,DBL_MAX_EXP ,LDBL_MAX_EXP|FLT_RADIX 的指数的最大整数值\n|FLT_MAX_10_EXP +37 ,DBL_MAX_10_EXP ,LDBL_MAX_10_EXP +37 +37|10进制表示法的的指数的最大整数值\n|FLT_MAX 1E+37，DBL_MAX 1E+37，LDBL_MAX 1E+37|浮点型的最大限\n|FLT_EPSILON 1E-5，DBL_EPSILON 1E-9，LDBL_EPSILON 1E-9|能表示的最小有符号数\n\n### math.h \nmath.h是 C 语言内的数学函数库。\n\n|函数|含义|函数|含义|\n|--|--|--|--|\n|**三角函数**| | |  |\n|double sin(double x);| 正弦|double cos(double x);|余弦|\n|double tan(double x);|正切|*cot三角函数，可以使用tan(PI/2-x)来实现。||\n|**反三角函数**| | | |\n|double asin(double x);|结果介于[-PI/2, PI/2]|double acos(double x); |结果介于[0, PI]|\n|double atan(double x);|反正切(主值), <br>结果介于[-PI/2, PI/2] | double atan2(double y,double);|反正切(整圆值),<br> 结果介于[-PI, PI]|\n|**双曲三角函数**||||\n|double sinh(double x);|计算双曲正弦|double cosh(double x);|计算双曲余弦|\n|double tanh(double x);|计算双曲正切|||\n|**指数与对数**||||\n|double exp(double x); |求取自然数e的幂|double sqrt(double x);|开平方|\n|double log(double x);|以e为底的对数|double log10(double x);|以10为底的对数|\n|double pow(double x, double y);|计算以x为底数的y次幂| float powf(float x, float y);|与pow一致，输入与输出皆为浮点数|\n|**取整**||||\n|double ceil(double);|取上整|double floor(double);|取下整|\n|**标准化浮点数**||||\n|double frexp(double f, int *p);|标准化浮点数,<br> f = x * 2^p, <br>已知f求x, p <br>( x介于[0.5, 1] ) |double ldexp(double x, int p);|与frexp相反, 已知x, p求f|\n|**取整与取余**||||\n|double modf(double, double*);|将参数的整数部分通过指针回传, 返回小数部分 |double fmod(double, double);|返回两参数相除的余数|\n\n### errno.h \nerror定义了通过错误码来返回错误信息的宏：\n\n`errno` 宏定义为一个 `int` 型态的左值, 包含任何函数使用 `errno` 功能所产生的上一个错误码。\n一些表示错误码，定义为整数值的宏：\n`EDOM` 源自于函数的参数超出范围,例如 `sqrt(-1)`\n`ERANGE` 源自于函数的结果超出范围,例如 `strtol(\"0xfffffffff\",NULL,0)`\n`EILSEQ` 源自于不合​​法的字符顺序,例如 `wcstombs(str, L\"\\xffff\", 2)`\n\n### locale.h \nlocal 定义了区域设置相关的函数和相关的宏以及类型定义。\n\n1. 定义了一个类型 `struct lconv;`\n其中几个比较重要的变量是\n`char *decimal_point; `格式化非货币量中的小数点字符\n`char *thousands_sep;` 用来对格式化的非货币量中小数点前面的数字进行分组的字符\n`char *grouping;` 用来说明格式化的非货币量中每一组数字的数目\n````C\ntypedef struct {\n   char *decimal_point;\n   char *thousands_sep;\n   char *grouping;\t\n   char *int_curr_symbol;\n   char *currency_symbol;\n   char *mon_decimal_point;\n   char *mon_thousands_sep;\n   char *mon_grouping;\n   char *positive_sign;\n   char *negative_sign;\n   char int_frac_digits;\n   char frac_digits;\n   char p_cs_precedes;\n   char p_sep_by_space;\n   char n_cs_precedes;\n   char n_sep_by_space;\n   char p_sign_posn;\n   char n_sign_posn;\n} lconv````\n\n\n2. 定义了两个函数\n`struct lconv *localeconv(void);` 用于返回当前区域中的数字和货币信息\n`char *setlocale(int category, const char *locale);`用于设置或返回当前的区域特性\n\n3. 定义了几个宏\n\n|参数\t|说明|\n|--|--|\n|LC_ALL|\t设置所有信息|\n|LC_COLLATE|\t影响strcoll和strxfrm函数|\n|LC_CTYPE|\t影响所有字符函数|\n|LC_MONETARY|\t影响由 `localeconv` 函数提供的货币信息|\n|LC_NUMERIC|\t影响十进制小数格式和 `localeconv` 函数提供的信息|\n|LC_TIME|\t影响 `strftime` 函数|\n\n### setjmp.h \nsetjmp 定义了一种特别的函数调用和函数返回顺序的方式。它允许程序流程从一个深层嵌套的函数中返回。\n> typedef int jmp_buf[16];\nint setjmp(jmp_buf);\nvoid longjmp(jmp_buf, int);\n\n非本地跳转的原理非常简单： \n\n1. `setjmp(j)`设置 **jump** 点，用正确的程序上下文填充 `jmp_buf` 对象 `j`。这个上下文包括程序存放位置，栈和框架指针，其它重要的寄存器和内存数据。当初始化完 `jump` 的上下文，`setjmp()` 返回0值。 \n2. 以后调用 `longjmp(j,r)` 的效果就是一个非局部的 `goto` 或 **长跳转** 到由 `j` 描述的上下文处（也就是原来调用 `setjmp(j)` 处）。当作为长跳转的目标而被调用时，`setjmp()` 返回 `r` 或 `1`（如果 `r` 设为`0` 的话）。（记住，`setjmp()`不能在这种情况时返回0） \n通过有两类返回值，`setjmp()` 让你知道它正在被怎么使用。当设置 `j` 时，`setjmp()` 如你期望地执行；但当作为长跳转的目标时，`setjmp()`就从外面 **唤醒** 它的上下文。你可以用 `longjmp()` 来终止异常，用 `setjmp()` 标记相应的异常处理程序。\n\n一个简单的例子如下：\n````C++\n#include  <stdio.h>\n#include  <setjmp.h>\n\nstatic jmp_buf buf;\n\nvoid second(void) {\n  printf(\"second\\n\");        \n  longjmp(buf,1);            \n}\n\nvoid first(void) {\n  second();\n  printf(\"first\\n\");          \n}\n\nint main() {   \n  if ( ! setjmp(buf) ) {\n    first();               \n  } else {                  \n    printf(\"main\\n\");  \n  }\n  return 0;\n}\n````\n\n程序首先执行了 `setjmp` ，初始化了 `buf`，函数返回了0，进入 `first` 函数，执行了 `second` 函数，打印\"second\"，随后执行 `longjmp` 函数跳转到 `setjmp` 的地方，此时`setjmp` 的返回值为 1，所以直接进入 `else` 打印 \"main\" ，函数结束。\n\n### signal.h\nsignal提供了一些定义和函数用来处理执行过程中产生的信号。\n\n1. 定义了相关的宏\n  * 以 `SIG_` 开头的宏用于定义信号处理函数:  \n    * `SIG_DFL` 默认信号处理函数。\n    * `SIG_ERR` 表示一个错误信号，当signal函数调用失败时的返回值。\n    * `SIG_IGN` 信号处理函数，表示忽略该信号。  \n  * 以`SIG`开头的宏是用来在下列情况下，用来表示一个信号代码：\n    * `SIGABRT` 异常终止（`abort`函数产生）。\n    * `SIGFPE` 浮点错误（0作为除数产生的错误，非法的操作）。\n    * `SIGILL` 非法操作（指令）。\n    * `SIGINT` 交互式操作产生的信号（如CTRL - C）。\n    * `SIGSEGV` 无效访问存储（片段的非法访问，内存非法访问）。\n    * `SIGTERM` 终止请求。\n\n2. 定义了一个变量\n`typedef sig_atomic_t`\n`sig_atomic_t` 类型是int类型，用于接收 `signal` 函数的返回值。\n\n3. 定义了两个函数\n* signal 函数\n  `void(*signal(int sig,void (*func)(int)))(int);`\n  上面的函数定义中，`sig` 表示一个信号代码（相当于暗号类别），即是上面所定义的 `SIG` 开头的宏。当有信号出现（即当收到暗号）的时候，参数 `func` 所定义的函数就会被调用。\n* raise 函数\n  `int raise(int sig);`\n  发出一个信号 `sig`。信号参数为 `SIG`开头的宏。\n\n### stdarg.h\nstdarg定义了一些宏，当函数参数未知时去获取函数的参数\n\n1. 变量：`typedef va_list` 通过 `stdarg` 宏定义来访问一个函数的参数表，参数列表的末尾会用省略号省略 \n\n2. 宏：\n`void va_start(va_list ap, last_arg);`\n用va_arg和va_end宏初始化参数ap，last_arg是传给函数的固定参数的最后一个，省略号之前的那个参数注意va_start必须在使用va_arg和va_end之前调用\n`type va_arg(va_list ap, type);`\n用type类型扩展到参数表的下个参数\n注意ap必须用va_start初始化，如果没有下一个参数，结果会是undefined\n`void va_end(va_list ap);`\n允许一个有参数表（使用va_start宏）的函数返回，如果返回之前没有调用va_end,结果会是undefined。参数变量列表可能不再使用（在没调用va_start的情况下调用va_end）","source":"_posts/C语言学习总结（五）——C库函数总结.md","raw":"---\ntitle: C语言学习总结（五）——C库函数总结\ndate: 2016-12-08 14:31:21\ncategories: C语言学习总结\ntags: [C语言, 标准C库]\n---\nC 库函数主要指那些由美国国家标准协会（ANSI）或国际标准化组织(ISO)发布的标准中规定的库函数，按照标准 C 的要求来进行 C 语言编程是很重要的，因为这样你的代码才有可能跨平台使用。\n<!--more-->\n最早的 `C89` 中有15个标准头文件：\n>  assert.h   ctype.h   errno.h   float.h   limits.h    \n locale.h   math.h   setjmp.h   signal.h   stdarg.h   \n stddef.h   stdio.h   stdlib.h   string.h   time.h   \n\n随后的 `C95` 增加了3个标准头文件：\n> iso646.h   wchar.h   wctype.h \n\n其次 `C99` 增加了6个标准头文件：\n>  complex.h    fenv.h   inttypes.h    stdbool.h    stdint.h   tgmath.h \n\n最新的 `C11` 又增加了5个标准头文件：\n>  stdalign.h   stdatomic.h   stdnoreturn.h   threads.h   uchar.h \n\n所以目前总共有29个标准头文件，但是大部分的编译器并没有支持全部的C标注，所以目前我们在这里讨论的主要还是 `C89` 中的15个标准头文件。\n\n## 相关头文件的内容说明\n`C89` 的15个标准头文件的主要内容如下：\n\n|头文件|说明|头文件|说明|头文件|说明|\n|--|--|--|--|--|--|\n| assert.h |断言相关| ctype.h |字符类型判断| errno.h |标准错误机制|\n| float.h |浮点限制| limits.h |整形限制| locale.h |本地化接口|\n| math.h |数学函数| setjmp.h |非本地跳转| signal.h |信号相关|\n| stdarg.h |可变参数处理| stddef.h |宏和类型定义| stdio.h |标准I/O|\n| stdlib.h |标准工具库| string.h |字符串和内存处理| time.h |时间相关|\n\n有人说，标准库(C89)——也就是ISO C——可以分为3组，根据这3组可以分出三种层次的程序员：\n* 合格程序员： ctype.h 、 stdio.h 、 stdlib.h 、 string \n* 熟练程序员： assert.h 、 limits.h 、 stddef.h 、 time.h \n* 优秀程序员： float.h 、 math.h 、 errno.h 、 locale.h 、 setjmp.h 、 signal.h 、 stdarg.h \n作为一个走在优秀程序员路上的 XX 程序员，这里简单把三个层次分开说一下。\n\n## 合格程序员的层次\n###  ctype.h \n ctype.h 这个头文件主要定义了一批 C 语言字符分类函数，所有的函数都只有一个参数，且参数和返回值均为 `int` 类型。下面是简单的函数介绍：\n\n|函数名|说明|函数名|说明|函数名|说明|\n|-----|----|------|----|-----|----|\n|isalpha|是否为字母|isdigit|是否为数字|isalnum|是否为数字或字母|\n|iscntrl|是否为控制字符|isgraph|是否为图形文字|isupper|是否为大写字母|\n|islower|是否为小写字母|tolower|转换为小写字母|toupper|转换为大写字母|\n|isprintf|是否为可打印字符|ispunct|是否为标点符号|isspace|是否为空白|\n|isxdigit|是否为十六进制的数字||||||\n###  stdio.h \n stdio.h 这个头文件应该是大多数人接触 C 语言的时候第一个认识的 C 库函数。这个函数最常用，但是也很复杂。它定义了三种类型，一些宏和很多的输入输出函数。\n\n1. 定义的三种类型：  \n * `size_t` 是由 `sizeof` 关键字产生的无符号整类型。\n * `FILE` 是一个结构体类型，记录了控制流需要的所有信息，包括它的文件定位符、指向相关缓冲的指针、记录是否发生了读/写错误的错误提示符和记录文件是否结束的文件结束符。 \n * `fpos_t`包含可以唯一指定文件中的每一个位置所需的所有信息。\n2. 定义了一些常量：  \n * `NULL` 空值 \n * `_IOFBF` 表示完全缓冲 `_IOLBF` 表示线缓冲 `_IONBF` 表示无缓存\n * `BUFSIZ` 是`setbuf`函数所使用的缓冲区的大小\n * `EOF` 是负整数,该表达式由几个函数返回来说明文件的结束，即一个流输入结束了(END OF FILE)\n * `FOPEN_MAX` (20)同时打开的文件的最大数量\n * `FILENAME_MAX` 文件名的最大长度\n * `L_tmpnam`整数，最大长度的临时文件名\n * `SEEK_CUR`取得目前文件位置 `SEEK_END` 将读写位置移到文件尾时 `SEEK_SET` 将读写位置移到文件开头\n * `TMP_MAX` 表示`tmpnam`函数可以生成的单独文件名的最大数目\n * ``stderr`标准错误流，默认为屏幕, 可输出到文件 `stdin`标准输入流，默认为键盘 `stdout`标准输出流，默认为屏幕 \n3. 一些相关的函数\n * 文件操作函数 （4个）  \n `int remove(const char *filename);`  删除文件  \n `int rename(const char *old, const char *new);`  重命名文件  \n `FILE *tmpfile(void);` 创建一个临时的二进制文件，并通过模式“wb+”打开。  \n `char *tmpname（char *s）;` 生成一个字符串，这个字符串是一个有效的文件名。  \n * 文件访问函数 (6个)  \n `FILE* fopen(const char *filename, const char *mode);`打开名字为 `filename` 指向的文件，并且把这个文件和一个流相关联。    \n `FILE* freopen(const char *filename, const char *mode, FILE *stream);`打开名字为 `filename` 指向的文件，并且把它和 `stream` 指向的流关联在一起。  \n `int fclose(FILE *stream);`使 `stream` 指向的流被清空，并且和流相关联的文件被关闭。  \n `int fflush(FILE *stream);`对 `stream` 指向的流执行清空行为。  \n `void setbuf(FILE *stream, char *buf);`除了没有返回值，等价于函数 `setvbuf`。  \n `void setvbuf(FILE *stream, char *buf, int mode, size_t size);`设定 `stream` 缓冲的方式。   \n * 格式化的输入输出函数 （9个）  \n `int fprintf(FILE *stream, const char *format, ...);`  \n `int printf(const char *format, ...);`  \n `int sprintf(char *s, const char *format, ...);`  \n 返回传送的字符的数目。  \n `int fscanf(FILE *stream, const char *format, ...);`  \n `int scanf(const char *format, ...);`  \n `int sscanf(char *s, const char *format, ...);`  \n 如果在任何转换之前发生了输入失败，返回 `EOF`；否则返回赋值的输入项的数目。  \n `int vfprintf(FILE *stream, const char *format, va_list arg);`  \n `int vprintf(const char *format, va_list arg);`  \n `int vsprintf(char *s, const char *format, va_list arg);`  \n 等价于对应的 `printf` 函数，不过可变参数表用 `arg` 代替。   \n * 字符输入/输出函数 （11个）  \n `int fgetc(FILE *stream);`从 `stream` 指向的输入流中读取下一个字符。  \n `int getc(FILE *stream);`等价于函数 `fgetc`。  \n `int getchar(void);`等价于用参数 `stdin` 调用函数 `getc`。  \n `int fputc(int c, FILE *stream);`把字符写到指向的输出流中指定的位置处。  \n `int putc(int c, FILE *stream);`等价于 `fputc。`  \n `int putchar(int c);` 等价于把stdout作为第二个参数调用的 `putc。`  \n `char *fgets(char *s, int n, FILE *stream);`从 `stream`指向的流中读取字符。  \n `int fputs(const char *s, FILE *stream);`把 `s` 指向的串写入 `stream` 指向的流中。  \n `char *gets(char *s);`从 `stdin` 指向的输入流中读取若干个字符，并将其保留到 `s` 指向的数组中，直到遇到文件结束符或者读取一个换行符。  \n `int puts(const char *s);`把 `s` 指向的串写到 `stdout` 指向的流中，并且在输出最后添加一个换行符。  \n `int ungetc(int c, FILE *stream);` 把 `c` 指定的字符（转换为 `unsigned char` 类型）退回到 `stream` 指向的输入流中。  \n * 直接输入/输出函数 （2个）  \n `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`  \n 从 `stream` 指向的流中读取最多 `nmemb` 个元素到 `ptr` 指向的数组中 。  \n `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);`  \n 从 `ptr` 指向的数组中读取最多 `nmemb` 个元素并将其写到 `stream` 指向的流中。  \n * 文件定位函数 (5个)\n `int fgetpos(FILE *stream, fpos_t *pos);`\n 把 `stream` 指向的流的文件定位符的当前值存储到 `pos` 指向的对象中。\n `int fsetpos(FILE *stream, const fpos_t *pos);`\n 根据 `pos` 指向的对象的值来设置 `stream` 指向的流的文件定位符，\n `long int ftell(FILE *stream);`\n 获得 `stream` 指向的流的文件定位符的当前值。\n `int fseek(FILE *stream, long int offset, int whence);`\n 为 `stream` 指向的流设置文件定位符。\n `void rewind(FILE *stream);`\n 把 `stream` 指向的流的文件定位符设置在文件的开始位置，等价于 `(void)fseek(stream, 0L, SEEK_SET);`，只不过流的错误指示符也被清零。\n * 错误处理函数 (4个)\n `void clearerr(FILE *stream);`\n 清空 `stream` 指向的流的文件结束符和错误指示符。\n `int feof(FILE *stream);`\n 测试 `stream` 指向的流的文件结束符。当且仅当 `stream` 流设置了文件结束符时函数返回一个非0值。\n `int ferror(FILE *stream);`\n 测试 `stream` 指向的流的错误指示符。当且仅当 `stream` 流设置了错误指示符时函数返回一个非0值。\n `void perror(const char *s);`\n 把整数表达式 `errno` 中的错误编号转换为一条错误消息。\n\n### stdlib.h\n是标准工具库。包含了C语言的中最常用的系统函数\n\n1. 定义了五个宏\n * `NULL` 空\n * `EXIT_FAILURE` 失败状态码\n * `EXIT_SUCCESS` 成功状态码\n * `RAND_MAX rand` 的最大返回值\n * `MB_CUR_MAX` 多字节字符中的最大字节数\n2. 定义了四个类型：\n * `size_t` 是由 `sizeof` 关键字产生的无符号整类型。\n * `wchar_t` 是一个整型，标识一个宽字节字符，例如 `L’x’` 的类型就是 `wchar_t`。\n * `div_t` 是结构体类型 作为 `div` 函数的返回类型\n * `ldiv_t` 是一个结构类型，是函数 `ldiv` 的返回值类型。\n3. 定义了六类函数：\n * 字符串函数\n`double atof(const char *nptr);` 将字符串转换成浮点型数\n`int atoi(const char *nptr);` 将字符串转换成整型数\n`long int atol(const char *nptr);`将字符串转换成长整型数\n`double strtod(const char *nptr, char **endptr);`将字符串转换成浮点数\n`long int strtol(const char *nptr, char **endptr, int base);`将字符串转换成长整型数\n`unsigned long int strtoul(const char *nptr, char **endptr, int base);` 将字符串转换成无符号长整型数 \n * 内存控制函数\n`void *calloc(size_t nmemb, size_t size);` 配置内存空间\n`void free(void *ptr);` 释放原先配置的内存\n`void *malloc(size_t size);` 配置内存空间\n`void *realloc(void *ptr, size_t size);`重新分配主存\n * 环境函数\n`int atexit(void (*func)(void)); `\n注册func指向的函数，该函数在程序正常终止的时候被调用。\n`void exit(int status); `\n使程序正常终止。 \n`void abort(void);` \n使程序异常终止，除非捕获了信号SIGABRT且信号处理程序没有返回。\n`char *getenv(const char *name);` \n搜索宿主环境提供的环境表，来查找一个能和name指向的串匹配的串。\n`int system(const char *string); `\n把sring指向的串传递给宿主环境，然后命令处理程序按照实现定义的方式执行它。\n * 搜索和排序函数\n`void bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compare)(const void , const void *)); `\n搜索一个拥有 `nmemb` 个元素的数组，来查找与 `key` 指向的对象匹配的元素，\n`void qsort(void base, size_t nmemb, size_t size, int (*compare)(const void , const void *)); ` \n根据 `compare` 所指向的比较函数将数组内容排列成升序。\n * 数学函数\n`int abs(int j);`计算整型数的绝对值\n`long int labs(long int j);`将两个整数相除, 返回商和余数\n`div_t div(int number, int denom);`取长整型绝对值\n`ldiv_t ldiv(long int number, long int denom);`两个长整型数相除, 返回商和余数\n`int rand(void);` 随机数发生器\n`void srand(unsigned int seed);` 设置随机数种子\n * 多字节函数\n`int mblen(const char *s, size_t n); `根据locale的设置确定字符的字节数\n`int mbtowc(wchar_t *pwc, const char *s, size_t n); `把多字节字符转换为宽字符\n`int wctomb(char *s, wchar_t wchar); `把宽字符转换为多字节字符\n`size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n); `把多字节字符串转换为宽字符串\n`size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);`把宽字符串转换为多字节字符串\n\n### string \n包含了C语言的最常用的字符串操作函数\n\n1. 定义了一个宏： `NULL` 空\n2. 定义了一个变量： `size_t`\n3. 定义了五类函数：\n * 名字以mem开头的函数对任意的字符序列进行操作。其中一个参数指向字符串的起始位置，另一个参数对元素的个数尽行计数。 \n`void *memmove(void *s1, const void *s2, size_t n);`\n`void *memcpy(void *s1, const void *s2, size_t n);`\nmemmove和memcpy均从s2指向的对象中复制n个字符到s1指向的对象中，返回s1的值。不同之处在于，当复制发生在两个重叠的对象中，memcpy对这种行为未定义，memmove则可以正确执行。\n`int memcmp(const void *s1, const void *s2, size_t n);`\n比较s1和s2指向的对象中前n个字符。\n`void *memchr(const void *s, int c, size_t n);`\n返回指向定位的字符的指针，如果没有返回空指针。\n`void *memset(void *s, int c, size_t n);`\n把c的值复制到s指向的对象的前n个字符的每个字符中，返回s的值。\n * 名字以strn开头的函数对非空字符序列进行操作。 \n `char *strcpy(char *s1, const char *s2);`\n包括终止的空字符，返回s1的值\n`char *strcat(char *s1, const char *s2);`\n包括终止的空字符，返回s1的值。\n`int strcmp(const char *s1, const char *s2);`\n比较s1和s2指向的串。\n`char *strchr(const char *s, int c);`\n终止的空字符被认为串的一部分。\n`char *strrchr(cosnt char *s, int c);`\n确定c在s指向的串中最后一次出现的位置。r意为right一侧。\n`char *strstr(const char *s1, const char *s2);`\ns2指向的串的字符序列在s1指向的串中第一次出现的位置。\n`size_t strspn(const char *s1, const char *s2);`\n计算s1指向的字符串中完全由s2指向的字符串中的字符组成的最大初始段的长度。也就是说，它从s1的开头搜索一个和s2中的任意元素都不匹配的字符，返回此字符的下标。\n`size_t strcspn(const char *s1, const char *s2);`\n查找两个字符串第一个相同的字符在s1中的位置，也就是The first char both in s1 and s2，如果没有则返回终止的空字符的索引。\nstrcspn和strchr很相似，但它匹配的是任意一个字符集而不是一个字符。\n`char *strpbrk(const char *s1, const char *s2);`\n确定s2指向的串中的任意的字符在s1中第一次出现的位置。\n`char *strtok(char *s1, const char *s2);`\n分解字符串为一组字符串。s1为要分解的字符串，s2为分隔符字符串。\n * 名字以str开头的函数对空字符结尾的字符序列进行操作。\n`char *strncpy(char *s1, const char *s2, size_t n);`\n从s2指向的数组中复制最多n个字符（包括空字符），不会在s1的末尾自动添加空字符；如果达到n个字符之前遇到了空字符，则复制完空字符后停止，并在s1指向的数组后面添加空字符，直到写入了n个字符。\n简单来说，复制，直到遇到空字符或达到n个字符，如果此时复制的字符数未达到n，就填充空字符，直到字符数达到n。\n`char *strncat(char *s1, const char *s2, size_t n);`\n从s2指向的数组中将最多n个字符（空字符及其后面的字符不添加）添加到s1指向的串的结尾。在最后的结果后面加上一个空字符。\n简单来说，cat，直到遇到空字符或达到n个字符，最后的结果一定以空字符结尾。\n`int strncmp(const char *s1, const char *s2, size_t n);`\n对s1和s2指向的数组中的最多n个字符进行比较（空字符后面的字符不参加比较）。\n * 其他类\n`size_t strlen(const char *s);`\n计算s指向的串的长度，不包括结尾的空字符。\n`char *strerror(int errnum);`\n将errnum中的错误编号对应到一个错误信息串。\n * 与区域设置有关\n`int strcoll(const char *s1, const char *s2);`\n功能同strcmp，只是比较时串都被解释为适合当前区域设置的类别LC_COLLATE的形式。\n`size_t strxfrm(char *s1, const char *s2, size_t n);`\n如果区域选项是”POSIX”或者”C”，那么strxfrm()同用strncpy()来拷贝字符串是等价的。\n\n## 熟练程序员的层次：\n### assert.h \n这个头文件只定义了一个宏：`assert`\n如果条件为假，assert将输出一些信息并调用abort函数退出程序。 \n一个可能的实现：\n````C++\n#define NDEBUG\n#include <assert.h>\t\nint main(int argc, char* argv[]) {\n  int a = 12;\n  int b = 24;\n  assert( a > b );\n  printf(\"a is larger than b!\");\n  return 0;\n}````\n\n上面的程序会发现程序中止，`printf` 并未执行，且有这样的输出：` main: Assertion 'a > b' failed. `原因就是因为 `a` 其实小于 `b`，导致断言失败，`assert` 输出错误信息，并调用 `abort()`中止了程序执行。\n\n### limits.h \n头文件定义了整型变量的一些极限值和设置。\n\n`CHAR_BIT` 一个ASCII字符长度  `SCHAR_MIN` 字符型最小值  \n`SCHAR_MAX` 字符型最大值  `UCHAR_MAX` 无符号字符型最大值  \n`CHAR_MIN`/`CHAR_MAX` char字符的最大最小值，如果char字符正被表示有符号整数。它们的值就跟有符号整数一样。否则char字符的最小值就是0，最大值就是无符号char字符的最大值。\n`MB_LEN_MAX` 一个字符所占最大字节数`SHRT_MIN` 最小短整型\n`SHRT_MAX` 最大短整形 `USHRT_MAX` 最大无符号短整型\n`INT_MIN` 最小整型 `INT_MAX` 最大整形\n`UINT_MAX` 最大无符号整型 `LONG_MIN` 最小长整型\n`LONG_MAX` 最大长整型 `ULONG_MAX` 无符号长整型\n\n### stddef.h \n此头文件定义了3个类型和2个宏，其中一些在其他头文件中也有定义。\n\n * 定义了三个类型 \n `ptrdiff_t`两个指针相减的结果的类型，有符号整型，一般来说是int或long的typedef。 \n `size_t`是sizeof操作符的结果的类型，无符号整型。 \n `wchar_t`是一个整型，标识一个宽字节字符，例如L’x’的类型就是wchar_t。\n * 定义了两个宏\n `NULL` 空指针常量。 \n `offsetof(type, member-designator)` 展开为一个size_t类型的整值常量表达式。\n\n### time.h \n作时间的函数。 \n\n1. 定义了两个宏\n * `NULL`\n * `CLOCKS_PER_SEC` 使 `clock` 函数的返回值 `CLOCKS_PER_SEC` 的单位是秒\n\n2. 定义了四个类型\n声明的类型有size_t、clock_t、time_t和struct tm。 \n * `size_t` 在 `stddef.h` 中已介绍过。 \n * `clock_t` 是 `clock` 函数的返回值类型\n * `time_t` 是 `time` 函数的返回值类型，\n * `struct tm` 保存了一个日历时间的各组成部分，比如年月日时分秒等。\n\n3. 定义了两类函数\n  * 时间获取函数\n  `time_t time(time_t *timer);`\n  取得目前的时间\n  `clock_t clock(void);`\n  确定处理器使用的时间。\n  * 时间转换函数\n  `struct tm *gmtime(const time_t *timer);`把日期和时间转换为(GMT)时间\n  `struct tm *localtime(const time_t *timer);`取得当地目前时间和日期\n  `char *ctime(const time_t *timer);` 把日期和时间转换为字符串\n  `time_t mktime(struct tm *timeptr);`将时间结构数据转换成经过的秒数\n  `char *asctime(const struct tm *timeptr);`将时间和日期以字符串格式表示\n  `size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);`将时间格式化\n  * 其他函数 \n  `double difftime(time_t time1, time_t time0); `\n  计算两个日历时间之差：`time1-time0，`返回以秒为单位的差值。这个函数似乎简单到没有存在的必要，直接执行减法不就得了。\n\n\n## 优秀程序员的层次：\n### float.h \nfloat 头文件类似 limit 头文件，主要是浮点型数值的相关定义。\n\n在所有实例里`FLT`指的是`float`，`DBL`是`double`，`LDBL`指的是`long double`.\n\n|变量|定义|\n|---|---|\n|FLT_ROUNDS |定义浮点型数值四舍五入的方式，-1是不确定，0是向0，1是向最近，2是向正无穷大，3是负无穷大|\n|FLT_RADIX 2|定义指数的基本表示（比如base-2是二进制，base-10是十进制表示法，16是十六进制）|\n|FLT_MANT_DIG，DBL_MANT_DIG，LDBL_MANT_DIG|定义数值里数字的个数\n|FLT_DIG 6，DBL_DIG 10，LDBL_DIG 10|在四舍五入之后能不更改表示的最大小数位\n|FLT_MIN_EXP，DBL_MIN_EXP，LDBL_MIN_EXP|FLT_RADIX 的指数的最小负整数值\n|FLT_MIN_10_EXP -37，DBL_MIN_10_EXP -37，LDBL_MIN_10_EXP -37|10进制表示法的的指数的最小负整数值\n|FLT_MAX_EXP ,DBL_MAX_EXP ,LDBL_MAX_EXP|FLT_RADIX 的指数的最大整数值\n|FLT_MAX_10_EXP +37 ,DBL_MAX_10_EXP ,LDBL_MAX_10_EXP +37 +37|10进制表示法的的指数的最大整数值\n|FLT_MAX 1E+37，DBL_MAX 1E+37，LDBL_MAX 1E+37|浮点型的最大限\n|FLT_EPSILON 1E-5，DBL_EPSILON 1E-9，LDBL_EPSILON 1E-9|能表示的最小有符号数\n\n### math.h \nmath.h是 C 语言内的数学函数库。\n\n|函数|含义|函数|含义|\n|--|--|--|--|\n|**三角函数**| | |  |\n|double sin(double x);| 正弦|double cos(double x);|余弦|\n|double tan(double x);|正切|*cot三角函数，可以使用tan(PI/2-x)来实现。||\n|**反三角函数**| | | |\n|double asin(double x);|结果介于[-PI/2, PI/2]|double acos(double x); |结果介于[0, PI]|\n|double atan(double x);|反正切(主值), <br>结果介于[-PI/2, PI/2] | double atan2(double y,double);|反正切(整圆值),<br> 结果介于[-PI, PI]|\n|**双曲三角函数**||||\n|double sinh(double x);|计算双曲正弦|double cosh(double x);|计算双曲余弦|\n|double tanh(double x);|计算双曲正切|||\n|**指数与对数**||||\n|double exp(double x); |求取自然数e的幂|double sqrt(double x);|开平方|\n|double log(double x);|以e为底的对数|double log10(double x);|以10为底的对数|\n|double pow(double x, double y);|计算以x为底数的y次幂| float powf(float x, float y);|与pow一致，输入与输出皆为浮点数|\n|**取整**||||\n|double ceil(double);|取上整|double floor(double);|取下整|\n|**标准化浮点数**||||\n|double frexp(double f, int *p);|标准化浮点数,<br> f = x * 2^p, <br>已知f求x, p <br>( x介于[0.5, 1] ) |double ldexp(double x, int p);|与frexp相反, 已知x, p求f|\n|**取整与取余**||||\n|double modf(double, double*);|将参数的整数部分通过指针回传, 返回小数部分 |double fmod(double, double);|返回两参数相除的余数|\n\n### errno.h \nerror定义了通过错误码来返回错误信息的宏：\n\n`errno` 宏定义为一个 `int` 型态的左值, 包含任何函数使用 `errno` 功能所产生的上一个错误码。\n一些表示错误码，定义为整数值的宏：\n`EDOM` 源自于函数的参数超出范围,例如 `sqrt(-1)`\n`ERANGE` 源自于函数的结果超出范围,例如 `strtol(\"0xfffffffff\",NULL,0)`\n`EILSEQ` 源自于不合​​法的字符顺序,例如 `wcstombs(str, L\"\\xffff\", 2)`\n\n### locale.h \nlocal 定义了区域设置相关的函数和相关的宏以及类型定义。\n\n1. 定义了一个类型 `struct lconv;`\n其中几个比较重要的变量是\n`char *decimal_point; `格式化非货币量中的小数点字符\n`char *thousands_sep;` 用来对格式化的非货币量中小数点前面的数字进行分组的字符\n`char *grouping;` 用来说明格式化的非货币量中每一组数字的数目\n````C\ntypedef struct {\n   char *decimal_point;\n   char *thousands_sep;\n   char *grouping;\t\n   char *int_curr_symbol;\n   char *currency_symbol;\n   char *mon_decimal_point;\n   char *mon_thousands_sep;\n   char *mon_grouping;\n   char *positive_sign;\n   char *negative_sign;\n   char int_frac_digits;\n   char frac_digits;\n   char p_cs_precedes;\n   char p_sep_by_space;\n   char n_cs_precedes;\n   char n_sep_by_space;\n   char p_sign_posn;\n   char n_sign_posn;\n} lconv````\n\n\n2. 定义了两个函数\n`struct lconv *localeconv(void);` 用于返回当前区域中的数字和货币信息\n`char *setlocale(int category, const char *locale);`用于设置或返回当前的区域特性\n\n3. 定义了几个宏\n\n|参数\t|说明|\n|--|--|\n|LC_ALL|\t设置所有信息|\n|LC_COLLATE|\t影响strcoll和strxfrm函数|\n|LC_CTYPE|\t影响所有字符函数|\n|LC_MONETARY|\t影响由 `localeconv` 函数提供的货币信息|\n|LC_NUMERIC|\t影响十进制小数格式和 `localeconv` 函数提供的信息|\n|LC_TIME|\t影响 `strftime` 函数|\n\n### setjmp.h \nsetjmp 定义了一种特别的函数调用和函数返回顺序的方式。它允许程序流程从一个深层嵌套的函数中返回。\n> typedef int jmp_buf[16];\nint setjmp(jmp_buf);\nvoid longjmp(jmp_buf, int);\n\n非本地跳转的原理非常简单： \n\n1. `setjmp(j)`设置 **jump** 点，用正确的程序上下文填充 `jmp_buf` 对象 `j`。这个上下文包括程序存放位置，栈和框架指针，其它重要的寄存器和内存数据。当初始化完 `jump` 的上下文，`setjmp()` 返回0值。 \n2. 以后调用 `longjmp(j,r)` 的效果就是一个非局部的 `goto` 或 **长跳转** 到由 `j` 描述的上下文处（也就是原来调用 `setjmp(j)` 处）。当作为长跳转的目标而被调用时，`setjmp()` 返回 `r` 或 `1`（如果 `r` 设为`0` 的话）。（记住，`setjmp()`不能在这种情况时返回0） \n通过有两类返回值，`setjmp()` 让你知道它正在被怎么使用。当设置 `j` 时，`setjmp()` 如你期望地执行；但当作为长跳转的目标时，`setjmp()`就从外面 **唤醒** 它的上下文。你可以用 `longjmp()` 来终止异常，用 `setjmp()` 标记相应的异常处理程序。\n\n一个简单的例子如下：\n````C++\n#include  <stdio.h>\n#include  <setjmp.h>\n\nstatic jmp_buf buf;\n\nvoid second(void) {\n  printf(\"second\\n\");        \n  longjmp(buf,1);            \n}\n\nvoid first(void) {\n  second();\n  printf(\"first\\n\");          \n}\n\nint main() {   \n  if ( ! setjmp(buf) ) {\n    first();               \n  } else {                  \n    printf(\"main\\n\");  \n  }\n  return 0;\n}\n````\n\n程序首先执行了 `setjmp` ，初始化了 `buf`，函数返回了0，进入 `first` 函数，执行了 `second` 函数，打印\"second\"，随后执行 `longjmp` 函数跳转到 `setjmp` 的地方，此时`setjmp` 的返回值为 1，所以直接进入 `else` 打印 \"main\" ，函数结束。\n\n### signal.h\nsignal提供了一些定义和函数用来处理执行过程中产生的信号。\n\n1. 定义了相关的宏\n  * 以 `SIG_` 开头的宏用于定义信号处理函数:  \n    * `SIG_DFL` 默认信号处理函数。\n    * `SIG_ERR` 表示一个错误信号，当signal函数调用失败时的返回值。\n    * `SIG_IGN` 信号处理函数，表示忽略该信号。  \n  * 以`SIG`开头的宏是用来在下列情况下，用来表示一个信号代码：\n    * `SIGABRT` 异常终止（`abort`函数产生）。\n    * `SIGFPE` 浮点错误（0作为除数产生的错误，非法的操作）。\n    * `SIGILL` 非法操作（指令）。\n    * `SIGINT` 交互式操作产生的信号（如CTRL - C）。\n    * `SIGSEGV` 无效访问存储（片段的非法访问，内存非法访问）。\n    * `SIGTERM` 终止请求。\n\n2. 定义了一个变量\n`typedef sig_atomic_t`\n`sig_atomic_t` 类型是int类型，用于接收 `signal` 函数的返回值。\n\n3. 定义了两个函数\n* signal 函数\n  `void(*signal(int sig,void (*func)(int)))(int);`\n  上面的函数定义中，`sig` 表示一个信号代码（相当于暗号类别），即是上面所定义的 `SIG` 开头的宏。当有信号出现（即当收到暗号）的时候，参数 `func` 所定义的函数就会被调用。\n* raise 函数\n  `int raise(int sig);`\n  发出一个信号 `sig`。信号参数为 `SIG`开头的宏。\n\n### stdarg.h\nstdarg定义了一些宏，当函数参数未知时去获取函数的参数\n\n1. 变量：`typedef va_list` 通过 `stdarg` 宏定义来访问一个函数的参数表，参数列表的末尾会用省略号省略 \n\n2. 宏：\n`void va_start(va_list ap, last_arg);`\n用va_arg和va_end宏初始化参数ap，last_arg是传给函数的固定参数的最后一个，省略号之前的那个参数注意va_start必须在使用va_arg和va_end之前调用\n`type va_arg(va_list ap, type);`\n用type类型扩展到参数表的下个参数\n注意ap必须用va_start初始化，如果没有下一个参数，结果会是undefined\n`void va_end(va_list ap);`\n允许一个有参数表（使用va_start宏）的函数返回，如果返回之前没有调用va_end,结果会是undefined。参数变量列表可能不再使用（在没调用va_start的情况下调用va_end）","slug":"C语言学习总结（五）——C库函数总结","published":1,"updated":"2016-12-21T14:08:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n02000hbkw13mtjvf1z","content":"<p>C 库函数主要指那些由美国国家标准协会（ANSI）或国际标准化组织(ISO)发布的标准中规定的库函数，按照标准 C 的要求来进行 C 语言编程是很重要的，因为这样你的代码才有可能跨平台使用。<br><a id=\"more\"></a><br>最早的 <code>C89</code> 中有15个标准头文件：</p>\n<blockquote>\n<p> assert.h   ctype.h   errno.h   float.h   limits.h<br> locale.h   math.h   setjmp.h   signal.h   stdarg.h<br> stddef.h   stdio.h   stdlib.h   string.h   time.h   </p>\n</blockquote>\n<p>随后的 <code>C95</code> 增加了3个标准头文件：</p>\n<blockquote>\n<p>iso646.h   wchar.h   wctype.h </p>\n</blockquote>\n<p>其次 <code>C99</code> 增加了6个标准头文件：</p>\n<blockquote>\n<p> complex.h    fenv.h   inttypes.h    stdbool.h    stdint.h   tgmath.h </p>\n</blockquote>\n<p>最新的 <code>C11</code> 又增加了5个标准头文件：</p>\n<blockquote>\n<p> stdalign.h   stdatomic.h   stdnoreturn.h   threads.h   uchar.h </p>\n</blockquote>\n<p>所以目前总共有29个标准头文件，但是大部分的编译器并没有支持全部的C标注，所以目前我们在这里讨论的主要还是 <code>C89</code> 中的15个标准头文件。</p>\n<h2 id=\"相关头文件的内容说明\"><a href=\"#相关头文件的内容说明\" class=\"headerlink\" title=\"相关头文件的内容说明\"></a>相关头文件的内容说明</h2><p><code>C89</code> 的15个标准头文件的主要内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>头文件</th>\n<th>说明</th>\n<th>头文件</th>\n<th>说明</th>\n<th>头文件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assert.h</td>\n<td>断言相关</td>\n<td>ctype.h</td>\n<td>字符类型判断</td>\n<td>errno.h</td>\n<td>标准错误机制</td>\n</tr>\n<tr>\n<td>float.h</td>\n<td>浮点限制</td>\n<td>limits.h</td>\n<td>整形限制</td>\n<td>locale.h</td>\n<td>本地化接口</td>\n</tr>\n<tr>\n<td>math.h</td>\n<td>数学函数</td>\n<td>setjmp.h</td>\n<td>非本地跳转</td>\n<td>signal.h</td>\n<td>信号相关</td>\n</tr>\n<tr>\n<td>stdarg.h</td>\n<td>可变参数处理</td>\n<td>stddef.h</td>\n<td>宏和类型定义</td>\n<td>stdio.h</td>\n<td>标准I/O</td>\n</tr>\n<tr>\n<td>stdlib.h</td>\n<td>标准工具库</td>\n<td>string.h</td>\n<td>字符串和内存处理</td>\n<td>time.h</td>\n<td>时间相关</td>\n</tr>\n</tbody>\n</table>\n<p>有人说，标准库(C89)——也就是ISO C——可以分为3组，根据这3组可以分出三种层次的程序员：</p>\n<ul>\n<li>合格程序员： ctype.h 、 stdio.h 、 stdlib.h 、 string </li>\n<li>熟练程序员： assert.h 、 limits.h 、 stddef.h 、 time.h </li>\n<li>优秀程序员： float.h 、 math.h 、 errno.h 、 locale.h 、 setjmp.h 、 signal.h 、 stdarg.h<br>作为一个走在优秀程序员路上的 XX 程序员，这里简单把三个层次分开说一下。</li>\n</ul>\n<h2 id=\"合格程序员的层次\"><a href=\"#合格程序员的层次\" class=\"headerlink\" title=\"合格程序员的层次\"></a>合格程序员的层次</h2><h3 id=\"ctype-h\"><a href=\"#ctype-h\" class=\"headerlink\" title=\"ctype.h\"></a>ctype.h</h3><p> ctype.h 这个头文件主要定义了一批 C 语言字符分类函数，所有的函数都只有一个参数，且参数和返回值均为 <code>int</code> 类型。下面是简单的函数介绍：</p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>说明</th>\n<th>函数名</th>\n<th>说明</th>\n<th>函数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isalpha</td>\n<td>是否为字母</td>\n<td>isdigit</td>\n<td>是否为数字</td>\n<td>isalnum</td>\n<td>是否为数字或字母</td>\n</tr>\n<tr>\n<td>iscntrl</td>\n<td>是否为控制字符</td>\n<td>isgraph</td>\n<td>是否为图形文字</td>\n<td>isupper</td>\n<td>是否为大写字母</td>\n</tr>\n<tr>\n<td>islower</td>\n<td>是否为小写字母</td>\n<td>tolower</td>\n<td>转换为小写字母</td>\n<td>toupper</td>\n<td>转换为大写字母</td>\n</tr>\n<tr>\n<td>isprintf</td>\n<td>是否为可打印字符</td>\n<td>ispunct</td>\n<td>是否为标点符号</td>\n<td>isspace</td>\n<td>是否为空白</td>\n</tr>\n<tr>\n<td>isxdigit</td>\n<td>是否为十六进制的数字</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"stdio-h\"><a href=\"#stdio-h\" class=\"headerlink\" title=\"stdio.h\"></a>stdio.h</h3><p> stdio.h 这个头文件应该是大多数人接触 C 语言的时候第一个认识的 C 库函数。这个函数最常用，但是也很复杂。它定义了三种类型，一些宏和很多的输入输出函数。</p>\n<ol>\n<li>定义的三种类型：  <ul>\n<li><code>size_t</code> 是由 <code>sizeof</code> 关键字产生的无符号整类型。</li>\n<li><code>FILE</code> 是一个结构体类型，记录了控制流需要的所有信息，包括它的文件定位符、指向相关缓冲的指针、记录是否发生了读/写错误的错误提示符和记录文件是否结束的文件结束符。 </li>\n<li><code>fpos_t</code>包含可以唯一指定文件中的每一个位置所需的所有信息。</li>\n</ul>\n</li>\n<li>定义了一些常量：  <ul>\n<li><code>NULL</code> 空值 </li>\n<li><code>_IOFBF</code> 表示完全缓冲 <code>_IOLBF</code> 表示线缓冲 <code>_IONBF</code> 表示无缓存</li>\n<li><code>BUFSIZ</code> 是<code>setbuf</code>函数所使用的缓冲区的大小</li>\n<li><code>EOF</code> 是负整数,该表达式由几个函数返回来说明文件的结束，即一个流输入结束了(END OF FILE)</li>\n<li><code>FOPEN_MAX</code> (20)同时打开的文件的最大数量</li>\n<li><code>FILENAME_MAX</code> 文件名的最大长度</li>\n<li><code>L_tmpnam</code>整数，最大长度的临时文件名</li>\n<li><code>SEEK_CUR</code>取得目前文件位置 <code>SEEK_END</code> 将读写位置移到文件尾时 <code>SEEK_SET</code> 将读写位置移到文件开头</li>\n<li><code>TMP_MAX</code> 表示<code>tmpnam</code>函数可以生成的单独文件名的最大数目</li>\n<li><code>`stderr</code>标准错误流，默认为屏幕, 可输出到文件 <code>stdin</code>标准输入流，默认为键盘 <code>stdout</code>标准输出流，默认为屏幕 </li>\n</ul>\n</li>\n<li>一些相关的函数<ul>\n<li>文件操作函数 （4个）<br><code>int remove(const char *filename);</code>  删除文件<br><code>int rename(const char *old, const char *new);</code>  重命名文件<br><code>FILE *tmpfile(void);</code> 创建一个临时的二进制文件，并通过模式“wb+”打开。<br><code>char *tmpname（char *s）;</code> 生成一个字符串，这个字符串是一个有效的文件名。  </li>\n<li>文件访问函数 (6个)<br><code>FILE* fopen(const char *filename, const char *mode);</code>打开名字为 <code>filename</code> 指向的文件，并且把这个文件和一个流相关联。<br><code>FILE* freopen(const char *filename, const char *mode, FILE *stream);</code>打开名字为 <code>filename</code> 指向的文件，并且把它和 <code>stream</code> 指向的流关联在一起。<br><code>int fclose(FILE *stream);</code>使 <code>stream</code> 指向的流被清空，并且和流相关联的文件被关闭。<br><code>int fflush(FILE *stream);</code>对 <code>stream</code> 指向的流执行清空行为。<br><code>void setbuf(FILE *stream, char *buf);</code>除了没有返回值，等价于函数 <code>setvbuf</code>。<br><code>void setvbuf(FILE *stream, char *buf, int mode, size_t size);</code>设定 <code>stream</code> 缓冲的方式。   </li>\n<li>格式化的输入输出函数 （9个）<br><code>int fprintf(FILE *stream, const char *format, ...);</code><br><code>int printf(const char *format, ...);</code><br><code>int sprintf(char *s, const char *format, ...);</code><br>返回传送的字符的数目。<br><code>int fscanf(FILE *stream, const char *format, ...);</code><br><code>int scanf(const char *format, ...);</code><br><code>int sscanf(char *s, const char *format, ...);</code><br>如果在任何转换之前发生了输入失败，返回 <code>EOF</code>；否则返回赋值的输入项的数目。<br><code>int vfprintf(FILE *stream, const char *format, va_list arg);</code><br><code>int vprintf(const char *format, va_list arg);</code><br><code>int vsprintf(char *s, const char *format, va_list arg);</code><br>等价于对应的 <code>printf</code> 函数，不过可变参数表用 <code>arg</code> 代替。   </li>\n<li>字符输入/输出函数 （11个）<br><code>int fgetc(FILE *stream);</code>从 <code>stream</code> 指向的输入流中读取下一个字符。<br><code>int getc(FILE *stream);</code>等价于函数 <code>fgetc</code>。<br><code>int getchar(void);</code>等价于用参数 <code>stdin</code> 调用函数 <code>getc</code>。<br><code>int fputc(int c, FILE *stream);</code>把字符写到指向的输出流中指定的位置处。<br><code>int putc(int c, FILE *stream);</code>等价于 <code>fputc。</code><br><code>int putchar(int c);</code> 等价于把stdout作为第二个参数调用的 <code>putc。</code><br><code>char *fgets(char *s, int n, FILE *stream);</code>从 <code>stream</code>指向的流中读取字符。<br><code>int fputs(const char *s, FILE *stream);</code>把 <code>s</code> 指向的串写入 <code>stream</code> 指向的流中。<br><code>char *gets(char *s);</code>从 <code>stdin</code> 指向的输入流中读取若干个字符，并将其保留到 <code>s</code> 指向的数组中，直到遇到文件结束符或者读取一个换行符。<br><code>int puts(const char *s);</code>把 <code>s</code> 指向的串写到 <code>stdout</code> 指向的流中，并且在输出最后添加一个换行符。<br><code>int ungetc(int c, FILE *stream);</code> 把 <code>c</code> 指定的字符（转换为 <code>unsigned char</code> 类型）退回到 <code>stream</code> 指向的输入流中。  </li>\n<li>直接输入/输出函数 （2个）<br><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code><br>从 <code>stream</code> 指向的流中读取最多 <code>nmemb</code> 个元素到 <code>ptr</code> 指向的数组中 。<br><code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code><br>从 <code>ptr</code> 指向的数组中读取最多 <code>nmemb</code> 个元素并将其写到 <code>stream</code> 指向的流中。  </li>\n<li>文件定位函数 (5个)<br><code>int fgetpos(FILE *stream, fpos_t *pos);</code><br>把 <code>stream</code> 指向的流的文件定位符的当前值存储到 <code>pos</code> 指向的对象中。<br><code>int fsetpos(FILE *stream, const fpos_t *pos);</code><br>根据 <code>pos</code> 指向的对象的值来设置 <code>stream</code> 指向的流的文件定位符，<br><code>long int ftell(FILE *stream);</code><br>获得 <code>stream</code> 指向的流的文件定位符的当前值。<br><code>int fseek(FILE *stream, long int offset, int whence);</code><br>为 <code>stream</code> 指向的流设置文件定位符。<br><code>void rewind(FILE *stream);</code><br>把 <code>stream</code> 指向的流的文件定位符设置在文件的开始位置，等价于 <code>(void)fseek(stream, 0L, SEEK_SET);</code>，只不过流的错误指示符也被清零。</li>\n<li>错误处理函数 (4个)<br><code>void clearerr(FILE *stream);</code><br>清空 <code>stream</code> 指向的流的文件结束符和错误指示符。<br><code>int feof(FILE *stream);</code><br>测试 <code>stream</code> 指向的流的文件结束符。当且仅当 <code>stream</code> 流设置了文件结束符时函数返回一个非0值。<br><code>int ferror(FILE *stream);</code><br>测试 <code>stream</code> 指向的流的错误指示符。当且仅当 <code>stream</code> 流设置了错误指示符时函数返回一个非0值。<br><code>void perror(const char *s);</code><br>把整数表达式 <code>errno</code> 中的错误编号转换为一条错误消息。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"stdlib-h\"><a href=\"#stdlib-h\" class=\"headerlink\" title=\"stdlib.h\"></a>stdlib.h</h3><p>是标准工具库。包含了C语言的中最常用的系统函数</p>\n<ol>\n<li>定义了五个宏<ul>\n<li><code>NULL</code> 空</li>\n<li><code>EXIT_FAILURE</code> 失败状态码</li>\n<li><code>EXIT_SUCCESS</code> 成功状态码</li>\n<li><code>RAND_MAX rand</code> 的最大返回值</li>\n<li><code>MB_CUR_MAX</code> 多字节字符中的最大字节数</li>\n</ul>\n</li>\n<li>定义了四个类型：<ul>\n<li><code>size_t</code> 是由 <code>sizeof</code> 关键字产生的无符号整类型。</li>\n<li><code>wchar_t</code> 是一个整型，标识一个宽字节字符，例如 <code>L’x’</code> 的类型就是 <code>wchar_t</code>。</li>\n<li><code>div_t</code> 是结构体类型 作为 <code>div</code> 函数的返回类型</li>\n<li><code>ldiv_t</code> 是一个结构类型，是函数 <code>ldiv</code> 的返回值类型。</li>\n</ul>\n</li>\n<li>定义了六类函数：<ul>\n<li>字符串函数<br><code>double atof(const char *nptr);</code> 将字符串转换成浮点型数<br><code>int atoi(const char *nptr);</code> 将字符串转换成整型数<br><code>long int atol(const char *nptr);</code>将字符串转换成长整型数<br><code>double strtod(const char *nptr, char **endptr);</code>将字符串转换成浮点数<br><code>long int strtol(const char *nptr, char **endptr, int base);</code>将字符串转换成长整型数<br><code>unsigned long int strtoul(const char *nptr, char **endptr, int base);</code> 将字符串转换成无符号长整型数 </li>\n<li>内存控制函数<br><code>void *calloc(size_t nmemb, size_t size);</code> 配置内存空间<br><code>void free(void *ptr);</code> 释放原先配置的内存<br><code>void *malloc(size_t size);</code> 配置内存空间<br><code>void *realloc(void *ptr, size_t size);</code>重新分配主存</li>\n<li>环境函数<br><code>int atexit(void (*func)(void));</code><br>注册func指向的函数，该函数在程序正常终止的时候被调用。<br><code>void exit(int status);</code><br>使程序正常终止。<br><code>void abort(void);</code><br>使程序异常终止，除非捕获了信号SIGABRT且信号处理程序没有返回。<br><code>char *getenv(const char *name);</code><br>搜索宿主环境提供的环境表，来查找一个能和name指向的串匹配的串。<br><code>int system(const char *string);</code><br>把sring指向的串传递给宿主环境，然后命令处理程序按照实现定义的方式执行它。</li>\n<li>搜索和排序函数<br><code>void bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compare)(const void , const void *));</code><br>搜索一个拥有 <code>nmemb</code> 个元素的数组，来查找与 <code>key</code> 指向的对象匹配的元素，<br><code>void qsort(void base, size_t nmemb, size_t size, int (*compare)(const void , const void *));</code><br>根据 <code>compare</code> 所指向的比较函数将数组内容排列成升序。</li>\n<li>数学函数<br><code>int abs(int j);</code>计算整型数的绝对值<br><code>long int labs(long int j);</code>将两个整数相除, 返回商和余数<br><code>div_t div(int number, int denom);</code>取长整型绝对值<br><code>ldiv_t ldiv(long int number, long int denom);</code>两个长整型数相除, 返回商和余数<br><code>int rand(void);</code> 随机数发生器<br><code>void srand(unsigned int seed);</code> 设置随机数种子</li>\n<li>多字节函数<br><code>int mblen(const char *s, size_t n);</code>根据locale的设置确定字符的字节数<br><code>int mbtowc(wchar_t *pwc, const char *s, size_t n);</code>把多字节字符转换为宽字符<br><code>int wctomb(char *s, wchar_t wchar);</code>把宽字符转换为多字节字符<br><code>size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);</code>把多字节字符串转换为宽字符串<br><code>size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);</code>把宽字符串转换为多字节字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>包含了C语言的最常用的字符串操作函数</p>\n<ol>\n<li>定义了一个宏： <code>NULL</code> 空</li>\n<li>定义了一个变量： <code>size_t</code></li>\n<li>定义了五类函数：<ul>\n<li>名字以mem开头的函数对任意的字符序列进行操作。其中一个参数指向字符串的起始位置，另一个参数对元素的个数尽行计数。<br><code>void *memmove(void *s1, const void *s2, size_t n);</code><br><code>void *memcpy(void *s1, const void *s2, size_t n);</code><br>memmove和memcpy均从s2指向的对象中复制n个字符到s1指向的对象中，返回s1的值。不同之处在于，当复制发生在两个重叠的对象中，memcpy对这种行为未定义，memmove则可以正确执行。<br><code>int memcmp(const void *s1, const void *s2, size_t n);</code><br>比较s1和s2指向的对象中前n个字符。<br><code>void *memchr(const void *s, int c, size_t n);</code><br>返回指向定位的字符的指针，如果没有返回空指针。<br><code>void *memset(void *s, int c, size_t n);</code><br>把c的值复制到s指向的对象的前n个字符的每个字符中，返回s的值。</li>\n<li>名字以strn开头的函数对非空字符序列进行操作。<br><code>char *strcpy(char *s1, const char *s2);</code><br>包括终止的空字符，返回s1的值<br><code>char *strcat(char *s1, const char *s2);</code><br>包括终止的空字符，返回s1的值。<br><code>int strcmp(const char *s1, const char *s2);</code><br>比较s1和s2指向的串。<br><code>char *strchr(const char *s, int c);</code><br>终止的空字符被认为串的一部分。<br><code>char *strrchr(cosnt char *s, int c);</code><br>确定c在s指向的串中最后一次出现的位置。r意为right一侧。<br><code>char *strstr(const char *s1, const char *s2);</code><br>s2指向的串的字符序列在s1指向的串中第一次出现的位置。<br><code>size_t strspn(const char *s1, const char *s2);</code><br>计算s1指向的字符串中完全由s2指向的字符串中的字符组成的最大初始段的长度。也就是说，它从s1的开头搜索一个和s2中的任意元素都不匹配的字符，返回此字符的下标。<br><code>size_t strcspn(const char *s1, const char *s2);</code><br>查找两个字符串第一个相同的字符在s1中的位置，也就是The first char both in s1 and s2，如果没有则返回终止的空字符的索引。<br>strcspn和strchr很相似，但它匹配的是任意一个字符集而不是一个字符。<br><code>char *strpbrk(const char *s1, const char *s2);</code><br>确定s2指向的串中的任意的字符在s1中第一次出现的位置。<br><code>char *strtok(char *s1, const char *s2);</code><br>分解字符串为一组字符串。s1为要分解的字符串，s2为分隔符字符串。</li>\n<li>名字以str开头的函数对空字符结尾的字符序列进行操作。<br><code>char *strncpy(char *s1, const char *s2, size_t n);</code><br>从s2指向的数组中复制最多n个字符（包括空字符），不会在s1的末尾自动添加空字符；如果达到n个字符之前遇到了空字符，则复制完空字符后停止，并在s1指向的数组后面添加空字符，直到写入了n个字符。<br>简单来说，复制，直到遇到空字符或达到n个字符，如果此时复制的字符数未达到n，就填充空字符，直到字符数达到n。<br><code>char *strncat(char *s1, const char *s2, size_t n);</code><br>从s2指向的数组中将最多n个字符（空字符及其后面的字符不添加）添加到s1指向的串的结尾。在最后的结果后面加上一个空字符。<br>简单来说，cat，直到遇到空字符或达到n个字符，最后的结果一定以空字符结尾。<br><code>int strncmp(const char *s1, const char *s2, size_t n);</code><br>对s1和s2指向的数组中的最多n个字符进行比较（空字符后面的字符不参加比较）。</li>\n<li>其他类<br><code>size_t strlen(const char *s);</code><br>计算s指向的串的长度，不包括结尾的空字符。<br><code>char *strerror(int errnum);</code><br>将errnum中的错误编号对应到一个错误信息串。</li>\n<li>与区域设置有关<br><code>int strcoll(const char *s1, const char *s2);</code><br>功能同strcmp，只是比较时串都被解释为适合当前区域设置的类别LC_COLLATE的形式。<br><code>size_t strxfrm(char *s1, const char *s2, size_t n);</code><br>如果区域选项是”POSIX”或者”C”，那么strxfrm()同用strncpy()来拷贝字符串是等价的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"熟练程序员的层次：\"><a href=\"#熟练程序员的层次：\" class=\"headerlink\" title=\"熟练程序员的层次：\"></a>熟练程序员的层次：</h2><h3 id=\"assert-h\"><a href=\"#assert-h\" class=\"headerlink\" title=\"assert.h\"></a>assert.h</h3><p>这个头文件只定义了一个宏：<code>assert</code><br>如果条件为假，assert将输出一些信息并调用abort函数退出程序。<br>一个可能的实现：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NDEBUG</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span>\t</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">12</span>;</div><div class=\"line\">  <span class=\"keyword\">int</span> b = <span class=\"number\">24</span>;</div><div class=\"line\">  assert( a &gt; b );</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"a is larger than b!\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的程序会发现程序中止，<code>printf</code> 并未执行，且有这样的输出：<code>main: Assertion &#39;a &gt; b&#39; failed.</code>原因就是因为 <code>a</code> 其实小于 <code>b</code>，导致断言失败，<code>assert</code> 输出错误信息，并调用 <code>abort()</code>中止了程序执行。</p>\n<h3 id=\"limits-h\"><a href=\"#limits-h\" class=\"headerlink\" title=\"limits.h\"></a>limits.h</h3><p>头文件定义了整型变量的一些极限值和设置。</p>\n<p><code>CHAR_BIT</code> 一个ASCII字符长度  <code>SCHAR_MIN</code> 字符型最小值<br><code>SCHAR_MAX</code> 字符型最大值  <code>UCHAR_MAX</code> 无符号字符型最大值<br><code>CHAR_MIN</code>/<code>CHAR_MAX</code> char字符的最大最小值，如果char字符正被表示有符号整数。它们的值就跟有符号整数一样。否则char字符的最小值就是0，最大值就是无符号char字符的最大值。<br><code>MB_LEN_MAX</code> 一个字符所占最大字节数<code>SHRT_MIN</code> 最小短整型<br><code>SHRT_MAX</code> 最大短整形 <code>USHRT_MAX</code> 最大无符号短整型<br><code>INT_MIN</code> 最小整型 <code>INT_MAX</code> 最大整形<br><code>UINT_MAX</code> 最大无符号整型 <code>LONG_MIN</code> 最小长整型<br><code>LONG_MAX</code> 最大长整型 <code>ULONG_MAX</code> 无符号长整型</p>\n<h3 id=\"stddef-h\"><a href=\"#stddef-h\" class=\"headerlink\" title=\"stddef.h\"></a>stddef.h</h3><p>此头文件定义了3个类型和2个宏，其中一些在其他头文件中也有定义。</p>\n<ul>\n<li>定义了三个类型<br><code>ptrdiff_t</code>两个指针相减的结果的类型，有符号整型，一般来说是int或long的typedef。<br><code>size_t</code>是sizeof操作符的结果的类型，无符号整型。<br><code>wchar_t</code>是一个整型，标识一个宽字节字符，例如L’x’的类型就是wchar_t。</li>\n<li>定义了两个宏<br><code>NULL</code> 空指针常量。<br><code>offsetof(type, member-designator)</code> 展开为一个size_t类型的整值常量表达式。</li>\n</ul>\n<h3 id=\"time-h\"><a href=\"#time-h\" class=\"headerlink\" title=\"time.h\"></a>time.h</h3><p>作时间的函数。 </p>\n<ol>\n<li><p>定义了两个宏</p>\n<ul>\n<li><code>NULL</code></li>\n<li><code>CLOCKS_PER_SEC</code> 使 <code>clock</code> 函数的返回值 <code>CLOCKS_PER_SEC</code> 的单位是秒</li>\n</ul>\n</li>\n<li><p>定义了四个类型<br>声明的类型有size_t、clock_t、time_t和struct tm。 </p>\n<ul>\n<li><code>size_t</code> 在 <code>stddef.h</code> 中已介绍过。 </li>\n<li><code>clock_t</code> 是 <code>clock</code> 函数的返回值类型</li>\n<li><code>time_t</code> 是 <code>time</code> 函数的返回值类型，</li>\n<li><code>struct tm</code> 保存了一个日历时间的各组成部分，比如年月日时分秒等。</li>\n</ul>\n</li>\n<li><p>定义了两类函数</p>\n<ul>\n<li>时间获取函数<br><code>time_t time(time_t *timer);</code><br>取得目前的时间<br><code>clock_t clock(void);</code><br>确定处理器使用的时间。</li>\n<li>时间转换函数<br><code>struct tm *gmtime(const time_t *timer);</code>把日期和时间转换为(GMT)时间<br><code>struct tm *localtime(const time_t *timer);</code>取得当地目前时间和日期<br><code>char *ctime(const time_t *timer);</code> 把日期和时间转换为字符串<br><code>time_t mktime(struct tm *timeptr);</code>将时间结构数据转换成经过的秒数<br><code>char *asctime(const struct tm *timeptr);</code>将时间和日期以字符串格式表示<br><code>size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);</code>将时间格式化</li>\n<li>其他函数<br><code>double difftime(time_t time1, time_t time0);</code><br>计算两个日历时间之差：<code>time1-time0，</code>返回以秒为单位的差值。这个函数似乎简单到没有存在的必要，直接执行减法不就得了。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"优秀程序员的层次：\"><a href=\"#优秀程序员的层次：\" class=\"headerlink\" title=\"优秀程序员的层次：\"></a>优秀程序员的层次：</h2><h3 id=\"float-h\"><a href=\"#float-h\" class=\"headerlink\" title=\"float.h\"></a>float.h</h3><p>float 头文件类似 limit 头文件，主要是浮点型数值的相关定义。</p>\n<p>在所有实例里<code>FLT</code>指的是<code>float</code>，<code>DBL</code>是<code>double</code>，<code>LDBL</code>指的是<code>long double</code>.</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FLT_ROUNDS</td>\n<td>定义浮点型数值四舍五入的方式，-1是不确定，0是向0，1是向最近，2是向正无穷大，3是负无穷大</td>\n</tr>\n<tr>\n<td>FLT_RADIX 2</td>\n<td>定义指数的基本表示（比如base-2是二进制，base-10是十进制表示法，16是十六进制）</td>\n</tr>\n<tr>\n<td>FLT_MANT_DIG，DBL_MANT_DIG，LDBL_MANT_DIG</td>\n<td>定义数值里数字的个数</td>\n</tr>\n<tr>\n<td>FLT_DIG 6，DBL_DIG 10，LDBL_DIG 10</td>\n<td>在四舍五入之后能不更改表示的最大小数位</td>\n</tr>\n<tr>\n<td>FLT_MIN_EXP，DBL_MIN_EXP，LDBL_MIN_EXP</td>\n<td>FLT_RADIX 的指数的最小负整数值</td>\n</tr>\n<tr>\n<td>FLT_MIN_10_EXP -37，DBL_MIN_10_EXP -37，LDBL_MIN_10_EXP -37</td>\n<td>10进制表示法的的指数的最小负整数值</td>\n</tr>\n<tr>\n<td>FLT_MAX_EXP ,DBL_MAX_EXP ,LDBL_MAX_EXP</td>\n<td>FLT_RADIX 的指数的最大整数值</td>\n</tr>\n<tr>\n<td>FLT_MAX_10_EXP +37 ,DBL_MAX_10_EXP ,LDBL_MAX_10_EXP +37 +37</td>\n<td>10进制表示法的的指数的最大整数值</td>\n</tr>\n<tr>\n<td>FLT_MAX 1E+37，DBL_MAX 1E+37，LDBL_MAX 1E+37</td>\n<td>浮点型的最大限</td>\n</tr>\n<tr>\n<td>FLT_EPSILON 1E-5，DBL_EPSILON 1E-9，LDBL_EPSILON 1E-9</td>\n<td>能表示的最小有符号数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"math-h\"><a href=\"#math-h\" class=\"headerlink\" title=\"math.h\"></a>math.h</h3><p>math.h是 C 语言内的数学函数库。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>含义</th>\n<th>函数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>三角函数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double sin(double x);</td>\n<td>正弦</td>\n<td>double cos(double x);</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>double tan(double x);</td>\n<td>正切</td>\n<td>*cot三角函数，可以使用tan(PI/2-x)来实现。</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>反三角函数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double asin(double x);</td>\n<td>结果介于[-PI/2, PI/2]</td>\n<td>double acos(double x);</td>\n<td>结果介于[0, PI]</td>\n</tr>\n<tr>\n<td>double atan(double x);</td>\n<td>反正切(主值), <br>结果介于[-PI/2, PI/2]</td>\n<td>double atan2(double y,double);</td>\n<td>反正切(整圆值),<br> 结果介于[-PI, PI]</td>\n</tr>\n<tr>\n<td><strong>双曲三角函数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double sinh(double x);</td>\n<td>计算双曲正弦</td>\n<td>double cosh(double x);</td>\n<td>计算双曲余弦</td>\n</tr>\n<tr>\n<td>double tanh(double x);</td>\n<td>计算双曲正切</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指数与对数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double exp(double x);</td>\n<td>求取自然数e的幂</td>\n<td>double sqrt(double x);</td>\n<td>开平方</td>\n</tr>\n<tr>\n<td>double log(double x);</td>\n<td>以e为底的对数</td>\n<td>double log10(double x);</td>\n<td>以10为底的对数</td>\n</tr>\n<tr>\n<td>double pow(double x, double y);</td>\n<td>计算以x为底数的y次幂</td>\n<td>float powf(float x, float y);</td>\n<td>与pow一致，输入与输出皆为浮点数</td>\n</tr>\n<tr>\n<td><strong>取整</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double ceil(double);</td>\n<td>取上整</td>\n<td>double floor(double);</td>\n<td>取下整</td>\n</tr>\n<tr>\n<td><strong>标准化浮点数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double frexp(double f, int *p);</td>\n<td>标准化浮点数,<br> f = x * 2^p, <br>已知f求x, p <br>( x介于[0.5, 1] )</td>\n<td>double ldexp(double x, int p);</td>\n<td>与frexp相反, 已知x, p求f</td>\n</tr>\n<tr>\n<td><strong>取整与取余</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double modf(double, double*);</td>\n<td>将参数的整数部分通过指针回传, 返回小数部分</td>\n<td>double fmod(double, double);</td>\n<td>返回两参数相除的余数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"errno-h\"><a href=\"#errno-h\" class=\"headerlink\" title=\"errno.h\"></a>errno.h</h3><p>error定义了通过错误码来返回错误信息的宏：</p>\n<p><code>errno</code> 宏定义为一个 <code>int</code> 型态的左值, 包含任何函数使用 <code>errno</code> 功能所产生的上一个错误码。<br>一些表示错误码，定义为整数值的宏：<br><code>EDOM</code> 源自于函数的参数超出范围,例如 <code>sqrt(-1)</code><br><code>ERANGE</code> 源自于函数的结果超出范围,例如 <code>strtol(&quot;0xfffffffff&quot;,NULL,0)</code><br><code>EILSEQ</code> 源自于不合​​法的字符顺序,例如 <code>wcstombs(str, L&quot;\\xffff&quot;, 2)</code></p>\n<h3 id=\"locale-h\"><a href=\"#locale-h\" class=\"headerlink\" title=\"locale.h\"></a>locale.h</h3><p>local 定义了区域设置相关的函数和相关的宏以及类型定义。</p>\n<ol>\n<li><p>定义了一个类型 <code>struct lconv;</code><br>其中几个比较重要的变量是<br><code>char *decimal_point;</code>格式化非货币量中的小数点字符<br><code>char *thousands_sep;</code> 用来对格式化的非货币量中小数点前面的数字进行分组的字符<br><code>char *grouping;</code> 用来说明格式化的非货币量中每一组数字的数目</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">   <span class=\"keyword\">char</span> *decimal_point;</div><div class=\"line\">   <span class=\"keyword\">char</span> *thousands_sep;</div><div class=\"line\">   <span class=\"keyword\">char</span> *grouping;\t</div><div class=\"line\">   <span class=\"keyword\">char</span> *int_curr_symbol;</div><div class=\"line\">   <span class=\"keyword\">char</span> *currency_symbol;</div><div class=\"line\">   <span class=\"keyword\">char</span> *mon_decimal_point;</div><div class=\"line\">   <span class=\"keyword\">char</span> *mon_thousands_sep;</div><div class=\"line\">   <span class=\"keyword\">char</span> *mon_grouping;</div><div class=\"line\">   <span class=\"keyword\">char</span> *positive_sign;</div><div class=\"line\">   <span class=\"keyword\">char</span> *negative_sign;</div><div class=\"line\">   <span class=\"keyword\">char</span> int_frac_digits;</div><div class=\"line\">   <span class=\"keyword\">char</span> frac_digits;</div><div class=\"line\">   <span class=\"keyword\">char</span> p_cs_precedes;</div><div class=\"line\">   <span class=\"keyword\">char</span> p_sep_by_space;</div><div class=\"line\">   <span class=\"keyword\">char</span> n_cs_precedes;</div><div class=\"line\">   <span class=\"keyword\">char</span> n_sep_by_space;</div><div class=\"line\">   <span class=\"keyword\">char</span> p_sign_posn;</div><div class=\"line\">   <span class=\"keyword\">char</span> n_sign_posn;</div><div class=\"line\">&#125; lconv</div></pre></td></tr></table></figure>\n</li>\n<li><p>定义了两个函数<br><code>struct lconv *localeconv(void);</code> 用于返回当前区域中的数字和货币信息<br><code>char *setlocale(int category, const char *locale);</code>用于设置或返回当前的区域特性</p>\n</li>\n<li><p>定义了几个宏</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LC_ALL</td>\n<td>设置所有信息</td>\n</tr>\n<tr>\n<td>LC_COLLATE</td>\n<td>影响strcoll和strxfrm函数</td>\n</tr>\n<tr>\n<td>LC_CTYPE</td>\n<td>影响所有字符函数</td>\n</tr>\n<tr>\n<td>LC_MONETARY</td>\n<td>影响由 <code>localeconv</code> 函数提供的货币信息</td>\n</tr>\n<tr>\n<td>LC_NUMERIC</td>\n<td>影响十进制小数格式和 <code>localeconv</code> 函数提供的信息</td>\n</tr>\n<tr>\n<td>LC_TIME</td>\n<td>影响 <code>strftime</code> 函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"setjmp-h\"><a href=\"#setjmp-h\" class=\"headerlink\" title=\"setjmp.h\"></a>setjmp.h</h3><p>setjmp 定义了一种特别的函数调用和函数返回顺序的方式。它允许程序流程从一个深层嵌套的函数中返回。</p>\n<blockquote>\n<p>typedef int jmp_buf[16];<br>int setjmp(jmp_buf);<br>void longjmp(jmp_buf, int);</p>\n</blockquote>\n<p>非本地跳转的原理非常简单： </p>\n<ol>\n<li><code>setjmp(j)</code>设置 <strong>jump</strong> 点，用正确的程序上下文填充 <code>jmp_buf</code> 对象 <code>j</code>。这个上下文包括程序存放位置，栈和框架指针，其它重要的寄存器和内存数据。当初始化完 <code>jump</code> 的上下文，<code>setjmp()</code> 返回0值。 </li>\n<li>以后调用 <code>longjmp(j,r)</code> 的效果就是一个非局部的 <code>goto</code> 或 <strong>长跳转</strong> 到由 <code>j</code> 描述的上下文处（也就是原来调用 <code>setjmp(j)</code> 处）。当作为长跳转的目标而被调用时，<code>setjmp()</code> 返回 <code>r</code> 或 <code>1</code>（如果 <code>r</code> 设为<code>0</code> 的话）。（记住，<code>setjmp()</code>不能在这种情况时返回0）<br>通过有两类返回值，<code>setjmp()</code> 让你知道它正在被怎么使用。当设置 <code>j</code> 时，<code>setjmp()</code> 如你期望地执行；但当作为长跳转的目标时，<code>setjmp()</code>就从外面 <strong>唤醒</strong> 它的上下文。你可以用 <code>longjmp()</code> 来终止异常，用 <code>setjmp()</code> 标记相应的异常处理程序。</li>\n</ol>\n<p>一个简单的例子如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;setjmp.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> jmp_buf buf;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">second</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"second\\n\"</span>);        </div><div class=\"line\">  longjmp(buf,<span class=\"number\">1</span>);            </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">first</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  second();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"first\\n\"</span>);          </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;   </div><div class=\"line\">  <span class=\"keyword\">if</span> ( ! setjmp(buf) ) &#123;</div><div class=\"line\">    first();               </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                  </div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"main\\n\"</span>);  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>程序首先执行了 <code>setjmp</code> ，初始化了 <code>buf</code>，函数返回了0，进入 <code>first</code> 函数，执行了 <code>second</code> 函数，打印”second”，随后执行 <code>longjmp</code> 函数跳转到 <code>setjmp</code> 的地方，此时<code>setjmp</code> 的返回值为 1，所以直接进入 <code>else</code> 打印 “main” ，函数结束。</p>\n<h3 id=\"signal-h\"><a href=\"#signal-h\" class=\"headerlink\" title=\"signal.h\"></a>signal.h</h3><p>signal提供了一些定义和函数用来处理执行过程中产生的信号。</p>\n<ol>\n<li><p>定义了相关的宏</p>\n<ul>\n<li>以 <code>SIG_</code> 开头的宏用于定义信号处理函数:  <ul>\n<li><code>SIG_DFL</code> 默认信号处理函数。</li>\n<li><code>SIG_ERR</code> 表示一个错误信号，当signal函数调用失败时的返回值。</li>\n<li><code>SIG_IGN</code> 信号处理函数，表示忽略该信号。  </li>\n</ul>\n</li>\n<li>以<code>SIG</code>开头的宏是用来在下列情况下，用来表示一个信号代码：<ul>\n<li><code>SIGABRT</code> 异常终止（<code>abort</code>函数产生）。</li>\n<li><code>SIGFPE</code> 浮点错误（0作为除数产生的错误，非法的操作）。</li>\n<li><code>SIGILL</code> 非法操作（指令）。</li>\n<li><code>SIGINT</code> 交互式操作产生的信号（如CTRL - C）。</li>\n<li><code>SIGSEGV</code> 无效访问存储（片段的非法访问，内存非法访问）。</li>\n<li><code>SIGTERM</code> 终止请求。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>定义了一个变量<br><code>typedef sig_atomic_t</code><br><code>sig_atomic_t</code> 类型是int类型，用于接收 <code>signal</code> 函数的返回值。</p>\n</li>\n<li><p>定义了两个函数</p>\n</li>\n</ol>\n<ul>\n<li>signal 函数<br><code>void(*signal(int sig,void (*func)(int)))(int);</code><br>上面的函数定义中，<code>sig</code> 表示一个信号代码（相当于暗号类别），即是上面所定义的 <code>SIG</code> 开头的宏。当有信号出现（即当收到暗号）的时候，参数 <code>func</code> 所定义的函数就会被调用。</li>\n<li>raise 函数<br><code>int raise(int sig);</code><br>发出一个信号 <code>sig</code>。信号参数为 <code>SIG</code>开头的宏。</li>\n</ul>\n<h3 id=\"stdarg-h\"><a href=\"#stdarg-h\" class=\"headerlink\" title=\"stdarg.h\"></a>stdarg.h</h3><p>stdarg定义了一些宏，当函数参数未知时去获取函数的参数</p>\n<ol>\n<li><p>变量：<code>typedef va_list</code> 通过 <code>stdarg</code> 宏定义来访问一个函数的参数表，参数列表的末尾会用省略号省略 </p>\n</li>\n<li><p>宏：<br><code>void va_start(va_list ap, last_arg);</code><br>用va_arg和va_end宏初始化参数ap，last_arg是传给函数的固定参数的最后一个，省略号之前的那个参数注意va_start必须在使用va_arg和va_end之前调用<br><code>type va_arg(va_list ap, type);</code><br>用type类型扩展到参数表的下个参数<br>注意ap必须用va_start初始化，如果没有下一个参数，结果会是undefined<br><code>void va_end(va_list ap);</code><br>允许一个有参数表（使用va_start宏）的函数返回，如果返回之前没有调用va_end,结果会是undefined。参数变量列表可能不再使用（在没调用va_start的情况下调用va_end）</p>\n</li>\n</ol>\n","excerpt":"<p>C 库函数主要指那些由美国国家标准协会（ANSI）或国际标准化组织(ISO)发布的标准中规定的库函数，按照标准 C 的要求来进行 C 语言编程是很重要的，因为这样你的代码才有可能跨平台使用。<br>","more":"<br>最早的 <code>C89</code> 中有15个标准头文件：</p>\n<blockquote>\n<p> assert.h   ctype.h   errno.h   float.h   limits.h<br> locale.h   math.h   setjmp.h   signal.h   stdarg.h<br> stddef.h   stdio.h   stdlib.h   string.h   time.h   </p>\n</blockquote>\n<p>随后的 <code>C95</code> 增加了3个标准头文件：</p>\n<blockquote>\n<p>iso646.h   wchar.h   wctype.h </p>\n</blockquote>\n<p>其次 <code>C99</code> 增加了6个标准头文件：</p>\n<blockquote>\n<p> complex.h    fenv.h   inttypes.h    stdbool.h    stdint.h   tgmath.h </p>\n</blockquote>\n<p>最新的 <code>C11</code> 又增加了5个标准头文件：</p>\n<blockquote>\n<p> stdalign.h   stdatomic.h   stdnoreturn.h   threads.h   uchar.h </p>\n</blockquote>\n<p>所以目前总共有29个标准头文件，但是大部分的编译器并没有支持全部的C标注，所以目前我们在这里讨论的主要还是 <code>C89</code> 中的15个标准头文件。</p>\n<h2 id=\"相关头文件的内容说明\"><a href=\"#相关头文件的内容说明\" class=\"headerlink\" title=\"相关头文件的内容说明\"></a>相关头文件的内容说明</h2><p><code>C89</code> 的15个标准头文件的主要内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>头文件</th>\n<th>说明</th>\n<th>头文件</th>\n<th>说明</th>\n<th>头文件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assert.h</td>\n<td>断言相关</td>\n<td>ctype.h</td>\n<td>字符类型判断</td>\n<td>errno.h</td>\n<td>标准错误机制</td>\n</tr>\n<tr>\n<td>float.h</td>\n<td>浮点限制</td>\n<td>limits.h</td>\n<td>整形限制</td>\n<td>locale.h</td>\n<td>本地化接口</td>\n</tr>\n<tr>\n<td>math.h</td>\n<td>数学函数</td>\n<td>setjmp.h</td>\n<td>非本地跳转</td>\n<td>signal.h</td>\n<td>信号相关</td>\n</tr>\n<tr>\n<td>stdarg.h</td>\n<td>可变参数处理</td>\n<td>stddef.h</td>\n<td>宏和类型定义</td>\n<td>stdio.h</td>\n<td>标准I/O</td>\n</tr>\n<tr>\n<td>stdlib.h</td>\n<td>标准工具库</td>\n<td>string.h</td>\n<td>字符串和内存处理</td>\n<td>time.h</td>\n<td>时间相关</td>\n</tr>\n</tbody>\n</table>\n<p>有人说，标准库(C89)——也就是ISO C——可以分为3组，根据这3组可以分出三种层次的程序员：</p>\n<ul>\n<li>合格程序员： ctype.h 、 stdio.h 、 stdlib.h 、 string </li>\n<li>熟练程序员： assert.h 、 limits.h 、 stddef.h 、 time.h </li>\n<li>优秀程序员： float.h 、 math.h 、 errno.h 、 locale.h 、 setjmp.h 、 signal.h 、 stdarg.h<br>作为一个走在优秀程序员路上的 XX 程序员，这里简单把三个层次分开说一下。</li>\n</ul>\n<h2 id=\"合格程序员的层次\"><a href=\"#合格程序员的层次\" class=\"headerlink\" title=\"合格程序员的层次\"></a>合格程序员的层次</h2><h3 id=\"ctype-h\"><a href=\"#ctype-h\" class=\"headerlink\" title=\"ctype.h\"></a>ctype.h</h3><p> ctype.h 这个头文件主要定义了一批 C 语言字符分类函数，所有的函数都只有一个参数，且参数和返回值均为 <code>int</code> 类型。下面是简单的函数介绍：</p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>说明</th>\n<th>函数名</th>\n<th>说明</th>\n<th>函数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isalpha</td>\n<td>是否为字母</td>\n<td>isdigit</td>\n<td>是否为数字</td>\n<td>isalnum</td>\n<td>是否为数字或字母</td>\n</tr>\n<tr>\n<td>iscntrl</td>\n<td>是否为控制字符</td>\n<td>isgraph</td>\n<td>是否为图形文字</td>\n<td>isupper</td>\n<td>是否为大写字母</td>\n</tr>\n<tr>\n<td>islower</td>\n<td>是否为小写字母</td>\n<td>tolower</td>\n<td>转换为小写字母</td>\n<td>toupper</td>\n<td>转换为大写字母</td>\n</tr>\n<tr>\n<td>isprintf</td>\n<td>是否为可打印字符</td>\n<td>ispunct</td>\n<td>是否为标点符号</td>\n<td>isspace</td>\n<td>是否为空白</td>\n</tr>\n<tr>\n<td>isxdigit</td>\n<td>是否为十六进制的数字</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"stdio-h\"><a href=\"#stdio-h\" class=\"headerlink\" title=\"stdio.h\"></a>stdio.h</h3><p> stdio.h 这个头文件应该是大多数人接触 C 语言的时候第一个认识的 C 库函数。这个函数最常用，但是也很复杂。它定义了三种类型，一些宏和很多的输入输出函数。</p>\n<ol>\n<li>定义的三种类型：  <ul>\n<li><code>size_t</code> 是由 <code>sizeof</code> 关键字产生的无符号整类型。</li>\n<li><code>FILE</code> 是一个结构体类型，记录了控制流需要的所有信息，包括它的文件定位符、指向相关缓冲的指针、记录是否发生了读/写错误的错误提示符和记录文件是否结束的文件结束符。 </li>\n<li><code>fpos_t</code>包含可以唯一指定文件中的每一个位置所需的所有信息。</li>\n</ul>\n</li>\n<li>定义了一些常量：  <ul>\n<li><code>NULL</code> 空值 </li>\n<li><code>_IOFBF</code> 表示完全缓冲 <code>_IOLBF</code> 表示线缓冲 <code>_IONBF</code> 表示无缓存</li>\n<li><code>BUFSIZ</code> 是<code>setbuf</code>函数所使用的缓冲区的大小</li>\n<li><code>EOF</code> 是负整数,该表达式由几个函数返回来说明文件的结束，即一个流输入结束了(END OF FILE)</li>\n<li><code>FOPEN_MAX</code> (20)同时打开的文件的最大数量</li>\n<li><code>FILENAME_MAX</code> 文件名的最大长度</li>\n<li><code>L_tmpnam</code>整数，最大长度的临时文件名</li>\n<li><code>SEEK_CUR</code>取得目前文件位置 <code>SEEK_END</code> 将读写位置移到文件尾时 <code>SEEK_SET</code> 将读写位置移到文件开头</li>\n<li><code>TMP_MAX</code> 表示<code>tmpnam</code>函数可以生成的单独文件名的最大数目</li>\n<li><code>`stderr</code>标准错误流，默认为屏幕, 可输出到文件 <code>stdin</code>标准输入流，默认为键盘 <code>stdout</code>标准输出流，默认为屏幕 </li>\n</ul>\n</li>\n<li>一些相关的函数<ul>\n<li>文件操作函数 （4个）<br><code>int remove(const char *filename);</code>  删除文件<br><code>int rename(const char *old, const char *new);</code>  重命名文件<br><code>FILE *tmpfile(void);</code> 创建一个临时的二进制文件，并通过模式“wb+”打开。<br><code>char *tmpname（char *s）;</code> 生成一个字符串，这个字符串是一个有效的文件名。  </li>\n<li>文件访问函数 (6个)<br><code>FILE* fopen(const char *filename, const char *mode);</code>打开名字为 <code>filename</code> 指向的文件，并且把这个文件和一个流相关联。<br><code>FILE* freopen(const char *filename, const char *mode, FILE *stream);</code>打开名字为 <code>filename</code> 指向的文件，并且把它和 <code>stream</code> 指向的流关联在一起。<br><code>int fclose(FILE *stream);</code>使 <code>stream</code> 指向的流被清空，并且和流相关联的文件被关闭。<br><code>int fflush(FILE *stream);</code>对 <code>stream</code> 指向的流执行清空行为。<br><code>void setbuf(FILE *stream, char *buf);</code>除了没有返回值，等价于函数 <code>setvbuf</code>。<br><code>void setvbuf(FILE *stream, char *buf, int mode, size_t size);</code>设定 <code>stream</code> 缓冲的方式。   </li>\n<li>格式化的输入输出函数 （9个）<br><code>int fprintf(FILE *stream, const char *format, ...);</code><br><code>int printf(const char *format, ...);</code><br><code>int sprintf(char *s, const char *format, ...);</code><br>返回传送的字符的数目。<br><code>int fscanf(FILE *stream, const char *format, ...);</code><br><code>int scanf(const char *format, ...);</code><br><code>int sscanf(char *s, const char *format, ...);</code><br>如果在任何转换之前发生了输入失败，返回 <code>EOF</code>；否则返回赋值的输入项的数目。<br><code>int vfprintf(FILE *stream, const char *format, va_list arg);</code><br><code>int vprintf(const char *format, va_list arg);</code><br><code>int vsprintf(char *s, const char *format, va_list arg);</code><br>等价于对应的 <code>printf</code> 函数，不过可变参数表用 <code>arg</code> 代替。   </li>\n<li>字符输入/输出函数 （11个）<br><code>int fgetc(FILE *stream);</code>从 <code>stream</code> 指向的输入流中读取下一个字符。<br><code>int getc(FILE *stream);</code>等价于函数 <code>fgetc</code>。<br><code>int getchar(void);</code>等价于用参数 <code>stdin</code> 调用函数 <code>getc</code>。<br><code>int fputc(int c, FILE *stream);</code>把字符写到指向的输出流中指定的位置处。<br><code>int putc(int c, FILE *stream);</code>等价于 <code>fputc。</code><br><code>int putchar(int c);</code> 等价于把stdout作为第二个参数调用的 <code>putc。</code><br><code>char *fgets(char *s, int n, FILE *stream);</code>从 <code>stream</code>指向的流中读取字符。<br><code>int fputs(const char *s, FILE *stream);</code>把 <code>s</code> 指向的串写入 <code>stream</code> 指向的流中。<br><code>char *gets(char *s);</code>从 <code>stdin</code> 指向的输入流中读取若干个字符，并将其保留到 <code>s</code> 指向的数组中，直到遇到文件结束符或者读取一个换行符。<br><code>int puts(const char *s);</code>把 <code>s</code> 指向的串写到 <code>stdout</code> 指向的流中，并且在输出最后添加一个换行符。<br><code>int ungetc(int c, FILE *stream);</code> 把 <code>c</code> 指定的字符（转换为 <code>unsigned char</code> 类型）退回到 <code>stream</code> 指向的输入流中。  </li>\n<li>直接输入/输出函数 （2个）<br><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code><br>从 <code>stream</code> 指向的流中读取最多 <code>nmemb</code> 个元素到 <code>ptr</code> 指向的数组中 。<br><code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code><br>从 <code>ptr</code> 指向的数组中读取最多 <code>nmemb</code> 个元素并将其写到 <code>stream</code> 指向的流中。  </li>\n<li>文件定位函数 (5个)<br><code>int fgetpos(FILE *stream, fpos_t *pos);</code><br>把 <code>stream</code> 指向的流的文件定位符的当前值存储到 <code>pos</code> 指向的对象中。<br><code>int fsetpos(FILE *stream, const fpos_t *pos);</code><br>根据 <code>pos</code> 指向的对象的值来设置 <code>stream</code> 指向的流的文件定位符，<br><code>long int ftell(FILE *stream);</code><br>获得 <code>stream</code> 指向的流的文件定位符的当前值。<br><code>int fseek(FILE *stream, long int offset, int whence);</code><br>为 <code>stream</code> 指向的流设置文件定位符。<br><code>void rewind(FILE *stream);</code><br>把 <code>stream</code> 指向的流的文件定位符设置在文件的开始位置，等价于 <code>(void)fseek(stream, 0L, SEEK_SET);</code>，只不过流的错误指示符也被清零。</li>\n<li>错误处理函数 (4个)<br><code>void clearerr(FILE *stream);</code><br>清空 <code>stream</code> 指向的流的文件结束符和错误指示符。<br><code>int feof(FILE *stream);</code><br>测试 <code>stream</code> 指向的流的文件结束符。当且仅当 <code>stream</code> 流设置了文件结束符时函数返回一个非0值。<br><code>int ferror(FILE *stream);</code><br>测试 <code>stream</code> 指向的流的错误指示符。当且仅当 <code>stream</code> 流设置了错误指示符时函数返回一个非0值。<br><code>void perror(const char *s);</code><br>把整数表达式 <code>errno</code> 中的错误编号转换为一条错误消息。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"stdlib-h\"><a href=\"#stdlib-h\" class=\"headerlink\" title=\"stdlib.h\"></a>stdlib.h</h3><p>是标准工具库。包含了C语言的中最常用的系统函数</p>\n<ol>\n<li>定义了五个宏<ul>\n<li><code>NULL</code> 空</li>\n<li><code>EXIT_FAILURE</code> 失败状态码</li>\n<li><code>EXIT_SUCCESS</code> 成功状态码</li>\n<li><code>RAND_MAX rand</code> 的最大返回值</li>\n<li><code>MB_CUR_MAX</code> 多字节字符中的最大字节数</li>\n</ul>\n</li>\n<li>定义了四个类型：<ul>\n<li><code>size_t</code> 是由 <code>sizeof</code> 关键字产生的无符号整类型。</li>\n<li><code>wchar_t</code> 是一个整型，标识一个宽字节字符，例如 <code>L’x’</code> 的类型就是 <code>wchar_t</code>。</li>\n<li><code>div_t</code> 是结构体类型 作为 <code>div</code> 函数的返回类型</li>\n<li><code>ldiv_t</code> 是一个结构类型，是函数 <code>ldiv</code> 的返回值类型。</li>\n</ul>\n</li>\n<li>定义了六类函数：<ul>\n<li>字符串函数<br><code>double atof(const char *nptr);</code> 将字符串转换成浮点型数<br><code>int atoi(const char *nptr);</code> 将字符串转换成整型数<br><code>long int atol(const char *nptr);</code>将字符串转换成长整型数<br><code>double strtod(const char *nptr, char **endptr);</code>将字符串转换成浮点数<br><code>long int strtol(const char *nptr, char **endptr, int base);</code>将字符串转换成长整型数<br><code>unsigned long int strtoul(const char *nptr, char **endptr, int base);</code> 将字符串转换成无符号长整型数 </li>\n<li>内存控制函数<br><code>void *calloc(size_t nmemb, size_t size);</code> 配置内存空间<br><code>void free(void *ptr);</code> 释放原先配置的内存<br><code>void *malloc(size_t size);</code> 配置内存空间<br><code>void *realloc(void *ptr, size_t size);</code>重新分配主存</li>\n<li>环境函数<br><code>int atexit(void (*func)(void));</code><br>注册func指向的函数，该函数在程序正常终止的时候被调用。<br><code>void exit(int status);</code><br>使程序正常终止。<br><code>void abort(void);</code><br>使程序异常终止，除非捕获了信号SIGABRT且信号处理程序没有返回。<br><code>char *getenv(const char *name);</code><br>搜索宿主环境提供的环境表，来查找一个能和name指向的串匹配的串。<br><code>int system(const char *string);</code><br>把sring指向的串传递给宿主环境，然后命令处理程序按照实现定义的方式执行它。</li>\n<li>搜索和排序函数<br><code>void bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compare)(const void , const void *));</code><br>搜索一个拥有 <code>nmemb</code> 个元素的数组，来查找与 <code>key</code> 指向的对象匹配的元素，<br><code>void qsort(void base, size_t nmemb, size_t size, int (*compare)(const void , const void *));</code><br>根据 <code>compare</code> 所指向的比较函数将数组内容排列成升序。</li>\n<li>数学函数<br><code>int abs(int j);</code>计算整型数的绝对值<br><code>long int labs(long int j);</code>将两个整数相除, 返回商和余数<br><code>div_t div(int number, int denom);</code>取长整型绝对值<br><code>ldiv_t ldiv(long int number, long int denom);</code>两个长整型数相除, 返回商和余数<br><code>int rand(void);</code> 随机数发生器<br><code>void srand(unsigned int seed);</code> 设置随机数种子</li>\n<li>多字节函数<br><code>int mblen(const char *s, size_t n);</code>根据locale的设置确定字符的字节数<br><code>int mbtowc(wchar_t *pwc, const char *s, size_t n);</code>把多字节字符转换为宽字符<br><code>int wctomb(char *s, wchar_t wchar);</code>把宽字符转换为多字节字符<br><code>size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);</code>把多字节字符串转换为宽字符串<br><code>size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);</code>把宽字符串转换为多字节字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>包含了C语言的最常用的字符串操作函数</p>\n<ol>\n<li>定义了一个宏： <code>NULL</code> 空</li>\n<li>定义了一个变量： <code>size_t</code></li>\n<li>定义了五类函数：<ul>\n<li>名字以mem开头的函数对任意的字符序列进行操作。其中一个参数指向字符串的起始位置，另一个参数对元素的个数尽行计数。<br><code>void *memmove(void *s1, const void *s2, size_t n);</code><br><code>void *memcpy(void *s1, const void *s2, size_t n);</code><br>memmove和memcpy均从s2指向的对象中复制n个字符到s1指向的对象中，返回s1的值。不同之处在于，当复制发生在两个重叠的对象中，memcpy对这种行为未定义，memmove则可以正确执行。<br><code>int memcmp(const void *s1, const void *s2, size_t n);</code><br>比较s1和s2指向的对象中前n个字符。<br><code>void *memchr(const void *s, int c, size_t n);</code><br>返回指向定位的字符的指针，如果没有返回空指针。<br><code>void *memset(void *s, int c, size_t n);</code><br>把c的值复制到s指向的对象的前n个字符的每个字符中，返回s的值。</li>\n<li>名字以strn开头的函数对非空字符序列进行操作。<br><code>char *strcpy(char *s1, const char *s2);</code><br>包括终止的空字符，返回s1的值<br><code>char *strcat(char *s1, const char *s2);</code><br>包括终止的空字符，返回s1的值。<br><code>int strcmp(const char *s1, const char *s2);</code><br>比较s1和s2指向的串。<br><code>char *strchr(const char *s, int c);</code><br>终止的空字符被认为串的一部分。<br><code>char *strrchr(cosnt char *s, int c);</code><br>确定c在s指向的串中最后一次出现的位置。r意为right一侧。<br><code>char *strstr(const char *s1, const char *s2);</code><br>s2指向的串的字符序列在s1指向的串中第一次出现的位置。<br><code>size_t strspn(const char *s1, const char *s2);</code><br>计算s1指向的字符串中完全由s2指向的字符串中的字符组成的最大初始段的长度。也就是说，它从s1的开头搜索一个和s2中的任意元素都不匹配的字符，返回此字符的下标。<br><code>size_t strcspn(const char *s1, const char *s2);</code><br>查找两个字符串第一个相同的字符在s1中的位置，也就是The first char both in s1 and s2，如果没有则返回终止的空字符的索引。<br>strcspn和strchr很相似，但它匹配的是任意一个字符集而不是一个字符。<br><code>char *strpbrk(const char *s1, const char *s2);</code><br>确定s2指向的串中的任意的字符在s1中第一次出现的位置。<br><code>char *strtok(char *s1, const char *s2);</code><br>分解字符串为一组字符串。s1为要分解的字符串，s2为分隔符字符串。</li>\n<li>名字以str开头的函数对空字符结尾的字符序列进行操作。<br><code>char *strncpy(char *s1, const char *s2, size_t n);</code><br>从s2指向的数组中复制最多n个字符（包括空字符），不会在s1的末尾自动添加空字符；如果达到n个字符之前遇到了空字符，则复制完空字符后停止，并在s1指向的数组后面添加空字符，直到写入了n个字符。<br>简单来说，复制，直到遇到空字符或达到n个字符，如果此时复制的字符数未达到n，就填充空字符，直到字符数达到n。<br><code>char *strncat(char *s1, const char *s2, size_t n);</code><br>从s2指向的数组中将最多n个字符（空字符及其后面的字符不添加）添加到s1指向的串的结尾。在最后的结果后面加上一个空字符。<br>简单来说，cat，直到遇到空字符或达到n个字符，最后的结果一定以空字符结尾。<br><code>int strncmp(const char *s1, const char *s2, size_t n);</code><br>对s1和s2指向的数组中的最多n个字符进行比较（空字符后面的字符不参加比较）。</li>\n<li>其他类<br><code>size_t strlen(const char *s);</code><br>计算s指向的串的长度，不包括结尾的空字符。<br><code>char *strerror(int errnum);</code><br>将errnum中的错误编号对应到一个错误信息串。</li>\n<li>与区域设置有关<br><code>int strcoll(const char *s1, const char *s2);</code><br>功能同strcmp，只是比较时串都被解释为适合当前区域设置的类别LC_COLLATE的形式。<br><code>size_t strxfrm(char *s1, const char *s2, size_t n);</code><br>如果区域选项是”POSIX”或者”C”，那么strxfrm()同用strncpy()来拷贝字符串是等价的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"熟练程序员的层次：\"><a href=\"#熟练程序员的层次：\" class=\"headerlink\" title=\"熟练程序员的层次：\"></a>熟练程序员的层次：</h2><h3 id=\"assert-h\"><a href=\"#assert-h\" class=\"headerlink\" title=\"assert.h\"></a>assert.h</h3><p>这个头文件只定义了一个宏：<code>assert</code><br>如果条件为假，assert将输出一些信息并调用abort函数退出程序。<br>一个可能的实现：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NDEBUG</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span>\t</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">12</span>;</div><div class=\"line\">  <span class=\"keyword\">int</span> b = <span class=\"number\">24</span>;</div><div class=\"line\">  assert( a &gt; b );</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"a is larger than b!\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的程序会发现程序中止，<code>printf</code> 并未执行，且有这样的输出：<code>main: Assertion &#39;a &gt; b&#39; failed.</code>原因就是因为 <code>a</code> 其实小于 <code>b</code>，导致断言失败，<code>assert</code> 输出错误信息，并调用 <code>abort()</code>中止了程序执行。</p>\n<h3 id=\"limits-h\"><a href=\"#limits-h\" class=\"headerlink\" title=\"limits.h\"></a>limits.h</h3><p>头文件定义了整型变量的一些极限值和设置。</p>\n<p><code>CHAR_BIT</code> 一个ASCII字符长度  <code>SCHAR_MIN</code> 字符型最小值<br><code>SCHAR_MAX</code> 字符型最大值  <code>UCHAR_MAX</code> 无符号字符型最大值<br><code>CHAR_MIN</code>/<code>CHAR_MAX</code> char字符的最大最小值，如果char字符正被表示有符号整数。它们的值就跟有符号整数一样。否则char字符的最小值就是0，最大值就是无符号char字符的最大值。<br><code>MB_LEN_MAX</code> 一个字符所占最大字节数<code>SHRT_MIN</code> 最小短整型<br><code>SHRT_MAX</code> 最大短整形 <code>USHRT_MAX</code> 最大无符号短整型<br><code>INT_MIN</code> 最小整型 <code>INT_MAX</code> 最大整形<br><code>UINT_MAX</code> 最大无符号整型 <code>LONG_MIN</code> 最小长整型<br><code>LONG_MAX</code> 最大长整型 <code>ULONG_MAX</code> 无符号长整型</p>\n<h3 id=\"stddef-h\"><a href=\"#stddef-h\" class=\"headerlink\" title=\"stddef.h\"></a>stddef.h</h3><p>此头文件定义了3个类型和2个宏，其中一些在其他头文件中也有定义。</p>\n<ul>\n<li>定义了三个类型<br><code>ptrdiff_t</code>两个指针相减的结果的类型，有符号整型，一般来说是int或long的typedef。<br><code>size_t</code>是sizeof操作符的结果的类型，无符号整型。<br><code>wchar_t</code>是一个整型，标识一个宽字节字符，例如L’x’的类型就是wchar_t。</li>\n<li>定义了两个宏<br><code>NULL</code> 空指针常量。<br><code>offsetof(type, member-designator)</code> 展开为一个size_t类型的整值常量表达式。</li>\n</ul>\n<h3 id=\"time-h\"><a href=\"#time-h\" class=\"headerlink\" title=\"time.h\"></a>time.h</h3><p>作时间的函数。 </p>\n<ol>\n<li><p>定义了两个宏</p>\n<ul>\n<li><code>NULL</code></li>\n<li><code>CLOCKS_PER_SEC</code> 使 <code>clock</code> 函数的返回值 <code>CLOCKS_PER_SEC</code> 的单位是秒</li>\n</ul>\n</li>\n<li><p>定义了四个类型<br>声明的类型有size_t、clock_t、time_t和struct tm。 </p>\n<ul>\n<li><code>size_t</code> 在 <code>stddef.h</code> 中已介绍过。 </li>\n<li><code>clock_t</code> 是 <code>clock</code> 函数的返回值类型</li>\n<li><code>time_t</code> 是 <code>time</code> 函数的返回值类型，</li>\n<li><code>struct tm</code> 保存了一个日历时间的各组成部分，比如年月日时分秒等。</li>\n</ul>\n</li>\n<li><p>定义了两类函数</p>\n<ul>\n<li>时间获取函数<br><code>time_t time(time_t *timer);</code><br>取得目前的时间<br><code>clock_t clock(void);</code><br>确定处理器使用的时间。</li>\n<li>时间转换函数<br><code>struct tm *gmtime(const time_t *timer);</code>把日期和时间转换为(GMT)时间<br><code>struct tm *localtime(const time_t *timer);</code>取得当地目前时间和日期<br><code>char *ctime(const time_t *timer);</code> 把日期和时间转换为字符串<br><code>time_t mktime(struct tm *timeptr);</code>将时间结构数据转换成经过的秒数<br><code>char *asctime(const struct tm *timeptr);</code>将时间和日期以字符串格式表示<br><code>size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);</code>将时间格式化</li>\n<li>其他函数<br><code>double difftime(time_t time1, time_t time0);</code><br>计算两个日历时间之差：<code>time1-time0，</code>返回以秒为单位的差值。这个函数似乎简单到没有存在的必要，直接执行减法不就得了。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"优秀程序员的层次：\"><a href=\"#优秀程序员的层次：\" class=\"headerlink\" title=\"优秀程序员的层次：\"></a>优秀程序员的层次：</h2><h3 id=\"float-h\"><a href=\"#float-h\" class=\"headerlink\" title=\"float.h\"></a>float.h</h3><p>float 头文件类似 limit 头文件，主要是浮点型数值的相关定义。</p>\n<p>在所有实例里<code>FLT</code>指的是<code>float</code>，<code>DBL</code>是<code>double</code>，<code>LDBL</code>指的是<code>long double</code>.</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FLT_ROUNDS</td>\n<td>定义浮点型数值四舍五入的方式，-1是不确定，0是向0，1是向最近，2是向正无穷大，3是负无穷大</td>\n</tr>\n<tr>\n<td>FLT_RADIX 2</td>\n<td>定义指数的基本表示（比如base-2是二进制，base-10是十进制表示法，16是十六进制）</td>\n</tr>\n<tr>\n<td>FLT_MANT_DIG，DBL_MANT_DIG，LDBL_MANT_DIG</td>\n<td>定义数值里数字的个数</td>\n</tr>\n<tr>\n<td>FLT_DIG 6，DBL_DIG 10，LDBL_DIG 10</td>\n<td>在四舍五入之后能不更改表示的最大小数位</td>\n</tr>\n<tr>\n<td>FLT_MIN_EXP，DBL_MIN_EXP，LDBL_MIN_EXP</td>\n<td>FLT_RADIX 的指数的最小负整数值</td>\n</tr>\n<tr>\n<td>FLT_MIN_10_EXP -37，DBL_MIN_10_EXP -37，LDBL_MIN_10_EXP -37</td>\n<td>10进制表示法的的指数的最小负整数值</td>\n</tr>\n<tr>\n<td>FLT_MAX_EXP ,DBL_MAX_EXP ,LDBL_MAX_EXP</td>\n<td>FLT_RADIX 的指数的最大整数值</td>\n</tr>\n<tr>\n<td>FLT_MAX_10_EXP +37 ,DBL_MAX_10_EXP ,LDBL_MAX_10_EXP +37 +37</td>\n<td>10进制表示法的的指数的最大整数值</td>\n</tr>\n<tr>\n<td>FLT_MAX 1E+37，DBL_MAX 1E+37，LDBL_MAX 1E+37</td>\n<td>浮点型的最大限</td>\n</tr>\n<tr>\n<td>FLT_EPSILON 1E-5，DBL_EPSILON 1E-9，LDBL_EPSILON 1E-9</td>\n<td>能表示的最小有符号数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"math-h\"><a href=\"#math-h\" class=\"headerlink\" title=\"math.h\"></a>math.h</h3><p>math.h是 C 语言内的数学函数库。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>含义</th>\n<th>函数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>三角函数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double sin(double x);</td>\n<td>正弦</td>\n<td>double cos(double x);</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>double tan(double x);</td>\n<td>正切</td>\n<td>*cot三角函数，可以使用tan(PI/2-x)来实现。</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>反三角函数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double asin(double x);</td>\n<td>结果介于[-PI/2, PI/2]</td>\n<td>double acos(double x);</td>\n<td>结果介于[0, PI]</td>\n</tr>\n<tr>\n<td>double atan(double x);</td>\n<td>反正切(主值), <br>结果介于[-PI/2, PI/2]</td>\n<td>double atan2(double y,double);</td>\n<td>反正切(整圆值),<br> 结果介于[-PI, PI]</td>\n</tr>\n<tr>\n<td><strong>双曲三角函数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double sinh(double x);</td>\n<td>计算双曲正弦</td>\n<td>double cosh(double x);</td>\n<td>计算双曲余弦</td>\n</tr>\n<tr>\n<td>double tanh(double x);</td>\n<td>计算双曲正切</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>指数与对数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double exp(double x);</td>\n<td>求取自然数e的幂</td>\n<td>double sqrt(double x);</td>\n<td>开平方</td>\n</tr>\n<tr>\n<td>double log(double x);</td>\n<td>以e为底的对数</td>\n<td>double log10(double x);</td>\n<td>以10为底的对数</td>\n</tr>\n<tr>\n<td>double pow(double x, double y);</td>\n<td>计算以x为底数的y次幂</td>\n<td>float powf(float x, float y);</td>\n<td>与pow一致，输入与输出皆为浮点数</td>\n</tr>\n<tr>\n<td><strong>取整</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double ceil(double);</td>\n<td>取上整</td>\n<td>double floor(double);</td>\n<td>取下整</td>\n</tr>\n<tr>\n<td><strong>标准化浮点数</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double frexp(double f, int *p);</td>\n<td>标准化浮点数,<br> f = x * 2^p, <br>已知f求x, p <br>( x介于[0.5, 1] )</td>\n<td>double ldexp(double x, int p);</td>\n<td>与frexp相反, 已知x, p求f</td>\n</tr>\n<tr>\n<td><strong>取整与取余</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>double modf(double, double*);</td>\n<td>将参数的整数部分通过指针回传, 返回小数部分</td>\n<td>double fmod(double, double);</td>\n<td>返回两参数相除的余数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"errno-h\"><a href=\"#errno-h\" class=\"headerlink\" title=\"errno.h\"></a>errno.h</h3><p>error定义了通过错误码来返回错误信息的宏：</p>\n<p><code>errno</code> 宏定义为一个 <code>int</code> 型态的左值, 包含任何函数使用 <code>errno</code> 功能所产生的上一个错误码。<br>一些表示错误码，定义为整数值的宏：<br><code>EDOM</code> 源自于函数的参数超出范围,例如 <code>sqrt(-1)</code><br><code>ERANGE</code> 源自于函数的结果超出范围,例如 <code>strtol(&quot;0xfffffffff&quot;,NULL,0)</code><br><code>EILSEQ</code> 源自于不合​​法的字符顺序,例如 <code>wcstombs(str, L&quot;\\xffff&quot;, 2)</code></p>\n<h3 id=\"locale-h\"><a href=\"#locale-h\" class=\"headerlink\" title=\"locale.h\"></a>locale.h</h3><p>local 定义了区域设置相关的函数和相关的宏以及类型定义。</p>\n<ol>\n<li><p>定义了一个类型 <code>struct lconv;</code><br>其中几个比较重要的变量是<br><code>char *decimal_point;</code>格式化非货币量中的小数点字符<br><code>char *thousands_sep;</code> 用来对格式化的非货币量中小数点前面的数字进行分组的字符<br><code>char *grouping;</code> 用来说明格式化的非货币量中每一组数字的数目</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">   <span class=\"keyword\">char</span> *decimal_point;</div><div class=\"line\">   <span class=\"keyword\">char</span> *thousands_sep;</div><div class=\"line\">   <span class=\"keyword\">char</span> *grouping;\t</div><div class=\"line\">   <span class=\"keyword\">char</span> *int_curr_symbol;</div><div class=\"line\">   <span class=\"keyword\">char</span> *currency_symbol;</div><div class=\"line\">   <span class=\"keyword\">char</span> *mon_decimal_point;</div><div class=\"line\">   <span class=\"keyword\">char</span> *mon_thousands_sep;</div><div class=\"line\">   <span class=\"keyword\">char</span> *mon_grouping;</div><div class=\"line\">   <span class=\"keyword\">char</span> *positive_sign;</div><div class=\"line\">   <span class=\"keyword\">char</span> *negative_sign;</div><div class=\"line\">   <span class=\"keyword\">char</span> int_frac_digits;</div><div class=\"line\">   <span class=\"keyword\">char</span> frac_digits;</div><div class=\"line\">   <span class=\"keyword\">char</span> p_cs_precedes;</div><div class=\"line\">   <span class=\"keyword\">char</span> p_sep_by_space;</div><div class=\"line\">   <span class=\"keyword\">char</span> n_cs_precedes;</div><div class=\"line\">   <span class=\"keyword\">char</span> n_sep_by_space;</div><div class=\"line\">   <span class=\"keyword\">char</span> p_sign_posn;</div><div class=\"line\">   <span class=\"keyword\">char</span> n_sign_posn;</div><div class=\"line\">&#125; lconv</div></pre></td></tr></table></figure>\n</li>\n<li><p>定义了两个函数<br><code>struct lconv *localeconv(void);</code> 用于返回当前区域中的数字和货币信息<br><code>char *setlocale(int category, const char *locale);</code>用于设置或返回当前的区域特性</p>\n</li>\n<li><p>定义了几个宏</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>LC_ALL</td>\n<td>设置所有信息</td>\n</tr>\n<tr>\n<td>LC_COLLATE</td>\n<td>影响strcoll和strxfrm函数</td>\n</tr>\n<tr>\n<td>LC_CTYPE</td>\n<td>影响所有字符函数</td>\n</tr>\n<tr>\n<td>LC_MONETARY</td>\n<td>影响由 <code>localeconv</code> 函数提供的货币信息</td>\n</tr>\n<tr>\n<td>LC_NUMERIC</td>\n<td>影响十进制小数格式和 <code>localeconv</code> 函数提供的信息</td>\n</tr>\n<tr>\n<td>LC_TIME</td>\n<td>影响 <code>strftime</code> 函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"setjmp-h\"><a href=\"#setjmp-h\" class=\"headerlink\" title=\"setjmp.h\"></a>setjmp.h</h3><p>setjmp 定义了一种特别的函数调用和函数返回顺序的方式。它允许程序流程从一个深层嵌套的函数中返回。</p>\n<blockquote>\n<p>typedef int jmp_buf[16];<br>int setjmp(jmp_buf);<br>void longjmp(jmp_buf, int);</p>\n</blockquote>\n<p>非本地跳转的原理非常简单： </p>\n<ol>\n<li><code>setjmp(j)</code>设置 <strong>jump</strong> 点，用正确的程序上下文填充 <code>jmp_buf</code> 对象 <code>j</code>。这个上下文包括程序存放位置，栈和框架指针，其它重要的寄存器和内存数据。当初始化完 <code>jump</code> 的上下文，<code>setjmp()</code> 返回0值。 </li>\n<li>以后调用 <code>longjmp(j,r)</code> 的效果就是一个非局部的 <code>goto</code> 或 <strong>长跳转</strong> 到由 <code>j</code> 描述的上下文处（也就是原来调用 <code>setjmp(j)</code> 处）。当作为长跳转的目标而被调用时，<code>setjmp()</code> 返回 <code>r</code> 或 <code>1</code>（如果 <code>r</code> 设为<code>0</code> 的话）。（记住，<code>setjmp()</code>不能在这种情况时返回0）<br>通过有两类返回值，<code>setjmp()</code> 让你知道它正在被怎么使用。当设置 <code>j</code> 时，<code>setjmp()</code> 如你期望地执行；但当作为长跳转的目标时，<code>setjmp()</code>就从外面 <strong>唤醒</strong> 它的上下文。你可以用 <code>longjmp()</code> 来终止异常，用 <code>setjmp()</code> 标记相应的异常处理程序。</li>\n</ol>\n<p>一个简单的例子如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>  <span class=\"meta-string\">&lt;setjmp.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> jmp_buf buf;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">second</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"second\\n\"</span>);        </div><div class=\"line\">  longjmp(buf,<span class=\"number\">1</span>);            </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">first</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  second();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"first\\n\"</span>);          </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;   </div><div class=\"line\">  <span class=\"keyword\">if</span> ( ! setjmp(buf) ) &#123;</div><div class=\"line\">    first();               </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                  </div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"main\\n\"</span>);  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>程序首先执行了 <code>setjmp</code> ，初始化了 <code>buf</code>，函数返回了0，进入 <code>first</code> 函数，执行了 <code>second</code> 函数，打印”second”，随后执行 <code>longjmp</code> 函数跳转到 <code>setjmp</code> 的地方，此时<code>setjmp</code> 的返回值为 1，所以直接进入 <code>else</code> 打印 “main” ，函数结束。</p>\n<h3 id=\"signal-h\"><a href=\"#signal-h\" class=\"headerlink\" title=\"signal.h\"></a>signal.h</h3><p>signal提供了一些定义和函数用来处理执行过程中产生的信号。</p>\n<ol>\n<li><p>定义了相关的宏</p>\n<ul>\n<li>以 <code>SIG_</code> 开头的宏用于定义信号处理函数:  <ul>\n<li><code>SIG_DFL</code> 默认信号处理函数。</li>\n<li><code>SIG_ERR</code> 表示一个错误信号，当signal函数调用失败时的返回值。</li>\n<li><code>SIG_IGN</code> 信号处理函数，表示忽略该信号。  </li>\n</ul>\n</li>\n<li>以<code>SIG</code>开头的宏是用来在下列情况下，用来表示一个信号代码：<ul>\n<li><code>SIGABRT</code> 异常终止（<code>abort</code>函数产生）。</li>\n<li><code>SIGFPE</code> 浮点错误（0作为除数产生的错误，非法的操作）。</li>\n<li><code>SIGILL</code> 非法操作（指令）。</li>\n<li><code>SIGINT</code> 交互式操作产生的信号（如CTRL - C）。</li>\n<li><code>SIGSEGV</code> 无效访问存储（片段的非法访问，内存非法访问）。</li>\n<li><code>SIGTERM</code> 终止请求。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>定义了一个变量<br><code>typedef sig_atomic_t</code><br><code>sig_atomic_t</code> 类型是int类型，用于接收 <code>signal</code> 函数的返回值。</p>\n</li>\n<li><p>定义了两个函数</p>\n</li>\n</ol>\n<ul>\n<li>signal 函数<br><code>void(*signal(int sig,void (*func)(int)))(int);</code><br>上面的函数定义中，<code>sig</code> 表示一个信号代码（相当于暗号类别），即是上面所定义的 <code>SIG</code> 开头的宏。当有信号出现（即当收到暗号）的时候，参数 <code>func</code> 所定义的函数就会被调用。</li>\n<li>raise 函数<br><code>int raise(int sig);</code><br>发出一个信号 <code>sig</code>。信号参数为 <code>SIG</code>开头的宏。</li>\n</ul>\n<h3 id=\"stdarg-h\"><a href=\"#stdarg-h\" class=\"headerlink\" title=\"stdarg.h\"></a>stdarg.h</h3><p>stdarg定义了一些宏，当函数参数未知时去获取函数的参数</p>\n<ol>\n<li><p>变量：<code>typedef va_list</code> 通过 <code>stdarg</code> 宏定义来访问一个函数的参数表，参数列表的末尾会用省略号省略 </p>\n</li>\n<li><p>宏：<br><code>void va_start(va_list ap, last_arg);</code><br>用va_arg和va_end宏初始化参数ap，last_arg是传给函数的固定参数的最后一个，省略号之前的那个参数注意va_start必须在使用va_arg和va_end之前调用<br><code>type va_arg(va_list ap, type);</code><br>用type类型扩展到参数表的下个参数<br>注意ap必须用va_start初始化，如果没有下一个参数，结果会是undefined<br><code>void va_end(va_list ap);</code><br>允许一个有参数表（使用va_start宏）的函数返回，如果返回之前没有调用va_end,结果会是undefined。参数变量列表可能不再使用（在没调用va_start的情况下调用va_end）</p>\n</li>\n</ol>"},{"title":"C语言学习总结（二）——GCC和GDB","date":"2016-11-21T06:44:46.000Z","_content":"\n使用 Linux ，不可避免的需要使用 GCC 套件，从原本的只能编译C语言，到现在的系列的套件，而今天在这里主要讨论的是：GCC 是如何一步步的将代码编译成可执行文件的，以及如何使用 GDB 进行调试。\n<!--more-->\n\n# 一、GCC是什么\nGCC是什么，GCC是一个软件，GNU编译器套件（GNU Compiler Collection），最初由GNU组织为C语言开发，之后发展为一个套件。\n\n# 二、GCC编译过程\n## 1、预处理\n预处理的过程是编译器去将头文件进行包含，将宏定义进行替换，在这个过程中，inlude和define命令生效。\n预处理过程中的常用知识点有：\n\n1. 头文件未包含，<> 和 \"\" 的使用范围是不一样的，对于用户自定义的头文件，需要用 “” 指出路径。  可以使用 -I 命令指定头文件的目录路径\n2. 宏的重定义，因为不同头文件可能会重复引用同样的宏，会出现类似的问题，所以，使用 \n````C++\n#ifndef   XXX\n#define   XXX\n…\n#endif````\n    来避免重复定义宏，这种写法同样可以用来进行条件编译：`-D XXX` 。\n\n3. include与define不是关键字，他们是GCC可以识别的标识码。\n3. 宏定义中可以进行函数替换，但是必须是在同一行，多行函数一般使用`do{ … }while(0)`。\n3. 常见的预定义宏\n    * __FILE__ ：代表当前源文件的文件名\n    * __LINE__ ：代表展开成当前代码行的行号，是编译器内建的特殊宏定义\n    * __FUNCTION__  : 函数名\n\n3. \\# 和 ## 是预处理运算符 \n\n|写法|含义|\n|----------|--------------|\n| #define ABC(x)   #x\t|字符串化|\n| #define ABC(x)   day##x\t| 字符连接|\n\n最后的问题，在预处理的过程中，头文件中的定义是如何被包含在文件中的。\n\n## 2. 编译\n编译是将C语言程序编译成汇编文件的一个过程。\n编译的过程主要经过了六步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。\n在编译过程中可能出现的问题有：\n\n1. 语法错误，根据错误提示进行修改代码\n2. 优化错误，在嵌入式系统中会出现编译器的过度优化，有时候需要设定优化选项\n\n## 3. 汇编\n汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。\n## 4. 链接\n通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。链接的过程主要分为：*地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution），重定位（Relocation）*等。\n链接分为静态链接和动态链接：\n\n1. 静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。\n- 编译静态链接库\n    1. 生成目标文件 .o\n    1. ar crv [*.a] [*.o] \n- 调用静态链接库\n    gcc -o [file] [file.c] -L.  [file.a]\n\n1. 动态链接是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。\n- 首先、在任何给定的文件系统中,对于一个库只有一个.so文件\n- 第二、所有引用该库德可执行目标文件共享这个.so文件中的代码和数据\n- 第三、在存储器中,一个共享库的.text节只有一个副本可以被不同的正在运行的进程共享.\n    1. 编译动态链接库\n        - 生成位置无关的目标代码 gcc-fPIC -c [*.c]\n        - gcc -shared -o [*.so] [*.o] \n    2. 调用动态链接库（与静态链接库类似）\n        - gcc -o [file] [file.c] -L.  [file.so]\n\n\n### **链接过程详解**\n**目标文件**\n目标文件分为三种：\n\n1. 可重定位的目标文件:\n包含二进制代码和数据,其形式可以再编译时与其他可定位目标文件合并起来,创建一个可执行目标文件。\n\n2. 可执行目标文件:\n包含二进制代码和数据,其形式可以被直接拷贝到存储器并执行.\n\n3. 共享目标文件:\n一种特殊的可重定位目标文件,可以再加载或运行时,被动态地夹在到存储器并执行.\n编译器和汇编器生成可重定位目标文件(包括共享目标文件),链接器生成可执行目标文件.\n 可重定位的目标文件的结构如下：\n\n|标识|作用|\n|---------|--------|\n|.text:\t|已编译程序的机器代码|\n|.rodata:\t|只读数据|\n|.data:\t|已初始化的全局C变量|\n|.bss:\t|未初始化的全局C变量.在目标文件中这个节不占实际空间,仅是一个占位符.|\n|.sysmtab:\t|一个符号表,存放在程序中被定义和引用的函数和全局变量的信息.\n|.rel.text:\t|当链接器把这个目标文件和其他文件结合时,.text节中的许多位置都需要修改.一般而言,任何调用外部函数或者引用全局变量的指令都要修改.另一个方面,调用本地函数的指令则不需要修改.|\n|.rel.data:\t|被模块定义或引用的任何全局变量的信息.|\n|.debug:\t|一个调试符号表|\n|.line:\t|原始C源程序中的行号和.text节中机器指令之间的映射.|\n|.strtab:|\t一个字符串表,其中内容包括.symtab和.debug节中的符号表,以及节头部中的节名字.|\n\n一个m文件的符号表有三种不同的符号\n\n|类型|作用|\n|---|---|\n|由m定义并能被其他模块引用的全局符号.       |1.m定义的非静态的C函数 2.m定义的不带static属性的全局变量.           \n|由其他模块定义并被模块m引用的全局符号.这些符号成为外部符号,  |在其他模块中的C函数和变量.  |\n|只被模块m定义和引用的本地符号.       |由m定义的带static属性的C函数和全局变量|\n\n**符号解析**\n将每个引用和它输入的可重定位目标文件按的符号表中的一个确定的符号定义联系起来.\n\n1. 局部和static变量等：\n对于那些和引用定义在相同模块的本地符号的引用,符号解析式非常简单明了的.编译器只允许每个模块中的每个本地符号只有一个定义.编译器还确保静态本地变量,它们会有本地链接器符号,拥有唯一的名字.\n\n2. 外部引用：对于全局符号的引用解析,当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,它会假设该符号式在其他某个模块中定义的,生成一个链接器符号表表目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用的符号,它就输出一条错误信息并终止.\n1. 在编译时,编译器输出的每个全局符号给汇编器,或者是强,或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中.函数和以初始化的全局变量是强符号,未初始化的全局变量是弱符号.\n    编译系统提供一种机制,将所有相关的目标模块打包为一个单独的文件,称为静态库,它可以用做链接器的输入.当链接器构造一个输出的可执行文件时,它只拷贝静态库里被应用程序引用的目标模块。\n    输入命令时要考虑到,静态库和目标文件的位置,库文件放在目标文件的后面,如果库文件之间有引用关系,则被引用的库放在后面。\n\n### **链接过程常见错误：**\n\n - 原材料不够  `undefined reference to fun`\n 寻找标签是否实现了，链接时是否加入一起链接\n - 原材料重复  `multiple definition of fun`\n 多次实现了标签，只保留一个标签实现\n\n## 5. GCC的主要选项\n\n|选项|含义|\n|----------|------------|\n|1. **编译过程**|\n|预处理\t-E \t|不经过编译预处理程序的输出而输送至标准输出\n|编译\t-S\t|要求编译程序生成来自源代码的汇编程序输出\n|汇编\t-c\t|通知GCC取消链接步骤,即编译源码并在最后生成目标文件\n|链接\t-o\t|生成可执行文件\n|调试\t-g\t|包含调试信息\n|头文件\t-I|\t包含指定路径的头文件\n|2. **警告选项**|\n|-v |\t启动所有警报\n|-Wall \t|在发生警报时取消编译操作,即将警报看作是错误\n|-w |\t禁止所有的报警\n|3. **库文件**|\n|-static\t|静态编译\n|-shared|\t1、生成动态库文件 2、进行动态编译\n|-L dir\t\t|库文件搜索中添加路径\n|-fPIC\t|\t生成使用相对位置无关的目标代码(Position Independent Code)然后通常用于使用gcc的-static选项从该PIC目标文件生成动态库文件\n|4. **特定功能**|\n|-D |\t定义指定的宏,使它能够通过源码中的#ifdef进行检验;\n|-O、|\t-O2、-O3 将优化状态打开,该选项不能与-g选项联合使用;\n\n# 三、GDB的使用\nGDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。一般来说，GDB主要帮忙你完成下面四个方面的功能：\n\n- 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。\n- 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）\n- 当程序被停住时，可以检查此时你的程序中所发生的事。\n- 动态的改变你程序的执行环境。\n\n## 1. 启动调试\n首先，要进行调试，需要在生成可执行文件的时候使用`gcc -g `选项：\n        `-g[level]  默认为2`\n\n - 0  表示不生成任何调试信息\n - 1  表示生成最少的调试信息，不提供局部变量及源代码行列等信息。\n - 2  标准模式\n - 3  较2而言,包含了宏定义等额外信息\n\n然后有两种方式启动调试\n方式一： 直接在命令行下输入gdb ./[filename]\n方式二：运行gdb后输入file ./[filename]\n\n## 2. 设置断点\n除了断点外还有Watchpoints(观测点)及Catchpoints (异常捕捉点)\n\n1. **设置断点**\n输入b或break加上断点位置或断点函数名,如\nb main 在main函数入口设置断点\nb text2bin.c:50   在源代码第50行设置断点\ninfo breakpoints  查看断点信息\nclear  清除所有断点\nclear text2bin.c:50  清除特定的断点\nclear main   清除特定函数断点\ndisable及enable  开关某个特定的断点\nb +5 及b -5   表示在当前行的后五行及前五行位置设置断点\n对于观测点(Watchpoints)，是指在某个条件下触发的断点,如text2bin中77行:\n`Buffer2[nCount++] = ConvertTextToInt(sData);` \n我们要查看当nCount为10时的运行状况,我们可以通过下面的步骤完成:\n    1. 执行b 77,返回这个断点号是<3></3>\n    2. 执行condition 3 nCount=10\n        这样就可以控制当nCount为10时在77行处中断.\n\n2. **设置捕捉点**\n你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。设置捕捉点的格式为：`catch`\n\n3. **其它相关命令**\n\n|命令|含义|\n|-------|--------|\n|info b\t|查看所设断点|\n|break 行号或函数名 <条件表达式>|\t设置断点|\n|tbreak 行号或函数名 <条件表达式>\t|设置临时断点，到达后被自动删除\n|delete [断点号]\t|删除指定断点，若缺省断点号则删除所有断点\n|disable [断点号]]\t|停止指定断点，使用”info b”仍能查看此断点。\n|enable [断点号]\t|激活指定断点，即激活被disable停止的断点\n|condition [断点号] <条件表达式>\t|修改对应断点的条件\n|ignore [断点号]<num>\t|在程序执行中，忽略对应断点num次\n|step\t|单步恢复程序运行，且进入函数调用\n|next\t|单步恢复程序运行，但不进入函数调用\n|finish\t|运行程序，直到当前函数完成返回\n|c\t|继续执行函数，直到函数结束或遇到新的断点\n\n## 3. 检查程序 可以使用以下命令查询程序\n|命令|含义|\n|--------------------|---------|\n|list<行号>/<函数名>|\t查看指定位置代码|\n|forward-search 正则表达式\t|源代码前向搜索|\n|reverse-search 正则表达式|\t源代码后向搜索|\n|dir dir\t|停止路径名|\n|show directories|\t显示定义了的源文件搜索路径\n|info line\t|显示加载到Gdb内存中的代码\n|print 表达式/变量\t|查看程序运行时对应表达式和变量的值\n|x <n/f/u>\t|查看内存变量内容。其中n为整数表示显示内存的长度，f表示显示的格式，u表示从当前地址往后请求显示的字节数\n|display 表达式\t|设定在单步运行或其他情况中，自动显示的对应表达式的内容\n|info thread\t|查看当前有多少线程\n|thread # \t|切换到指定线程\n|set print thread-events on/off\t|设定是否打印线程状态\n|b/break [location]  thread #\t|当设置中断时,也可以专为某个线程设置\n\n**print详解**\n\n1. 操作符:\n    - /@\t是一个和数组有关的操作符，在后面会有更详细的说明。\n    - ::\t指定一个在文件或是一个函数中的变量。\n    - {}\t表示一个指向内存地址的类型为type的一个对象。\n\n2. 程序变量\n在GDB中，你可以随时查看以下三种变量的值：\n    - 全局变量（所有文件可见的）\n    - 静态全局变量（当前文件可见的）\n    - 局部变量（当前Scope可见的）\n\n2. 数组\n“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。\n例如，你的程序中有这样的语句：\n`int *array = (int *) malloc (len * sizeof (int));`\n于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：\n`p *array@len`\n\n1. 输出格式\nx  按十六进制格式显示变量。\nd  按十进制格式显示变量。\nu  按十六进制格式显示无符号整型。\no  按八进制格式显示变量。\nt  按二进制格式显示变量。\na  按十六进制格式显示变量。\nc  按字符格式显示变量。\nf  按浮点数格式显示变量。\n\n## 4. 改变程序的执行\n1. 修改变量值\n修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的`print`命令即可完成。如：\n`(gdb) print x=4`\n\n2. 跳转执行\n一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的`jump`命令来完：\njump 指定下一条语句的运行点。可以是文件的行号，可以是`file:line`格式，可以是`+num`这种偏移量格式。表式着下一条运行语句从哪里开始。\n\n3. 产生信号量\n使用`singal`命令，可以产生一个信号量给被调试的程序。如：中断信号`Ctrl+C`。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。\n>single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。\n\n4. 强制函数返回\n如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用`return`命令强制函数忽略还没有执行的语句并返回。\n使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。\n\n5. 强制调用函数\n`call`表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。\n","source":"_posts/C语言学习总结（二）——GCC和GDB.md","raw":"---\ntitle: C语言学习总结（二）——GCC和GDB\ndate: 2016-11-21 14:44:46\ncategories: C语言学习总结\ntags: [C语言,GCC,GDB]\n---\n\n使用 Linux ，不可避免的需要使用 GCC 套件，从原本的只能编译C语言，到现在的系列的套件，而今天在这里主要讨论的是：GCC 是如何一步步的将代码编译成可执行文件的，以及如何使用 GDB 进行调试。\n<!--more-->\n\n# 一、GCC是什么\nGCC是什么，GCC是一个软件，GNU编译器套件（GNU Compiler Collection），最初由GNU组织为C语言开发，之后发展为一个套件。\n\n# 二、GCC编译过程\n## 1、预处理\n预处理的过程是编译器去将头文件进行包含，将宏定义进行替换，在这个过程中，inlude和define命令生效。\n预处理过程中的常用知识点有：\n\n1. 头文件未包含，<> 和 \"\" 的使用范围是不一样的，对于用户自定义的头文件，需要用 “” 指出路径。  可以使用 -I 命令指定头文件的目录路径\n2. 宏的重定义，因为不同头文件可能会重复引用同样的宏，会出现类似的问题，所以，使用 \n````C++\n#ifndef   XXX\n#define   XXX\n…\n#endif````\n    来避免重复定义宏，这种写法同样可以用来进行条件编译：`-D XXX` 。\n\n3. include与define不是关键字，他们是GCC可以识别的标识码。\n3. 宏定义中可以进行函数替换，但是必须是在同一行，多行函数一般使用`do{ … }while(0)`。\n3. 常见的预定义宏\n    * __FILE__ ：代表当前源文件的文件名\n    * __LINE__ ：代表展开成当前代码行的行号，是编译器内建的特殊宏定义\n    * __FUNCTION__  : 函数名\n\n3. \\# 和 ## 是预处理运算符 \n\n|写法|含义|\n|----------|--------------|\n| #define ABC(x)   #x\t|字符串化|\n| #define ABC(x)   day##x\t| 字符连接|\n\n最后的问题，在预处理的过程中，头文件中的定义是如何被包含在文件中的。\n\n## 2. 编译\n编译是将C语言程序编译成汇编文件的一个过程。\n编译的过程主要经过了六步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。\n在编译过程中可能出现的问题有：\n\n1. 语法错误，根据错误提示进行修改代码\n2. 优化错误，在嵌入式系统中会出现编译器的过度优化，有时候需要设定优化选项\n\n## 3. 汇编\n汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。\n## 4. 链接\n通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。链接的过程主要分为：*地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution），重定位（Relocation）*等。\n链接分为静态链接和动态链接：\n\n1. 静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。\n- 编译静态链接库\n    1. 生成目标文件 .o\n    1. ar crv [*.a] [*.o] \n- 调用静态链接库\n    gcc -o [file] [file.c] -L.  [file.a]\n\n1. 动态链接是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。\n- 首先、在任何给定的文件系统中,对于一个库只有一个.so文件\n- 第二、所有引用该库德可执行目标文件共享这个.so文件中的代码和数据\n- 第三、在存储器中,一个共享库的.text节只有一个副本可以被不同的正在运行的进程共享.\n    1. 编译动态链接库\n        - 生成位置无关的目标代码 gcc-fPIC -c [*.c]\n        - gcc -shared -o [*.so] [*.o] \n    2. 调用动态链接库（与静态链接库类似）\n        - gcc -o [file] [file.c] -L.  [file.so]\n\n\n### **链接过程详解**\n**目标文件**\n目标文件分为三种：\n\n1. 可重定位的目标文件:\n包含二进制代码和数据,其形式可以再编译时与其他可定位目标文件合并起来,创建一个可执行目标文件。\n\n2. 可执行目标文件:\n包含二进制代码和数据,其形式可以被直接拷贝到存储器并执行.\n\n3. 共享目标文件:\n一种特殊的可重定位目标文件,可以再加载或运行时,被动态地夹在到存储器并执行.\n编译器和汇编器生成可重定位目标文件(包括共享目标文件),链接器生成可执行目标文件.\n 可重定位的目标文件的结构如下：\n\n|标识|作用|\n|---------|--------|\n|.text:\t|已编译程序的机器代码|\n|.rodata:\t|只读数据|\n|.data:\t|已初始化的全局C变量|\n|.bss:\t|未初始化的全局C变量.在目标文件中这个节不占实际空间,仅是一个占位符.|\n|.sysmtab:\t|一个符号表,存放在程序中被定义和引用的函数和全局变量的信息.\n|.rel.text:\t|当链接器把这个目标文件和其他文件结合时,.text节中的许多位置都需要修改.一般而言,任何调用外部函数或者引用全局变量的指令都要修改.另一个方面,调用本地函数的指令则不需要修改.|\n|.rel.data:\t|被模块定义或引用的任何全局变量的信息.|\n|.debug:\t|一个调试符号表|\n|.line:\t|原始C源程序中的行号和.text节中机器指令之间的映射.|\n|.strtab:|\t一个字符串表,其中内容包括.symtab和.debug节中的符号表,以及节头部中的节名字.|\n\n一个m文件的符号表有三种不同的符号\n\n|类型|作用|\n|---|---|\n|由m定义并能被其他模块引用的全局符号.       |1.m定义的非静态的C函数 2.m定义的不带static属性的全局变量.           \n|由其他模块定义并被模块m引用的全局符号.这些符号成为外部符号,  |在其他模块中的C函数和变量.  |\n|只被模块m定义和引用的本地符号.       |由m定义的带static属性的C函数和全局变量|\n\n**符号解析**\n将每个引用和它输入的可重定位目标文件按的符号表中的一个确定的符号定义联系起来.\n\n1. 局部和static变量等：\n对于那些和引用定义在相同模块的本地符号的引用,符号解析式非常简单明了的.编译器只允许每个模块中的每个本地符号只有一个定义.编译器还确保静态本地变量,它们会有本地链接器符号,拥有唯一的名字.\n\n2. 外部引用：对于全局符号的引用解析,当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,它会假设该符号式在其他某个模块中定义的,生成一个链接器符号表表目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用的符号,它就输出一条错误信息并终止.\n1. 在编译时,编译器输出的每个全局符号给汇编器,或者是强,或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中.函数和以初始化的全局变量是强符号,未初始化的全局变量是弱符号.\n    编译系统提供一种机制,将所有相关的目标模块打包为一个单独的文件,称为静态库,它可以用做链接器的输入.当链接器构造一个输出的可执行文件时,它只拷贝静态库里被应用程序引用的目标模块。\n    输入命令时要考虑到,静态库和目标文件的位置,库文件放在目标文件的后面,如果库文件之间有引用关系,则被引用的库放在后面。\n\n### **链接过程常见错误：**\n\n - 原材料不够  `undefined reference to fun`\n 寻找标签是否实现了，链接时是否加入一起链接\n - 原材料重复  `multiple definition of fun`\n 多次实现了标签，只保留一个标签实现\n\n## 5. GCC的主要选项\n\n|选项|含义|\n|----------|------------|\n|1. **编译过程**|\n|预处理\t-E \t|不经过编译预处理程序的输出而输送至标准输出\n|编译\t-S\t|要求编译程序生成来自源代码的汇编程序输出\n|汇编\t-c\t|通知GCC取消链接步骤,即编译源码并在最后生成目标文件\n|链接\t-o\t|生成可执行文件\n|调试\t-g\t|包含调试信息\n|头文件\t-I|\t包含指定路径的头文件\n|2. **警告选项**|\n|-v |\t启动所有警报\n|-Wall \t|在发生警报时取消编译操作,即将警报看作是错误\n|-w |\t禁止所有的报警\n|3. **库文件**|\n|-static\t|静态编译\n|-shared|\t1、生成动态库文件 2、进行动态编译\n|-L dir\t\t|库文件搜索中添加路径\n|-fPIC\t|\t生成使用相对位置无关的目标代码(Position Independent Code)然后通常用于使用gcc的-static选项从该PIC目标文件生成动态库文件\n|4. **特定功能**|\n|-D |\t定义指定的宏,使它能够通过源码中的#ifdef进行检验;\n|-O、|\t-O2、-O3 将优化状态打开,该选项不能与-g选项联合使用;\n\n# 三、GDB的使用\nGDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。一般来说，GDB主要帮忙你完成下面四个方面的功能：\n\n- 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。\n- 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）\n- 当程序被停住时，可以检查此时你的程序中所发生的事。\n- 动态的改变你程序的执行环境。\n\n## 1. 启动调试\n首先，要进行调试，需要在生成可执行文件的时候使用`gcc -g `选项：\n        `-g[level]  默认为2`\n\n - 0  表示不生成任何调试信息\n - 1  表示生成最少的调试信息，不提供局部变量及源代码行列等信息。\n - 2  标准模式\n - 3  较2而言,包含了宏定义等额外信息\n\n然后有两种方式启动调试\n方式一： 直接在命令行下输入gdb ./[filename]\n方式二：运行gdb后输入file ./[filename]\n\n## 2. 设置断点\n除了断点外还有Watchpoints(观测点)及Catchpoints (异常捕捉点)\n\n1. **设置断点**\n输入b或break加上断点位置或断点函数名,如\nb main 在main函数入口设置断点\nb text2bin.c:50   在源代码第50行设置断点\ninfo breakpoints  查看断点信息\nclear  清除所有断点\nclear text2bin.c:50  清除特定的断点\nclear main   清除特定函数断点\ndisable及enable  开关某个特定的断点\nb +5 及b -5   表示在当前行的后五行及前五行位置设置断点\n对于观测点(Watchpoints)，是指在某个条件下触发的断点,如text2bin中77行:\n`Buffer2[nCount++] = ConvertTextToInt(sData);` \n我们要查看当nCount为10时的运行状况,我们可以通过下面的步骤完成:\n    1. 执行b 77,返回这个断点号是<3></3>\n    2. 执行condition 3 nCount=10\n        这样就可以控制当nCount为10时在77行处中断.\n\n2. **设置捕捉点**\n你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。设置捕捉点的格式为：`catch`\n\n3. **其它相关命令**\n\n|命令|含义|\n|-------|--------|\n|info b\t|查看所设断点|\n|break 行号或函数名 <条件表达式>|\t设置断点|\n|tbreak 行号或函数名 <条件表达式>\t|设置临时断点，到达后被自动删除\n|delete [断点号]\t|删除指定断点，若缺省断点号则删除所有断点\n|disable [断点号]]\t|停止指定断点，使用”info b”仍能查看此断点。\n|enable [断点号]\t|激活指定断点，即激活被disable停止的断点\n|condition [断点号] <条件表达式>\t|修改对应断点的条件\n|ignore [断点号]<num>\t|在程序执行中，忽略对应断点num次\n|step\t|单步恢复程序运行，且进入函数调用\n|next\t|单步恢复程序运行，但不进入函数调用\n|finish\t|运行程序，直到当前函数完成返回\n|c\t|继续执行函数，直到函数结束或遇到新的断点\n\n## 3. 检查程序 可以使用以下命令查询程序\n|命令|含义|\n|--------------------|---------|\n|list<行号>/<函数名>|\t查看指定位置代码|\n|forward-search 正则表达式\t|源代码前向搜索|\n|reverse-search 正则表达式|\t源代码后向搜索|\n|dir dir\t|停止路径名|\n|show directories|\t显示定义了的源文件搜索路径\n|info line\t|显示加载到Gdb内存中的代码\n|print 表达式/变量\t|查看程序运行时对应表达式和变量的值\n|x <n/f/u>\t|查看内存变量内容。其中n为整数表示显示内存的长度，f表示显示的格式，u表示从当前地址往后请求显示的字节数\n|display 表达式\t|设定在单步运行或其他情况中，自动显示的对应表达式的内容\n|info thread\t|查看当前有多少线程\n|thread # \t|切换到指定线程\n|set print thread-events on/off\t|设定是否打印线程状态\n|b/break [location]  thread #\t|当设置中断时,也可以专为某个线程设置\n\n**print详解**\n\n1. 操作符:\n    - /@\t是一个和数组有关的操作符，在后面会有更详细的说明。\n    - ::\t指定一个在文件或是一个函数中的变量。\n    - {}\t表示一个指向内存地址的类型为type的一个对象。\n\n2. 程序变量\n在GDB中，你可以随时查看以下三种变量的值：\n    - 全局变量（所有文件可见的）\n    - 静态全局变量（当前文件可见的）\n    - 局部变量（当前Scope可见的）\n\n2. 数组\n“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。\n例如，你的程序中有这样的语句：\n`int *array = (int *) malloc (len * sizeof (int));`\n于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：\n`p *array@len`\n\n1. 输出格式\nx  按十六进制格式显示变量。\nd  按十进制格式显示变量。\nu  按十六进制格式显示无符号整型。\no  按八进制格式显示变量。\nt  按二进制格式显示变量。\na  按十六进制格式显示变量。\nc  按字符格式显示变量。\nf  按浮点数格式显示变量。\n\n## 4. 改变程序的执行\n1. 修改变量值\n修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的`print`命令即可完成。如：\n`(gdb) print x=4`\n\n2. 跳转执行\n一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的`jump`命令来完：\njump 指定下一条语句的运行点。可以是文件的行号，可以是`file:line`格式，可以是`+num`这种偏移量格式。表式着下一条运行语句从哪里开始。\n\n3. 产生信号量\n使用`singal`命令，可以产生一个信号量给被调试的程序。如：中断信号`Ctrl+C`。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。\n>single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。\n\n4. 强制函数返回\n如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用`return`命令强制函数忽略还没有执行的语句并返回。\n使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。\n\n5. 强制调用函数\n`call`表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。\n","slug":"C语言学习总结（二）——GCC和GDB","published":1,"updated":"2016-12-21T14:08:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n03000ibkw1cwf7ccgg","content":"<p>使用 Linux ，不可避免的需要使用 GCC 套件，从原本的只能编译C语言，到现在的系列的套件，而今天在这里主要讨论的是：GCC 是如何一步步的将代码编译成可执行文件的，以及如何使用 GDB 进行调试。<br><a id=\"more\"></a></p>\n<h1 id=\"一、GCC是什么\"><a href=\"#一、GCC是什么\" class=\"headerlink\" title=\"一、GCC是什么\"></a>一、GCC是什么</h1><p>GCC是什么，GCC是一个软件，GNU编译器套件（GNU Compiler Collection），最初由GNU组织为C语言开发，之后发展为一个套件。</p>\n<h1 id=\"二、GCC编译过程\"><a href=\"#二、GCC编译过程\" class=\"headerlink\" title=\"二、GCC编译过程\"></a>二、GCC编译过程</h1><h2 id=\"1、预处理\"><a href=\"#1、预处理\" class=\"headerlink\" title=\"1、预处理\"></a>1、预处理</h2><p>预处理的过程是编译器去将头文件进行包含，将宏定义进行替换，在这个过程中，inlude和define命令生效。<br>预处理过程中的常用知识点有：</p>\n<ol>\n<li>头文件未包含，&lt;&gt; 和 “” 的使用范围是不一样的，对于用户自定义的头文件，需要用 “” 指出路径。  可以使用 -I 命令指定头文件的目录路径</li>\n<li><p>宏的重定义，因为不同头文件可能会重复引用同样的宏，会出现类似的问题，所以，使用 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span>   XXX</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>   XXX</span></div><div class=\"line\">…</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p> 来避免重复定义宏，这种写法同样可以用来进行条件编译：<code>-D XXX</code> 。</p>\n</li>\n<li><p>include与define不是关键字，他们是GCC可以识别的标识码。</p>\n</li>\n<li>宏定义中可以进行函数替换，但是必须是在同一行，多行函数一般使用<code>do{ … }while(0)</code>。</li>\n<li><p>常见的预定义宏</p>\n<ul>\n<li><strong>FILE</strong> ：代表当前源文件的文件名</li>\n<li><strong>LINE</strong> ：代表展开成当前代码行的行号，是编译器内建的特殊宏定义</li>\n<li><strong>FUNCTION</strong>  : 函数名</li>\n</ul>\n</li>\n<li><p># 和 ## 是预处理运算符 </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>#define ABC(x)   #x</td>\n<td>字符串化</td>\n</tr>\n<tr>\n<td>#define ABC(x)   day##x</td>\n<td>字符连接</td>\n</tr>\n</tbody>\n</table>\n<p>最后的问题，在预处理的过程中，头文件中的定义是如何被包含在文件中的。</p>\n<h2 id=\"2-编译\"><a href=\"#2-编译\" class=\"headerlink\" title=\"2. 编译\"></a>2. 编译</h2><p>编译是将C语言程序编译成汇编文件的一个过程。<br>编译的过程主要经过了六步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。<br>在编译过程中可能出现的问题有：</p>\n<ol>\n<li>语法错误，根据错误提示进行修改代码</li>\n<li>优化错误，在嵌入式系统中会出现编译器的过度优化，有时候需要设定优化选项</li>\n</ol>\n<h2 id=\"3-汇编\"><a href=\"#3-汇编\" class=\"headerlink\" title=\"3. 汇编\"></a>3. 汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。</p>\n<h2 id=\"4-链接\"><a href=\"#4-链接\" class=\"headerlink\" title=\"4. 链接\"></a>4. 链接</h2><p>通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。链接的过程主要分为：<em>地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution），重定位（Relocation）</em>等。<br>链接分为静态链接和动态链接：</p>\n<ol>\n<li>静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。</li>\n</ol>\n<ul>\n<li>编译静态链接库<ol>\n<li>生成目标文件 .o</li>\n<li>ar crv [<em>.a] [</em>.o] </li>\n</ol>\n</li>\n<li>调用静态链接库<br>  gcc -o [file] [file.c] -L.  [file.a]</li>\n</ul>\n<ol>\n<li>动态链接是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</li>\n</ol>\n<ul>\n<li>首先、在任何给定的文件系统中,对于一个库只有一个.so文件</li>\n<li>第二、所有引用该库德可执行目标文件共享这个.so文件中的代码和数据</li>\n<li>第三、在存储器中,一个共享库的.text节只有一个副本可以被不同的正在运行的进程共享.<ol>\n<li>编译动态链接库<ul>\n<li>生成位置无关的目标代码 gcc-fPIC -c [*.c]</li>\n<li>gcc -shared -o [<em>.so] [</em>.o] </li>\n</ul>\n</li>\n<li>调用动态链接库（与静态链接库类似）<ul>\n<li>gcc -o [file] [file.c] -L.  [file.so]</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"链接过程详解\"><a href=\"#链接过程详解\" class=\"headerlink\" title=\"链接过程详解\"></a><strong>链接过程详解</strong></h3><p><strong>目标文件</strong><br>目标文件分为三种：</p>\n<ol>\n<li><p>可重定位的目标文件:<br>包含二进制代码和数据,其形式可以再编译时与其他可定位目标文件合并起来,创建一个可执行目标文件。</p>\n</li>\n<li><p>可执行目标文件:<br>包含二进制代码和数据,其形式可以被直接拷贝到存储器并执行.</p>\n</li>\n<li><p>共享目标文件:<br>一种特殊的可重定位目标文件,可以再加载或运行时,被动态地夹在到存储器并执行.<br>编译器和汇编器生成可重定位目标文件(包括共享目标文件),链接器生成可执行目标文件.<br>可重定位的目标文件的结构如下：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>标识</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.text:</td>\n<td>已编译程序的机器代码</td>\n</tr>\n<tr>\n<td>.rodata:</td>\n<td>只读数据</td>\n</tr>\n<tr>\n<td>.data:</td>\n<td>已初始化的全局C变量</td>\n</tr>\n<tr>\n<td>.bss:</td>\n<td>未初始化的全局C变量.在目标文件中这个节不占实际空间,仅是一个占位符.</td>\n</tr>\n<tr>\n<td>.sysmtab:</td>\n<td>一个符号表,存放在程序中被定义和引用的函数和全局变量的信息.</td>\n</tr>\n<tr>\n<td>.rel.text:</td>\n<td>当链接器把这个目标文件和其他文件结合时,.text节中的许多位置都需要修改.一般而言,任何调用外部函数或者引用全局变量的指令都要修改.另一个方面,调用本地函数的指令则不需要修改.</td>\n</tr>\n<tr>\n<td>.rel.data:</td>\n<td>被模块定义或引用的任何全局变量的信息.</td>\n</tr>\n<tr>\n<td>.debug:</td>\n<td>一个调试符号表</td>\n</tr>\n<tr>\n<td>.line:</td>\n<td>原始C源程序中的行号和.text节中机器指令之间的映射.</td>\n</tr>\n<tr>\n<td>.strtab:</td>\n<td>一个字符串表,其中内容包括.symtab和.debug节中的符号表,以及节头部中的节名字.</td>\n</tr>\n</tbody>\n</table>\n<p>一个m文件的符号表有三种不同的符号</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>由m定义并能被其他模块引用的全局符号.</td>\n<td>1.m定义的非静态的C函数 2.m定义的不带static属性的全局变量.           </td>\n</tr>\n<tr>\n<td>由其他模块定义并被模块m引用的全局符号.这些符号成为外部符号,</td>\n<td>在其他模块中的C函数和变量.</td>\n</tr>\n<tr>\n<td>只被模块m定义和引用的本地符号.</td>\n<td>由m定义的带static属性的C函数和全局变量</td>\n</tr>\n</tbody>\n</table>\n<p><strong>符号解析</strong><br>将每个引用和它输入的可重定位目标文件按的符号表中的一个确定的符号定义联系起来.</p>\n<ol>\n<li><p>局部和static变量等：<br>对于那些和引用定义在相同模块的本地符号的引用,符号解析式非常简单明了的.编译器只允许每个模块中的每个本地符号只有一个定义.编译器还确保静态本地变量,它们会有本地链接器符号,拥有唯一的名字.</p>\n</li>\n<li><p>外部引用：对于全局符号的引用解析,当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,它会假设该符号式在其他某个模块中定义的,生成一个链接器符号表表目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用的符号,它就输出一条错误信息并终止.</p>\n</li>\n<li>在编译时,编译器输出的每个全局符号给汇编器,或者是强,或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中.函数和以初始化的全局变量是强符号,未初始化的全局变量是弱符号.<br> 编译系统提供一种机制,将所有相关的目标模块打包为一个单独的文件,称为静态库,它可以用做链接器的输入.当链接器构造一个输出的可执行文件时,它只拷贝静态库里被应用程序引用的目标模块。<br> 输入命令时要考虑到,静态库和目标文件的位置,库文件放在目标文件的后面,如果库文件之间有引用关系,则被引用的库放在后面。</li>\n</ol>\n<h3 id=\"链接过程常见错误：\"><a href=\"#链接过程常见错误：\" class=\"headerlink\" title=\"链接过程常见错误：\"></a><strong>链接过程常见错误：</strong></h3><ul>\n<li>原材料不够  <code>undefined reference to fun</code><br>寻找标签是否实现了，链接时是否加入一起链接</li>\n<li>原材料重复  <code>multiple definition of fun</code><br>多次实现了标签，只保留一个标签实现</li>\n</ul>\n<h2 id=\"5-GCC的主要选项\"><a href=\"#5-GCC的主要选项\" class=\"headerlink\" title=\"5. GCC的主要选项\"></a>5. GCC的主要选项</h2><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. <strong>编译过程</strong></td>\n</tr>\n<tr>\n<td>预处理    -E</td>\n<td>不经过编译预处理程序的输出而输送至标准输出</td>\n</tr>\n<tr>\n<td>编译    -S</td>\n<td>要求编译程序生成来自源代码的汇编程序输出</td>\n</tr>\n<tr>\n<td>汇编    -c</td>\n<td>通知GCC取消链接步骤,即编译源码并在最后生成目标文件</td>\n</tr>\n<tr>\n<td>链接    -o</td>\n<td>生成可执行文件</td>\n</tr>\n<tr>\n<td>调试    -g</td>\n<td>包含调试信息</td>\n</tr>\n<tr>\n<td>头文件    -I</td>\n<td>包含指定路径的头文件</td>\n</tr>\n<tr>\n<td>2. <strong>警告选项</strong></td>\n</tr>\n<tr>\n<td>-v</td>\n<td>启动所有警报</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>在发生警报时取消编译操作,即将警报看作是错误</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>禁止所有的报警</td>\n</tr>\n<tr>\n<td>3. <strong>库文件</strong></td>\n</tr>\n<tr>\n<td>-static</td>\n<td>静态编译</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>1、生成动态库文件 2、进行动态编译</td>\n</tr>\n<tr>\n<td>-L dir</td>\n<td>库文件搜索中添加路径</td>\n</tr>\n<tr>\n<td>-fPIC</td>\n<td>生成使用相对位置无关的目标代码(Position Independent Code)然后通常用于使用gcc的-static选项从该PIC目标文件生成动态库文件</td>\n</tr>\n<tr>\n<td>4. <strong>特定功能</strong></td>\n</tr>\n<tr>\n<td>-D</td>\n<td>定义指定的宏,使它能够通过源码中的#ifdef进行检验;</td>\n</tr>\n<tr>\n<td>-O、</td>\n<td>-O2、-O3 将优化状态打开,该选项不能与-g选项联合使用;</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"三、GDB的使用\"><a href=\"#三、GDB的使用\" class=\"headerlink\" title=\"三、GDB的使用\"></a>三、GDB的使用</h1><p>GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。一般来说，GDB主要帮忙你完成下面四个方面的功能：</p>\n<ul>\n<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>\n<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>\n<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>\n<li>动态的改变你程序的执行环境。</li>\n</ul>\n<h2 id=\"1-启动调试\"><a href=\"#1-启动调试\" class=\"headerlink\" title=\"1. 启动调试\"></a>1. 启动调试</h2><p>首先，要进行调试，需要在生成可执行文件的时候使用<code>gcc -g</code>选项：<br>        <code>-g[level]  默认为2</code></p>\n<ul>\n<li>0  表示不生成任何调试信息</li>\n<li>1  表示生成最少的调试信息，不提供局部变量及源代码行列等信息。</li>\n<li>2  标准模式</li>\n<li>3  较2而言,包含了宏定义等额外信息</li>\n</ul>\n<p>然后有两种方式启动调试<br>方式一： 直接在命令行下输入gdb ./[filename]<br>方式二：运行gdb后输入file ./[filename]</p>\n<h2 id=\"2-设置断点\"><a href=\"#2-设置断点\" class=\"headerlink\" title=\"2. 设置断点\"></a>2. 设置断点</h2><p>除了断点外还有Watchpoints(观测点)及Catchpoints (异常捕捉点)</p>\n<ol>\n<li><p><strong>设置断点</strong><br>输入b或break加上断点位置或断点函数名,如<br>b main 在main函数入口设置断点<br>b text2bin.c:50   在源代码第50行设置断点<br>info breakpoints  查看断点信息<br>clear  清除所有断点<br>clear text2bin.c:50  清除特定的断点<br>clear main   清除特定函数断点<br>disable及enable  开关某个特定的断点<br>b +5 及b -5   表示在当前行的后五行及前五行位置设置断点<br>对于观测点(Watchpoints)，是指在某个条件下触发的断点,如text2bin中77行:<br><code>Buffer2[nCount++] = ConvertTextToInt(sData);</code><br>我们要查看当nCount为10时的运行状况,我们可以通过下面的步骤完成:</p>\n<ol>\n<li>执行b 77,返回这个断点号是<3></3></li>\n<li>执行condition 3 nCount=10<br> 这样就可以控制当nCount为10时在77行处中断.</li>\n</ol>\n</li>\n<li><p><strong>设置捕捉点</strong><br>你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。设置捕捉点的格式为：<code>catch</code></p>\n</li>\n<li><p><strong>其它相关命令</strong></p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>info b</td>\n<td>查看所设断点</td>\n</tr>\n<tr>\n<td>break 行号或函数名 &lt;条件表达式&gt;</td>\n<td>设置断点</td>\n</tr>\n<tr>\n<td>tbreak 行号或函数名 &lt;条件表达式&gt;</td>\n<td>设置临时断点，到达后被自动删除</td>\n</tr>\n<tr>\n<td>delete [断点号]</td>\n<td>删除指定断点，若缺省断点号则删除所有断点</td>\n</tr>\n<tr>\n<td>disable [断点号]]</td>\n<td>停止指定断点，使用”info b”仍能查看此断点。</td>\n</tr>\n<tr>\n<td>enable [断点号]</td>\n<td>激活指定断点，即激活被disable停止的断点</td>\n</tr>\n<tr>\n<td>condition [断点号] &lt;条件表达式&gt;</td>\n<td>修改对应断点的条件</td>\n</tr>\n<tr>\n<td>ignore [断点号]<num></num></td>\n<td>在程序执行中，忽略对应断点num次</td>\n</tr>\n<tr>\n<td>step</td>\n<td>单步恢复程序运行，且进入函数调用</td>\n</tr>\n<tr>\n<td>next</td>\n<td>单步恢复程序运行，但不进入函数调用</td>\n</tr>\n<tr>\n<td>finish</td>\n<td>运行程序，直到当前函数完成返回</td>\n</tr>\n<tr>\n<td>c</td>\n<td>继续执行函数，直到函数结束或遇到新的断点</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-检查程序-可以使用以下命令查询程序\"><a href=\"#3-检查程序-可以使用以下命令查询程序\" class=\"headerlink\" title=\"3. 检查程序 可以使用以下命令查询程序\"></a>3. 检查程序 可以使用以下命令查询程序</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>list&lt;行号&gt;/&lt;函数名&gt;</td>\n<td>查看指定位置代码</td>\n</tr>\n<tr>\n<td>forward-search 正则表达式</td>\n<td>源代码前向搜索</td>\n</tr>\n<tr>\n<td>reverse-search 正则表达式</td>\n<td>源代码后向搜索</td>\n</tr>\n<tr>\n<td>dir dir</td>\n<td>停止路径名</td>\n</tr>\n<tr>\n<td>show directories</td>\n<td>显示定义了的源文件搜索路径</td>\n</tr>\n<tr>\n<td>info line</td>\n<td>显示加载到Gdb内存中的代码</td>\n</tr>\n<tr>\n<td>print 表达式/变量</td>\n<td>查看程序运行时对应表达式和变量的值</td>\n</tr>\n<tr>\n<td>x <n f=\"\" u=\"\"></n></td>\n<td>查看内存变量内容。其中n为整数表示显示内存的长度，f表示显示的格式，u表示从当前地址往后请求显示的字节数</td>\n</tr>\n<tr>\n<td>display 表达式</td>\n<td>设定在单步运行或其他情况中，自动显示的对应表达式的内容</td>\n</tr>\n<tr>\n<td>info thread</td>\n<td>查看当前有多少线程</td>\n</tr>\n<tr>\n<td>thread #</td>\n<td>切换到指定线程</td>\n</tr>\n<tr>\n<td>set print thread-events on/off</td>\n<td>设定是否打印线程状态</td>\n</tr>\n<tr>\n<td>b/break [location]  thread #</td>\n<td>当设置中断时,也可以专为某个线程设置</td>\n</tr>\n</tbody>\n</table>\n<p><strong>print详解</strong></p>\n<ol>\n<li><p>操作符:</p>\n<ul>\n<li>/@    是一个和数组有关的操作符，在后面会有更详细的说明。</li>\n<li>::    指定一个在文件或是一个函数中的变量。</li>\n<li>{}    表示一个指向内存地址的类型为type的一个对象。</li>\n</ul>\n</li>\n<li><p>程序变量<br>在GDB中，你可以随时查看以下三种变量的值：</p>\n<ul>\n<li>全局变量（所有文件可见的）</li>\n<li>静态全局变量（当前文件可见的）</li>\n<li>局部变量（当前Scope可见的）</li>\n</ul>\n</li>\n<li><p>数组<br>“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。<br>例如，你的程序中有这样的语句：<br><code>int *array = (int *) malloc (len * sizeof (int));</code><br>于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：<br><code>p *array@len</code></p>\n</li>\n<li><p>输出格式<br>x  按十六进制格式显示变量。<br>d  按十进制格式显示变量。<br>u  按十六进制格式显示无符号整型。<br>o  按八进制格式显示变量。<br>t  按二进制格式显示变量。<br>a  按十六进制格式显示变量。<br>c  按字符格式显示变量。<br>f  按浮点数格式显示变量。</p>\n</li>\n</ol>\n<h2 id=\"4-改变程序的执行\"><a href=\"#4-改变程序的执行\" class=\"headerlink\" title=\"4. 改变程序的执行\"></a>4. 改变程序的执行</h2><ol>\n<li><p>修改变量值<br>修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的<code>print</code>命令即可完成。如：<br><code>(gdb) print x=4</code></p>\n</li>\n<li><p>跳转执行<br>一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的<code>jump</code>命令来完：<br>jump 指定下一条语句的运行点。可以是文件的行号，可以是<code>file:line</code>格式，可以是<code>+num</code>这种偏移量格式。表式着下一条运行语句从哪里开始。</p>\n</li>\n<li><p>产生信号量<br>使用<code>singal</code>命令，可以产生一个信号量给被调试的程序。如：中断信号<code>Ctrl+C</code>。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。</p>\n<blockquote>\n<p>single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</p>\n</blockquote>\n</li>\n<li><p>强制函数返回<br>如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用<code>return</code>命令强制函数忽略还没有执行的语句并返回。<br>使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。</p>\n</li>\n<li><p>强制调用函数<br><code>call</code>表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。</p>\n</li>\n</ol>\n","excerpt":"<p>使用 Linux ，不可避免的需要使用 GCC 套件，从原本的只能编译C语言，到现在的系列的套件，而今天在这里主要讨论的是：GCC 是如何一步步的将代码编译成可执行文件的，以及如何使用 GDB 进行调试。<br>","more":"</p>\n<h1 id=\"一、GCC是什么\"><a href=\"#一、GCC是什么\" class=\"headerlink\" title=\"一、GCC是什么\"></a>一、GCC是什么</h1><p>GCC是什么，GCC是一个软件，GNU编译器套件（GNU Compiler Collection），最初由GNU组织为C语言开发，之后发展为一个套件。</p>\n<h1 id=\"二、GCC编译过程\"><a href=\"#二、GCC编译过程\" class=\"headerlink\" title=\"二、GCC编译过程\"></a>二、GCC编译过程</h1><h2 id=\"1、预处理\"><a href=\"#1、预处理\" class=\"headerlink\" title=\"1、预处理\"></a>1、预处理</h2><p>预处理的过程是编译器去将头文件进行包含，将宏定义进行替换，在这个过程中，inlude和define命令生效。<br>预处理过程中的常用知识点有：</p>\n<ol>\n<li>头文件未包含，&lt;&gt; 和 “” 的使用范围是不一样的，对于用户自定义的头文件，需要用 “” 指出路径。  可以使用 -I 命令指定头文件的目录路径</li>\n<li><p>宏的重定义，因为不同头文件可能会重复引用同样的宏，会出现类似的问题，所以，使用 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span>   XXX</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>   XXX</span></div><div class=\"line\">…</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p> 来避免重复定义宏，这种写法同样可以用来进行条件编译：<code>-D XXX</code> 。</p>\n</li>\n<li><p>include与define不是关键字，他们是GCC可以识别的标识码。</p>\n</li>\n<li>宏定义中可以进行函数替换，但是必须是在同一行，多行函数一般使用<code>do{ … }while(0)</code>。</li>\n<li><p>常见的预定义宏</p>\n<ul>\n<li><strong>FILE</strong> ：代表当前源文件的文件名</li>\n<li><strong>LINE</strong> ：代表展开成当前代码行的行号，是编译器内建的特殊宏定义</li>\n<li><strong>FUNCTION</strong>  : 函数名</li>\n</ul>\n</li>\n<li><p># 和 ## 是预处理运算符 </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>#define ABC(x)   #x</td>\n<td>字符串化</td>\n</tr>\n<tr>\n<td>#define ABC(x)   day##x</td>\n<td>字符连接</td>\n</tr>\n</tbody>\n</table>\n<p>最后的问题，在预处理的过程中，头文件中的定义是如何被包含在文件中的。</p>\n<h2 id=\"2-编译\"><a href=\"#2-编译\" class=\"headerlink\" title=\"2. 编译\"></a>2. 编译</h2><p>编译是将C语言程序编译成汇编文件的一个过程。<br>编译的过程主要经过了六步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。<br>在编译过程中可能出现的问题有：</p>\n<ol>\n<li>语法错误，根据错误提示进行修改代码</li>\n<li>优化错误，在嵌入式系统中会出现编译器的过度优化，有时候需要设定优化选项</li>\n</ol>\n<h2 id=\"3-汇编\"><a href=\"#3-汇编\" class=\"headerlink\" title=\"3. 汇编\"></a>3. 汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。</p>\n<h2 id=\"4-链接\"><a href=\"#4-链接\" class=\"headerlink\" title=\"4. 链接\"></a>4. 链接</h2><p>通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。链接的过程主要分为：<em>地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution），重定位（Relocation）</em>等。<br>链接分为静态链接和动态链接：</p>\n<ol>\n<li>静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。</li>\n</ol>\n<ul>\n<li>编译静态链接库<ol>\n<li>生成目标文件 .o</li>\n<li>ar crv [<em>.a] [</em>.o] </li>\n</ol>\n</li>\n<li>调用静态链接库<br>  gcc -o [file] [file.c] -L.  [file.a]</li>\n</ul>\n<ol>\n<li>动态链接是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</li>\n</ol>\n<ul>\n<li>首先、在任何给定的文件系统中,对于一个库只有一个.so文件</li>\n<li>第二、所有引用该库德可执行目标文件共享这个.so文件中的代码和数据</li>\n<li>第三、在存储器中,一个共享库的.text节只有一个副本可以被不同的正在运行的进程共享.<ol>\n<li>编译动态链接库<ul>\n<li>生成位置无关的目标代码 gcc-fPIC -c [*.c]</li>\n<li>gcc -shared -o [<em>.so] [</em>.o] </li>\n</ul>\n</li>\n<li>调用动态链接库（与静态链接库类似）<ul>\n<li>gcc -o [file] [file.c] -L.  [file.so]</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"链接过程详解\"><a href=\"#链接过程详解\" class=\"headerlink\" title=\"链接过程详解\"></a><strong>链接过程详解</strong></h3><p><strong>目标文件</strong><br>目标文件分为三种：</p>\n<ol>\n<li><p>可重定位的目标文件:<br>包含二进制代码和数据,其形式可以再编译时与其他可定位目标文件合并起来,创建一个可执行目标文件。</p>\n</li>\n<li><p>可执行目标文件:<br>包含二进制代码和数据,其形式可以被直接拷贝到存储器并执行.</p>\n</li>\n<li><p>共享目标文件:<br>一种特殊的可重定位目标文件,可以再加载或运行时,被动态地夹在到存储器并执行.<br>编译器和汇编器生成可重定位目标文件(包括共享目标文件),链接器生成可执行目标文件.<br>可重定位的目标文件的结构如下：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>标识</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.text:</td>\n<td>已编译程序的机器代码</td>\n</tr>\n<tr>\n<td>.rodata:</td>\n<td>只读数据</td>\n</tr>\n<tr>\n<td>.data:</td>\n<td>已初始化的全局C变量</td>\n</tr>\n<tr>\n<td>.bss:</td>\n<td>未初始化的全局C变量.在目标文件中这个节不占实际空间,仅是一个占位符.</td>\n</tr>\n<tr>\n<td>.sysmtab:</td>\n<td>一个符号表,存放在程序中被定义和引用的函数和全局变量的信息.</td>\n</tr>\n<tr>\n<td>.rel.text:</td>\n<td>当链接器把这个目标文件和其他文件结合时,.text节中的许多位置都需要修改.一般而言,任何调用外部函数或者引用全局变量的指令都要修改.另一个方面,调用本地函数的指令则不需要修改.</td>\n</tr>\n<tr>\n<td>.rel.data:</td>\n<td>被模块定义或引用的任何全局变量的信息.</td>\n</tr>\n<tr>\n<td>.debug:</td>\n<td>一个调试符号表</td>\n</tr>\n<tr>\n<td>.line:</td>\n<td>原始C源程序中的行号和.text节中机器指令之间的映射.</td>\n</tr>\n<tr>\n<td>.strtab:</td>\n<td>一个字符串表,其中内容包括.symtab和.debug节中的符号表,以及节头部中的节名字.</td>\n</tr>\n</tbody>\n</table>\n<p>一个m文件的符号表有三种不同的符号</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>由m定义并能被其他模块引用的全局符号.</td>\n<td>1.m定义的非静态的C函数 2.m定义的不带static属性的全局变量.           </td>\n</tr>\n<tr>\n<td>由其他模块定义并被模块m引用的全局符号.这些符号成为外部符号,</td>\n<td>在其他模块中的C函数和变量.</td>\n</tr>\n<tr>\n<td>只被模块m定义和引用的本地符号.</td>\n<td>由m定义的带static属性的C函数和全局变量</td>\n</tr>\n</tbody>\n</table>\n<p><strong>符号解析</strong><br>将每个引用和它输入的可重定位目标文件按的符号表中的一个确定的符号定义联系起来.</p>\n<ol>\n<li><p>局部和static变量等：<br>对于那些和引用定义在相同模块的本地符号的引用,符号解析式非常简单明了的.编译器只允许每个模块中的每个本地符号只有一个定义.编译器还确保静态本地变量,它们会有本地链接器符号,拥有唯一的名字.</p>\n</li>\n<li><p>外部引用：对于全局符号的引用解析,当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,它会假设该符号式在其他某个模块中定义的,生成一个链接器符号表表目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用的符号,它就输出一条错误信息并终止.</p>\n</li>\n<li>在编译时,编译器输出的每个全局符号给汇编器,或者是强,或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中.函数和以初始化的全局变量是强符号,未初始化的全局变量是弱符号.<br> 编译系统提供一种机制,将所有相关的目标模块打包为一个单独的文件,称为静态库,它可以用做链接器的输入.当链接器构造一个输出的可执行文件时,它只拷贝静态库里被应用程序引用的目标模块。<br> 输入命令时要考虑到,静态库和目标文件的位置,库文件放在目标文件的后面,如果库文件之间有引用关系,则被引用的库放在后面。</li>\n</ol>\n<h3 id=\"链接过程常见错误：\"><a href=\"#链接过程常见错误：\" class=\"headerlink\" title=\"链接过程常见错误：\"></a><strong>链接过程常见错误：</strong></h3><ul>\n<li>原材料不够  <code>undefined reference to fun</code><br>寻找标签是否实现了，链接时是否加入一起链接</li>\n<li>原材料重复  <code>multiple definition of fun</code><br>多次实现了标签，只保留一个标签实现</li>\n</ul>\n<h2 id=\"5-GCC的主要选项\"><a href=\"#5-GCC的主要选项\" class=\"headerlink\" title=\"5. GCC的主要选项\"></a>5. GCC的主要选项</h2><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. <strong>编译过程</strong></td>\n</tr>\n<tr>\n<td>预处理    -E</td>\n<td>不经过编译预处理程序的输出而输送至标准输出</td>\n</tr>\n<tr>\n<td>编译    -S</td>\n<td>要求编译程序生成来自源代码的汇编程序输出</td>\n</tr>\n<tr>\n<td>汇编    -c</td>\n<td>通知GCC取消链接步骤,即编译源码并在最后生成目标文件</td>\n</tr>\n<tr>\n<td>链接    -o</td>\n<td>生成可执行文件</td>\n</tr>\n<tr>\n<td>调试    -g</td>\n<td>包含调试信息</td>\n</tr>\n<tr>\n<td>头文件    -I</td>\n<td>包含指定路径的头文件</td>\n</tr>\n<tr>\n<td>2. <strong>警告选项</strong></td>\n</tr>\n<tr>\n<td>-v</td>\n<td>启动所有警报</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>在发生警报时取消编译操作,即将警报看作是错误</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>禁止所有的报警</td>\n</tr>\n<tr>\n<td>3. <strong>库文件</strong></td>\n</tr>\n<tr>\n<td>-static</td>\n<td>静态编译</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>1、生成动态库文件 2、进行动态编译</td>\n</tr>\n<tr>\n<td>-L dir</td>\n<td>库文件搜索中添加路径</td>\n</tr>\n<tr>\n<td>-fPIC</td>\n<td>生成使用相对位置无关的目标代码(Position Independent Code)然后通常用于使用gcc的-static选项从该PIC目标文件生成动态库文件</td>\n</tr>\n<tr>\n<td>4. <strong>特定功能</strong></td>\n</tr>\n<tr>\n<td>-D</td>\n<td>定义指定的宏,使它能够通过源码中的#ifdef进行检验;</td>\n</tr>\n<tr>\n<td>-O、</td>\n<td>-O2、-O3 将优化状态打开,该选项不能与-g选项联合使用;</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"三、GDB的使用\"><a href=\"#三、GDB的使用\" class=\"headerlink\" title=\"三、GDB的使用\"></a>三、GDB的使用</h1><p>GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。一般来说，GDB主要帮忙你完成下面四个方面的功能：</p>\n<ul>\n<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>\n<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>\n<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>\n<li>动态的改变你程序的执行环境。</li>\n</ul>\n<h2 id=\"1-启动调试\"><a href=\"#1-启动调试\" class=\"headerlink\" title=\"1. 启动调试\"></a>1. 启动调试</h2><p>首先，要进行调试，需要在生成可执行文件的时候使用<code>gcc -g</code>选项：<br>        <code>-g[level]  默认为2</code></p>\n<ul>\n<li>0  表示不生成任何调试信息</li>\n<li>1  表示生成最少的调试信息，不提供局部变量及源代码行列等信息。</li>\n<li>2  标准模式</li>\n<li>3  较2而言,包含了宏定义等额外信息</li>\n</ul>\n<p>然后有两种方式启动调试<br>方式一： 直接在命令行下输入gdb ./[filename]<br>方式二：运行gdb后输入file ./[filename]</p>\n<h2 id=\"2-设置断点\"><a href=\"#2-设置断点\" class=\"headerlink\" title=\"2. 设置断点\"></a>2. 设置断点</h2><p>除了断点外还有Watchpoints(观测点)及Catchpoints (异常捕捉点)</p>\n<ol>\n<li><p><strong>设置断点</strong><br>输入b或break加上断点位置或断点函数名,如<br>b main 在main函数入口设置断点<br>b text2bin.c:50   在源代码第50行设置断点<br>info breakpoints  查看断点信息<br>clear  清除所有断点<br>clear text2bin.c:50  清除特定的断点<br>clear main   清除特定函数断点<br>disable及enable  开关某个特定的断点<br>b +5 及b -5   表示在当前行的后五行及前五行位置设置断点<br>对于观测点(Watchpoints)，是指在某个条件下触发的断点,如text2bin中77行:<br><code>Buffer2[nCount++] = ConvertTextToInt(sData);</code><br>我们要查看当nCount为10时的运行状况,我们可以通过下面的步骤完成:</p>\n<ol>\n<li>执行b 77,返回这个断点号是<3></3></li>\n<li>执行condition 3 nCount=10<br> 这样就可以控制当nCount为10时在77行处中断.</li>\n</ol>\n</li>\n<li><p><strong>设置捕捉点</strong><br>你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。设置捕捉点的格式为：<code>catch</code></p>\n</li>\n<li><p><strong>其它相关命令</strong></p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>info b</td>\n<td>查看所设断点</td>\n</tr>\n<tr>\n<td>break 行号或函数名 &lt;条件表达式&gt;</td>\n<td>设置断点</td>\n</tr>\n<tr>\n<td>tbreak 行号或函数名 &lt;条件表达式&gt;</td>\n<td>设置临时断点，到达后被自动删除</td>\n</tr>\n<tr>\n<td>delete [断点号]</td>\n<td>删除指定断点，若缺省断点号则删除所有断点</td>\n</tr>\n<tr>\n<td>disable [断点号]]</td>\n<td>停止指定断点，使用”info b”仍能查看此断点。</td>\n</tr>\n<tr>\n<td>enable [断点号]</td>\n<td>激活指定断点，即激活被disable停止的断点</td>\n</tr>\n<tr>\n<td>condition [断点号] &lt;条件表达式&gt;</td>\n<td>修改对应断点的条件</td>\n</tr>\n<tr>\n<td>ignore [断点号]<num></td>\n<td>在程序执行中，忽略对应断点num次</td>\n</tr>\n<tr>\n<td>step</td>\n<td>单步恢复程序运行，且进入函数调用</td>\n</tr>\n<tr>\n<td>next</td>\n<td>单步恢复程序运行，但不进入函数调用</td>\n</tr>\n<tr>\n<td>finish</td>\n<td>运行程序，直到当前函数完成返回</td>\n</tr>\n<tr>\n<td>c</td>\n<td>继续执行函数，直到函数结束或遇到新的断点</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-检查程序-可以使用以下命令查询程序\"><a href=\"#3-检查程序-可以使用以下命令查询程序\" class=\"headerlink\" title=\"3. 检查程序 可以使用以下命令查询程序\"></a>3. 检查程序 可以使用以下命令查询程序</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>list&lt;行号&gt;/&lt;函数名&gt;</td>\n<td>查看指定位置代码</td>\n</tr>\n<tr>\n<td>forward-search 正则表达式</td>\n<td>源代码前向搜索</td>\n</tr>\n<tr>\n<td>reverse-search 正则表达式</td>\n<td>源代码后向搜索</td>\n</tr>\n<tr>\n<td>dir dir</td>\n<td>停止路径名</td>\n</tr>\n<tr>\n<td>show directories</td>\n<td>显示定义了的源文件搜索路径</td>\n</tr>\n<tr>\n<td>info line</td>\n<td>显示加载到Gdb内存中的代码</td>\n</tr>\n<tr>\n<td>print 表达式/变量</td>\n<td>查看程序运行时对应表达式和变量的值</td>\n</tr>\n<tr>\n<td>x <n/f/u></td>\n<td>查看内存变量内容。其中n为整数表示显示内存的长度，f表示显示的格式，u表示从当前地址往后请求显示的字节数</td>\n</tr>\n<tr>\n<td>display 表达式</td>\n<td>设定在单步运行或其他情况中，自动显示的对应表达式的内容</td>\n</tr>\n<tr>\n<td>info thread</td>\n<td>查看当前有多少线程</td>\n</tr>\n<tr>\n<td>thread #</td>\n<td>切换到指定线程</td>\n</tr>\n<tr>\n<td>set print thread-events on/off</td>\n<td>设定是否打印线程状态</td>\n</tr>\n<tr>\n<td>b/break [location]  thread #</td>\n<td>当设置中断时,也可以专为某个线程设置</td>\n</tr>\n</tbody>\n</table>\n<p><strong>print详解</strong></p>\n<ol>\n<li><p>操作符:</p>\n<ul>\n<li>/@    是一个和数组有关的操作符，在后面会有更详细的说明。</li>\n<li>::    指定一个在文件或是一个函数中的变量。</li>\n<li>{}    表示一个指向内存地址的类型为type的一个对象。</li>\n</ul>\n</li>\n<li><p>程序变量<br>在GDB中，你可以随时查看以下三种变量的值：</p>\n<ul>\n<li>全局变量（所有文件可见的）</li>\n<li>静态全局变量（当前文件可见的）</li>\n<li>局部变量（当前Scope可见的）</li>\n</ul>\n</li>\n<li><p>数组<br>“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。<br>例如，你的程序中有这样的语句：<br><code>int *array = (int *) malloc (len * sizeof (int));</code><br>于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：<br><code>p *array@len</code></p>\n</li>\n<li><p>输出格式<br>x  按十六进制格式显示变量。<br>d  按十进制格式显示变量。<br>u  按十六进制格式显示无符号整型。<br>o  按八进制格式显示变量。<br>t  按二进制格式显示变量。<br>a  按十六进制格式显示变量。<br>c  按字符格式显示变量。<br>f  按浮点数格式显示变量。</p>\n</li>\n</ol>\n<h2 id=\"4-改变程序的执行\"><a href=\"#4-改变程序的执行\" class=\"headerlink\" title=\"4. 改变程序的执行\"></a>4. 改变程序的执行</h2><ol>\n<li><p>修改变量值<br>修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的<code>print</code>命令即可完成。如：<br><code>(gdb) print x=4</code></p>\n</li>\n<li><p>跳转执行<br>一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的<code>jump</code>命令来完：<br>jump 指定下一条语句的运行点。可以是文件的行号，可以是<code>file:line</code>格式，可以是<code>+num</code>这种偏移量格式。表式着下一条运行语句从哪里开始。</p>\n</li>\n<li><p>产生信号量<br>使用<code>singal</code>命令，可以产生一个信号量给被调试的程序。如：中断信号<code>Ctrl+C</code>。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。</p>\n<blockquote>\n<p>single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</p>\n</blockquote>\n</li>\n<li><p>强制函数返回<br>如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用<code>return</code>命令强制函数忽略还没有执行的语句并返回。<br>使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。</p>\n</li>\n<li><p>强制调用函数<br><code>call</code>表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。</p>\n</li>\n</ol>"},{"title":"C语言学习总结（四）——数据结构","date":"2016-11-21T08:15:24.000Z","_content":"\n程序 = 数据结构 +　算法。\n<!--more-->\n当我们需要解决一个计算机问题，大致的步骤是这样的：\n1. 从一个具体的问题抽象出一个适当的数学模型\n2. 设计一个解决这个模型的算法\n3. 编写相应的程序，测试、调整直到得到最终解答。\n所以：数据结构是一门用来研究非数值计算的程序设计问题中计算机的操作对象及他们之间的关系和操作等的学科。\n\n# 一、定义\n数据元素和数据元素之间的关系，也可称之为数据的组织形式，包括3方面\n\n1. 逻辑结构：\n集合\n线性结构 1:1\n层次结构（树形结构）1:n\n图形结构（网状结构）n:n\n\n2. 存储结构：\n顺序存储：讲数据元素按照逻辑上的先后次序存储到一片连续的内存中（一般用数组实现）\n链式存储：讲数据元素存储在内存的不同位置（每个数据元素单独存），利用指针来建立元素之间的联系（用指针）\n索引存储\n散列存储\n\n3. 运算：增删改查等\n\n# 二、线性结构\n\n1. 顺序表\n**特点：**逻辑结构和存储结构一致，存储密度高，但是插入和删除等运算复杂度较高，且要求系统提供连续的空间进行存储。\n**常见：**数组\n\n2. 链表\n**特点：**一种物理存储单元上非连续、非顺序的存储结构，存储密度低，插入和删除的时间复杂度低。\n**定义一个单链表节点（link_list）**\n\n        typedef int typedate;\n        typedef struct node\n        {\n            typedate date;\n            struct * next;  //指向下一个元素\n        }linknode；\n        此时定义的仅仅只是链表的一个节点\n\n3. 单链表\n最常见的链表，有头有尾。\n\n4. 单循环链表\n链表的尾端指向链表的头。\n\n5. 双循环链表\n链表节点中有两个指针，可以双向寻找。\n````C++\ntypedef struct DuLNode {\n  ElemType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;````\n\n6. 栈\n**特点：**仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。\n\n7. 队列\n**特点：**只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。\n\n\n# 三、非线性结构\n## 1. 树\n由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n* 每个节点有零个或多个子节点；\n* 没有父节点的节点称为根节点；\n* 每一个非根节点有且只有一个父节点；\n* 除了根节点外，每个子节点可以分为多个不相交的子树。\n\n常见的树：\n\n1. 二叉树  \n二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。  \n二叉树有以下几个性质：\n * 性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。\n * 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。\n * 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。\n * 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 \n2. AVL树  \nAVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。  \n它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于\"二叉查找树\"，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。\n3. 伸展树\n伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。  \n伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] <= key[x]；如果y是x的右子树的一个结点，则key[y] >= key[x]。  >\n除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。  \n假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。\n4. 哈弗曼树\nHuffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。  \n定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。\n5. 红黑树  \nR-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。  \n红黑树的特性:  \n * 每个节点或者是黑色，或者是红色。\n * 根节点是黑色。\n * 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n * 如果一个节点是红色的，则它的子节点必须是黑色的。\n * 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。\n\n## 2. 堆\n堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质： \n\n* [性质一] 堆中某个节点的值总是不大于或不小于其父节点的值；\n* [性质二] 堆总是一棵完全树。  \n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、左倾堆、斜堆、斐波那契堆等等。\n\n1. 二叉堆  \n   二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。  \n   * 最大堆：父结点的键值总是大于或等于任何一个子节点的键值；\n   * 最小堆：父结点的键值总是小于或等于任何一个子节点的键值。\n2. 左倾堆\n   左倾堆是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。  \n   * 键值的作用是来比较节点的大小，从而对节点进行排序。\n   * 零距离(英文名NPL，即Null Path Length)则是从一个节点到一个\"最近的不满节点\"的路径长度。\n   * 不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。 \n   左倾堆的基本性质：\n   > [性质1] 节点的键值小于或等于它的左右子节点的键值。\n   > [性质2] 节点的左孩子的NPL >= 右孩子的NPL。\n   > [性质3] 节点的NPL = 它的右孩子的NPL + 1。\n\n3. 斜堆 \n   斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。它的合并操作的时间复杂度也是O(log n)。  \n   相比于左倾堆，斜堆的节点没有\"零距离\"这个属性。除此之外，它们斜堆的合并操作也不同。斜堆的合并操作算法如下：  \n   * 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。\n   * 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将\"较小堆的根节点的右孩子\"和\"较大堆\"进行合并。\n   * 合并后，交换新堆根节点的左孩子和右孩子。\n3. 二项堆\n    二项堆是二项树的集合。  \n    二项树是一种递归定义的有序树。它的递归定义如下：  \n    * 二项树B0只有一个结点；\n    * 二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。\n\n    二项堆通常被用来实现优先队列，它堆是指满足以下性质的二项树的集合：\n    * 每棵二项树都满足最小堆性质。即，父节点的关键字 <= 它的孩子的关键字。\n    * 不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。\n\n4. 斐波那契堆  \n    斐波那契堆(Fibonacci heap)是堆中一种，它和二项堆一样，也是一种可合并堆；可用于实现合并优先队列。斐波那契堆比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。  \n    * 与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。\n    * 与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。\n\n## 3. 图\n由有穷、非空点集和边集合组成，简写成G(V,E).\n1. 邻接矩阵无向图的介绍  \n邻接矩阵无向图是指通过邻接矩阵表示的无向图。\n2. 邻接表无向图的介绍    \n邻接表无向图是指通过邻接表表示的无向图。\n3. 邻接矩阵有向图的介绍  \n邻接矩阵有向图是指通过邻接矩阵表示的有向图。\n4. 邻接表有向图的介绍  \n邻接表有向图是指通过邻接表表示的有向图。\n\n图相关算法介绍：\n1. 深度优先搜索介绍  \n图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。  \n它的思想：  \n假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n2. 拓扑排序介绍\n拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。  \n这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！  \n例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。  \n在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。\n3. 克鲁斯卡尔算法介绍  \n克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。  \n基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。  \n具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。\n4. 普里姆算法介绍  \n普里姆(Prim)算法，和克鲁斯卡尔算法一样，是用来求加权连通图的最小生成树的算法。  \n基本思想：对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。\n5. 迪杰斯特拉算法介绍\n迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。  \n它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。  \n基本思想：通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。  \n此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。  \n初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是\"起点s到该顶点的路径\"。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。\n\n# 四、算法\n衡量算法的标准：\n\n* 时间复杂度\n* 空间复杂度\n* 难易程度\n* 健壮性\n\n常用算法介绍：\n\n1. 冒泡排序介绍  \n冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。\n它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！\n2. 快速排序介绍  \n快速排序(Quick Sort)使用分治法策略。  \n它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n3. 直接插入排序介绍  \n直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。\n4. 希尔排序介绍  \n希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。  \n希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。\n5. 选择排序介绍  \n选择排序(Selection sort)是一种简单直观的排序算法。  \n它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n6. 堆排序介绍  \n堆排序(Heap Sort)是指利用堆这种数据结构所设计的一种排序算法。  \n因此，学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先学习\"二叉堆\"，然后再来学习本章。  \n我们知道，堆分为\"最大堆\"和\"最小堆\"。最大堆通常被用来进行\"升序\"排序，而最小堆通常被用来进行\"降序\"排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。\n7. 归并排序介绍  \n将两个的有序数列合并成一个有序数列，我们称之为\"归并\"。  \n归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括\"从上往下\"和\"从下往上\"2种方式。  \n    * 从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。\n    * 从上往下的归并排序：它与\"从下往上\"在排序上是反方向的。它基本包括3步：\n    1. 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2;\n    2. 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。\n    3. 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。 \n\n8. 桶排序介绍  \n桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。  \n假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个\"桶\"。  \n在排序时，逐个遍历数组a，将数组a的值，作为\"桶数组r\"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。  \n9. 基数排序介绍  \n基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。  \n具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。","source":"_posts/C语言学习总结（四）——数据结构.md","raw":"---\ntitle: C语言学习总结（四）——数据结构\ndate: 2016-11-21 16:15:24\ncategories: C语言学习总结\ntags: [C语言,数据结构]\n---\n\n程序 = 数据结构 +　算法。\n<!--more-->\n当我们需要解决一个计算机问题，大致的步骤是这样的：\n1. 从一个具体的问题抽象出一个适当的数学模型\n2. 设计一个解决这个模型的算法\n3. 编写相应的程序，测试、调整直到得到最终解答。\n所以：数据结构是一门用来研究非数值计算的程序设计问题中计算机的操作对象及他们之间的关系和操作等的学科。\n\n# 一、定义\n数据元素和数据元素之间的关系，也可称之为数据的组织形式，包括3方面\n\n1. 逻辑结构：\n集合\n线性结构 1:1\n层次结构（树形结构）1:n\n图形结构（网状结构）n:n\n\n2. 存储结构：\n顺序存储：讲数据元素按照逻辑上的先后次序存储到一片连续的内存中（一般用数组实现）\n链式存储：讲数据元素存储在内存的不同位置（每个数据元素单独存），利用指针来建立元素之间的联系（用指针）\n索引存储\n散列存储\n\n3. 运算：增删改查等\n\n# 二、线性结构\n\n1. 顺序表\n**特点：**逻辑结构和存储结构一致，存储密度高，但是插入和删除等运算复杂度较高，且要求系统提供连续的空间进行存储。\n**常见：**数组\n\n2. 链表\n**特点：**一种物理存储单元上非连续、非顺序的存储结构，存储密度低，插入和删除的时间复杂度低。\n**定义一个单链表节点（link_list）**\n\n        typedef int typedate;\n        typedef struct node\n        {\n            typedate date;\n            struct * next;  //指向下一个元素\n        }linknode；\n        此时定义的仅仅只是链表的一个节点\n\n3. 单链表\n最常见的链表，有头有尾。\n\n4. 单循环链表\n链表的尾端指向链表的头。\n\n5. 双循环链表\n链表节点中有两个指针，可以双向寻找。\n````C++\ntypedef struct DuLNode {\n  ElemType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;````\n\n6. 栈\n**特点：**仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。\n\n7. 队列\n**特点：**只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。\n\n\n# 三、非线性结构\n## 1. 树\n由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n* 每个节点有零个或多个子节点；\n* 没有父节点的节点称为根节点；\n* 每一个非根节点有且只有一个父节点；\n* 除了根节点外，每个子节点可以分为多个不相交的子树。\n\n常见的树：\n\n1. 二叉树  \n二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。  \n二叉树有以下几个性质：\n * 性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。\n * 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。\n * 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。\n * 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 \n2. AVL树  \nAVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。  \n它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于\"二叉查找树\"，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。\n3. 伸展树\n伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。  \n伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] <= key[x]；如果y是x的右子树的一个结点，则key[y] >= key[x]。  >\n除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。  \n假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。\n4. 哈弗曼树\nHuffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。  \n定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。\n5. 红黑树  \nR-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。  \n红黑树的特性:  \n * 每个节点或者是黑色，或者是红色。\n * 根节点是黑色。\n * 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n * 如果一个节点是红色的，则它的子节点必须是黑色的。\n * 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。\n\n## 2. 堆\n堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质： \n\n* [性质一] 堆中某个节点的值总是不大于或不小于其父节点的值；\n* [性质二] 堆总是一棵完全树。  \n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、左倾堆、斜堆、斐波那契堆等等。\n\n1. 二叉堆  \n   二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。  \n   * 最大堆：父结点的键值总是大于或等于任何一个子节点的键值；\n   * 最小堆：父结点的键值总是小于或等于任何一个子节点的键值。\n2. 左倾堆\n   左倾堆是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。  \n   * 键值的作用是来比较节点的大小，从而对节点进行排序。\n   * 零距离(英文名NPL，即Null Path Length)则是从一个节点到一个\"最近的不满节点\"的路径长度。\n   * 不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。 \n   左倾堆的基本性质：\n   > [性质1] 节点的键值小于或等于它的左右子节点的键值。\n   > [性质2] 节点的左孩子的NPL >= 右孩子的NPL。\n   > [性质3] 节点的NPL = 它的右孩子的NPL + 1。\n\n3. 斜堆 \n   斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。它的合并操作的时间复杂度也是O(log n)。  \n   相比于左倾堆，斜堆的节点没有\"零距离\"这个属性。除此之外，它们斜堆的合并操作也不同。斜堆的合并操作算法如下：  \n   * 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。\n   * 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将\"较小堆的根节点的右孩子\"和\"较大堆\"进行合并。\n   * 合并后，交换新堆根节点的左孩子和右孩子。\n3. 二项堆\n    二项堆是二项树的集合。  \n    二项树是一种递归定义的有序树。它的递归定义如下：  \n    * 二项树B0只有一个结点；\n    * 二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。\n\n    二项堆通常被用来实现优先队列，它堆是指满足以下性质的二项树的集合：\n    * 每棵二项树都满足最小堆性质。即，父节点的关键字 <= 它的孩子的关键字。\n    * 不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。\n\n4. 斐波那契堆  \n    斐波那契堆(Fibonacci heap)是堆中一种，它和二项堆一样，也是一种可合并堆；可用于实现合并优先队列。斐波那契堆比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。  \n    * 与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。\n    * 与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。\n\n## 3. 图\n由有穷、非空点集和边集合组成，简写成G(V,E).\n1. 邻接矩阵无向图的介绍  \n邻接矩阵无向图是指通过邻接矩阵表示的无向图。\n2. 邻接表无向图的介绍    \n邻接表无向图是指通过邻接表表示的无向图。\n3. 邻接矩阵有向图的介绍  \n邻接矩阵有向图是指通过邻接矩阵表示的有向图。\n4. 邻接表有向图的介绍  \n邻接表有向图是指通过邻接表表示的有向图。\n\n图相关算法介绍：\n1. 深度优先搜索介绍  \n图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。  \n它的思想：  \n假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n2. 拓扑排序介绍\n拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。  \n这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！  \n例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。  \n在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。\n3. 克鲁斯卡尔算法介绍  \n克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。  \n基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。  \n具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。\n4. 普里姆算法介绍  \n普里姆(Prim)算法，和克鲁斯卡尔算法一样，是用来求加权连通图的最小生成树的算法。  \n基本思想：对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。\n5. 迪杰斯特拉算法介绍\n迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。  \n它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。  \n基本思想：通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。  \n此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。  \n初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是\"起点s到该顶点的路径\"。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。\n\n# 四、算法\n衡量算法的标准：\n\n* 时间复杂度\n* 空间复杂度\n* 难易程度\n* 健壮性\n\n常用算法介绍：\n\n1. 冒泡排序介绍  \n冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。\n它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！\n2. 快速排序介绍  \n快速排序(Quick Sort)使用分治法策略。  \n它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n3. 直接插入排序介绍  \n直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。\n4. 希尔排序介绍  \n希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。  \n希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。\n5. 选择排序介绍  \n选择排序(Selection sort)是一种简单直观的排序算法。  \n它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n6. 堆排序介绍  \n堆排序(Heap Sort)是指利用堆这种数据结构所设计的一种排序算法。  \n因此，学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先学习\"二叉堆\"，然后再来学习本章。  \n我们知道，堆分为\"最大堆\"和\"最小堆\"。最大堆通常被用来进行\"升序\"排序，而最小堆通常被用来进行\"降序\"排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。\n7. 归并排序介绍  \n将两个的有序数列合并成一个有序数列，我们称之为\"归并\"。  \n归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括\"从上往下\"和\"从下往上\"2种方式。  \n    * 从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。\n    * 从上往下的归并排序：它与\"从下往上\"在排序上是反方向的。它基本包括3步：\n    1. 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2;\n    2. 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。\n    3. 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。 \n\n8. 桶排序介绍  \n桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。  \n假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个\"桶\"。  \n在排序时，逐个遍历数组a，将数组a的值，作为\"桶数组r\"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。  \n9. 基数排序介绍  \n基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。  \n具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。","slug":"C语言学习总结（四）——数据结构","published":1,"updated":"2017-12-14T05:19:41.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n06000mbkw1i7d3vs5h","content":"<p>程序 = 数据结构 +　算法。<br><a id=\"more\"></a><br>当我们需要解决一个计算机问题，大致的步骤是这样的：</p>\n<ol>\n<li>从一个具体的问题抽象出一个适当的数学模型</li>\n<li>设计一个解决这个模型的算法</li>\n<li>编写相应的程序，测试、调整直到得到最终解答。<br>所以：数据结构是一门用来研究非数值计算的程序设计问题中计算机的操作对象及他们之间的关系和操作等的学科。</li>\n</ol>\n<h1 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h1><p>数据元素和数据元素之间的关系，也可称之为数据的组织形式，包括3方面</p>\n<ol>\n<li><p>逻辑结构：<br>集合<br>线性结构 1:1<br>层次结构（树形结构）1:n<br>图形结构（网状结构）n:n</p>\n</li>\n<li><p>存储结构：<br>顺序存储：讲数据元素按照逻辑上的先后次序存储到一片连续的内存中（一般用数组实现）<br>链式存储：讲数据元素存储在内存的不同位置（每个数据元素单独存），利用指针来建立元素之间的联系（用指针）<br>索引存储<br>散列存储</p>\n</li>\n<li><p>运算：增删改查等</p>\n</li>\n</ol>\n<h1 id=\"二、线性结构\"><a href=\"#二、线性结构\" class=\"headerlink\" title=\"二、线性结构\"></a>二、线性结构</h1><ol>\n<li><p>顺序表<br><strong>特点：</strong>逻辑结构和存储结构一致，存储密度高，但是插入和删除等运算复杂度较高，且要求系统提供连续的空间进行存储。<br><strong>常见：</strong>数组</p>\n</li>\n<li><p>链表<br><strong>特点：</strong>一种物理存储单元上非连续、非顺序的存储结构，存储密度低，插入和删除的时间复杂度低。<br><strong>定义一个单链表节点（link_list）</strong></p>\n<pre><code>typedef int typedate;\ntypedef struct node\n{\n    typedate date;\n    struct * next;  //指向下一个元素\n}linknode；\n此时定义的仅仅只是链表的一个节点\n</code></pre></li>\n<li><p>单链表<br>最常见的链表，有头有尾。</p>\n</li>\n<li><p>单循环链表<br>链表的尾端指向链表的头。</p>\n</li>\n<li><p>双循环链表<br>链表节点中有两个指针，可以双向寻找。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> DuLNode &#123;</div><div class=\"line\">  ElemType data;</div><div class=\"line\">  <span class=\"keyword\">struct</span> DuLNode *prior,*next;</div><div class=\"line\">&#125;DuLNode,*DuLinkList;</div></pre></td></tr></table></figure>\n</li>\n<li><p>栈<br><strong>特点：</strong>仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。</p>\n</li>\n<li><p>队列<br><strong>特点：</strong>只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。</p>\n</li>\n</ol>\n<h1 id=\"三、非线性结构\"><a href=\"#三、非线性结构\" class=\"headerlink\" title=\"三、非线性结构\"></a>三、非线性结构</h1><h2 id=\"1-树\"><a href=\"#1-树\" class=\"headerlink\" title=\"1. 树\"></a>1. 树</h2><p>由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n<ul>\n<li>每个节点有零个或多个子节点；</li>\n<li>没有父节点的节点称为根节点；</li>\n<li>每一个非根节点有且只有一个父节点；</li>\n<li>除了根节点外，每个子节点可以分为多个不相交的子树。</li>\n</ul>\n<p>常见的树：</p>\n<ol>\n<li>二叉树<br>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。<br>二叉树有以下几个性质：<ul>\n<li>性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。</li>\n<li>性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。</li>\n<li>性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。</li>\n<li>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 </li>\n</ul>\n</li>\n<li>AVL树<br>AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。<br>它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于”二叉查找树”，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。</li>\n<li>伸展树<br>伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。<br>伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。  &gt;<br>除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。<br>假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</li>\n<li>哈弗曼树<br>Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。<br>定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。</li>\n<li>红黑树<br>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。<br>红黑树的特性:  <ul>\n<li>每个节点或者是黑色，或者是红色。</li>\n<li>根节点是黑色。</li>\n<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>\n<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>\n<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-堆\"><a href=\"#2-堆\" class=\"headerlink\" title=\"2. 堆\"></a>2. 堆</h2><p>堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质： </p>\n<ul>\n<li>[性质一] 堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>[性质二] 堆总是一棵完全树。<br>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、左倾堆、斜堆、斐波那契堆等等。</li>\n</ul>\n<ol>\n<li>二叉堆<br>二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。  <ul>\n<li>最大堆：父结点的键值总是大于或等于任何一个子节点的键值；</li>\n<li>最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</li>\n</ul>\n</li>\n<li><p>左倾堆<br>左倾堆是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。  </p>\n<ul>\n<li>键值的作用是来比较节点的大小，从而对节点进行排序。</li>\n<li>零距离(英文名NPL，即Null Path Length)则是从一个节点到一个”最近的不满节点”的路径长度。</li>\n<li>不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。<br>左倾堆的基本性质：<blockquote>\n<p>[性质1] 节点的键值小于或等于它的左右子节点的键值。<br>[性质2] 节点的左孩子的NPL &gt;= 右孩子的NPL。<br>[性质3] 节点的NPL = 它的右孩子的NPL + 1。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>斜堆<br>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。它的合并操作的时间复杂度也是O(log n)。<br>相比于左倾堆，斜堆的节点没有”零距离”这个属性。除此之外，它们斜堆的合并操作也不同。斜堆的合并操作算法如下：  </p>\n<ul>\n<li>如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。</li>\n<li>如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li>\n<li>合并后，交换新堆根节点的左孩子和右孩子。</li>\n</ul>\n</li>\n<li><p>二项堆<br> 二项堆是二项树的集合。<br> 二项树是一种递归定义的有序树。它的递归定义如下：  </p>\n<ul>\n<li>二项树B0只有一个结点；</li>\n<li><p>二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。</p>\n<p>二项堆通常被用来实现优先队列，它堆是指满足以下性质的二项树的集合：</p>\n</li>\n<li>每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。</li>\n<li>不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</li>\n</ul>\n</li>\n<li><p>斐波那契堆<br> 斐波那契堆(Fibonacci heap)是堆中一种，它和二项堆一样，也是一种可合并堆；可用于实现合并优先队列。斐波那契堆比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。  </p>\n<ul>\n<li>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。</li>\n<li>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-图\"><a href=\"#3-图\" class=\"headerlink\" title=\"3. 图\"></a>3. 图</h2><p>由有穷、非空点集和边集合组成，简写成G(V,E).</p>\n<ol>\n<li>邻接矩阵无向图的介绍<br>邻接矩阵无向图是指通过邻接矩阵表示的无向图。</li>\n<li>邻接表无向图的介绍<br>邻接表无向图是指通过邻接表表示的无向图。</li>\n<li>邻接矩阵有向图的介绍<br>邻接矩阵有向图是指通过邻接矩阵表示的有向图。</li>\n<li>邻接表有向图的介绍<br>邻接表有向图是指通过邻接表表示的有向图。</li>\n</ol>\n<p>图相关算法介绍：</p>\n<ol>\n<li>深度优先搜索介绍<br>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。<br>它的思想：<br>假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</li>\n<li>拓扑排序介绍<br>拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。<br>这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！<br>例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。<br>在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。</li>\n<li>克鲁斯卡尔算法介绍<br>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。<br>基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。<br>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</li>\n<li>普里姆算法介绍<br>普里姆(Prim)算法，和克鲁斯卡尔算法一样，是用来求加权连通图的最小生成树的算法。<br>基本思想：对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</li>\n<li>迪杰斯特拉算法介绍<br>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。<br>基本思想：通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。<br>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。<br>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</li>\n</ol>\n<h1 id=\"四、算法\"><a href=\"#四、算法\" class=\"headerlink\" title=\"四、算法\"></a>四、算法</h1><p>衡量算法的标准：</p>\n<ul>\n<li>时间复杂度</li>\n<li>空间复杂度</li>\n<li>难易程度</li>\n<li>健壮性</li>\n</ul>\n<p>常用算法介绍：</p>\n<ol>\n<li>冒泡排序介绍<br>冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。<br>它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！</li>\n<li>快速排序介绍<br>快速排序(Quick Sort)使用分治法策略。<br>它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>\n<li>直接插入排序介绍<br>直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</li>\n<li>希尔排序介绍<br>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。<br>希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。</li>\n<li>选择排序介绍<br>选择排序(Selection sort)是一种简单直观的排序算法。<br>它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>\n<li>堆排序介绍<br>堆排序(Heap Sort)是指利用堆这种数据结构所设计的一种排序算法。<br>因此，学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先学习”二叉堆”，然后再来学习本章。<br>我们知道，堆分为”最大堆”和”最小堆”。最大堆通常被用来进行”升序”排序，而最小堆通常被用来进行”降序”排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。</li>\n<li><p>归并排序介绍<br>将两个的有序数列合并成一个有序数列，我们称之为”归并”。<br>归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括”从上往下”和”从下往上”2种方式。  </p>\n<ul>\n<li>从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。</li>\n<li>从上往下的归并排序：它与”从下往上”在排序上是反方向的。它基本包括3步：</li>\n</ul>\n<ol>\n<li>分解 – 将当前区间一分为二，即求分裂点 mid = (low + high)/2;</li>\n<li>求解 – 递归地对两个子区间a[low…mid] 和 a[mid+1…high]进行归并排序。递归的终结条件是子区间长度为1。</li>\n<li>合并 – 将已排序的两个子区间a[low…mid]和 a[mid+1…high]归并为一个有序的区间a[low…high]。 </li>\n</ol>\n</li>\n<li><p>桶排序介绍<br>桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。<br>假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。<br>在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。  </p>\n</li>\n<li>基数排序介绍<br>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>\n</ol>\n","excerpt":"<p>程序 = 数据结构 +　算法。<br>","more":"<br>当我们需要解决一个计算机问题，大致的步骤是这样的：</p>\n<ol>\n<li>从一个具体的问题抽象出一个适当的数学模型</li>\n<li>设计一个解决这个模型的算法</li>\n<li>编写相应的程序，测试、调整直到得到最终解答。<br>所以：数据结构是一门用来研究非数值计算的程序设计问题中计算机的操作对象及他们之间的关系和操作等的学科。</li>\n</ol>\n<h1 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h1><p>数据元素和数据元素之间的关系，也可称之为数据的组织形式，包括3方面</p>\n<ol>\n<li><p>逻辑结构：<br>集合<br>线性结构 1:1<br>层次结构（树形结构）1:n<br>图形结构（网状结构）n:n</p>\n</li>\n<li><p>存储结构：<br>顺序存储：讲数据元素按照逻辑上的先后次序存储到一片连续的内存中（一般用数组实现）<br>链式存储：讲数据元素存储在内存的不同位置（每个数据元素单独存），利用指针来建立元素之间的联系（用指针）<br>索引存储<br>散列存储</p>\n</li>\n<li><p>运算：增删改查等</p>\n</li>\n</ol>\n<h1 id=\"二、线性结构\"><a href=\"#二、线性结构\" class=\"headerlink\" title=\"二、线性结构\"></a>二、线性结构</h1><ol>\n<li><p>顺序表<br><strong>特点：</strong>逻辑结构和存储结构一致，存储密度高，但是插入和删除等运算复杂度较高，且要求系统提供连续的空间进行存储。<br><strong>常见：</strong>数组</p>\n</li>\n<li><p>链表<br><strong>特点：</strong>一种物理存储单元上非连续、非顺序的存储结构，存储密度低，插入和删除的时间复杂度低。<br><strong>定义一个单链表节点（link_list）</strong></p>\n<pre><code>typedef int typedate;\ntypedef struct node\n{\n    typedate date;\n    struct * next;  //指向下一个元素\n}linknode；\n此时定义的仅仅只是链表的一个节点\n</code></pre></li>\n<li><p>单链表<br>最常见的链表，有头有尾。</p>\n</li>\n<li><p>单循环链表<br>链表的尾端指向链表的头。</p>\n</li>\n<li><p>双循环链表<br>链表节点中有两个指针，可以双向寻找。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> DuLNode &#123;</div><div class=\"line\">  ElemType data;</div><div class=\"line\">  <span class=\"keyword\">struct</span> DuLNode *prior,*next;</div><div class=\"line\">&#125;DuLNode,*DuLinkList;</div></pre></td></tr></table></figure>\n</li>\n<li><p>栈<br><strong>特点：</strong>仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。</p>\n</li>\n<li><p>队列<br><strong>特点：</strong>只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。</p>\n</li>\n</ol>\n<h1 id=\"三、非线性结构\"><a href=\"#三、非线性结构\" class=\"headerlink\" title=\"三、非线性结构\"></a>三、非线性结构</h1><h2 id=\"1-树\"><a href=\"#1-树\" class=\"headerlink\" title=\"1. 树\"></a>1. 树</h2><p>由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n<ul>\n<li>每个节点有零个或多个子节点；</li>\n<li>没有父节点的节点称为根节点；</li>\n<li>每一个非根节点有且只有一个父节点；</li>\n<li>除了根节点外，每个子节点可以分为多个不相交的子树。</li>\n</ul>\n<p>常见的树：</p>\n<ol>\n<li>二叉树<br>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。<br>二叉树有以下几个性质：<ul>\n<li>性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。</li>\n<li>性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。</li>\n<li>性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。</li>\n<li>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 </li>\n</ul>\n</li>\n<li>AVL树<br>AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。<br>它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于”二叉查找树”，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。</li>\n<li>伸展树<br>伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。<br>伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。  &gt;<br>除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。<br>假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</li>\n<li>哈弗曼树<br>Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。<br>定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。</li>\n<li>红黑树<br>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。<br>红黑树的特性:  <ul>\n<li>每个节点或者是黑色，或者是红色。</li>\n<li>根节点是黑色。</li>\n<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>\n<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>\n<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-堆\"><a href=\"#2-堆\" class=\"headerlink\" title=\"2. 堆\"></a>2. 堆</h2><p>堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质： </p>\n<ul>\n<li>[性质一] 堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>[性质二] 堆总是一棵完全树。<br>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、左倾堆、斜堆、斐波那契堆等等。</li>\n</ul>\n<ol>\n<li>二叉堆<br>二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。  <ul>\n<li>最大堆：父结点的键值总是大于或等于任何一个子节点的键值；</li>\n<li>最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</li>\n</ul>\n</li>\n<li><p>左倾堆<br>左倾堆是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。  </p>\n<ul>\n<li>键值的作用是来比较节点的大小，从而对节点进行排序。</li>\n<li>零距离(英文名NPL，即Null Path Length)则是从一个节点到一个”最近的不满节点”的路径长度。</li>\n<li>不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。<br>左倾堆的基本性质：<blockquote>\n<p>[性质1] 节点的键值小于或等于它的左右子节点的键值。<br>[性质2] 节点的左孩子的NPL &gt;= 右孩子的NPL。<br>[性质3] 节点的NPL = 它的右孩子的NPL + 1。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>斜堆<br>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。它的合并操作的时间复杂度也是O(log n)。<br>相比于左倾堆，斜堆的节点没有”零距离”这个属性。除此之外，它们斜堆的合并操作也不同。斜堆的合并操作算法如下：  </p>\n<ul>\n<li>如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。</li>\n<li>如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li>\n<li>合并后，交换新堆根节点的左孩子和右孩子。</li>\n</ul>\n</li>\n<li><p>二项堆<br> 二项堆是二项树的集合。<br> 二项树是一种递归定义的有序树。它的递归定义如下：  </p>\n<ul>\n<li>二项树B0只有一个结点；</li>\n<li><p>二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。</p>\n<p>二项堆通常被用来实现优先队列，它堆是指满足以下性质的二项树的集合：</p>\n</li>\n<li>每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。</li>\n<li>不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</li>\n</ul>\n</li>\n<li><p>斐波那契堆<br> 斐波那契堆(Fibonacci heap)是堆中一种，它和二项堆一样，也是一种可合并堆；可用于实现合并优先队列。斐波那契堆比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。  </p>\n<ul>\n<li>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。</li>\n<li>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-图\"><a href=\"#3-图\" class=\"headerlink\" title=\"3. 图\"></a>3. 图</h2><p>由有穷、非空点集和边集合组成，简写成G(V,E).</p>\n<ol>\n<li>邻接矩阵无向图的介绍<br>邻接矩阵无向图是指通过邻接矩阵表示的无向图。</li>\n<li>邻接表无向图的介绍<br>邻接表无向图是指通过邻接表表示的无向图。</li>\n<li>邻接矩阵有向图的介绍<br>邻接矩阵有向图是指通过邻接矩阵表示的有向图。</li>\n<li>邻接表有向图的介绍<br>邻接表有向图是指通过邻接表表示的有向图。</li>\n</ol>\n<p>图相关算法介绍：</p>\n<ol>\n<li>深度优先搜索介绍<br>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。<br>它的思想：<br>假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</li>\n<li>拓扑排序介绍<br>拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。<br>这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！<br>例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。<br>在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。</li>\n<li>克鲁斯卡尔算法介绍<br>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。<br>基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。<br>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</li>\n<li>普里姆算法介绍<br>普里姆(Prim)算法，和克鲁斯卡尔算法一样，是用来求加权连通图的最小生成树的算法。<br>基本思想：对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</li>\n<li>迪杰斯特拉算法介绍<br>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。<br>基本思想：通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。<br>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。<br>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</li>\n</ol>\n<h1 id=\"四、算法\"><a href=\"#四、算法\" class=\"headerlink\" title=\"四、算法\"></a>四、算法</h1><p>衡量算法的标准：</p>\n<ul>\n<li>时间复杂度</li>\n<li>空间复杂度</li>\n<li>难易程度</li>\n<li>健壮性</li>\n</ul>\n<p>常用算法介绍：</p>\n<ol>\n<li>冒泡排序介绍<br>冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。<br>它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！</li>\n<li>快速排序介绍<br>快速排序(Quick Sort)使用分治法策略。<br>它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>\n<li>直接插入排序介绍<br>直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</li>\n<li>希尔排序介绍<br>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。<br>希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。</li>\n<li>选择排序介绍<br>选择排序(Selection sort)是一种简单直观的排序算法。<br>它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>\n<li>堆排序介绍<br>堆排序(Heap Sort)是指利用堆这种数据结构所设计的一种排序算法。<br>因此，学习堆排序之前，有必要了解堆！若读者不熟悉堆，建议先学习”二叉堆”，然后再来学习本章。<br>我们知道，堆分为”最大堆”和”最小堆”。最大堆通常被用来进行”升序”排序，而最小堆通常被用来进行”降序”排序。 鉴于最大堆和最小堆是对称关系，理解其中一种即可。本文将对最大堆实现的升序排序进行详细说明。</li>\n<li><p>归并排序介绍<br>将两个的有序数列合并成一个有序数列，我们称之为”归并”。<br>归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括”从上往下”和”从下往上”2种方式。  </p>\n<ul>\n<li>从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。</li>\n<li>从上往下的归并排序：它与”从下往上”在排序上是反方向的。它基本包括3步：</li>\n</ul>\n<ol>\n<li>分解 – 将当前区间一分为二，即求分裂点 mid = (low + high)/2;</li>\n<li>求解 – 递归地对两个子区间a[low…mid] 和 a[mid+1…high]进行归并排序。递归的终结条件是子区间长度为1。</li>\n<li>合并 – 将已排序的两个子区间a[low…mid]和 a[mid+1…high]归并为一个有序的区间a[low…high]。 </li>\n</ol>\n</li>\n<li><p>桶排序介绍<br>桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。<br>假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。<br>在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。  </p>\n</li>\n<li>基数排序介绍<br>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>\n</ol>"},{"title":"Google C++ Style Guide","date":"2016-12-02T07:57:09.000Z","_content":"\n最近把 Google C++ Style Guide 从头到尾看了一遍，把相应的内容记录在这里，也规范下以后自己的代码。  \n\n<!--more-->\n![Google C++ Style Guide](http://ogf054qp1.bkt.clouddn.com/Google%20C++%20Style%20Guide.png)\n\n## Header Files\n通常每一个 `.cpp` 文件都应该有一个对应的 `.h` 头文件，对于一个头文件来说（1）需要**Self-contained**，即一个头文件应该有相应的**#define 保护**、并包含所有他需要的其它头文件；（2）尽量应使用头文件而不是**前置声明**；（3）不能滥用**内联函数**只在函数少于10行的时候才使用内联函数；（4）使用标准的**头文件包含顺序**来增强可读性，避免隐藏依赖。  \n* #define保护的格式为 `#define <PROJECT>_<PATH>_<FILE>_H_`\n* 头文件的包含顺序应该为：\n  1. 优先位置，当前文件需要实现或测试的头文件\n  2. C 系统文件\n  3. C++ 系统文件\n  4. 其他库的 .h 文件\n  5. 本项目内 .h 文件\n\n## Scoping\n作用域主要规范了 `名称空间 `、`非成员函数`、`静态成员函数`、`全局函数`、`局部变量`、`静态和全局变量` 的使用规范：\n* 名称空间\n  * 推荐在 `.cpp` 文件中使用匿名名称空间\n  * 不能在 `.h` 文件中使用匿名名称空间\n  * 不要在名称空间 `std` 内声明任何东西\n  * 不要使用 `using` 包含整个命名空间\n  * 不要使用内联命名空间\n  * 可以使用 `using` 声明\n  * 可以使用名称空间别名\n* 使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数。\n* 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。\n* 禁止使用 `class` 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 `constexpr` 变量除外，毕竟它们又不涉及动态初始化或析构。\n\n## Classes\n在使用类的时候应遵循以下规则：\n* 不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化)。\n* 对单个参数的构造函数使用 C++ 关键字 `explicit`.不要定义隐式转换。\n* 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用。\n* 仅当只有数据时使用 `struct`, 其它一概使用 `class`。\n* 使用组合 (`composition`) 常常比使用继承更合理. 如果使用继承的话, 定义为 `public` 继承。\n* 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 `Interface` 为后缀的 纯接口类。\n* 接口是指满足特定条件的类, 这些类以 `Interface` 为后缀 (不强制)。\n* 除少数特定环境外，不要重载运算符。\n* 将所有数据成员声明为 `private`, 并根据需要提供相应的存取函数，一般在头文件中把存取函数定义成内联函数。\n* 在类中使用特定的声明顺序: `public` 在 `private` 之前, 成员函数在数据成员 (变量) 前;  \n  每个区段内的声明通常按以下顺序:\n  1. `typedefs` 和枚举\n  2. 常量\n  3. 构造函数\n  4. 析构函数\n  5. 成员函数, 含静态成员函数\n  6. 数据成员, 含静态数据成员\n  友元声明应该放在 `private` 区段. 如果用宏 `DISALLOW_COPY_AND_ASSIGN` 禁用拷贝和赋值, 应当将其置于 `private` 区段的末尾, 也即整个类声明的末尾.  \n\n* `.cc` 文件中函数的定义应尽可能和声明顺序一致。\n\n## Functions\n在定义函数时，参数顺序应该是：**先输入，后输出**。所有按引用传递的参数必须加上 `const` 。倾向编写简短, 凝练的函数，**函数一般不应超过40行**。**重载函数**时最好在函数名里加入参数信息。除以下情况，最好不要使用缺省参数：\n* 其一，位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。\n* 其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。\n* 其三，可以用来模拟变长数组。\n\n## Other C++ Features\nGoogle设定的C++的新特性规范有很多，从中选取了以下几条：\n* `Casting` 使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;\n\n* `Streams` 只在记录日志时使用流.\n\n* `Preincrement and Predecrement` 对于迭代器和其他模板对象使用前缀形式 (`++i`) 的自增, 自减运算符.\n\n* `Use of const` `const` 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误。在任何可能的情况下使用 const:\n  * 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const.\n  * 尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const.\n  * 如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.\n\n* `Use of constexpr` 在 C++11 里，用 `constexpr` 来定义真正的常量，或实现常量初始化。\n \n* `Integer Types` C++ 内建整型中, 仅使用`int`。在需要确保整型大小时, 可以使用 `<stdint.h>` 中长度精确的整型。\n\n* `Preprocessor Macros` 如果要使用宏, 尽可能遵守:\n  * 不要在 .h 文件中定义宏.\n  * 在马上要使用时才进行 #define, 使用后要立即 #undef.\n  * 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；\n  * 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.\n  * 不要用 ## 处理函数，类和变量的名字。\n\n\n* `nullptr/NULL/0` 整数用 `0`, 实数用 `0.0`, 指针用 `nullptr` 或 `NUL`, 字符 (串) 用 `'\\0'`.\n\n* `sizeof` 尽可能用 sizeof(varname) 代替 sizeof(type).\n\n* `auto` 用 `auto` 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。\n\n## Naming\n命名的一致性是规则代码最鲜明的体现，规则的命名可以快速的让阅读者获知名字代表的是函数还是类型还是常量，命名需要遵守的最基本的原则是`要有描述性；少用缩写`。对不同的类型，以不同的方式进行命名，规则如下：\n* **文件名**要全部小写, 可以包含下划线 (`_`) 或连字符 (`-`)。`_` 更好：`my_useful_class.cc`。\n* **类型名称**（类, 结构体, 类型定义 (typedef), 枚举）的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`。\n* **变量名**一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`。\n* **在全局或类里的常量**名称前加 `k`: `kDaysInAWeek`。且除去开头的 k 之外每个单词开头字母均大写。\n* **常规函数**使用大小写混合, **取值和设值函数**则要求与变量名匹配: `MyExcitingFunction()`, `MyExcitingMethod()`, `my_exciting_member_variable()`, `set_my_exciting_member_variable()`。\n* **名字空间**用小写字母命名, 并基于项目名称和目录结构: `google_awesome_project`。\n* **枚举**的命名应当和**常量**或**宏**一致: `kEnumName` 或是 `ENUM_NAME`。\n* 如果你一定要用**宏**, 像这样命名: `MY_MACRO_THAT_SCARES_SMALL_CHILDREN`。\n\n## Comments\n注释虽然写起来很痛苦, 但对保证代码可读性至关重要。但同时需要记住的是: 注释固然很重要, 但`最好的代码本身应该是自文档化`。有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字。注释主要有以下7类：\n\n### 1. 文件注释   \n在每一个文件开头加入版权公告, 然后是文件内容描述。每个文件都应该包含以下项, 依次是:\n\n * 版权声明 (比如, `Copyright 2008 Google Inc.`)\n * 许可证. 为项目选择合适的许可证版本 (比如, `Apache 2.0`, `BSD`, `LGPL`, `GPL`)\n * 作者: 标识文件的原始作者.\n * 文件内容:紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容。\n   通常, `.h` 文件要对所声明的类的功能和用法作简单说明. `.cc` 文件通常包含了更多的实现细节或算法技巧讨论。\n\n### 2. 类注释  \n每个类的定义都要附带一份注释, 描述类的功能和用法.\n\n### 3. 函数注释  \n函数声明处注释描述函数功能; 定义处描述函数实现.\n\n * 函数声明:  \n    * 函数的输入输出.\n    * 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.\n    * 如果函数分配了空间, 需要由调用者释放.\n    * 参数是否可以为 NULL.\n    * 是否存在函数使用上的性能隐患.\n    * 如果函数是可重入的, 其同步前提是什么?\n\n * 函数定义:  \n  每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.\n\n### 4. 变量注释  \n通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.\n * 类数据成员:每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明。\n * 全局变量:和数据成员一样, 所有全局变量也要注释说明含义及用途。\n\n### 5. 实现注释\n对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释。\n * 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释。\n * 如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性。\n * 向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意。\n * **永远不要**用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意。\n\n### 6. `TODO` 注释  \n对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 `TODO` 注释。\n`TODO` 注释要使用全大写的字符串 `TODO`, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 `TODO` 格式进行查找. 添加 `TODO` 注释并不意味着你要自己来修正。\n\n### 7. 弃用注释\n通过弃用注释（`DEPRECATED comments`）以标记某接口点（`interface points`）已弃用。\n\n## Formatting\n代码风格和格式是一个比较个人化的问题, 但整个项目(或一个人的所有项目)服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码。\n\n### 1. 行长度\n每一行代码字符数不超过 80.\n\n### 2. 非 `ASCII` 字符\n尽量不使用非 `ASCII` 字符, 使用时必须使用 `UTF-8` 编码.\n\n### 3. 空格还是制表位\n只使用空格, 每次缩进 2 个空格.\n\n### 4. 函数声明与定义\n返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。\n注意以下几点:\n\n * 如果返回类型和函数名在一行放不下，分行。\n * 如果返回类型那个与函数声明或定义分行了，不要缩进。\n * 左圆括号总是和函数名在同一行;\n * 函数名和左圆括号间没有空格;\n * 圆括号与参数间没有空格;\n * 左大括号总在最后一个参数同一行的末尾处;\n * 如果其它风格规则允许的话，右大括号总是单独位于函数最后一行，或者与左大括号同一行。\n * 右大括号和左大括号间总是有一个空格;\n * 函数声明和定义中的所有形参必须有命名且一致;\n * 所有形参应尽可能对齐;\n * 缺省缩进为 2 个空格;\n * 换行后的参数保持 4 个空格的缩进;\n\n### 5. `Lambda` 表达式\n其它函数怎么格式化形参和函数体，`Lambda` 表达式就怎么格式化；捕获列表同理。\n\n### 6. 函数调用\n要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。函数调用遵循如下形式：\n\n * 如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：\n * 参数也可以放在次行，缩进四格：\n * 把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：\n * 如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给函数,或者放着不管，补充上注释：\n * 如果某参数独立成行，对可读性更有帮助的话，就这么办。\n * 此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：\n\n### 7. 列表初始化格式\n您平时怎么格式化函数调用，就怎么格式化。\n\n### 8. 条件语句\n倾向于不在圆括号内使用空格. 关键字 `if` 和 `else` 另起一行.\n对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有。只要其中一个分支用了大括号，所有分支都要用上大括号。\n````C++\nif (condition) {  圆括号里没空格紧邻。\n  ...  // 2 空格缩进。\n} else {  // else 与 if 的右括号同一行。\n  ...\n}````\n\n### 9. 循环和开关选择语句\n`switch` 语句可以使用大括号分段，以表明 `cases` 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 `{}` 或 `continue`.\n````C++\nswitch (var) {\n  case 0: {  // 2 空格缩进\n    ...      // 4 空格缩进\n    break;\n  }\n  case 1: {\n    ...\n    break;\n  }\n  default: {\n    assert(false);\n  }\n}````\n在单语句循环里，括号可用可不用：\n````C++\nfor (int i = 0; i < kSomeNumber; ++i)\n  printf(\"I love you\\n\");\n\nfor (int i = 0; i < kSomeNumber; ++i) {\n  printf(\"I take it back\\n\");\n}````\n空循环体应使用 `{}` 或 `continue`, 而不是一个简单的分号.\n````C++\nwhile (condition) {\n// 反复循环直到条件失效。\n}\nfor (int i = 0; i < kSomeNumber; ++i) {}  // 可 - 空循环体。\nwhile (condition) continue;  // 可 - contunue 表明没有逻辑。\n````\n### 10. 指针和引用表达式\n句点或箭头前后不要有空格. 指针/地址操作符 (`*`, `&`) 之后不能有空格.\n下面是指针和引用表达式的正确使用范例:\n````C++\nx = *p;\np = &x;\nx = r.y;\nx = r->y;\n````\n### 11. 布尔表达式\n如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.\n下例中, 逻辑与 (`&&`) 操作符总位于行尾:\n````C++\nif (this_one_thing > this_other_thing &&\n  a_third_thing == a_fourth_thing &&\n  yet_another & last_one) {\n...\n}````\n    \n### 12. 函数返回值\n`return` 表达式里时没必要都用圆括号，变量返回时不要使用圆括号，可以用圆括号把复杂表达式圈起来，改善可读性。\n\n### 13. 变量及数组初始化\n用 `=`, `()` 和 `{}` 均可。请务必小心列表初始化 `{...}`。 \n\n### 14. 预处理指令\n预处理指令不要缩进, 从行首开始。即使预处理指令位于缩进代码块中, 指令也应从行首开始.\n````C++\n// 可 - directives at beginning of line\nif (lopsided_score) {\n#if DISASTER_PENDING      // 正确 -- 行开头起。\n  DropEverything();\n#endif\n  BackToNormal();\n}````\n\n### 15. 类格式\n访问控制块的声明依次序是 `public:`, `protected:`, `private:`, 每次缩进 1 个空格.\n类声明 (对类注释不了解的话, 参考 类注释) 的基本格式如下:\n````C++\nclass MyClass : public OtherClass {\n public:      // 注意有 1 空格缩进!\n  MyClass();  // 照常，2 空格缩进。\n  explicit MyClass(int var);\n  ~MyClass() {}\n\n  void SomeFunction();\n  void SomeFunctionThatDoesNothing() {\n  }\n\n  void set_some_var(int var) { some_var_ = var; }\n  int some_var() const { return some_var_; }\n\n private:\n  bool SomeInternalFunction();\n\n  int some_var_;\n  int some_other_var_;\n  DISALLOW_COPY_AND_ASSIGN(MyClass);\n};````\n注意事项:\n\n * 所有基类名应在 80 列限制下尽量与子类名放在同一行.\n * 关键词 public:, protected:, private: 要缩进 1 个空格.\n * 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.\n * 这些关键词后不要保留空行.\n * public 放在最前面, 然后是 protected, 最后是 private.\n\n### 16. 构造函数初始值列表\n构造函数初始值列表放在同一行或按四格缩进并排几行.\n\n### 17. 名字空间格式化\n名字空间 不要增加额外的缩进层次,\n\n### 18. 水平留白\n水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.\n * 常规\n     * 左大括号前恒有空格。\n     * 分号前不加空格。\n     * 大括号内部可与空格紧邻也不可，不过两边都要加上。\n     * 继承与初始化列表中的冒号前后恒有空格。\n     * 内联函数实现，在大括号内部加上空格并编写实现。\n     * 大括号里面是空的话，不加空格。\n * 循环和条件语句\n     * if 条件语句和循环语句关键字后均有空格。\n     * 圆括号内部不紧邻空格。\n     * 循环和条件语句的圆括号里可以与空格紧邻。\n     * 循环里内 `;` 后恒有空格，`；` 前可以加个空格。\n     * `switch` `case` 的冒号前无空格。\n * 操作符:\n     *  赋值操作系统前后恒有空格。\n     *  其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。\n     *  圆括号内部不紧邻空格。\n     *  在参数和一元操作符之间不加空格。\n * 模板和转换:\n     *  尖叫括号(< and >) 不与空格紧邻，< 前没有空格，>( 之间也没有。\n     *  在类型与指针操作符之间留空格也可以，但要保持一致。\n     *  您或许可以在 < < 里加上一对对称的空格。\n\n### 19. 垂直留白\n垂直留白越少越好.\n这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. \n * 两个函数定义之间的空行不要超过 2 行\n * 函数体首尾不要留空行, 函数体中也不要随意添加空行.\n * 函数体内开头或结尾的空行可读性微乎其微。\n * 在多重 if-else 块里加空行或许有点可读性。\n","source":"_posts/Google-C-Style-Guide.md","raw":"---\ntitle: Google C++ Style Guide\ndate: 2016-12-02 15:57:09\ncategories: 学习记录\ntags: [Google, C++, Code Style]\n---\n\n最近把 Google C++ Style Guide 从头到尾看了一遍，把相应的内容记录在这里，也规范下以后自己的代码。  \n\n<!--more-->\n![Google C++ Style Guide](http://ogf054qp1.bkt.clouddn.com/Google%20C++%20Style%20Guide.png)\n\n## Header Files\n通常每一个 `.cpp` 文件都应该有一个对应的 `.h` 头文件，对于一个头文件来说（1）需要**Self-contained**，即一个头文件应该有相应的**#define 保护**、并包含所有他需要的其它头文件；（2）尽量应使用头文件而不是**前置声明**；（3）不能滥用**内联函数**只在函数少于10行的时候才使用内联函数；（4）使用标准的**头文件包含顺序**来增强可读性，避免隐藏依赖。  \n* #define保护的格式为 `#define <PROJECT>_<PATH>_<FILE>_H_`\n* 头文件的包含顺序应该为：\n  1. 优先位置，当前文件需要实现或测试的头文件\n  2. C 系统文件\n  3. C++ 系统文件\n  4. 其他库的 .h 文件\n  5. 本项目内 .h 文件\n\n## Scoping\n作用域主要规范了 `名称空间 `、`非成员函数`、`静态成员函数`、`全局函数`、`局部变量`、`静态和全局变量` 的使用规范：\n* 名称空间\n  * 推荐在 `.cpp` 文件中使用匿名名称空间\n  * 不能在 `.h` 文件中使用匿名名称空间\n  * 不要在名称空间 `std` 内声明任何东西\n  * 不要使用 `using` 包含整个命名空间\n  * 不要使用内联命名空间\n  * 可以使用 `using` 声明\n  * 可以使用名称空间别名\n* 使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数。\n* 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。\n* 禁止使用 `class` 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 `constexpr` 变量除外，毕竟它们又不涉及动态初始化或析构。\n\n## Classes\n在使用类的时候应遵循以下规则：\n* 不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化)。\n* 对单个参数的构造函数使用 C++ 关键字 `explicit`.不要定义隐式转换。\n* 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用。\n* 仅当只有数据时使用 `struct`, 其它一概使用 `class`。\n* 使用组合 (`composition`) 常常比使用继承更合理. 如果使用继承的话, 定义为 `public` 继承。\n* 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 `Interface` 为后缀的 纯接口类。\n* 接口是指满足特定条件的类, 这些类以 `Interface` 为后缀 (不强制)。\n* 除少数特定环境外，不要重载运算符。\n* 将所有数据成员声明为 `private`, 并根据需要提供相应的存取函数，一般在头文件中把存取函数定义成内联函数。\n* 在类中使用特定的声明顺序: `public` 在 `private` 之前, 成员函数在数据成员 (变量) 前;  \n  每个区段内的声明通常按以下顺序:\n  1. `typedefs` 和枚举\n  2. 常量\n  3. 构造函数\n  4. 析构函数\n  5. 成员函数, 含静态成员函数\n  6. 数据成员, 含静态数据成员\n  友元声明应该放在 `private` 区段. 如果用宏 `DISALLOW_COPY_AND_ASSIGN` 禁用拷贝和赋值, 应当将其置于 `private` 区段的末尾, 也即整个类声明的末尾.  \n\n* `.cc` 文件中函数的定义应尽可能和声明顺序一致。\n\n## Functions\n在定义函数时，参数顺序应该是：**先输入，后输出**。所有按引用传递的参数必须加上 `const` 。倾向编写简短, 凝练的函数，**函数一般不应超过40行**。**重载函数**时最好在函数名里加入参数信息。除以下情况，最好不要使用缺省参数：\n* 其一，位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。\n* 其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。\n* 其三，可以用来模拟变长数组。\n\n## Other C++ Features\nGoogle设定的C++的新特性规范有很多，从中选取了以下几条：\n* `Casting` 使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;\n\n* `Streams` 只在记录日志时使用流.\n\n* `Preincrement and Predecrement` 对于迭代器和其他模板对象使用前缀形式 (`++i`) 的自增, 自减运算符.\n\n* `Use of const` `const` 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误。在任何可能的情况下使用 const:\n  * 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const.\n  * 尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const.\n  * 如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.\n\n* `Use of constexpr` 在 C++11 里，用 `constexpr` 来定义真正的常量，或实现常量初始化。\n \n* `Integer Types` C++ 内建整型中, 仅使用`int`。在需要确保整型大小时, 可以使用 `<stdint.h>` 中长度精确的整型。\n\n* `Preprocessor Macros` 如果要使用宏, 尽可能遵守:\n  * 不要在 .h 文件中定义宏.\n  * 在马上要使用时才进行 #define, 使用后要立即 #undef.\n  * 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；\n  * 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.\n  * 不要用 ## 处理函数，类和变量的名字。\n\n\n* `nullptr/NULL/0` 整数用 `0`, 实数用 `0.0`, 指针用 `nullptr` 或 `NUL`, 字符 (串) 用 `'\\0'`.\n\n* `sizeof` 尽可能用 sizeof(varname) 代替 sizeof(type).\n\n* `auto` 用 `auto` 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。\n\n## Naming\n命名的一致性是规则代码最鲜明的体现，规则的命名可以快速的让阅读者获知名字代表的是函数还是类型还是常量，命名需要遵守的最基本的原则是`要有描述性；少用缩写`。对不同的类型，以不同的方式进行命名，规则如下：\n* **文件名**要全部小写, 可以包含下划线 (`_`) 或连字符 (`-`)。`_` 更好：`my_useful_class.cc`。\n* **类型名称**（类, 结构体, 类型定义 (typedef), 枚举）的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`。\n* **变量名**一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`。\n* **在全局或类里的常量**名称前加 `k`: `kDaysInAWeek`。且除去开头的 k 之外每个单词开头字母均大写。\n* **常规函数**使用大小写混合, **取值和设值函数**则要求与变量名匹配: `MyExcitingFunction()`, `MyExcitingMethod()`, `my_exciting_member_variable()`, `set_my_exciting_member_variable()`。\n* **名字空间**用小写字母命名, 并基于项目名称和目录结构: `google_awesome_project`。\n* **枚举**的命名应当和**常量**或**宏**一致: `kEnumName` 或是 `ENUM_NAME`。\n* 如果你一定要用**宏**, 像这样命名: `MY_MACRO_THAT_SCARES_SMALL_CHILDREN`。\n\n## Comments\n注释虽然写起来很痛苦, 但对保证代码可读性至关重要。但同时需要记住的是: 注释固然很重要, 但`最好的代码本身应该是自文档化`。有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字。注释主要有以下7类：\n\n### 1. 文件注释   \n在每一个文件开头加入版权公告, 然后是文件内容描述。每个文件都应该包含以下项, 依次是:\n\n * 版权声明 (比如, `Copyright 2008 Google Inc.`)\n * 许可证. 为项目选择合适的许可证版本 (比如, `Apache 2.0`, `BSD`, `LGPL`, `GPL`)\n * 作者: 标识文件的原始作者.\n * 文件内容:紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容。\n   通常, `.h` 文件要对所声明的类的功能和用法作简单说明. `.cc` 文件通常包含了更多的实现细节或算法技巧讨论。\n\n### 2. 类注释  \n每个类的定义都要附带一份注释, 描述类的功能和用法.\n\n### 3. 函数注释  \n函数声明处注释描述函数功能; 定义处描述函数实现.\n\n * 函数声明:  \n    * 函数的输入输出.\n    * 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.\n    * 如果函数分配了空间, 需要由调用者释放.\n    * 参数是否可以为 NULL.\n    * 是否存在函数使用上的性能隐患.\n    * 如果函数是可重入的, 其同步前提是什么?\n\n * 函数定义:  \n  每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.\n\n### 4. 变量注释  \n通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.\n * 类数据成员:每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明。\n * 全局变量:和数据成员一样, 所有全局变量也要注释说明含义及用途。\n\n### 5. 实现注释\n对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释。\n * 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释。\n * 如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性。\n * 向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意。\n * **永远不要**用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意。\n\n### 6. `TODO` 注释  \n对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 `TODO` 注释。\n`TODO` 注释要使用全大写的字符串 `TODO`, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 `TODO` 格式进行查找. 添加 `TODO` 注释并不意味着你要自己来修正。\n\n### 7. 弃用注释\n通过弃用注释（`DEPRECATED comments`）以标记某接口点（`interface points`）已弃用。\n\n## Formatting\n代码风格和格式是一个比较个人化的问题, 但整个项目(或一个人的所有项目)服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码。\n\n### 1. 行长度\n每一行代码字符数不超过 80.\n\n### 2. 非 `ASCII` 字符\n尽量不使用非 `ASCII` 字符, 使用时必须使用 `UTF-8` 编码.\n\n### 3. 空格还是制表位\n只使用空格, 每次缩进 2 个空格.\n\n### 4. 函数声明与定义\n返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。\n注意以下几点:\n\n * 如果返回类型和函数名在一行放不下，分行。\n * 如果返回类型那个与函数声明或定义分行了，不要缩进。\n * 左圆括号总是和函数名在同一行;\n * 函数名和左圆括号间没有空格;\n * 圆括号与参数间没有空格;\n * 左大括号总在最后一个参数同一行的末尾处;\n * 如果其它风格规则允许的话，右大括号总是单独位于函数最后一行，或者与左大括号同一行。\n * 右大括号和左大括号间总是有一个空格;\n * 函数声明和定义中的所有形参必须有命名且一致;\n * 所有形参应尽可能对齐;\n * 缺省缩进为 2 个空格;\n * 换行后的参数保持 4 个空格的缩进;\n\n### 5. `Lambda` 表达式\n其它函数怎么格式化形参和函数体，`Lambda` 表达式就怎么格式化；捕获列表同理。\n\n### 6. 函数调用\n要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。函数调用遵循如下形式：\n\n * 如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：\n * 参数也可以放在次行，缩进四格：\n * 把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：\n * 如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给函数,或者放着不管，补充上注释：\n * 如果某参数独立成行，对可读性更有帮助的话，就这么办。\n * 此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：\n\n### 7. 列表初始化格式\n您平时怎么格式化函数调用，就怎么格式化。\n\n### 8. 条件语句\n倾向于不在圆括号内使用空格. 关键字 `if` 和 `else` 另起一行.\n对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有。只要其中一个分支用了大括号，所有分支都要用上大括号。\n````C++\nif (condition) {  圆括号里没空格紧邻。\n  ...  // 2 空格缩进。\n} else {  // else 与 if 的右括号同一行。\n  ...\n}````\n\n### 9. 循环和开关选择语句\n`switch` 语句可以使用大括号分段，以表明 `cases` 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 `{}` 或 `continue`.\n````C++\nswitch (var) {\n  case 0: {  // 2 空格缩进\n    ...      // 4 空格缩进\n    break;\n  }\n  case 1: {\n    ...\n    break;\n  }\n  default: {\n    assert(false);\n  }\n}````\n在单语句循环里，括号可用可不用：\n````C++\nfor (int i = 0; i < kSomeNumber; ++i)\n  printf(\"I love you\\n\");\n\nfor (int i = 0; i < kSomeNumber; ++i) {\n  printf(\"I take it back\\n\");\n}````\n空循环体应使用 `{}` 或 `continue`, 而不是一个简单的分号.\n````C++\nwhile (condition) {\n// 反复循环直到条件失效。\n}\nfor (int i = 0; i < kSomeNumber; ++i) {}  // 可 - 空循环体。\nwhile (condition) continue;  // 可 - contunue 表明没有逻辑。\n````\n### 10. 指针和引用表达式\n句点或箭头前后不要有空格. 指针/地址操作符 (`*`, `&`) 之后不能有空格.\n下面是指针和引用表达式的正确使用范例:\n````C++\nx = *p;\np = &x;\nx = r.y;\nx = r->y;\n````\n### 11. 布尔表达式\n如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.\n下例中, 逻辑与 (`&&`) 操作符总位于行尾:\n````C++\nif (this_one_thing > this_other_thing &&\n  a_third_thing == a_fourth_thing &&\n  yet_another & last_one) {\n...\n}````\n    \n### 12. 函数返回值\n`return` 表达式里时没必要都用圆括号，变量返回时不要使用圆括号，可以用圆括号把复杂表达式圈起来，改善可读性。\n\n### 13. 变量及数组初始化\n用 `=`, `()` 和 `{}` 均可。请务必小心列表初始化 `{...}`。 \n\n### 14. 预处理指令\n预处理指令不要缩进, 从行首开始。即使预处理指令位于缩进代码块中, 指令也应从行首开始.\n````C++\n// 可 - directives at beginning of line\nif (lopsided_score) {\n#if DISASTER_PENDING      // 正确 -- 行开头起。\n  DropEverything();\n#endif\n  BackToNormal();\n}````\n\n### 15. 类格式\n访问控制块的声明依次序是 `public:`, `protected:`, `private:`, 每次缩进 1 个空格.\n类声明 (对类注释不了解的话, 参考 类注释) 的基本格式如下:\n````C++\nclass MyClass : public OtherClass {\n public:      // 注意有 1 空格缩进!\n  MyClass();  // 照常，2 空格缩进。\n  explicit MyClass(int var);\n  ~MyClass() {}\n\n  void SomeFunction();\n  void SomeFunctionThatDoesNothing() {\n  }\n\n  void set_some_var(int var) { some_var_ = var; }\n  int some_var() const { return some_var_; }\n\n private:\n  bool SomeInternalFunction();\n\n  int some_var_;\n  int some_other_var_;\n  DISALLOW_COPY_AND_ASSIGN(MyClass);\n};````\n注意事项:\n\n * 所有基类名应在 80 列限制下尽量与子类名放在同一行.\n * 关键词 public:, protected:, private: 要缩进 1 个空格.\n * 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.\n * 这些关键词后不要保留空行.\n * public 放在最前面, 然后是 protected, 最后是 private.\n\n### 16. 构造函数初始值列表\n构造函数初始值列表放在同一行或按四格缩进并排几行.\n\n### 17. 名字空间格式化\n名字空间 不要增加额外的缩进层次,\n\n### 18. 水平留白\n水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.\n * 常规\n     * 左大括号前恒有空格。\n     * 分号前不加空格。\n     * 大括号内部可与空格紧邻也不可，不过两边都要加上。\n     * 继承与初始化列表中的冒号前后恒有空格。\n     * 内联函数实现，在大括号内部加上空格并编写实现。\n     * 大括号里面是空的话，不加空格。\n * 循环和条件语句\n     * if 条件语句和循环语句关键字后均有空格。\n     * 圆括号内部不紧邻空格。\n     * 循环和条件语句的圆括号里可以与空格紧邻。\n     * 循环里内 `;` 后恒有空格，`；` 前可以加个空格。\n     * `switch` `case` 的冒号前无空格。\n * 操作符:\n     *  赋值操作系统前后恒有空格。\n     *  其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。\n     *  圆括号内部不紧邻空格。\n     *  在参数和一元操作符之间不加空格。\n * 模板和转换:\n     *  尖叫括号(< and >) 不与空格紧邻，< 前没有空格，>( 之间也没有。\n     *  在类型与指针操作符之间留空格也可以，但要保持一致。\n     *  您或许可以在 < < 里加上一对对称的空格。\n\n### 19. 垂直留白\n垂直留白越少越好.\n这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. \n * 两个函数定义之间的空行不要超过 2 行\n * 函数体首尾不要留空行, 函数体中也不要随意添加空行.\n * 函数体内开头或结尾的空行可读性微乎其微。\n * 在多重 if-else 块里加空行或许有点可读性。\n","slug":"Google-C-Style-Guide","published":1,"updated":"2017-12-06T13:36:09.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n09000nbkw1bo50lw2c","content":"<p>最近把 Google C++ Style Guide 从头到尾看了一遍，把相应的内容记录在这里，也规范下以后自己的代码。  </p>\n<a id=\"more\"></a>\n<p><img src=\"http://ogf054qp1.bkt.clouddn.com/Google%20C++%20Style%20Guide.png\" alt=\"Google C++ Style Guide\"></p>\n<h2 id=\"Header-Files\"><a href=\"#Header-Files\" class=\"headerlink\" title=\"Header Files\"></a>Header Files</h2><p>通常每一个 <code>.cpp</code> 文件都应该有一个对应的 <code>.h</code> 头文件，对于一个头文件来说（1）需要<strong>Self-contained</strong>，即一个头文件应该有相应的<strong>#define 保护</strong>、并包含所有他需要的其它头文件；（2）尽量应使用头文件而不是<strong>前置声明</strong>；（3）不能滥用<strong>内联函数</strong>只在函数少于10行的时候才使用内联函数；（4）使用标准的<strong>头文件包含顺序</strong>来增强可读性，避免隐藏依赖。  </p>\n<ul>\n<li>#define保护的格式为 <code>#define &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code></li>\n<li>头文件的包含顺序应该为：<ol>\n<li>优先位置，当前文件需要实现或测试的头文件</li>\n<li>C 系统文件</li>\n<li>C++ 系统文件</li>\n<li>其他库的 .h 文件</li>\n<li>本项目内 .h 文件</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Scoping\"><a href=\"#Scoping\" class=\"headerlink\" title=\"Scoping\"></a>Scoping</h2><p>作用域主要规范了 <code>名称空间</code>、<code>非成员函数</code>、<code>静态成员函数</code>、<code>全局函数</code>、<code>局部变量</code>、<code>静态和全局变量</code> 的使用规范：</p>\n<ul>\n<li>名称空间<ul>\n<li>推荐在 <code>.cpp</code> 文件中使用匿名名称空间</li>\n<li>不能在 <code>.h</code> 文件中使用匿名名称空间</li>\n<li>不要在名称空间 <code>std</code> 内声明任何东西</li>\n<li>不要使用 <code>using</code> 包含整个命名空间</li>\n<li>不要使用内联命名空间</li>\n<li>可以使用 <code>using</code> 声明</li>\n<li>可以使用名称空间别名</li>\n</ul>\n</li>\n<li>使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数。</li>\n<li>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。</li>\n<li>禁止使用 <code>class</code> 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</li>\n</ul>\n<h2 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h2><p>在使用类的时候应遵循以下规则：</p>\n<ul>\n<li>不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化)。</li>\n<li>对单个参数的构造函数使用 C++ 关键字 <code>explicit</code>.不要定义隐式转换。</li>\n<li>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用。</li>\n<li>仅当只有数据时使用 <code>struct</code>, 其它一概使用 <code>class</code>。</li>\n<li>使用组合 (<code>composition</code>) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承。</li>\n<li>只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code> 为后缀的 纯接口类。</li>\n<li>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀 (不强制)。</li>\n<li>除少数特定环境外，不要重载运算符。</li>\n<li>将所有数据成员声明为 <code>private</code>, 并根据需要提供相应的存取函数，一般在头文件中把存取函数定义成内联函数。</li>\n<li><p>在类中使用特定的声明顺序: <code>public</code> 在 <code>private</code> 之前, 成员函数在数据成员 (变量) 前;<br>每个区段内的声明通常按以下顺序:</p>\n<ol>\n<li><code>typedefs</code> 和枚举</li>\n<li>常量</li>\n<li>构造函数</li>\n<li>析构函数</li>\n<li>成员函数, 含静态成员函数</li>\n<li>数据成员, 含静态数据成员<br>友元声明应该放在 <code>private</code> 区段. 如果用宏 <code>DISALLOW_COPY_AND_ASSIGN</code> 禁用拷贝和赋值, 应当将其置于 <code>private</code> 区段的末尾, 也即整个类声明的末尾.  </li>\n</ol>\n</li>\n<li><p><code>.cc</code> 文件中函数的定义应尽可能和声明顺序一致。</p>\n</li>\n</ul>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><p>在定义函数时，参数顺序应该是：<strong>先输入，后输出</strong>。所有按引用传递的参数必须加上 <code>const</code> 。倾向编写简短, 凝练的函数，<strong>函数一般不应超过40行</strong>。<strong>重载函数</strong>时最好在函数名里加入参数信息。除以下情况，最好不要使用缺省参数：</p>\n<ul>\n<li>其一，位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</li>\n<li>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</li>\n<li>其三，可以用来模拟变长数组。</li>\n</ul>\n<h2 id=\"Other-C-Features\"><a href=\"#Other-C-Features\" class=\"headerlink\" title=\"Other C++ Features\"></a>Other C++ Features</h2><p>Google设定的C++的新特性规范有很多，从中选取了以下几条：</p>\n<ul>\n<li><p><code>Casting</code> 使用 C++ 的类型转换, 如 static_cast&lt;&gt;(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;</p>\n</li>\n<li><p><code>Streams</code> 只在记录日志时使用流.</p>\n</li>\n<li><p><code>Preincrement and Predecrement</code> 对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p>\n</li>\n<li><p><code>Use of const</code> <code>const</code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误。在任何可能的情况下使用 const:</p>\n<ul>\n<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const.</li>\n<li>尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const.</li>\n<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.</li>\n</ul>\n</li>\n<li><p><code>Use of constexpr</code> 在 C++11 里，用 <code>constexpr</code> 来定义真正的常量，或实现常量初始化。</p>\n</li>\n<li><p><code>Integer Types</code> C++ 内建整型中, 仅使用<code>int</code>。在需要确保整型大小时, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型。</p>\n</li>\n<li><p><code>Preprocessor Macros</code> 如果要使用宏, 尽可能遵守:</p>\n<ul>\n<li>不要在 .h 文件中定义宏.</li>\n<li>在马上要使用时才进行 #define, 使用后要立即 #undef.</li>\n<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>\n<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>\n<li>不要用 ## 处理函数，类和变量的名字。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>nullptr/NULL/0</code> 整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NUL</code>, 字符 (串) 用 <code>&#39;\\0&#39;</code>.</p>\n</li>\n<li><p><code>sizeof</code> 尽可能用 sizeof(varname) 代替 sizeof(type).</p>\n</li>\n<li><p><code>auto</code> 用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>\n</li>\n</ul>\n<h2 id=\"Naming\"><a href=\"#Naming\" class=\"headerlink\" title=\"Naming\"></a>Naming</h2><p>命名的一致性是规则代码最鲜明的体现，规则的命名可以快速的让阅读者获知名字代表的是函数还是类型还是常量，命名需要遵守的最基本的原则是<code>要有描述性；少用缩写</code>。对不同的类型，以不同的方式进行命名，规则如下：</p>\n<ul>\n<li><strong>文件名</strong>要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>)。<code>_</code> 更好：<code>my_useful_class.cc</code>。</li>\n<li><strong>类型名称</strong>（类, 结构体, 类型定义 (typedef), 枚举）的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>。</li>\n<li><strong>变量名</strong>一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>。</li>\n<li><strong>在全局或类里的常量</strong>名称前加 <code>k</code>: <code>kDaysInAWeek</code>。且除去开头的 k 之外每个单词开头字母均大写。</li>\n<li><strong>常规函数</strong>使用大小写混合, <strong>取值和设值函数</strong>则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>。</li>\n<li><strong>名字空间</strong>用小写字母命名, 并基于项目名称和目录结构: <code>google_awesome_project</code>。</li>\n<li><strong>枚举</strong>的命名应当和<strong>常量</strong>或<strong>宏</strong>一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>。</li>\n<li>如果你一定要用<strong>宏</strong>, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>。</li>\n</ul>\n<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要。但同时需要记住的是: 注释固然很重要, 但<code>最好的代码本身应该是自文档化</code>。有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字。注释主要有以下7类：</p>\n<h3 id=\"1-文件注释\"><a href=\"#1-文件注释\" class=\"headerlink\" title=\"1. 文件注释\"></a>1. 文件注释</h3><p>在每一个文件开头加入版权公告, 然后是文件内容描述。每个文件都应该包含以下项, 依次是:</p>\n<ul>\n<li>版权声明 (比如, <code>Copyright 2008 Google Inc.</code>)</li>\n<li>许可证. 为项目选择合适的许可证版本 (比如, <code>Apache 2.0</code>, <code>BSD</code>, <code>LGPL</code>, <code>GPL</code>)</li>\n<li>作者: 标识文件的原始作者.</li>\n<li>文件内容:紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容。<br>通常, <code>.h</code> 文件要对所声明的类的功能和用法作简单说明. <code>.cc</code> 文件通常包含了更多的实现细节或算法技巧讨论。</li>\n</ul>\n<h3 id=\"2-类注释\"><a href=\"#2-类注释\" class=\"headerlink\" title=\"2. 类注释\"></a>2. 类注释</h3><p>每个类的定义都要附带一份注释, 描述类的功能和用法.</p>\n<h3 id=\"3-函数注释\"><a href=\"#3-函数注释\" class=\"headerlink\" title=\"3. 函数注释\"></a>3. 函数注释</h3><p>函数声明处注释描述函数功能; 定义处描述函数实现.</p>\n<ul>\n<li><p>函数声明:  </p>\n<ul>\n<li>函数的输入输出.</li>\n<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>\n<li>如果函数分配了空间, 需要由调用者释放.</li>\n<li>参数是否可以为 NULL.</li>\n<li>是否存在函数使用上的性能隐患.</li>\n<li>如果函数是可重入的, 其同步前提是什么?</li>\n</ul>\n</li>\n<li><p>函数定义:<br>每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.</p>\n</li>\n</ul>\n<h3 id=\"4-变量注释\"><a href=\"#4-变量注释\" class=\"headerlink\" title=\"4. 变量注释\"></a>4. 变量注释</h3><p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>\n<ul>\n<li>类数据成员:每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明。</li>\n<li>全局变量:和数据成员一样, 所有全局变量也要注释说明含义及用途。</li>\n</ul>\n<h3 id=\"5-实现注释\"><a href=\"#5-实现注释\" class=\"headerlink\" title=\"5. 实现注释\"></a>5. 实现注释</h3><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释。</p>\n<ul>\n<li>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释。</li>\n<li>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性。</li>\n<li>向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意。</li>\n<li><strong>永远不要</strong>用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意。</li>\n</ul>\n<h3 id=\"6-TODO-注释\"><a href=\"#6-TODO-注释\" class=\"headerlink\" title=\"6. TODO 注释\"></a>6. <code>TODO</code> 注释</h3><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释。<br><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正。</p>\n<h3 id=\"7-弃用注释\"><a href=\"#7-弃用注释\" class=\"headerlink\" title=\"7. 弃用注释\"></a>7. 弃用注释</h3><p>通过弃用注释（<code>DEPRECATED comments</code>）以标记某接口点（<code>interface points</code>）已弃用。</p>\n<h2 id=\"Formatting\"><a href=\"#Formatting\" class=\"headerlink\" title=\"Formatting\"></a>Formatting</h2><p>代码风格和格式是一个比较个人化的问题, 但整个项目(或一个人的所有项目)服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码。</p>\n<h3 id=\"1-行长度\"><a href=\"#1-行长度\" class=\"headerlink\" title=\"1. 行长度\"></a>1. 行长度</h3><p>每一行代码字符数不超过 80.</p>\n<h3 id=\"2-非-ASCII-字符\"><a href=\"#2-非-ASCII-字符\" class=\"headerlink\" title=\"2. 非 ASCII 字符\"></a>2. 非 <code>ASCII</code> 字符</h3><p>尽量不使用非 <code>ASCII</code> 字符, 使用时必须使用 <code>UTF-8</code> 编码.</p>\n<h3 id=\"3-空格还是制表位\"><a href=\"#3-空格还是制表位\" class=\"headerlink\" title=\"3. 空格还是制表位\"></a>3. 空格还是制表位</h3><p>只使用空格, 每次缩进 2 个空格.</p>\n<h3 id=\"4-函数声明与定义\"><a href=\"#4-函数声明与定义\" class=\"headerlink\" title=\"4. 函数声明与定义\"></a>4. 函数声明与定义</h3><p>返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。<br>注意以下几点:</p>\n<ul>\n<li>如果返回类型和函数名在一行放不下，分行。</li>\n<li>如果返回类型那个与函数声明或定义分行了，不要缩进。</li>\n<li>左圆括号总是和函数名在同一行;</li>\n<li>函数名和左圆括号间没有空格;</li>\n<li>圆括号与参数间没有空格;</li>\n<li>左大括号总在最后一个参数同一行的末尾处;</li>\n<li>如果其它风格规则允许的话，右大括号总是单独位于函数最后一行，或者与左大括号同一行。</li>\n<li>右大括号和左大括号间总是有一个空格;</li>\n<li>函数声明和定义中的所有形参必须有命名且一致;</li>\n<li>所有形参应尽可能对齐;</li>\n<li>缺省缩进为 2 个空格;</li>\n<li>换行后的参数保持 4 个空格的缩进;</li>\n</ul>\n<h3 id=\"5-Lambda-表达式\"><a href=\"#5-Lambda-表达式\" class=\"headerlink\" title=\"5. Lambda 表达式\"></a>5. <code>Lambda</code> 表达式</h3><p>其它函数怎么格式化形参和函数体，<code>Lambda</code> 表达式就怎么格式化；捕获列表同理。</p>\n<h3 id=\"6-函数调用\"><a href=\"#6-函数调用\" class=\"headerlink\" title=\"6. 函数调用\"></a>6. 函数调用</h3><p>要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。函数调用遵循如下形式：</p>\n<ul>\n<li>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</li>\n<li>参数也可以放在次行，缩进四格：</li>\n<li>把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：</li>\n<li>如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给函数,或者放着不管，补充上注释：</li>\n<li>如果某参数独立成行，对可读性更有帮助的话，就这么办。</li>\n<li>此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：</li>\n</ul>\n<h3 id=\"7-列表初始化格式\"><a href=\"#7-列表初始化格式\" class=\"headerlink\" title=\"7. 列表初始化格式\"></a>7. 列表初始化格式</h3><p>您平时怎么格式化函数调用，就怎么格式化。</p>\n<h3 id=\"8-条件语句\"><a href=\"#8-条件语句\" class=\"headerlink\" title=\"8. 条件语句\"></a>8. 条件语句</h3><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.<br>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有。只要其中一个分支用了大括号，所有分支都要用上大括号。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;  圆括号里没空格紧邻。</div><div class=\"line\">  ...  <span class=\"comment\">// 2 空格缩进。</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// else 与 if 的右括号同一行。</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"9-循环和开关选择语句\"><a href=\"#9-循环和开关选择语句\" class=\"headerlink\" title=\"9. 循环和开关选择语句\"></a>9. 循环和开关选择语句</h3><p><code>switch</code> 语句可以使用大括号分段，以表明 <code>cases</code> 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 <code>{}</code> 或 <code>continue</code>.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> (var) &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>: &#123;  <span class=\"comment\">// 2 空格缩进</span></div><div class=\"line\">    ...      <span class=\"comment\">// 4 空格缩进</span></div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">default</span>: &#123;</div><div class=\"line\">    assert(<span class=\"literal\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在单语句循环里，括号可用可不用：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kSomeNumber; ++i)</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"I love you\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kSomeNumber; ++i) &#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"I take it back\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>空循环体应使用 <code>{}</code> 或 <code>continue</code>, 而不是一个简单的分号.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (condition) &#123;</div><div class=\"line\"><span class=\"comment\">// 反复循环直到条件失效。</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class=\"comment\">// 可 - 空循环体。</span></div><div class=\"line\"><span class=\"keyword\">while</span> (condition) <span class=\"keyword\">continue</span>;  <span class=\"comment\">// 可 - contunue 表明没有逻辑。</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"10-指针和引用表达式\"><a href=\"#10-指针和引用表达式\" class=\"headerlink\" title=\"10. 指针和引用表达式\"></a>10. 指针和引用表达式</h3><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*</code>, <code>&amp;</code>) 之后不能有空格.<br>下面是指针和引用表达式的正确使用范例:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = *p;</div><div class=\"line\">p = &amp;x;</div><div class=\"line\">x = r.y;</div><div class=\"line\">x = r-&gt;y;</div></pre></td></tr></table></figure></p>\n<h3 id=\"11-布尔表达式\"><a href=\"#11-布尔表达式\" class=\"headerlink\" title=\"11. 布尔表达式\"></a>11. 布尔表达式</h3><p>如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.<br>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</div><div class=\"line\">  a_third_thing == a_fourth_thing &amp;&amp;</div><div class=\"line\">  yet_another &amp; last_one) &#123;</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"12-函数返回值\"><a href=\"#12-函数返回值\" class=\"headerlink\" title=\"12. 函数返回值\"></a>12. 函数返回值</h3><p><code>return</code> 表达式里时没必要都用圆括号，变量返回时不要使用圆括号，可以用圆括号把复杂表达式圈起来，改善可读性。</p>\n<h3 id=\"13-变量及数组初始化\"><a href=\"#13-变量及数组初始化\" class=\"headerlink\" title=\"13. 变量及数组初始化\"></a>13. 变量及数组初始化</h3><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可。请务必小心列表初始化 <code>{...}</code>。 </p>\n<h3 id=\"14-预处理指令\"><a href=\"#14-预处理指令\" class=\"headerlink\" title=\"14. 预处理指令\"></a>14. 预处理指令</h3><p>预处理指令不要缩进, 从行首开始。即使预处理指令位于缩进代码块中, 指令也应从行首开始.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 可 - directives at beginning of line</span></div><div class=\"line\"><span class=\"keyword\">if</span> (lopsided_score) &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DISASTER_PENDING      <span class=\"comment\">// 正确 -- 行开头起。</span></span></div><div class=\"line\">  DropEverything();</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">  BackToNormal();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"15-类格式\"><a href=\"#15-类格式\" class=\"headerlink\" title=\"15. 类格式\"></a>15. 类格式</h3><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每次缩进 1 个空格.<br>类声明 (对类注释不了解的话, 参考 类注释) 的基本格式如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> MyClass : <span class=\"keyword\">public</span> OtherClass &#123;</div><div class=\"line\"> <span class=\"keyword\">public</span>:      <span class=\"comment\">// 注意有 1 空格缩进!</span></div><div class=\"line\">  MyClass();  <span class=\"comment\">// 照常，2 空格缩进。</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">MyClass</span><span class=\"params\">(<span class=\"keyword\">int</span> var)</span></span>;</div><div class=\"line\">  ~MyClass() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SomeFunction</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SomeFunctionThatDoesNothing</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_some_var</span><span class=\"params\">(<span class=\"keyword\">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">some_var</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> some_var_; &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">private</span>:</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SomeInternalFunction</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">int</span> some_var_;</div><div class=\"line\">  <span class=\"keyword\">int</span> some_other_var_;</div><div class=\"line\">  DISALLOW_COPY_AND_ASSIGN(MyClass);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>注意事项:</p>\n<ul>\n<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>\n<li>关键词 public:, protected:, private: 要缩进 1 个空格.</li>\n<li>除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>\n<li>这些关键词后不要保留空行.</li>\n<li>public 放在最前面, 然后是 protected, 最后是 private.</li>\n</ul>\n<h3 id=\"16-构造函数初始值列表\"><a href=\"#16-构造函数初始值列表\" class=\"headerlink\" title=\"16. 构造函数初始值列表\"></a>16. 构造函数初始值列表</h3><p>构造函数初始值列表放在同一行或按四格缩进并排几行.</p>\n<h3 id=\"17-名字空间格式化\"><a href=\"#17-名字空间格式化\" class=\"headerlink\" title=\"17. 名字空间格式化\"></a>17. 名字空间格式化</h3><p>名字空间 不要增加额外的缩进层次,</p>\n<h3 id=\"18-水平留白\"><a href=\"#18-水平留白\" class=\"headerlink\" title=\"18. 水平留白\"></a>18. 水平留白</h3><p>水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.</p>\n<ul>\n<li>常规<ul>\n<li>左大括号前恒有空格。</li>\n<li>分号前不加空格。</li>\n<li>大括号内部可与空格紧邻也不可，不过两边都要加上。</li>\n<li>继承与初始化列表中的冒号前后恒有空格。</li>\n<li>内联函数实现，在大括号内部加上空格并编写实现。</li>\n<li>大括号里面是空的话，不加空格。</li>\n</ul>\n</li>\n<li>循环和条件语句<ul>\n<li>if 条件语句和循环语句关键字后均有空格。</li>\n<li>圆括号内部不紧邻空格。</li>\n<li>循环和条件语句的圆括号里可以与空格紧邻。</li>\n<li>循环里内 <code>;</code> 后恒有空格，<code>；</code> 前可以加个空格。</li>\n<li><code>switch</code> <code>case</code> 的冒号前无空格。</li>\n</ul>\n</li>\n<li>操作符:<ul>\n<li>赋值操作系统前后恒有空格。</li>\n<li>其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。</li>\n<li>圆括号内部不紧邻空格。</li>\n<li>在参数和一元操作符之间不加空格。</li>\n</ul>\n</li>\n<li>模板和转换:<ul>\n<li>尖叫括号(&lt; and &gt;) 不与空格紧邻，&lt; 前没有空格，&gt;( 之间也没有。</li>\n<li>在类型与指针操作符之间留空格也可以，但要保持一致。</li>\n<li>您或许可以在 &lt; &lt; 里加上一对对称的空格。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"19-垂直留白\"><a href=\"#19-垂直留白\" class=\"headerlink\" title=\"19. 垂直留白\"></a>19. 垂直留白</h3><p>垂直留白越少越好.<br>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. </p>\n<ul>\n<li>两个函数定义之间的空行不要超过 2 行</li>\n<li>函数体首尾不要留空行, 函数体中也不要随意添加空行.</li>\n<li>函数体内开头或结尾的空行可读性微乎其微。</li>\n<li>在多重 if-else 块里加空行或许有点可读性。</li>\n</ul>\n","excerpt":"<p>最近把 Google C++ Style Guide 从头到尾看了一遍，把相应的内容记录在这里，也规范下以后自己的代码。  </p>","more":"<p><img src=\"http://ogf054qp1.bkt.clouddn.com/Google%20C++%20Style%20Guide.png\" alt=\"Google C++ Style Guide\"></p>\n<h2 id=\"Header-Files\"><a href=\"#Header-Files\" class=\"headerlink\" title=\"Header Files\"></a>Header Files</h2><p>通常每一个 <code>.cpp</code> 文件都应该有一个对应的 <code>.h</code> 头文件，对于一个头文件来说（1）需要<strong>Self-contained</strong>，即一个头文件应该有相应的<strong>#define 保护</strong>、并包含所有他需要的其它头文件；（2）尽量应使用头文件而不是<strong>前置声明</strong>；（3）不能滥用<strong>内联函数</strong>只在函数少于10行的时候才使用内联函数；（4）使用标准的<strong>头文件包含顺序</strong>来增强可读性，避免隐藏依赖。  </p>\n<ul>\n<li>#define保护的格式为 <code>#define &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code></li>\n<li>头文件的包含顺序应该为：<ol>\n<li>优先位置，当前文件需要实现或测试的头文件</li>\n<li>C 系统文件</li>\n<li>C++ 系统文件</li>\n<li>其他库的 .h 文件</li>\n<li>本项目内 .h 文件</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Scoping\"><a href=\"#Scoping\" class=\"headerlink\" title=\"Scoping\"></a>Scoping</h2><p>作用域主要规范了 <code>名称空间</code>、<code>非成员函数</code>、<code>静态成员函数</code>、<code>全局函数</code>、<code>局部变量</code>、<code>静态和全局变量</code> 的使用规范：</p>\n<ul>\n<li>名称空间<ul>\n<li>推荐在 <code>.cpp</code> 文件中使用匿名名称空间</li>\n<li>不能在 <code>.h</code> 文件中使用匿名名称空间</li>\n<li>不要在名称空间 <code>std</code> 内声明任何东西</li>\n<li>不要使用 <code>using</code> 包含整个命名空间</li>\n<li>不要使用内联命名空间</li>\n<li>可以使用 <code>using</code> 声明</li>\n<li>可以使用名称空间别名</li>\n</ul>\n</li>\n<li>使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数。</li>\n<li>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。</li>\n<li>禁止使用 <code>class</code> 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</li>\n</ul>\n<h2 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h2><p>在使用类的时候应遵循以下规则：</p>\n<ul>\n<li>不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化)。</li>\n<li>对单个参数的构造函数使用 C++ 关键字 <code>explicit</code>.不要定义隐式转换。</li>\n<li>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用。</li>\n<li>仅当只有数据时使用 <code>struct</code>, 其它一概使用 <code>class</code>。</li>\n<li>使用组合 (<code>composition</code>) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承。</li>\n<li>只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code> 为后缀的 纯接口类。</li>\n<li>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀 (不强制)。</li>\n<li>除少数特定环境外，不要重载运算符。</li>\n<li>将所有数据成员声明为 <code>private</code>, 并根据需要提供相应的存取函数，一般在头文件中把存取函数定义成内联函数。</li>\n<li><p>在类中使用特定的声明顺序: <code>public</code> 在 <code>private</code> 之前, 成员函数在数据成员 (变量) 前;<br>每个区段内的声明通常按以下顺序:</p>\n<ol>\n<li><code>typedefs</code> 和枚举</li>\n<li>常量</li>\n<li>构造函数</li>\n<li>析构函数</li>\n<li>成员函数, 含静态成员函数</li>\n<li>数据成员, 含静态数据成员<br>友元声明应该放在 <code>private</code> 区段. 如果用宏 <code>DISALLOW_COPY_AND_ASSIGN</code> 禁用拷贝和赋值, 应当将其置于 <code>private</code> 区段的末尾, 也即整个类声明的末尾.  </li>\n</ol>\n</li>\n<li><p><code>.cc</code> 文件中函数的定义应尽可能和声明顺序一致。</p>\n</li>\n</ul>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><p>在定义函数时，参数顺序应该是：<strong>先输入，后输出</strong>。所有按引用传递的参数必须加上 <code>const</code> 。倾向编写简短, 凝练的函数，<strong>函数一般不应超过40行</strong>。<strong>重载函数</strong>时最好在函数名里加入参数信息。除以下情况，最好不要使用缺省参数：</p>\n<ul>\n<li>其一，位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</li>\n<li>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</li>\n<li>其三，可以用来模拟变长数组。</li>\n</ul>\n<h2 id=\"Other-C-Features\"><a href=\"#Other-C-Features\" class=\"headerlink\" title=\"Other C++ Features\"></a>Other C++ Features</h2><p>Google设定的C++的新特性规范有很多，从中选取了以下几条：</p>\n<ul>\n<li><p><code>Casting</code> 使用 C++ 的类型转换, 如 static_cast&lt;&gt;(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;</p>\n</li>\n<li><p><code>Streams</code> 只在记录日志时使用流.</p>\n</li>\n<li><p><code>Preincrement and Predecrement</code> 对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p>\n</li>\n<li><p><code>Use of const</code> <code>const</code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误。在任何可能的情况下使用 const:</p>\n<ul>\n<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const.</li>\n<li>尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const.</li>\n<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.</li>\n</ul>\n</li>\n<li><p><code>Use of constexpr</code> 在 C++11 里，用 <code>constexpr</code> 来定义真正的常量，或实现常量初始化。</p>\n</li>\n<li><p><code>Integer Types</code> C++ 内建整型中, 仅使用<code>int</code>。在需要确保整型大小时, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型。</p>\n</li>\n<li><p><code>Preprocessor Macros</code> 如果要使用宏, 尽可能遵守:</p>\n<ul>\n<li>不要在 .h 文件中定义宏.</li>\n<li>在马上要使用时才进行 #define, 使用后要立即 #undef.</li>\n<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>\n<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>\n<li>不要用 ## 处理函数，类和变量的名字。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>nullptr/NULL/0</code> 整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NUL</code>, 字符 (串) 用 <code>&#39;\\0&#39;</code>.</p>\n</li>\n<li><p><code>sizeof</code> 尽可能用 sizeof(varname) 代替 sizeof(type).</p>\n</li>\n<li><p><code>auto</code> 用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>\n</li>\n</ul>\n<h2 id=\"Naming\"><a href=\"#Naming\" class=\"headerlink\" title=\"Naming\"></a>Naming</h2><p>命名的一致性是规则代码最鲜明的体现，规则的命名可以快速的让阅读者获知名字代表的是函数还是类型还是常量，命名需要遵守的最基本的原则是<code>要有描述性；少用缩写</code>。对不同的类型，以不同的方式进行命名，规则如下：</p>\n<ul>\n<li><strong>文件名</strong>要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>)。<code>_</code> 更好：<code>my_useful_class.cc</code>。</li>\n<li><strong>类型名称</strong>（类, 结构体, 类型定义 (typedef), 枚举）的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>。</li>\n<li><strong>变量名</strong>一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>。</li>\n<li><strong>在全局或类里的常量</strong>名称前加 <code>k</code>: <code>kDaysInAWeek</code>。且除去开头的 k 之外每个单词开头字母均大写。</li>\n<li><strong>常规函数</strong>使用大小写混合, <strong>取值和设值函数</strong>则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>。</li>\n<li><strong>名字空间</strong>用小写字母命名, 并基于项目名称和目录结构: <code>google_awesome_project</code>。</li>\n<li><strong>枚举</strong>的命名应当和<strong>常量</strong>或<strong>宏</strong>一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>。</li>\n<li>如果你一定要用<strong>宏</strong>, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>。</li>\n</ul>\n<h2 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要。但同时需要记住的是: 注释固然很重要, 但<code>最好的代码本身应该是自文档化</code>。有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字。注释主要有以下7类：</p>\n<h3 id=\"1-文件注释\"><a href=\"#1-文件注释\" class=\"headerlink\" title=\"1. 文件注释\"></a>1. 文件注释</h3><p>在每一个文件开头加入版权公告, 然后是文件内容描述。每个文件都应该包含以下项, 依次是:</p>\n<ul>\n<li>版权声明 (比如, <code>Copyright 2008 Google Inc.</code>)</li>\n<li>许可证. 为项目选择合适的许可证版本 (比如, <code>Apache 2.0</code>, <code>BSD</code>, <code>LGPL</code>, <code>GPL</code>)</li>\n<li>作者: 标识文件的原始作者.</li>\n<li>文件内容:紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容。<br>通常, <code>.h</code> 文件要对所声明的类的功能和用法作简单说明. <code>.cc</code> 文件通常包含了更多的实现细节或算法技巧讨论。</li>\n</ul>\n<h3 id=\"2-类注释\"><a href=\"#2-类注释\" class=\"headerlink\" title=\"2. 类注释\"></a>2. 类注释</h3><p>每个类的定义都要附带一份注释, 描述类的功能和用法.</p>\n<h3 id=\"3-函数注释\"><a href=\"#3-函数注释\" class=\"headerlink\" title=\"3. 函数注释\"></a>3. 函数注释</h3><p>函数声明处注释描述函数功能; 定义处描述函数实现.</p>\n<ul>\n<li><p>函数声明:  </p>\n<ul>\n<li>函数的输入输出.</li>\n<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>\n<li>如果函数分配了空间, 需要由调用者释放.</li>\n<li>参数是否可以为 NULL.</li>\n<li>是否存在函数使用上的性能隐患.</li>\n<li>如果函数是可重入的, 其同步前提是什么?</li>\n</ul>\n</li>\n<li><p>函数定义:<br>每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.</p>\n</li>\n</ul>\n<h3 id=\"4-变量注释\"><a href=\"#4-变量注释\" class=\"headerlink\" title=\"4. 变量注释\"></a>4. 变量注释</h3><p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>\n<ul>\n<li>类数据成员:每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明。</li>\n<li>全局变量:和数据成员一样, 所有全局变量也要注释说明含义及用途。</li>\n</ul>\n<h3 id=\"5-实现注释\"><a href=\"#5-实现注释\" class=\"headerlink\" title=\"5. 实现注释\"></a>5. 实现注释</h3><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释。</p>\n<ul>\n<li>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释。</li>\n<li>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性。</li>\n<li>向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意。</li>\n<li><strong>永远不要</strong>用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意。</li>\n</ul>\n<h3 id=\"6-TODO-注释\"><a href=\"#6-TODO-注释\" class=\"headerlink\" title=\"6. TODO 注释\"></a>6. <code>TODO</code> 注释</h3><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释。<br><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正。</p>\n<h3 id=\"7-弃用注释\"><a href=\"#7-弃用注释\" class=\"headerlink\" title=\"7. 弃用注释\"></a>7. 弃用注释</h3><p>通过弃用注释（<code>DEPRECATED comments</code>）以标记某接口点（<code>interface points</code>）已弃用。</p>\n<h2 id=\"Formatting\"><a href=\"#Formatting\" class=\"headerlink\" title=\"Formatting\"></a>Formatting</h2><p>代码风格和格式是一个比较个人化的问题, 但整个项目(或一个人的所有项目)服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码。</p>\n<h3 id=\"1-行长度\"><a href=\"#1-行长度\" class=\"headerlink\" title=\"1. 行长度\"></a>1. 行长度</h3><p>每一行代码字符数不超过 80.</p>\n<h3 id=\"2-非-ASCII-字符\"><a href=\"#2-非-ASCII-字符\" class=\"headerlink\" title=\"2. 非 ASCII 字符\"></a>2. 非 <code>ASCII</code> 字符</h3><p>尽量不使用非 <code>ASCII</code> 字符, 使用时必须使用 <code>UTF-8</code> 编码.</p>\n<h3 id=\"3-空格还是制表位\"><a href=\"#3-空格还是制表位\" class=\"headerlink\" title=\"3. 空格还是制表位\"></a>3. 空格还是制表位</h3><p>只使用空格, 每次缩进 2 个空格.</p>\n<h3 id=\"4-函数声明与定义\"><a href=\"#4-函数声明与定义\" class=\"headerlink\" title=\"4. 函数声明与定义\"></a>4. 函数声明与定义</h3><p>返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。<br>注意以下几点:</p>\n<ul>\n<li>如果返回类型和函数名在一行放不下，分行。</li>\n<li>如果返回类型那个与函数声明或定义分行了，不要缩进。</li>\n<li>左圆括号总是和函数名在同一行;</li>\n<li>函数名和左圆括号间没有空格;</li>\n<li>圆括号与参数间没有空格;</li>\n<li>左大括号总在最后一个参数同一行的末尾处;</li>\n<li>如果其它风格规则允许的话，右大括号总是单独位于函数最后一行，或者与左大括号同一行。</li>\n<li>右大括号和左大括号间总是有一个空格;</li>\n<li>函数声明和定义中的所有形参必须有命名且一致;</li>\n<li>所有形参应尽可能对齐;</li>\n<li>缺省缩进为 2 个空格;</li>\n<li>换行后的参数保持 4 个空格的缩进;</li>\n</ul>\n<h3 id=\"5-Lambda-表达式\"><a href=\"#5-Lambda-表达式\" class=\"headerlink\" title=\"5. Lambda 表达式\"></a>5. <code>Lambda</code> 表达式</h3><p>其它函数怎么格式化形参和函数体，<code>Lambda</code> 表达式就怎么格式化；捕获列表同理。</p>\n<h3 id=\"6-函数调用\"><a href=\"#6-函数调用\" class=\"headerlink\" title=\"6. 函数调用\"></a>6. 函数调用</h3><p>要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。函数调用遵循如下形式：</p>\n<ul>\n<li>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</li>\n<li>参数也可以放在次行，缩进四格：</li>\n<li>把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：</li>\n<li>如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给函数,或者放着不管，补充上注释：</li>\n<li>如果某参数独立成行，对可读性更有帮助的话，就这么办。</li>\n<li>此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：</li>\n</ul>\n<h3 id=\"7-列表初始化格式\"><a href=\"#7-列表初始化格式\" class=\"headerlink\" title=\"7. 列表初始化格式\"></a>7. 列表初始化格式</h3><p>您平时怎么格式化函数调用，就怎么格式化。</p>\n<h3 id=\"8-条件语句\"><a href=\"#8-条件语句\" class=\"headerlink\" title=\"8. 条件语句\"></a>8. 条件语句</h3><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.<br>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有。只要其中一个分支用了大括号，所有分支都要用上大括号。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;  圆括号里没空格紧邻。</div><div class=\"line\">  ...  <span class=\"comment\">// 2 空格缩进。</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// else 与 if 的右括号同一行。</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"9-循环和开关选择语句\"><a href=\"#9-循环和开关选择语句\" class=\"headerlink\" title=\"9. 循环和开关选择语句\"></a>9. 循环和开关选择语句</h3><p><code>switch</code> 语句可以使用大括号分段，以表明 <code>cases</code> 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 <code>{}</code> 或 <code>continue</code>.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> (var) &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>: &#123;  <span class=\"comment\">// 2 空格缩进</span></div><div class=\"line\">    ...      <span class=\"comment\">// 4 空格缩进</span></div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">default</span>: &#123;</div><div class=\"line\">    assert(<span class=\"literal\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在单语句循环里，括号可用可不用：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kSomeNumber; ++i)</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"I love you\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kSomeNumber; ++i) &#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"I take it back\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>空循环体应使用 <code>{}</code> 或 <code>continue</code>, 而不是一个简单的分号.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (condition) &#123;</div><div class=\"line\"><span class=\"comment\">// 反复循环直到条件失效。</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class=\"comment\">// 可 - 空循环体。</span></div><div class=\"line\"><span class=\"keyword\">while</span> (condition) <span class=\"keyword\">continue</span>;  <span class=\"comment\">// 可 - contunue 表明没有逻辑。</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"10-指针和引用表达式\"><a href=\"#10-指针和引用表达式\" class=\"headerlink\" title=\"10. 指针和引用表达式\"></a>10. 指针和引用表达式</h3><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*</code>, <code>&amp;</code>) 之后不能有空格.<br>下面是指针和引用表达式的正确使用范例:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = *p;</div><div class=\"line\">p = &amp;x;</div><div class=\"line\">x = r.y;</div><div class=\"line\">x = r-&gt;y;</div></pre></td></tr></table></figure></p>\n<h3 id=\"11-布尔表达式\"><a href=\"#11-布尔表达式\" class=\"headerlink\" title=\"11. 布尔表达式\"></a>11. 布尔表达式</h3><p>如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.<br>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</div><div class=\"line\">  a_third_thing == a_fourth_thing &amp;&amp;</div><div class=\"line\">  yet_another &amp; last_one) &#123;</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"12-函数返回值\"><a href=\"#12-函数返回值\" class=\"headerlink\" title=\"12. 函数返回值\"></a>12. 函数返回值</h3><p><code>return</code> 表达式里时没必要都用圆括号，变量返回时不要使用圆括号，可以用圆括号把复杂表达式圈起来，改善可读性。</p>\n<h3 id=\"13-变量及数组初始化\"><a href=\"#13-变量及数组初始化\" class=\"headerlink\" title=\"13. 变量及数组初始化\"></a>13. 变量及数组初始化</h3><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可。请务必小心列表初始化 <code>{...}</code>。 </p>\n<h3 id=\"14-预处理指令\"><a href=\"#14-预处理指令\" class=\"headerlink\" title=\"14. 预处理指令\"></a>14. 预处理指令</h3><p>预处理指令不要缩进, 从行首开始。即使预处理指令位于缩进代码块中, 指令也应从行首开始.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 可 - directives at beginning of line</span></div><div class=\"line\"><span class=\"keyword\">if</span> (lopsided_score) &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DISASTER_PENDING      <span class=\"comment\">// 正确 -- 行开头起。</span></span></div><div class=\"line\">  DropEverything();</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">  BackToNormal();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"15-类格式\"><a href=\"#15-类格式\" class=\"headerlink\" title=\"15. 类格式\"></a>15. 类格式</h3><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每次缩进 1 个空格.<br>类声明 (对类注释不了解的话, 参考 类注释) 的基本格式如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> MyClass : <span class=\"keyword\">public</span> OtherClass &#123;</div><div class=\"line\"> <span class=\"keyword\">public</span>:      <span class=\"comment\">// 注意有 1 空格缩进!</span></div><div class=\"line\">  MyClass();  <span class=\"comment\">// 照常，2 空格缩进。</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">MyClass</span><span class=\"params\">(<span class=\"keyword\">int</span> var)</span></span>;</div><div class=\"line\">  ~MyClass() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SomeFunction</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SomeFunctionThatDoesNothing</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_some_var</span><span class=\"params\">(<span class=\"keyword\">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">some_var</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> some_var_; &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">private</span>:</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SomeInternalFunction</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">int</span> some_var_;</div><div class=\"line\">  <span class=\"keyword\">int</span> some_other_var_;</div><div class=\"line\">  DISALLOW_COPY_AND_ASSIGN(MyClass);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>注意事项:</p>\n<ul>\n<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>\n<li>关键词 public:, protected:, private: 要缩进 1 个空格.</li>\n<li>除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>\n<li>这些关键词后不要保留空行.</li>\n<li>public 放在最前面, 然后是 protected, 最后是 private.</li>\n</ul>\n<h3 id=\"16-构造函数初始值列表\"><a href=\"#16-构造函数初始值列表\" class=\"headerlink\" title=\"16. 构造函数初始值列表\"></a>16. 构造函数初始值列表</h3><p>构造函数初始值列表放在同一行或按四格缩进并排几行.</p>\n<h3 id=\"17-名字空间格式化\"><a href=\"#17-名字空间格式化\" class=\"headerlink\" title=\"17. 名字空间格式化\"></a>17. 名字空间格式化</h3><p>名字空间 不要增加额外的缩进层次,</p>\n<h3 id=\"18-水平留白\"><a href=\"#18-水平留白\" class=\"headerlink\" title=\"18. 水平留白\"></a>18. 水平留白</h3><p>水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.</p>\n<ul>\n<li>常规<ul>\n<li>左大括号前恒有空格。</li>\n<li>分号前不加空格。</li>\n<li>大括号内部可与空格紧邻也不可，不过两边都要加上。</li>\n<li>继承与初始化列表中的冒号前后恒有空格。</li>\n<li>内联函数实现，在大括号内部加上空格并编写实现。</li>\n<li>大括号里面是空的话，不加空格。</li>\n</ul>\n</li>\n<li>循环和条件语句<ul>\n<li>if 条件语句和循环语句关键字后均有空格。</li>\n<li>圆括号内部不紧邻空格。</li>\n<li>循环和条件语句的圆括号里可以与空格紧邻。</li>\n<li>循环里内 <code>;</code> 后恒有空格，<code>；</code> 前可以加个空格。</li>\n<li><code>switch</code> <code>case</code> 的冒号前无空格。</li>\n</ul>\n</li>\n<li>操作符:<ul>\n<li>赋值操作系统前后恒有空格。</li>\n<li>其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。</li>\n<li>圆括号内部不紧邻空格。</li>\n<li>在参数和一元操作符之间不加空格。</li>\n</ul>\n</li>\n<li>模板和转换:<ul>\n<li>尖叫括号(&lt; and &gt;) 不与空格紧邻，&lt; 前没有空格，&gt;( 之间也没有。</li>\n<li>在类型与指针操作符之间留空格也可以，但要保持一致。</li>\n<li>您或许可以在 &lt; &lt; 里加上一对对称的空格。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"19-垂直留白\"><a href=\"#19-垂直留白\" class=\"headerlink\" title=\"19. 垂直留白\"></a>19. 垂直留白</h3><p>垂直留白越少越好.<br>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. </p>\n<ul>\n<li>两个函数定义之间的空行不要超过 2 行</li>\n<li>函数体首尾不要留空行, 函数体中也不要随意添加空行.</li>\n<li>函数体内开头或结尾的空行可读性微乎其微。</li>\n<li>在多重 if-else 块里加空行或许有点可读性。</li>\n</ul>"},{"title":"Linux学习总结（一）——系统结构","date":"2016-12-13T08:26:33.000Z","_content":"嵌入式开发不可避免的大部分都是使用 Linux 进行开发的，本篇在这里简单介绍自己对 Linux 的认识。\n<!--more-->\n## 什么是 Linux\nLinux 背后有两个最关键的关键字： UNIX，GNU。\nUNIX 最初是由贝尔实验室进行开发的，中间有过很曲折的发展历史，在这里就不详细说了。Linux是一个可自由发布的类UNIX内核实现，他是由Linus Torvalds 发明的。说一下所谓的最根本的哲学：简单原则，越大越复杂的系统注定包含越大，越复杂的漏洞，所以，KISS(keep It Small and Simple).\nGNU 计划是由Richard Stallman发起的。它的目标是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”。GNU 为 Linux 提供了大量的软件诸如：GCC，G++，GDB，GNU make，bash，GNU Emacs。\n简单的说，Linux 系统一般有4个主要部分：\n> 内核、shell、文件系统和应用程序。\n\n******\n\n## Linux内核\n内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：\n![系统架构](http://ogf054qp1.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png)\n\n1. 系统调用接口\nSCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 `./linux/kernel` 中您可以找到 SCI 的实现，并在 `./linux/arch` 中找到依赖于体系结构的部分。\n\n2. 内存管理 \n对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的**内存页**（对于大部分体系结构来说都是 4KB）。内存管理的源代码可以在 `./linux/mm` 中找到。\n\n3. 进程管理\n进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现**多任务**。这一短的时间间隔称为**时间片**，让进程轮流运行的方法称为**进程调度** ，完成调度的程序称为调度程序。\n内核通过 `SCI` 提供了一个应用程序编程接口（API）来创建一个新进程（`fork`、`exec` 或 `Portable Operating System Interface` [POSⅨ] 函数），停止进程（`kill`、`exit`），并在它们之间进行通信和同步（`signal` 或者 POSⅨ 机制）。\n\n4. 虚拟文件系统 \nLinux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.\n虚拟文件系统（`VirtualFileSystem`,`VFS`）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指 Linux 所支持的文件系统，如`ext2`,`fat`等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 \n\n4. 设备驱动程序 \n设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。\n\n5. 网络接口（NET）   \n提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。 \n网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。\n\n******\n\n## linux shell\nshell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。\n目前主要有下列版本的shell。\n\n1. `Bourne Shell`：是贝尔实验室开发的。 　\n2. `BASH`：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。\n3. `Korn Shell`：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。 　　　\n4. `C Shell`：是SUN公司Shell的BSD版本。\n\n我们最常使用的是`BASH`。\n\n******\n\n## linux 文件系统\n文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。\n### 1. 文件类型\nLinux下面的文件类型主要有：\n\n1. 普通文件(`-`)：C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。\n2. 目录文件(`d`)：目录，存储文件的唯一地方。\n3. 链接文件(`l`)：指向同一个文件或目录的的文件。\n4. 设备文件：与系统外设相关的，通常在/dev下面。分为块设备(`b`)和字符设备(`c`)。\n5. 管道文件(`p`) :  提供进程建通信的一种方式\n6. 套接字文件(`s`)： 该文件类型与网络通信有关\n\n\n### 2. Linux目录 \n文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。\nLinux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。\nlinux主要目录的功用:\n * `/bin` 二进制可执行命令\n * `/dev` 设备特殊文件\n * `/etc` 系统管理和配置文件\n  * `/etc/rc.d` 启动的配置文件和脚本\n * `/home` 用户主目录的基点，\n * `/lib` 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件\n * `/sbin` 系统管理命令，这里存放的是系统管理员使用的管理程序\n * `/tmp` 公用的临时文件存储点\n * `/root` 系统管理员的主目录\n * `/mnt` 系统提供这个目录是让用户临时挂载其他的文件系统。\n * `/lost+found` 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件\n * `/proc` 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息\n * `/var` 某些大文件的溢出区，比方说各种服务的日志文件\n * `/usr` 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：\n  * `/usr/bin` 众多的应用程序\n  * `/usr/sbin` 超级用户的一些管理程序\n  * `/usr/doc` linux文档\n  * `/usr/include` linux下开发和编译应用程序所需要的头文件\n  * `/usr/lib` 常用的动态链接库和软件包的配置文件\n  * `/usr/man` 帮助文档\n  * `/usr/src` 源代码，linux内核的源代码就放在/usr/src/linux里\n  * `/usr/local/bin` 本地增加的命令\n  * `/usr/local/lib` 本地增加的库\n\n### 3. Linux磁盘分区\n\n硬盘分区的标识一般使用 `/dev/hd[a-z]X` 或者 `/dev/sd[a-z]X` 来标识，其中 `[a-z]` 代表硬盘号，`X` 代表硬盘内的分区号。\n\n整块硬盘分区的块号标识:Linux下用 `hda`、`hdb`、`sda`、`sdb` 等来标识不同的硬盘;\n\n其中：\n\n`IDE` 接口硬盘：表示为 `/dev/hda1`、`/dev/hdb` ...；\n\n`SCSI` 接口的硬盘、`SATA`接口的硬盘表示为 `/dev/sda`、`/dev/sdb` ... ... ；\n\nLinux下磁盘分区和目录的关系如下：\n * 任何一个分区都必须挂载到某个目录上。\n\n * 目录是逻辑上的区分。分区是物理上的区分。\n\n * 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。\n\n * 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。\n\n### 4. linux文件系统\n文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。\n\n1. 文件系统类型：\n    `ext2` ： 早期linux中常用的文件系统\n    `ext3` ： ext2的升级版，带日志功能\n    `RAMFS` ： 内存文件系统，速度很快\n    `NFS` ： 网络文件系统，由SUN发明，主要用于远程文件共享\n    `MS-DOS` ： MS-DOS文件系统\n    `VFAT` ： Windows 95/98 操作系统采用的文件系统\n    `FAT` ： Windows XP 操作系统采用的文件系统\n    `NTFS`： Windows NT/XP 操作系统采用的文件系统\n    `HPFS` ： OS/2 操作系统采用的文件系统\n    `PROC` : 虚拟的进程文件系统\n    `ISO9660` ： 大部分光盘所采用的文件系统\n    `ufsSun` : OS 所采用的文件系统\n    `NCPFS` ： Novell 服务器所采用的文件系统\n    `SMBFS` ： Samba 的共享文件系统\n    `XFS` ： 由SGI开发的先进的日志文件系统，支持超大容量文件\n    `JFS` ：IBM的AIX使用的日志文件系统\n    `ReiserFS` : 基于平衡树结构的文件系统\n    `udf`: 可擦写的数据光盘文件系统\n2. 文件系统特性：\nLinux 正统的文件系统(如 `ext2、3` 等)将硬盘分区时会划分出 **超级块**、**inode Table区块** 和 **data block数据区域**。\n * 超级块(`Superblock`): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。\n * `inode`块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. \n * 数据块(`Block`) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。\n3. 链接\n可以用`ln`命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：\n * **硬连接**：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；\n * **符号连接**：用 `ln -s` 命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。\n \n 软硬链接的区别：\n> 通过 filename 找到对应的 inode，通过对应的 inode 找到对应的数据块。  \n当硬链接时，仅仅只是使链接文件名指向原文件的inode，而软链接是创建了一个新的inode指向了同样的数据块。\n","source":"_posts/Linux学习总结01.md","raw":"---\ntitle: Linux学习总结（一）——系统结构\ndate: 2016-12-13 16:26:33\ncategories: Linux学习记录\ntags: [Linux]\n---\n嵌入式开发不可避免的大部分都是使用 Linux 进行开发的，本篇在这里简单介绍自己对 Linux 的认识。\n<!--more-->\n## 什么是 Linux\nLinux 背后有两个最关键的关键字： UNIX，GNU。\nUNIX 最初是由贝尔实验室进行开发的，中间有过很曲折的发展历史，在这里就不详细说了。Linux是一个可自由发布的类UNIX内核实现，他是由Linus Torvalds 发明的。说一下所谓的最根本的哲学：简单原则，越大越复杂的系统注定包含越大，越复杂的漏洞，所以，KISS(keep It Small and Simple).\nGNU 计划是由Richard Stallman发起的。它的目标是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”。GNU 为 Linux 提供了大量的软件诸如：GCC，G++，GDB，GNU make，bash，GNU Emacs。\n简单的说，Linux 系统一般有4个主要部分：\n> 内核、shell、文件系统和应用程序。\n\n******\n\n## Linux内核\n内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：\n![系统架构](http://ogf054qp1.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png)\n\n1. 系统调用接口\nSCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 `./linux/kernel` 中您可以找到 SCI 的实现，并在 `./linux/arch` 中找到依赖于体系结构的部分。\n\n2. 内存管理 \n对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的**内存页**（对于大部分体系结构来说都是 4KB）。内存管理的源代码可以在 `./linux/mm` 中找到。\n\n3. 进程管理\n进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现**多任务**。这一短的时间间隔称为**时间片**，让进程轮流运行的方法称为**进程调度** ，完成调度的程序称为调度程序。\n内核通过 `SCI` 提供了一个应用程序编程接口（API）来创建一个新进程（`fork`、`exec` 或 `Portable Operating System Interface` [POSⅨ] 函数），停止进程（`kill`、`exit`），并在它们之间进行通信和同步（`signal` 或者 POSⅨ 机制）。\n\n4. 虚拟文件系统 \nLinux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.\n虚拟文件系统（`VirtualFileSystem`,`VFS`）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指 Linux 所支持的文件系统，如`ext2`,`fat`等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 \n\n4. 设备驱动程序 \n设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。\n\n5. 网络接口（NET）   \n提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。 \n网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。\n\n******\n\n## linux shell\nshell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。\n目前主要有下列版本的shell。\n\n1. `Bourne Shell`：是贝尔实验室开发的。 　\n2. `BASH`：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。\n3. `Korn Shell`：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。 　　　\n4. `C Shell`：是SUN公司Shell的BSD版本。\n\n我们最常使用的是`BASH`。\n\n******\n\n## linux 文件系统\n文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。\n### 1. 文件类型\nLinux下面的文件类型主要有：\n\n1. 普通文件(`-`)：C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。\n2. 目录文件(`d`)：目录，存储文件的唯一地方。\n3. 链接文件(`l`)：指向同一个文件或目录的的文件。\n4. 设备文件：与系统外设相关的，通常在/dev下面。分为块设备(`b`)和字符设备(`c`)。\n5. 管道文件(`p`) :  提供进程建通信的一种方式\n6. 套接字文件(`s`)： 该文件类型与网络通信有关\n\n\n### 2. Linux目录 \n文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。\nLinux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。\nlinux主要目录的功用:\n * `/bin` 二进制可执行命令\n * `/dev` 设备特殊文件\n * `/etc` 系统管理和配置文件\n  * `/etc/rc.d` 启动的配置文件和脚本\n * `/home` 用户主目录的基点，\n * `/lib` 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件\n * `/sbin` 系统管理命令，这里存放的是系统管理员使用的管理程序\n * `/tmp` 公用的临时文件存储点\n * `/root` 系统管理员的主目录\n * `/mnt` 系统提供这个目录是让用户临时挂载其他的文件系统。\n * `/lost+found` 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件\n * `/proc` 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息\n * `/var` 某些大文件的溢出区，比方说各种服务的日志文件\n * `/usr` 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：\n  * `/usr/bin` 众多的应用程序\n  * `/usr/sbin` 超级用户的一些管理程序\n  * `/usr/doc` linux文档\n  * `/usr/include` linux下开发和编译应用程序所需要的头文件\n  * `/usr/lib` 常用的动态链接库和软件包的配置文件\n  * `/usr/man` 帮助文档\n  * `/usr/src` 源代码，linux内核的源代码就放在/usr/src/linux里\n  * `/usr/local/bin` 本地增加的命令\n  * `/usr/local/lib` 本地增加的库\n\n### 3. Linux磁盘分区\n\n硬盘分区的标识一般使用 `/dev/hd[a-z]X` 或者 `/dev/sd[a-z]X` 来标识，其中 `[a-z]` 代表硬盘号，`X` 代表硬盘内的分区号。\n\n整块硬盘分区的块号标识:Linux下用 `hda`、`hdb`、`sda`、`sdb` 等来标识不同的硬盘;\n\n其中：\n\n`IDE` 接口硬盘：表示为 `/dev/hda1`、`/dev/hdb` ...；\n\n`SCSI` 接口的硬盘、`SATA`接口的硬盘表示为 `/dev/sda`、`/dev/sdb` ... ... ；\n\nLinux下磁盘分区和目录的关系如下：\n * 任何一个分区都必须挂载到某个目录上。\n\n * 目录是逻辑上的区分。分区是物理上的区分。\n\n * 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。\n\n * 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。\n\n### 4. linux文件系统\n文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。\n\n1. 文件系统类型：\n    `ext2` ： 早期linux中常用的文件系统\n    `ext3` ： ext2的升级版，带日志功能\n    `RAMFS` ： 内存文件系统，速度很快\n    `NFS` ： 网络文件系统，由SUN发明，主要用于远程文件共享\n    `MS-DOS` ： MS-DOS文件系统\n    `VFAT` ： Windows 95/98 操作系统采用的文件系统\n    `FAT` ： Windows XP 操作系统采用的文件系统\n    `NTFS`： Windows NT/XP 操作系统采用的文件系统\n    `HPFS` ： OS/2 操作系统采用的文件系统\n    `PROC` : 虚拟的进程文件系统\n    `ISO9660` ： 大部分光盘所采用的文件系统\n    `ufsSun` : OS 所采用的文件系统\n    `NCPFS` ： Novell 服务器所采用的文件系统\n    `SMBFS` ： Samba 的共享文件系统\n    `XFS` ： 由SGI开发的先进的日志文件系统，支持超大容量文件\n    `JFS` ：IBM的AIX使用的日志文件系统\n    `ReiserFS` : 基于平衡树结构的文件系统\n    `udf`: 可擦写的数据光盘文件系统\n2. 文件系统特性：\nLinux 正统的文件系统(如 `ext2、3` 等)将硬盘分区时会划分出 **超级块**、**inode Table区块** 和 **data block数据区域**。\n * 超级块(`Superblock`): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。\n * `inode`块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. \n * 数据块(`Block`) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。\n3. 链接\n可以用`ln`命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：\n * **硬连接**：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；\n * **符号连接**：用 `ln -s` 命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。\n \n 软硬链接的区别：\n> 通过 filename 找到对应的 inode，通过对应的 inode 找到对应的数据块。  \n当硬链接时，仅仅只是使链接文件名指向原文件的inode，而软链接是创建了一个新的inode指向了同样的数据块。\n","slug":"Linux学习总结01","published":1,"updated":"2016-12-21T14:08:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0c000rbkw1ey3ky1sa","content":"<p>嵌入式开发不可避免的大部分都是使用 Linux 进行开发的，本篇在这里简单介绍自己对 Linux 的认识。<br><a id=\"more\"></a></p>\n<h2 id=\"什么是-Linux\"><a href=\"#什么是-Linux\" class=\"headerlink\" title=\"什么是 Linux\"></a>什么是 Linux</h2><p>Linux 背后有两个最关键的关键字： UNIX，GNU。<br>UNIX 最初是由贝尔实验室进行开发的，中间有过很曲折的发展历史，在这里就不详细说了。Linux是一个可自由发布的类UNIX内核实现，他是由Linus Torvalds 发明的。说一下所谓的最根本的哲学：简单原则，越大越复杂的系统注定包含越大，越复杂的漏洞，所以，KISS(keep It Small and Simple).<br>GNU 计划是由Richard Stallman发起的。它的目标是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”。GNU 为 Linux 提供了大量的软件诸如：GCC，G++，GDB，GNU make，bash，GNU Emacs。<br>简单的说，Linux 系统一般有4个主要部分：</p>\n<blockquote>\n<p>内核、shell、文件系统和应用程序。</p>\n</blockquote>\n<hr>\n<h2 id=\"Linux内核\"><a href=\"#Linux内核\" class=\"headerlink\" title=\"Linux内核\"></a>Linux内核</h2><p>内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：<br><img src=\"http://ogf054qp1.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png\" alt=\"系统架构\"></p>\n<ol>\n<li><p>系统调用接口<br>SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 <code>./linux/kernel</code> 中您可以找到 SCI 的实现，并在 <code>./linux/arch</code> 中找到依赖于体系结构的部分。</p>\n</li>\n<li><p>内存管理<br>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的<strong>内存页</strong>（对于大部分体系结构来说都是 4KB）。内存管理的源代码可以在 <code>./linux/mm</code> 中找到。</p>\n</li>\n<li><p>进程管理<br>进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现<strong>多任务</strong>。这一短的时间间隔称为<strong>时间片</strong>，让进程轮流运行的方法称为<strong>进程调度</strong> ，完成调度的程序称为调度程序。<br>内核通过 <code>SCI</code> 提供了一个应用程序编程接口（API）来创建一个新进程（<code>fork</code>、<code>exec</code> 或 <code>Portable Operating System Interface</code> [POSⅨ] 函数），停止进程（<code>kill</code>、<code>exit</code>），并在它们之间进行通信和同步（<code>signal</code> 或者 POSⅨ 机制）。</p>\n</li>\n<li><p>虚拟文件系统<br>Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.<br>虚拟文件系统（<code>VirtualFileSystem</code>,<code>VFS</code>）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指 Linux 所支持的文件系统，如<code>ext2</code>,<code>fat</code>等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 </p>\n</li>\n<li><p>设备驱动程序<br>设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。</p>\n</li>\n<li><p>网络接口（NET）<br>提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。<br>网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"linux-shell\"><a href=\"#linux-shell\" class=\"headerlink\" title=\"linux shell\"></a>linux shell</h2><p>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。<br>目前主要有下列版本的shell。</p>\n<ol>\n<li><code>Bourne Shell</code>：是贝尔实验室开发的。 　</li>\n<li><code>BASH</code>：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。</li>\n<li><code>Korn Shell</code>：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。 　　　</li>\n<li><code>C Shell</code>：是SUN公司Shell的BSD版本。</li>\n</ol>\n<p>我们最常使用的是<code>BASH</code>。</p>\n<hr>\n<h2 id=\"linux-文件系统\"><a href=\"#linux-文件系统\" class=\"headerlink\" title=\"linux 文件系统\"></a>linux 文件系统</h2><p>文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。</p>\n<h3 id=\"1-文件类型\"><a href=\"#1-文件类型\" class=\"headerlink\" title=\"1. 文件类型\"></a>1. 文件类型</h3><p>Linux下面的文件类型主要有：</p>\n<ol>\n<li>普通文件(<code>-</code>)：C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。</li>\n<li>目录文件(<code>d</code>)：目录，存储文件的唯一地方。</li>\n<li>链接文件(<code>l</code>)：指向同一个文件或目录的的文件。</li>\n<li>设备文件：与系统外设相关的，通常在/dev下面。分为块设备(<code>b</code>)和字符设备(<code>c</code>)。</li>\n<li>管道文件(<code>p</code>) :  提供进程建通信的一种方式</li>\n<li>套接字文件(<code>s</code>)： 该文件类型与网络通信有关</li>\n</ol>\n<h3 id=\"2-Linux目录\"><a href=\"#2-Linux目录\" class=\"headerlink\" title=\"2. Linux目录\"></a>2. Linux目录</h3><p>文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。<br>Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。<br>linux主要目录的功用:</p>\n<ul>\n<li><code>/bin</code> 二进制可执行命令</li>\n<li><code>/dev</code> 设备特殊文件</li>\n<li><code>/etc</code> 系统管理和配置文件<ul>\n<li><code>/etc/rc.d</code> 启动的配置文件和脚本</li>\n</ul>\n</li>\n<li><code>/home</code> 用户主目录的基点，</li>\n<li><code>/lib</code> 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件</li>\n<li><code>/sbin</code> 系统管理命令，这里存放的是系统管理员使用的管理程序</li>\n<li><code>/tmp</code> 公用的临时文件存储点</li>\n<li><code>/root</code> 系统管理员的主目录</li>\n<li><code>/mnt</code> 系统提供这个目录是让用户临时挂载其他的文件系统。</li>\n<li><code>/lost+found</code> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件</li>\n<li><code>/proc</code> 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息</li>\n<li><code>/var</code> 某些大文件的溢出区，比方说各种服务的日志文件</li>\n<li><code>/usr</code> 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：<ul>\n<li><code>/usr/bin</code> 众多的应用程序</li>\n<li><code>/usr/sbin</code> 超级用户的一些管理程序</li>\n<li><code>/usr/doc</code> linux文档</li>\n<li><code>/usr/include</code> linux下开发和编译应用程序所需要的头文件</li>\n<li><code>/usr/lib</code> 常用的动态链接库和软件包的配置文件</li>\n<li><code>/usr/man</code> 帮助文档</li>\n<li><code>/usr/src</code> 源代码，linux内核的源代码就放在/usr/src/linux里</li>\n<li><code>/usr/local/bin</code> 本地增加的命令</li>\n<li><code>/usr/local/lib</code> 本地增加的库</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-Linux磁盘分区\"><a href=\"#3-Linux磁盘分区\" class=\"headerlink\" title=\"3. Linux磁盘分区\"></a>3. Linux磁盘分区</h3><p>硬盘分区的标识一般使用 <code>/dev/hd[a-z]X</code> 或者 <code>/dev/sd[a-z]X</code> 来标识，其中 <code>[a-z]</code> 代表硬盘号，<code>X</code> 代表硬盘内的分区号。</p>\n<p>整块硬盘分区的块号标识:Linux下用 <code>hda</code>、<code>hdb</code>、<code>sda</code>、<code>sdb</code> 等来标识不同的硬盘;</p>\n<p>其中：</p>\n<p><code>IDE</code> 接口硬盘：表示为 <code>/dev/hda1</code>、<code>/dev/hdb</code> …；</p>\n<p><code>SCSI</code> 接口的硬盘、<code>SATA</code>接口的硬盘表示为 <code>/dev/sda</code>、<code>/dev/sdb</code> … … ；</p>\n<p>Linux下磁盘分区和目录的关系如下：</p>\n<ul>\n<li><p>任何一个分区都必须挂载到某个目录上。</p>\n</li>\n<li><p>目录是逻辑上的区分。分区是物理上的区分。</p>\n</li>\n<li><p>磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。</p>\n</li>\n<li><p>根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。</p>\n</li>\n</ul>\n<h3 id=\"4-linux文件系统\"><a href=\"#4-linux文件系统\" class=\"headerlink\" title=\"4. linux文件系统\"></a>4. linux文件系统</h3><p>文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。</p>\n<ol>\n<li>文件系统类型：<br> <code>ext2</code> ： 早期linux中常用的文件系统<br> <code>ext3</code> ： ext2的升级版，带日志功能<br> <code>RAMFS</code> ： 内存文件系统，速度很快<br> <code>NFS</code> ： 网络文件系统，由SUN发明，主要用于远程文件共享<br> <code>MS-DOS</code> ： MS-DOS文件系统<br> <code>VFAT</code> ： Windows 95/98 操作系统采用的文件系统<br> <code>FAT</code> ： Windows XP 操作系统采用的文件系统<br> <code>NTFS</code>： Windows NT/XP 操作系统采用的文件系统<br> <code>HPFS</code> ： OS/2 操作系统采用的文件系统<br> <code>PROC</code> : 虚拟的进程文件系统<br> <code>ISO9660</code> ： 大部分光盘所采用的文件系统<br> <code>ufsSun</code> : OS 所采用的文件系统<br> <code>NCPFS</code> ： Novell 服务器所采用的文件系统<br> <code>SMBFS</code> ： Samba 的共享文件系统<br> <code>XFS</code> ： 由SGI开发的先进的日志文件系统，支持超大容量文件<br> <code>JFS</code> ：IBM的AIX使用的日志文件系统<br> <code>ReiserFS</code> : 基于平衡树结构的文件系统<br> <code>udf</code>: 可擦写的数据光盘文件系统</li>\n<li>文件系统特性：<br>Linux 正统的文件系统(如 <code>ext2、3</code> 等)将硬盘分区时会划分出 <strong>超级块</strong>、<strong>inode Table区块</strong> 和 <strong>data block数据区域</strong>。<ul>\n<li>超级块(<code>Superblock</code>): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。</li>\n<li><code>inode</code>块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. </li>\n<li>数据块(<code>Block</code>) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。</li>\n</ul>\n</li>\n<li><p>链接<br>可以用<code>ln</code>命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：</p>\n<ul>\n<li><strong>硬连接</strong>：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；</li>\n<li><strong>符号连接</strong>：用 <code>ln -s</code> 命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。</li>\n</ul>\n<p>软硬链接的区别：</p>\n<blockquote>\n<p>通过 filename 找到对应的 inode，通过对应的 inode 找到对应的数据块。<br>当硬链接时，仅仅只是使链接文件名指向原文件的inode，而软链接是创建了一个新的inode指向了同样的数据块。</p>\n</blockquote>\n</li>\n</ol>\n","excerpt":"<p>嵌入式开发不可避免的大部分都是使用 Linux 进行开发的，本篇在这里简单介绍自己对 Linux 的认识。<br>","more":"</p>\n<h2 id=\"什么是-Linux\"><a href=\"#什么是-Linux\" class=\"headerlink\" title=\"什么是 Linux\"></a>什么是 Linux</h2><p>Linux 背后有两个最关键的关键字： UNIX，GNU。<br>UNIX 最初是由贝尔实验室进行开发的，中间有过很曲折的发展历史，在这里就不详细说了。Linux是一个可自由发布的类UNIX内核实现，他是由Linus Torvalds 发明的。说一下所谓的最根本的哲学：简单原则，越大越复杂的系统注定包含越大，越复杂的漏洞，所以，KISS(keep It Small and Simple).<br>GNU 计划是由Richard Stallman发起的。它的目标是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”。GNU 为 Linux 提供了大量的软件诸如：GCC，G++，GDB，GNU make，bash，GNU Emacs。<br>简单的说，Linux 系统一般有4个主要部分：</p>\n<blockquote>\n<p>内核、shell、文件系统和应用程序。</p>\n</blockquote>\n<hr>\n<h2 id=\"Linux内核\"><a href=\"#Linux内核\" class=\"headerlink\" title=\"Linux内核\"></a>Linux内核</h2><p>内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：<br><img src=\"http://ogf054qp1.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png\" alt=\"系统架构\"></p>\n<ol>\n<li><p>系统调用接口<br>SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 <code>./linux/kernel</code> 中您可以找到 SCI 的实现，并在 <code>./linux/arch</code> 中找到依赖于体系结构的部分。</p>\n</li>\n<li><p>内存管理<br>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的<strong>内存页</strong>（对于大部分体系结构来说都是 4KB）。内存管理的源代码可以在 <code>./linux/mm</code> 中找到。</p>\n</li>\n<li><p>进程管理<br>进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现<strong>多任务</strong>。这一短的时间间隔称为<strong>时间片</strong>，让进程轮流运行的方法称为<strong>进程调度</strong> ，完成调度的程序称为调度程序。<br>内核通过 <code>SCI</code> 提供了一个应用程序编程接口（API）来创建一个新进程（<code>fork</code>、<code>exec</code> 或 <code>Portable Operating System Interface</code> [POSⅨ] 函数），停止进程（<code>kill</code>、<code>exit</code>），并在它们之间进行通信和同步（<code>signal</code> 或者 POSⅨ 机制）。</p>\n</li>\n<li><p>虚拟文件系统<br>Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.<br>虚拟文件系统（<code>VirtualFileSystem</code>,<code>VFS</code>）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指 Linux 所支持的文件系统，如<code>ext2</code>,<code>fat</code>等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 </p>\n</li>\n<li><p>设备驱动程序<br>设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。</p>\n</li>\n<li><p>网络接口（NET）<br>提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。<br>网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"linux-shell\"><a href=\"#linux-shell\" class=\"headerlink\" title=\"linux shell\"></a>linux shell</h2><p>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。<br>目前主要有下列版本的shell。</p>\n<ol>\n<li><code>Bourne Shell</code>：是贝尔实验室开发的。 　</li>\n<li><code>BASH</code>：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。</li>\n<li><code>Korn Shell</code>：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。 　　　</li>\n<li><code>C Shell</code>：是SUN公司Shell的BSD版本。</li>\n</ol>\n<p>我们最常使用的是<code>BASH</code>。</p>\n<hr>\n<h2 id=\"linux-文件系统\"><a href=\"#linux-文件系统\" class=\"headerlink\" title=\"linux 文件系统\"></a>linux 文件系统</h2><p>文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。</p>\n<h3 id=\"1-文件类型\"><a href=\"#1-文件类型\" class=\"headerlink\" title=\"1. 文件类型\"></a>1. 文件类型</h3><p>Linux下面的文件类型主要有：</p>\n<ol>\n<li>普通文件(<code>-</code>)：C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。</li>\n<li>目录文件(<code>d</code>)：目录，存储文件的唯一地方。</li>\n<li>链接文件(<code>l</code>)：指向同一个文件或目录的的文件。</li>\n<li>设备文件：与系统外设相关的，通常在/dev下面。分为块设备(<code>b</code>)和字符设备(<code>c</code>)。</li>\n<li>管道文件(<code>p</code>) :  提供进程建通信的一种方式</li>\n<li>套接字文件(<code>s</code>)： 该文件类型与网络通信有关</li>\n</ol>\n<h3 id=\"2-Linux目录\"><a href=\"#2-Linux目录\" class=\"headerlink\" title=\"2. Linux目录\"></a>2. Linux目录</h3><p>文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。<br>Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。<br>linux主要目录的功用:</p>\n<ul>\n<li><code>/bin</code> 二进制可执行命令</li>\n<li><code>/dev</code> 设备特殊文件</li>\n<li><code>/etc</code> 系统管理和配置文件<ul>\n<li><code>/etc/rc.d</code> 启动的配置文件和脚本</li>\n</ul>\n</li>\n<li><code>/home</code> 用户主目录的基点，</li>\n<li><code>/lib</code> 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件</li>\n<li><code>/sbin</code> 系统管理命令，这里存放的是系统管理员使用的管理程序</li>\n<li><code>/tmp</code> 公用的临时文件存储点</li>\n<li><code>/root</code> 系统管理员的主目录</li>\n<li><code>/mnt</code> 系统提供这个目录是让用户临时挂载其他的文件系统。</li>\n<li><code>/lost+found</code> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件</li>\n<li><code>/proc</code> 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息</li>\n<li><code>/var</code> 某些大文件的溢出区，比方说各种服务的日志文件</li>\n<li><code>/usr</code> 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：<ul>\n<li><code>/usr/bin</code> 众多的应用程序</li>\n<li><code>/usr/sbin</code> 超级用户的一些管理程序</li>\n<li><code>/usr/doc</code> linux文档</li>\n<li><code>/usr/include</code> linux下开发和编译应用程序所需要的头文件</li>\n<li><code>/usr/lib</code> 常用的动态链接库和软件包的配置文件</li>\n<li><code>/usr/man</code> 帮助文档</li>\n<li><code>/usr/src</code> 源代码，linux内核的源代码就放在/usr/src/linux里</li>\n<li><code>/usr/local/bin</code> 本地增加的命令</li>\n<li><code>/usr/local/lib</code> 本地增加的库</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-Linux磁盘分区\"><a href=\"#3-Linux磁盘分区\" class=\"headerlink\" title=\"3. Linux磁盘分区\"></a>3. Linux磁盘分区</h3><p>硬盘分区的标识一般使用 <code>/dev/hd[a-z]X</code> 或者 <code>/dev/sd[a-z]X</code> 来标识，其中 <code>[a-z]</code> 代表硬盘号，<code>X</code> 代表硬盘内的分区号。</p>\n<p>整块硬盘分区的块号标识:Linux下用 <code>hda</code>、<code>hdb</code>、<code>sda</code>、<code>sdb</code> 等来标识不同的硬盘;</p>\n<p>其中：</p>\n<p><code>IDE</code> 接口硬盘：表示为 <code>/dev/hda1</code>、<code>/dev/hdb</code> …；</p>\n<p><code>SCSI</code> 接口的硬盘、<code>SATA</code>接口的硬盘表示为 <code>/dev/sda</code>、<code>/dev/sdb</code> … … ；</p>\n<p>Linux下磁盘分区和目录的关系如下：</p>\n<ul>\n<li><p>任何一个分区都必须挂载到某个目录上。</p>\n</li>\n<li><p>目录是逻辑上的区分。分区是物理上的区分。</p>\n</li>\n<li><p>磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。</p>\n</li>\n<li><p>根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。</p>\n</li>\n</ul>\n<h3 id=\"4-linux文件系统\"><a href=\"#4-linux文件系统\" class=\"headerlink\" title=\"4. linux文件系统\"></a>4. linux文件系统</h3><p>文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。</p>\n<ol>\n<li>文件系统类型：<br> <code>ext2</code> ： 早期linux中常用的文件系统<br> <code>ext3</code> ： ext2的升级版，带日志功能<br> <code>RAMFS</code> ： 内存文件系统，速度很快<br> <code>NFS</code> ： 网络文件系统，由SUN发明，主要用于远程文件共享<br> <code>MS-DOS</code> ： MS-DOS文件系统<br> <code>VFAT</code> ： Windows 95/98 操作系统采用的文件系统<br> <code>FAT</code> ： Windows XP 操作系统采用的文件系统<br> <code>NTFS</code>： Windows NT/XP 操作系统采用的文件系统<br> <code>HPFS</code> ： OS/2 操作系统采用的文件系统<br> <code>PROC</code> : 虚拟的进程文件系统<br> <code>ISO9660</code> ： 大部分光盘所采用的文件系统<br> <code>ufsSun</code> : OS 所采用的文件系统<br> <code>NCPFS</code> ： Novell 服务器所采用的文件系统<br> <code>SMBFS</code> ： Samba 的共享文件系统<br> <code>XFS</code> ： 由SGI开发的先进的日志文件系统，支持超大容量文件<br> <code>JFS</code> ：IBM的AIX使用的日志文件系统<br> <code>ReiserFS</code> : 基于平衡树结构的文件系统<br> <code>udf</code>: 可擦写的数据光盘文件系统</li>\n<li>文件系统特性：<br>Linux 正统的文件系统(如 <code>ext2、3</code> 等)将硬盘分区时会划分出 <strong>超级块</strong>、<strong>inode Table区块</strong> 和 <strong>data block数据区域</strong>。<ul>\n<li>超级块(<code>Superblock</code>): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。</li>\n<li><code>inode</code>块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. </li>\n<li>数据块(<code>Block</code>) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。</li>\n</ul>\n</li>\n<li><p>链接<br>可以用<code>ln</code>命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：</p>\n<ul>\n<li><strong>硬连接</strong>：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；</li>\n<li><strong>符号连接</strong>：用 <code>ln -s</code> 命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。</li>\n</ul>\n<p>软硬链接的区别：</p>\n<blockquote>\n<p>通过 filename 找到对应的 inode，通过对应的 inode 找到对应的数据块。<br>当硬链接时，仅仅只是使链接文件名指向原文件的inode，而软链接是创建了一个新的inode指向了同样的数据块。</p>\n</blockquote>\n</li>\n</ol>"},{"title":"Linux学习总结（二）——Shell编程","date":"2016-12-16T01:24:39.000Z","_content":"\nShell 是 Unix 系统下的一个命令解释器，主要用于系统和用户的交互。在 Unix 上有各种不同版本的 Shell，Bash是Linux标准默认的Shell，它是BourneAgain Shell的缩写。我们这里主要讨论的也是 Bash。\n\n<!--more-->\nLinux常用命令表 ( 约60个常用命令)|\n\n|分类|命令|\n|-------------|---|\n|文件相关|`cd`, `whereis`, `pwd`, `ls`, `file`, `echo`, `mkdir/rmdir`, `cat/more`, `cp/mv/rm`, `chowm/chgrp`, `chmod`, `grep`, `find`, `locate`, `ln`, `gzip`, `tar`, `diff`, `patch`|\n|磁盘管理|`df`, `du`, `mount/umount`, `fdisk`, `mkfs`|\n|用户管理|`useradd`, `userdel`, `usermod`, `groupadd`, `groupdel`, `groupmod`, `groups`, `passwd`, `id`, `who`, `whoami`|\n|系统及相关|`su`, `sudo`, `export`, `shutdown`, `poweroff`,`halt`, `reboot`, `ps`, `top`, `uname`, `uptime`, `clear`, `cal`, `date/time`|\n|网络配置|`netstat`, `nslookup`, `finger`, `ping`, `ifconfig`, `ftp`, `telnet`, `ssh`|\n\n## Shell 编程\nShell 脚本（shell script），是一种为shell编写的脚本程序。\n> 简单的几点 shell 语法：\n* `#！`  指定sh解释程序\n* `#；`  注释\n* 关于空格， `=` 不加空格， 运算符要加空格。\n\n\n## Shell 变量\n### 用户自定义变量\n变量类型只支持字符串，不支持整形，字符，浮点;\n* 等号前后不要有空格\n* 一般变量命名用全大写\n* `unset` 命令删除变量赋值\n* `readonly` 标定只读变量\n* `export` 来指定global变量\n\n### 预定义变量\n* `$0` 与键入的命令行一样，包含脚本文件名\n* `$1, $2,...$9` 分别包含第一个到第九个命令行参数\n* `$#` 命令行参数的个数\n* `$@` 所有命令行参数\n* `$?` 前一个命令的退出状态\n* `$*` 所有命令行参数\n* `$$` 正在执行的进程ID号\n\n### 环境变量\n* `HOME`： 当前用户的主目录\n* `PATH`: shell搜索路径\n* `TERM`: 终端程序名称\n* `UID`: 当前用户的识别字，取值是由数位构成的字串。\n* `PWD`: 当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。\n* `PS1`: 主提示符，在特权用户下，默认的主提示符是#，在普通用户下，默认的主提示符是$。# , $\n* `PS2`: 在Shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“\\”然后回车，或者当用户按回车键时Shell判断出用户输入的命令没有结束时，就显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是>\n\n### 字符串\n字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。\n\n* 单引号\n ````\n str='this is a string'````\n 单引号字符串的限制：\n  * 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n  * 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n\n* 双引号\n ````shell\n your_name='qinjx'\n str=\"Hello, I know your are \\\"$your_name\\\"! \\n\"\n ````\n 双引号的优点：\n  * 双引号里可以有变量\n  * 双引号里可以出现转义字符\n\n* 拼接字符串\n ````shell\n your_name=\"qinjx\"\n greeting=\"hello, \"$your_name\" !\"\n greeting_1=\"hello, ${your_name} !\"\n echo $greeting $greeting_1\n ````\n\n* 获取字符串长度\n ````shell\n string=\"abcd\"\n echo ${#string} #输出 4````\n\n* 提取子字符串\n 以下实例从字符串第 `2` 个字符开始截取 `4` 个字符：\n ````shell\n string=\"runoob is a great site\"\n echo ${string:1:4} # 输出 unoo````\n\n* 查找子字符串\n 查找字符 `i` 或 `s` 的位置：\n ````\n string=\"runoob is a great company\"\n echo `expr index \"$string\" is`  # 输出 8````\n 注意： 以上脚本中 ` 是反引号，而不是单引号，不要看错了哦。\n\n### Shell 数组\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。\n类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。\n\n* 定义数组\n 在Shell中，用括号来表示数组，数组元素用\"空格\"符号分割开。定义数组的一般形式为：\n `数组名=(值1 值2 ... 值n)`\n 例如：\n ````shell\n array_name=(value0 value1 value2 value3)````\n 或者\n ````shell\n array_name=(\n value0\n value1\n value2\n value3\n )````\n 还可以单独定义数组的各个分量：\n ````shell\n array_name[0]=value0\n array_name[1]=value1\n array_name[n]=valuen````\n 可以不使用连续的下标，而且下标的范围没有限制。\n\n* 读取数组\n 读取数组元素值的一般格式是：\n `${数组名[下标]}`\n 例如：\n `valuen=${array_name[n]}`\n 使用@符号可以获取数组中的所有元素，例如：\n `echo ${array_name[@]}`\n\n* 获取数组的长度\n 获取数组长度的方法与获取字符串长度的方法相同，例如：\n ````shell\n# 取得数组元素的个数\nlength=${#array_name[@]}\n# 或者\nlength=${#array_name[*]}\n# 取得数组单个元素的长度\nlengthn=${#array_name[n]}````\n\n## Shell 语句\n### 基本运算符\nShell 和其他编程语言一样，支持多种运算符，原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：\n````shell\n#!/bin/bash\nval=`expr 2 + 2`\necho \"两数之和为 : $val\"````\n执行脚本，输出结果如下所示：\n> 两数之和为 : 4\n\n注意：\n * 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n * 完整的表达式要被 \\` \\` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。\n * 乘号(*)前边必须加反斜杠(\\\\)才能实现乘法运算.\n\n常用的运算符如下：\n\n|运算符|说明|举例|\n|--|--|--|\n|+|加法|expr $a + $b 结果为 30。|\n|-|减法|expr $a - $b 结果为 -10。|\n|*|乘法|expr $a \\* $b 结果为  200。|\n|/|除法|expr $b / $a 结果为 2。|\n|%|取余|expr $b % $a 结果为 0。|\n|=|赋值|a=$b 将把变量 b 的值赋给 a。|\n|==|相等。用于比较两个数字，相同则返回 true。|[ $a == $b ] 返回 false。|\n|!=|不相等。用于比较两个数字，不相同则返回 true。|[ $a != $b ] 返回 true。|\n|-eq|检测两个数是否相等，相等返回 true。|[ $a -eq $b ] 返回 false。|\n|-ne|检测两个数是否相等，不相等返回 true。|[ $a -ne $b ] 返回 true。|\n|-gt|检测左边的数是否大于右边的，如果是，则返回 true。|[ $a -gt $b ] 返回 false。|\n|-lt|检测左边的数是否小于右边的，如果是，则返回 true。|[ $a -lt $b ] 返回 true。|\n|-ge|检测左边的数是否大于等于右边的，如果是，则返回 true。|[ $a -ge $b ] 返回 false。|\n|-le|检测左边的数是否小于等于右边的，如果是，则返回 true。|[ $a -le $b ] 返回 true。|\n|!|非运算，表达式为 true 则返回 false，否则返回 true。|[ ! false ] 返回 true。|\n|-o|或运算，有一个表达式为 true 则返回 true。|[ $a -lt 20 -o $b -gt 100 ] 返回 true。|\n|-a|与运算，两个表达式都为 true 才返回 true。|[ $a -lt 20 -a $b -gt 100 ] 返回 false。|\n|&&|逻辑的 AND|[[ $a -lt 100 && $b -gt 100 ]] 返回 false|\n|II|逻辑的 OR|[[ $a -lt 100 II $b -gt 100 ]] 返回 true|\n|=|检测两个字符串是否相等，相等返回 true。|[ $a = $b ] 返回 false。|\n|!=|检测两个字符串是否相等，不相等返回 true。|[ $a != $b ] 返回 true。|\n|-z|检测字符串长度是否为0，为0返回 true。|[ -z $a ] 返回 false。|\n|-n|检测字符串长度是否为0，不为0返回 true。|[ -n $a ] 返回 true。|\n|str|检测字符串是否为空，不为空返回 true。|[ $a ] 返回 true。|\n|-b file|检测文件是否是块设备文件，如果是，则返回 true。|[ -b $file ] 返回 false。|\n|-c file|检测文件是否是字符设备文件，如果是，则返回 true。|[ -c $file ] 返回 false。|\n|-d file|检测文件是否是目录，如果是，则返回 true。|[ -d $file ] 返回 false。|\n|-f file|检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。|[ -f $file ] 返回 true。|\n|-g file|检测文件是否设置了 SGID 位，如果是，则返回 true。|[ -g $file ] 返回 false。|\n|-k file|检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。|[ -k $file ] 返回 false。|\n|-p file|检测文件是否是有名管道，如果是，则返回 true。|[ -p $file ] 返回 false。|\n|-u file|检测文件是否设置了 SUID 位，如果是，则返回 true。|[ -u $file ] 返回 false。|\n|-r file|检测文件是否可读，如果是，则返回 true。|[ -r $file ] 返回 true。|\n|-w file|检测文件是否可写，如果是，则返回 true。|[ -w $file ] 返回 true。|\n|-x file|检测文件是否可执行，如果是，则返回 true。|[ -x $file ] 返回 true。|\n|-s file|检测文件是否为空（文件大小是否大于0），不为空返回 true。|[ -s $file ] 返回 true。|\n|-e file|检测文件（包括目录）是否存在，如果是，则返回 true。|[ -e $file ] 返回 true。|\n\n### shell 内部命令\n* `echo` 输出\n* `exec`\n* `exit` 退出\n* `read` 从标准输入读取一行并且赋值给后面变量\n ````shell\n read var\n read var1 var2 var3 ````\n* `expr` 常见的算术运算 `+ ， - ， \\* ， / ， %`\n  注意，运算符左右两边都需要有空格，否则会视为字符串连接\n* `test` 测试结果也常常用来作为判断条件及结果\n ````\n test \"$answer\" = \"yes\"\n test $num -eq 18\n test -d temp````\n 可以用[]代替test  ， 但需要左右留有一个空格 ，比如\n  ```` \n  [ \"$answer\" = \"yes\" ]\n  if [ $num -eq 18 ]````\n \n### 结构性语句\n* 条件\n 1. `if`语句\n ````\n if...then...fi\n if [exp]\n then [command]\n fi````\n 2. `if else` 语句\n  ````\n if [exp]\n then [command]\n else [command]\n if````\n 3. `case...esac` 语句\n ````\n case [var] in\n [param1])\n [command]\n ;;\n [param2])\n [command]\n ;;\n [paramn])\n [command】\n ;;\n esac\n 注意：var只能是字符串型变量  ````\n\n\n* 循环\n 1.\tfor...do...done\n  ````\n for [var] in [list]\n do\n  [command]\n done````\n 2.\twhile...do...done\n  ````\n  while [exp]\n  do\n  [command]\n  done````\n 3.\tuntil...do...done\n  ````\n  until [exp]\n  do\n  [command]\n  done````\n 4. break, continue\n\n## Shell 函数\n * 定义格式\n ````\nfunction_name()\n{\n  command1\n  ...\n  commandn\n}\n \nfunction function_name()\n{\n  command1\n  ...\n  commandn\n}\n ````\n 说明：\n  * 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n  * 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\n * 调用函数\n ````\n[var]=`function_name [arg1,arg2...]` \ndo(fdf,dfdfd)\ndo fdf fdfdd\nfunction_name [arg1,arg2...]\necho $?````\n 说明：\n  * 函数返回值在调用该函数后通过 $? 来获得。\n  * 所有函数在使用前必须定义。调用函数仅使用其函数名即可。\n  * 调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，当n>=10时，需要使用${n}来获取参数。\n\n## Shell 文件包含\nShell 文件包含的语法格式如下：\n````shell\n. filename # 注意点号(.)和文件名中间有一空格\n或\nsource filename````\n\n\n\n\n","source":"_posts/Linux学习总结02.md","raw":"---\ntitle: Linux学习总结（二）——Shell编程\ndate: 2016-12-16 09:24:39\ncategories: Linux学习记录\ntags: [Linux, Shell]\n---\n\nShell 是 Unix 系统下的一个命令解释器，主要用于系统和用户的交互。在 Unix 上有各种不同版本的 Shell，Bash是Linux标准默认的Shell，它是BourneAgain Shell的缩写。我们这里主要讨论的也是 Bash。\n\n<!--more-->\nLinux常用命令表 ( 约60个常用命令)|\n\n|分类|命令|\n|-------------|---|\n|文件相关|`cd`, `whereis`, `pwd`, `ls`, `file`, `echo`, `mkdir/rmdir`, `cat/more`, `cp/mv/rm`, `chowm/chgrp`, `chmod`, `grep`, `find`, `locate`, `ln`, `gzip`, `tar`, `diff`, `patch`|\n|磁盘管理|`df`, `du`, `mount/umount`, `fdisk`, `mkfs`|\n|用户管理|`useradd`, `userdel`, `usermod`, `groupadd`, `groupdel`, `groupmod`, `groups`, `passwd`, `id`, `who`, `whoami`|\n|系统及相关|`su`, `sudo`, `export`, `shutdown`, `poweroff`,`halt`, `reboot`, `ps`, `top`, `uname`, `uptime`, `clear`, `cal`, `date/time`|\n|网络配置|`netstat`, `nslookup`, `finger`, `ping`, `ifconfig`, `ftp`, `telnet`, `ssh`|\n\n## Shell 编程\nShell 脚本（shell script），是一种为shell编写的脚本程序。\n> 简单的几点 shell 语法：\n* `#！`  指定sh解释程序\n* `#；`  注释\n* 关于空格， `=` 不加空格， 运算符要加空格。\n\n\n## Shell 变量\n### 用户自定义变量\n变量类型只支持字符串，不支持整形，字符，浮点;\n* 等号前后不要有空格\n* 一般变量命名用全大写\n* `unset` 命令删除变量赋值\n* `readonly` 标定只读变量\n* `export` 来指定global变量\n\n### 预定义变量\n* `$0` 与键入的命令行一样，包含脚本文件名\n* `$1, $2,...$9` 分别包含第一个到第九个命令行参数\n* `$#` 命令行参数的个数\n* `$@` 所有命令行参数\n* `$?` 前一个命令的退出状态\n* `$*` 所有命令行参数\n* `$$` 正在执行的进程ID号\n\n### 环境变量\n* `HOME`： 当前用户的主目录\n* `PATH`: shell搜索路径\n* `TERM`: 终端程序名称\n* `UID`: 当前用户的识别字，取值是由数位构成的字串。\n* `PWD`: 当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。\n* `PS1`: 主提示符，在特权用户下，默认的主提示符是#，在普通用户下，默认的主提示符是$。# , $\n* `PS2`: 在Shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“\\”然后回车，或者当用户按回车键时Shell判断出用户输入的命令没有结束时，就显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是>\n\n### 字符串\n字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。\n\n* 单引号\n ````\n str='this is a string'````\n 单引号字符串的限制：\n  * 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n  * 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n\n* 双引号\n ````shell\n your_name='qinjx'\n str=\"Hello, I know your are \\\"$your_name\\\"! \\n\"\n ````\n 双引号的优点：\n  * 双引号里可以有变量\n  * 双引号里可以出现转义字符\n\n* 拼接字符串\n ````shell\n your_name=\"qinjx\"\n greeting=\"hello, \"$your_name\" !\"\n greeting_1=\"hello, ${your_name} !\"\n echo $greeting $greeting_1\n ````\n\n* 获取字符串长度\n ````shell\n string=\"abcd\"\n echo ${#string} #输出 4````\n\n* 提取子字符串\n 以下实例从字符串第 `2` 个字符开始截取 `4` 个字符：\n ````shell\n string=\"runoob is a great site\"\n echo ${string:1:4} # 输出 unoo````\n\n* 查找子字符串\n 查找字符 `i` 或 `s` 的位置：\n ````\n string=\"runoob is a great company\"\n echo `expr index \"$string\" is`  # 输出 8````\n 注意： 以上脚本中 ` 是反引号，而不是单引号，不要看错了哦。\n\n### Shell 数组\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。\n类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。\n\n* 定义数组\n 在Shell中，用括号来表示数组，数组元素用\"空格\"符号分割开。定义数组的一般形式为：\n `数组名=(值1 值2 ... 值n)`\n 例如：\n ````shell\n array_name=(value0 value1 value2 value3)````\n 或者\n ````shell\n array_name=(\n value0\n value1\n value2\n value3\n )````\n 还可以单独定义数组的各个分量：\n ````shell\n array_name[0]=value0\n array_name[1]=value1\n array_name[n]=valuen````\n 可以不使用连续的下标，而且下标的范围没有限制。\n\n* 读取数组\n 读取数组元素值的一般格式是：\n `${数组名[下标]}`\n 例如：\n `valuen=${array_name[n]}`\n 使用@符号可以获取数组中的所有元素，例如：\n `echo ${array_name[@]}`\n\n* 获取数组的长度\n 获取数组长度的方法与获取字符串长度的方法相同，例如：\n ````shell\n# 取得数组元素的个数\nlength=${#array_name[@]}\n# 或者\nlength=${#array_name[*]}\n# 取得数组单个元素的长度\nlengthn=${#array_name[n]}````\n\n## Shell 语句\n### 基本运算符\nShell 和其他编程语言一样，支持多种运算符，原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：\n````shell\n#!/bin/bash\nval=`expr 2 + 2`\necho \"两数之和为 : $val\"````\n执行脚本，输出结果如下所示：\n> 两数之和为 : 4\n\n注意：\n * 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n * 完整的表达式要被 \\` \\` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。\n * 乘号(*)前边必须加反斜杠(\\\\)才能实现乘法运算.\n\n常用的运算符如下：\n\n|运算符|说明|举例|\n|--|--|--|\n|+|加法|expr $a + $b 结果为 30。|\n|-|减法|expr $a - $b 结果为 -10。|\n|*|乘法|expr $a \\* $b 结果为  200。|\n|/|除法|expr $b / $a 结果为 2。|\n|%|取余|expr $b % $a 结果为 0。|\n|=|赋值|a=$b 将把变量 b 的值赋给 a。|\n|==|相等。用于比较两个数字，相同则返回 true。|[ $a == $b ] 返回 false。|\n|!=|不相等。用于比较两个数字，不相同则返回 true。|[ $a != $b ] 返回 true。|\n|-eq|检测两个数是否相等，相等返回 true。|[ $a -eq $b ] 返回 false。|\n|-ne|检测两个数是否相等，不相等返回 true。|[ $a -ne $b ] 返回 true。|\n|-gt|检测左边的数是否大于右边的，如果是，则返回 true。|[ $a -gt $b ] 返回 false。|\n|-lt|检测左边的数是否小于右边的，如果是，则返回 true。|[ $a -lt $b ] 返回 true。|\n|-ge|检测左边的数是否大于等于右边的，如果是，则返回 true。|[ $a -ge $b ] 返回 false。|\n|-le|检测左边的数是否小于等于右边的，如果是，则返回 true。|[ $a -le $b ] 返回 true。|\n|!|非运算，表达式为 true 则返回 false，否则返回 true。|[ ! false ] 返回 true。|\n|-o|或运算，有一个表达式为 true 则返回 true。|[ $a -lt 20 -o $b -gt 100 ] 返回 true。|\n|-a|与运算，两个表达式都为 true 才返回 true。|[ $a -lt 20 -a $b -gt 100 ] 返回 false。|\n|&&|逻辑的 AND|[[ $a -lt 100 && $b -gt 100 ]] 返回 false|\n|II|逻辑的 OR|[[ $a -lt 100 II $b -gt 100 ]] 返回 true|\n|=|检测两个字符串是否相等，相等返回 true。|[ $a = $b ] 返回 false。|\n|!=|检测两个字符串是否相等，不相等返回 true。|[ $a != $b ] 返回 true。|\n|-z|检测字符串长度是否为0，为0返回 true。|[ -z $a ] 返回 false。|\n|-n|检测字符串长度是否为0，不为0返回 true。|[ -n $a ] 返回 true。|\n|str|检测字符串是否为空，不为空返回 true。|[ $a ] 返回 true。|\n|-b file|检测文件是否是块设备文件，如果是，则返回 true。|[ -b $file ] 返回 false。|\n|-c file|检测文件是否是字符设备文件，如果是，则返回 true。|[ -c $file ] 返回 false。|\n|-d file|检测文件是否是目录，如果是，则返回 true。|[ -d $file ] 返回 false。|\n|-f file|检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。|[ -f $file ] 返回 true。|\n|-g file|检测文件是否设置了 SGID 位，如果是，则返回 true。|[ -g $file ] 返回 false。|\n|-k file|检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。|[ -k $file ] 返回 false。|\n|-p file|检测文件是否是有名管道，如果是，则返回 true。|[ -p $file ] 返回 false。|\n|-u file|检测文件是否设置了 SUID 位，如果是，则返回 true。|[ -u $file ] 返回 false。|\n|-r file|检测文件是否可读，如果是，则返回 true。|[ -r $file ] 返回 true。|\n|-w file|检测文件是否可写，如果是，则返回 true。|[ -w $file ] 返回 true。|\n|-x file|检测文件是否可执行，如果是，则返回 true。|[ -x $file ] 返回 true。|\n|-s file|检测文件是否为空（文件大小是否大于0），不为空返回 true。|[ -s $file ] 返回 true。|\n|-e file|检测文件（包括目录）是否存在，如果是，则返回 true。|[ -e $file ] 返回 true。|\n\n### shell 内部命令\n* `echo` 输出\n* `exec`\n* `exit` 退出\n* `read` 从标准输入读取一行并且赋值给后面变量\n ````shell\n read var\n read var1 var2 var3 ````\n* `expr` 常见的算术运算 `+ ， - ， \\* ， / ， %`\n  注意，运算符左右两边都需要有空格，否则会视为字符串连接\n* `test` 测试结果也常常用来作为判断条件及结果\n ````\n test \"$answer\" = \"yes\"\n test $num -eq 18\n test -d temp````\n 可以用[]代替test  ， 但需要左右留有一个空格 ，比如\n  ```` \n  [ \"$answer\" = \"yes\" ]\n  if [ $num -eq 18 ]````\n \n### 结构性语句\n* 条件\n 1. `if`语句\n ````\n if...then...fi\n if [exp]\n then [command]\n fi````\n 2. `if else` 语句\n  ````\n if [exp]\n then [command]\n else [command]\n if````\n 3. `case...esac` 语句\n ````\n case [var] in\n [param1])\n [command]\n ;;\n [param2])\n [command]\n ;;\n [paramn])\n [command】\n ;;\n esac\n 注意：var只能是字符串型变量  ````\n\n\n* 循环\n 1.\tfor...do...done\n  ````\n for [var] in [list]\n do\n  [command]\n done````\n 2.\twhile...do...done\n  ````\n  while [exp]\n  do\n  [command]\n  done````\n 3.\tuntil...do...done\n  ````\n  until [exp]\n  do\n  [command]\n  done````\n 4. break, continue\n\n## Shell 函数\n * 定义格式\n ````\nfunction_name()\n{\n  command1\n  ...\n  commandn\n}\n \nfunction function_name()\n{\n  command1\n  ...\n  commandn\n}\n ````\n 说明：\n  * 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n  * 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\n * 调用函数\n ````\n[var]=`function_name [arg1,arg2...]` \ndo(fdf,dfdfd)\ndo fdf fdfdd\nfunction_name [arg1,arg2...]\necho $?````\n 说明：\n  * 函数返回值在调用该函数后通过 $? 来获得。\n  * 所有函数在使用前必须定义。调用函数仅使用其函数名即可。\n  * 调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，当n>=10时，需要使用${n}来获取参数。\n\n## Shell 文件包含\nShell 文件包含的语法格式如下：\n````shell\n. filename # 注意点号(.)和文件名中间有一空格\n或\nsource filename````\n\n\n\n\n","slug":"Linux学习总结02","published":1,"updated":"2017-12-06T13:37:37.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0e000tbkw17ft9ribw","content":"<p>Shell 是 Unix 系统下的一个命令解释器，主要用于系统和用户的交互。在 Unix 上有各种不同版本的 Shell，Bash是Linux标准默认的Shell，它是BourneAgain Shell的缩写。我们这里主要讨论的也是 Bash。</p>\n<a id=\"more\"></a>\n<p>Linux常用命令表 ( 约60个常用命令)|</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文件相关</td>\n<td><code>cd</code>, <code>whereis</code>, <code>pwd</code>, <code>ls</code>, <code>file</code>, <code>echo</code>, <code>mkdir/rmdir</code>, <code>cat/more</code>, <code>cp/mv/rm</code>, <code>chowm/chgrp</code>, <code>chmod</code>, <code>grep</code>, <code>find</code>, <code>locate</code>, <code>ln</code>, <code>gzip</code>, <code>tar</code>, <code>diff</code>, <code>patch</code></td>\n</tr>\n<tr>\n<td>磁盘管理</td>\n<td><code>df</code>, <code>du</code>, <code>mount/umount</code>, <code>fdisk</code>, <code>mkfs</code></td>\n</tr>\n<tr>\n<td>用户管理</td>\n<td><code>useradd</code>, <code>userdel</code>, <code>usermod</code>, <code>groupadd</code>, <code>groupdel</code>, <code>groupmod</code>, <code>groups</code>, <code>passwd</code>, <code>id</code>, <code>who</code>, <code>whoami</code></td>\n</tr>\n<tr>\n<td>系统及相关</td>\n<td><code>su</code>, <code>sudo</code>, <code>export</code>, <code>shutdown</code>, <code>poweroff</code>,<code>halt</code>, <code>reboot</code>, <code>ps</code>, <code>top</code>, <code>uname</code>, <code>uptime</code>, <code>clear</code>, <code>cal</code>, <code>date/time</code></td>\n</tr>\n<tr>\n<td>网络配置</td>\n<td><code>netstat</code>, <code>nslookup</code>, <code>finger</code>, <code>ping</code>, <code>ifconfig</code>, <code>ftp</code>, <code>telnet</code>, <code>ssh</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Shell-编程\"><a href=\"#Shell-编程\" class=\"headerlink\" title=\"Shell 编程\"></a>Shell 编程</h2><p>Shell 脚本（shell script），是一种为shell编写的脚本程序。</p>\n<blockquote>\n<p>简单的几点 shell 语法：</p>\n<ul>\n<li><code>#！</code>  指定sh解释程序</li>\n<li><code>#；</code>  注释</li>\n<li>关于空格， <code>=</code> 不加空格， 运算符要加空格。</li>\n</ul>\n</blockquote>\n<h2 id=\"Shell-变量\"><a href=\"#Shell-变量\" class=\"headerlink\" title=\"Shell 变量\"></a>Shell 变量</h2><h3 id=\"用户自定义变量\"><a href=\"#用户自定义变量\" class=\"headerlink\" title=\"用户自定义变量\"></a>用户自定义变量</h3><p>变量类型只支持字符串，不支持整形，字符，浮点;</p>\n<ul>\n<li>等号前后不要有空格</li>\n<li>一般变量命名用全大写</li>\n<li><code>unset</code> 命令删除变量赋值</li>\n<li><code>readonly</code> 标定只读变量</li>\n<li><code>export</code> 来指定global变量</li>\n</ul>\n<h3 id=\"预定义变量\"><a href=\"#预定义变量\" class=\"headerlink\" title=\"预定义变量\"></a>预定义变量</h3><ul>\n<li><code>$0</code> 与键入的命令行一样，包含脚本文件名</li>\n<li><code>$1, $2,...$9</code> 分别包含第一个到第九个命令行参数</li>\n<li><code>$#</code> 命令行参数的个数</li>\n<li><code>$@</code> 所有命令行参数</li>\n<li><code>$?</code> 前一个命令的退出状态</li>\n<li><code>$*</code> 所有命令行参数</li>\n<li><code>$$</code> 正在执行的进程ID号</li>\n</ul>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><ul>\n<li><code>HOME</code>： 当前用户的主目录</li>\n<li><code>PATH</code>: shell搜索路径</li>\n<li><code>TERM</code>: 终端程序名称</li>\n<li><code>UID</code>: 当前用户的识别字，取值是由数位构成的字串。</li>\n<li><code>PWD</code>: 当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。</li>\n<li><code>PS1</code>: 主提示符，在特权用户下，默认的主提示符是#，在普通用户下，默认的主提示符是$。# , $</li>\n<li><code>PS2</code>: 在Shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“\\”然后回车，或者当用户按回车键时Shell判断出用户输入的命令没有结束时，就显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是&gt;</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>\n<ul>\n<li><p>单引号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str=&apos;this is a string&apos;</div></pre></td></tr></table></figure>\n<p>单引号字符串的限制：</p>\n<ul>\n<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>\n<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</li>\n</ul>\n</li>\n<li><p>双引号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">your_name=&apos;qinjx&apos;</div><div class=\"line\">str=&quot;Hello, I know your are \\&quot;$your_name\\&quot;! \\n&quot;</div></pre></td></tr></table></figure>\n<p>双引号的优点：</p>\n<ul>\n<li>双引号里可以有变量</li>\n<li>双引号里可以出现转义字符</li>\n</ul>\n</li>\n<li><p>拼接字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">your_name=&quot;qinjx&quot;</div><div class=\"line\">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</div><div class=\"line\">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</div><div class=\"line\">echo $greeting $greeting_1</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取字符串长度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string=&quot;abcd&quot;</div><div class=\"line\">echo $&#123;#string&#125; #输出 4</div></pre></td></tr></table></figure>\n</li>\n<li><p>提取子字符串<br>以下实例从字符串第 <code>2</code> 个字符开始截取 <code>4</code> 个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string=&quot;runoob is a great site&quot;</div><div class=\"line\">echo $&#123;string:1:4&#125; # 输出 unoo</div></pre></td></tr></table></figure>\n</li>\n<li><p>查找子字符串<br>查找字符 <code>i</code> 或 <code>s</code> 的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string=&quot;runoob is a great company&quot;</div><div class=\"line\">echo `expr index &quot;$string&quot; is`  # 输出 8</div></pre></td></tr></table></figure>\n<p>注意： 以上脚本中 ` 是反引号，而不是单引号，不要看错了哦。</p>\n</li>\n</ul>\n<h3 id=\"Shell-数组\"><a href=\"#Shell-数组\" class=\"headerlink\" title=\"Shell 数组\"></a>Shell 数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。<br>类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>\n<ul>\n<li><p>定义数组<br>在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<br><code>数组名=(值1 值2 ... 值n)</code><br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">array_name=(value0 value1 value2 value3)</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">array_name=(</div><div class=\"line\">value0</div><div class=\"line\">value1</div><div class=\"line\">value2</div><div class=\"line\">value3</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>还可以单独定义数组的各个分量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">array_name[0]=value0</div><div class=\"line\">array_name[1]=value1</div><div class=\"line\">array_name[n]=valuen</div></pre></td></tr></table></figure>\n<p>可以不使用连续的下标，而且下标的范围没有限制。</p>\n</li>\n<li><p>读取数组<br>读取数组元素值的一般格式是：<br><code>${数组名[下标]}</code><br>例如：<br><code>valuen=${array_name[n]}</code><br>使用@符号可以获取数组中的所有元素，例如：<br><code>echo ${array_name[@]}</code></p>\n</li>\n<li><p>获取数组的长度<br>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 取得数组元素的个数</div><div class=\"line\">length=$&#123;#array_name[@]&#125;</div><div class=\"line\"># 或者</div><div class=\"line\">length=$&#123;#array_name[*]&#125;</div><div class=\"line\"># 取得数组单个元素的长度</div><div class=\"line\">lengthn=$&#123;#array_name[n]&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Shell-语句\"><a href=\"#Shell-语句\" class=\"headerlink\" title=\"Shell 语句\"></a>Shell 语句</h2><h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><p>Shell 和其他编程语言一样，支持多种运算符，原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。<br>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。<br>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\">val=`expr 2 + 2`</div><div class=\"line\">echo &quot;两数之和为 : $val&quot;</div></pre></td></tr></table></figure></p>\n<p>执行脚本，输出结果如下所示：</p>\n<blockquote>\n<p>两数之和为 : 4</p>\n</blockquote>\n<p>注意：</p>\n<ul>\n<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>\n<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>\n<li>乘号(*)前边必须加反斜杠(\\)才能实现乘法运算.</li>\n</ul>\n<p>常用的运算符如下：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>加法</td>\n<td>expr $a + $b 结果为 30。</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n<td>expr $a - $b 结果为 -10。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n<td>expr $a * $b 结果为  200。</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n<td>expr $b / $a 结果为 2。</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余</td>\n<td>expr $b % $a 结果为 0。</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n<td>a=$b 将把变量 b 的值赋给 a。</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等。用于比较两个数字，相同则返回 true。</td>\n<td>[ $a == $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等。用于比较两个数字，不相同则返回 true。</td>\n<td>[ $a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-eq</td>\n<td>检测两个数是否相等，相等返回 true。</td>\n<td>[ $a -eq $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>检测两个数是否相等，不相等返回 true。</td>\n<td>[ $a -ne $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>\n<td>[ $a -gt $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>\n<td>[ $a -lt $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>\n<td>[ $a -ge $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n<td>[ $a -le $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>\n<td>[ ! false ] 返回 true。</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>或运算，有一个表达式为 true 则返回 true。</td>\n<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>与运算，两个表达式都为 true 才返回 true。</td>\n<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑的 AND</td>\n<td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>\n</tr>\n<tr>\n<td>II</td>\n<td>逻辑的 OR</td>\n<td>[[ $a -lt 100 II $b -gt 100 ]] 返回 true</td>\n</tr>\n<tr>\n<td>=</td>\n<td>检测两个字符串是否相等，相等返回 true。</td>\n<td>[ $a = $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检测两个字符串是否相等，不相等返回 true。</td>\n<td>[ $a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>检测字符串长度是否为0，为0返回 true。</td>\n<td>[ -z $a ] 返回 false。</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>检测字符串长度是否为0，不为0返回 true。</td>\n<td>[ -n $a ] 返回 true。</td>\n</tr>\n<tr>\n<td>str</td>\n<td>检测字符串是否为空，不为空返回 true。</td>\n<td>[ $a ] 返回 true。</td>\n</tr>\n<tr>\n<td>-b file</td>\n<td>检测文件是否是块设备文件，如果是，则返回 true。</td>\n<td>[ -b $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-c file</td>\n<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>\n<td>[ -c $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-d file</td>\n<td>检测文件是否是目录，如果是，则返回 true。</td>\n<td>[ -d $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n<td>[ -f $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-g file</td>\n<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n<td>[ -g $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-k file</td>\n<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n<td>[ -k $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-p file</td>\n<td>检测文件是否是有名管道，如果是，则返回 true。</td>\n<td>[ -p $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-u file</td>\n<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n<td>[ -u $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>检测文件是否可读，如果是，则返回 true。</td>\n<td>[ -r $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>检测文件是否可写，如果是，则返回 true。</td>\n<td>[ -w $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检测文件是否可执行，如果是，则返回 true。</td>\n<td>[ -x $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>\n<td>[ -s $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n<td>[ -e $file ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"shell-内部命令\"><a href=\"#shell-内部命令\" class=\"headerlink\" title=\"shell 内部命令\"></a>shell 内部命令</h3><ul>\n<li><code>echo</code> 输出</li>\n<li><code>exec</code></li>\n<li><code>exit</code> 退出</li>\n<li><p><code>read</code> 从标准输入读取一行并且赋值给后面变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">read var</div><div class=\"line\">read var1 var2 var3</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>expr</code> 常见的算术运算 <code>+ ， - ， \\* ， / ， %</code><br>注意，运算符左右两边都需要有空格，否则会视为字符串连接</p>\n</li>\n<li><p><code>test</code> 测试结果也常常用来作为判断条件及结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test &quot;$answer&quot; = &quot;yes&quot;</div><div class=\"line\">test $num -eq 18</div><div class=\"line\">test -d temp</div></pre></td></tr></table></figure>\n<p>可以用[]代替test  ， 但需要左右留有一个空格 ，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ &quot;$answer&quot; = &quot;yes&quot; ]</div><div class=\"line\">if [ $num -eq 18 ]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"结构性语句\"><a href=\"#结构性语句\" class=\"headerlink\" title=\"结构性语句\"></a>结构性语句</h3><ul>\n<li><p>条件</p>\n<ol>\n<li><p><code>if</code>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if...then...fi</div><div class=\"line\">if [exp]</div><div class=\"line\">then [command]</div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>if else</code> 语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if [exp]</div><div class=\"line\">then [command]</div><div class=\"line\">else [command]</div><div class=\"line\">if</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>case...esac</code> 语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">case [var] in</div><div class=\"line\">[param1])</div><div class=\"line\">[command]</div><div class=\"line\">;;</div><div class=\"line\">[param2])</div><div class=\"line\">[command]</div><div class=\"line\">;;</div><div class=\"line\">[paramn])</div><div class=\"line\">[command】</div><div class=\"line\">;;</div><div class=\"line\">esac</div><div class=\"line\">注意：var只能是字符串型变量</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>循环</p>\n<ol>\n<li><p>for…do…done</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for [var] in [list]</div><div class=\"line\">do</div><div class=\"line\"> [command]</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n</li>\n<li><p>while…do…done</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">while [exp]</div><div class=\"line\">do</div><div class=\"line\">[command]</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n</li>\n<li><p>until…do…done</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">until [exp]</div><div class=\"line\">do</div><div class=\"line\">[command]</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n</li>\n<li><p>break, continue</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Shell-函数\"><a href=\"#Shell-函数\" class=\"headerlink\" title=\"Shell 函数\"></a>Shell 函数</h2><ul>\n<li><p>定义格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function_name()</div><div class=\"line\">&#123;</div><div class=\"line\">  command1</div><div class=\"line\">  ...</div><div class=\"line\">  commandn</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">function function_name()</div><div class=\"line\">&#123;</div><div class=\"line\">  command1</div><div class=\"line\">  ...</div><div class=\"line\">  commandn</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>\n<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li>\n</ul>\n</li>\n<li><p>调用函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[var]=`function_name [arg1,arg2...]` </div><div class=\"line\">do(fdf,dfdfd)</div><div class=\"line\">do fdf fdfdd</div><div class=\"line\">function_name [arg1,arg2...]</div><div class=\"line\">echo $?</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>函数返回值在调用该函数后通过 $? 来获得。</li>\n<li>所有函数在使用前必须定义。调用函数仅使用其函数名即可。</li>\n<li>调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，当n&gt;=10时，需要使用${n}来获取参数。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Shell-文件包含\"><a href=\"#Shell-文件包含\" class=\"headerlink\" title=\"Shell 文件包含\"></a>Shell 文件包含</h2><p>Shell 文件包含的语法格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">. filename # 注意点号(.)和文件名中间有一空格</div><div class=\"line\">或</div><div class=\"line\">source filename</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>Shell 是 Unix 系统下的一个命令解释器，主要用于系统和用户的交互。在 Unix 上有各种不同版本的 Shell，Bash是Linux标准默认的Shell，它是BourneAgain Shell的缩写。我们这里主要讨论的也是 Bash。</p>","more":"<p>Linux常用命令表 ( 约60个常用命令)|</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文件相关</td>\n<td><code>cd</code>, <code>whereis</code>, <code>pwd</code>, <code>ls</code>, <code>file</code>, <code>echo</code>, <code>mkdir/rmdir</code>, <code>cat/more</code>, <code>cp/mv/rm</code>, <code>chowm/chgrp</code>, <code>chmod</code>, <code>grep</code>, <code>find</code>, <code>locate</code>, <code>ln</code>, <code>gzip</code>, <code>tar</code>, <code>diff</code>, <code>patch</code></td>\n</tr>\n<tr>\n<td>磁盘管理</td>\n<td><code>df</code>, <code>du</code>, <code>mount/umount</code>, <code>fdisk</code>, <code>mkfs</code></td>\n</tr>\n<tr>\n<td>用户管理</td>\n<td><code>useradd</code>, <code>userdel</code>, <code>usermod</code>, <code>groupadd</code>, <code>groupdel</code>, <code>groupmod</code>, <code>groups</code>, <code>passwd</code>, <code>id</code>, <code>who</code>, <code>whoami</code></td>\n</tr>\n<tr>\n<td>系统及相关</td>\n<td><code>su</code>, <code>sudo</code>, <code>export</code>, <code>shutdown</code>, <code>poweroff</code>,<code>halt</code>, <code>reboot</code>, <code>ps</code>, <code>top</code>, <code>uname</code>, <code>uptime</code>, <code>clear</code>, <code>cal</code>, <code>date/time</code></td>\n</tr>\n<tr>\n<td>网络配置</td>\n<td><code>netstat</code>, <code>nslookup</code>, <code>finger</code>, <code>ping</code>, <code>ifconfig</code>, <code>ftp</code>, <code>telnet</code>, <code>ssh</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Shell-编程\"><a href=\"#Shell-编程\" class=\"headerlink\" title=\"Shell 编程\"></a>Shell 编程</h2><p>Shell 脚本（shell script），是一种为shell编写的脚本程序。</p>\n<blockquote>\n<p>简单的几点 shell 语法：</p>\n<ul>\n<li><code>#！</code>  指定sh解释程序</li>\n<li><code>#；</code>  注释</li>\n<li>关于空格， <code>=</code> 不加空格， 运算符要加空格。</li>\n</ul>\n</blockquote>\n<h2 id=\"Shell-变量\"><a href=\"#Shell-变量\" class=\"headerlink\" title=\"Shell 变量\"></a>Shell 变量</h2><h3 id=\"用户自定义变量\"><a href=\"#用户自定义变量\" class=\"headerlink\" title=\"用户自定义变量\"></a>用户自定义变量</h3><p>变量类型只支持字符串，不支持整形，字符，浮点;</p>\n<ul>\n<li>等号前后不要有空格</li>\n<li>一般变量命名用全大写</li>\n<li><code>unset</code> 命令删除变量赋值</li>\n<li><code>readonly</code> 标定只读变量</li>\n<li><code>export</code> 来指定global变量</li>\n</ul>\n<h3 id=\"预定义变量\"><a href=\"#预定义变量\" class=\"headerlink\" title=\"预定义变量\"></a>预定义变量</h3><ul>\n<li><code>$0</code> 与键入的命令行一样，包含脚本文件名</li>\n<li><code>$1, $2,...$9</code> 分别包含第一个到第九个命令行参数</li>\n<li><code>$#</code> 命令行参数的个数</li>\n<li><code>$@</code> 所有命令行参数</li>\n<li><code>$?</code> 前一个命令的退出状态</li>\n<li><code>$*</code> 所有命令行参数</li>\n<li><code>$$</code> 正在执行的进程ID号</li>\n</ul>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><ul>\n<li><code>HOME</code>： 当前用户的主目录</li>\n<li><code>PATH</code>: shell搜索路径</li>\n<li><code>TERM</code>: 终端程序名称</li>\n<li><code>UID</code>: 当前用户的识别字，取值是由数位构成的字串。</li>\n<li><code>PWD</code>: 当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。</li>\n<li><code>PS1</code>: 主提示符，在特权用户下，默认的主提示符是#，在普通用户下，默认的主提示符是$。# , $</li>\n<li><code>PS2</code>: 在Shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“\\”然后回车，或者当用户按回车键时Shell判断出用户输入的命令没有结束时，就显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是&gt;</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>\n<ul>\n<li><p>单引号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str=&apos;this is a string&apos;</div></pre></td></tr></table></figure>\n<p>单引号字符串的限制：</p>\n<ul>\n<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>\n<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</li>\n</ul>\n</li>\n<li><p>双引号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">your_name=&apos;qinjx&apos;</div><div class=\"line\">str=&quot;Hello, I know your are \\&quot;$your_name\\&quot;! \\n&quot;</div></pre></td></tr></table></figure>\n<p>双引号的优点：</p>\n<ul>\n<li>双引号里可以有变量</li>\n<li>双引号里可以出现转义字符</li>\n</ul>\n</li>\n<li><p>拼接字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">your_name=&quot;qinjx&quot;</div><div class=\"line\">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</div><div class=\"line\">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</div><div class=\"line\">echo $greeting $greeting_1</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取字符串长度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string=&quot;abcd&quot;</div><div class=\"line\">echo $&#123;#string&#125; #输出 4</div></pre></td></tr></table></figure>\n</li>\n<li><p>提取子字符串<br>以下实例从字符串第 <code>2</code> 个字符开始截取 <code>4</code> 个字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string=&quot;runoob is a great site&quot;</div><div class=\"line\">echo $&#123;string:1:4&#125; # 输出 unoo</div></pre></td></tr></table></figure>\n</li>\n<li><p>查找子字符串<br>查找字符 <code>i</code> 或 <code>s</code> 的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string=&quot;runoob is a great company&quot;</div><div class=\"line\">echo `expr index &quot;$string&quot; is`  # 输出 8</div></pre></td></tr></table></figure>\n<p>注意： 以上脚本中 ` 是反引号，而不是单引号，不要看错了哦。</p>\n</li>\n</ul>\n<h3 id=\"Shell-数组\"><a href=\"#Shell-数组\" class=\"headerlink\" title=\"Shell 数组\"></a>Shell 数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。<br>类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>\n<ul>\n<li><p>定义数组<br>在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<br><code>数组名=(值1 值2 ... 值n)</code><br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">array_name=(value0 value1 value2 value3)</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">array_name=(</div><div class=\"line\">value0</div><div class=\"line\">value1</div><div class=\"line\">value2</div><div class=\"line\">value3</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>还可以单独定义数组的各个分量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">array_name[0]=value0</div><div class=\"line\">array_name[1]=value1</div><div class=\"line\">array_name[n]=valuen</div></pre></td></tr></table></figure>\n<p>可以不使用连续的下标，而且下标的范围没有限制。</p>\n</li>\n<li><p>读取数组<br>读取数组元素值的一般格式是：<br><code>${数组名[下标]}</code><br>例如：<br><code>valuen=${array_name[n]}</code><br>使用@符号可以获取数组中的所有元素，例如：<br><code>echo ${array_name[@]}</code></p>\n</li>\n<li><p>获取数组的长度<br>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 取得数组元素的个数</div><div class=\"line\">length=$&#123;#array_name[@]&#125;</div><div class=\"line\"># 或者</div><div class=\"line\">length=$&#123;#array_name[*]&#125;</div><div class=\"line\"># 取得数组单个元素的长度</div><div class=\"line\">lengthn=$&#123;#array_name[n]&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Shell-语句\"><a href=\"#Shell-语句\" class=\"headerlink\" title=\"Shell 语句\"></a>Shell 语句</h2><h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><p>Shell 和其他编程语言一样，支持多种运算符，原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。<br>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。<br>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\">val=`expr 2 + 2`</div><div class=\"line\">echo &quot;两数之和为 : $val&quot;</div></pre></td></tr></table></figure></p>\n<p>执行脚本，输出结果如下所示：</p>\n<blockquote>\n<p>两数之和为 : 4</p>\n</blockquote>\n<p>注意：</p>\n<ul>\n<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>\n<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>\n<li>乘号(*)前边必须加反斜杠(\\)才能实现乘法运算.</li>\n</ul>\n<p>常用的运算符如下：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>加法</td>\n<td>expr $a + $b 结果为 30。</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n<td>expr $a - $b 结果为 -10。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n<td>expr $a * $b 结果为  200。</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n<td>expr $b / $a 结果为 2。</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余</td>\n<td>expr $b % $a 结果为 0。</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n<td>a=$b 将把变量 b 的值赋给 a。</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等。用于比较两个数字，相同则返回 true。</td>\n<td>[ $a == $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等。用于比较两个数字，不相同则返回 true。</td>\n<td>[ $a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-eq</td>\n<td>检测两个数是否相等，相等返回 true。</td>\n<td>[ $a -eq $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>检测两个数是否相等，不相等返回 true。</td>\n<td>[ $a -ne $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>\n<td>[ $a -gt $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>\n<td>[ $a -lt $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>\n<td>[ $a -ge $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n<td>[ $a -le $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>\n<td>[ ! false ] 返回 true。</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>或运算，有一个表达式为 true 则返回 true。</td>\n<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>与运算，两个表达式都为 true 才返回 true。</td>\n<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑的 AND</td>\n<td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>\n</tr>\n<tr>\n<td>II</td>\n<td>逻辑的 OR</td>\n<td>[[ $a -lt 100 II $b -gt 100 ]] 返回 true</td>\n</tr>\n<tr>\n<td>=</td>\n<td>检测两个字符串是否相等，相等返回 true。</td>\n<td>[ $a = $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检测两个字符串是否相等，不相等返回 true。</td>\n<td>[ $a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>检测字符串长度是否为0，为0返回 true。</td>\n<td>[ -z $a ] 返回 false。</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>检测字符串长度是否为0，不为0返回 true。</td>\n<td>[ -n $a ] 返回 true。</td>\n</tr>\n<tr>\n<td>str</td>\n<td>检测字符串是否为空，不为空返回 true。</td>\n<td>[ $a ] 返回 true。</td>\n</tr>\n<tr>\n<td>-b file</td>\n<td>检测文件是否是块设备文件，如果是，则返回 true。</td>\n<td>[ -b $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-c file</td>\n<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>\n<td>[ -c $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-d file</td>\n<td>检测文件是否是目录，如果是，则返回 true。</td>\n<td>[ -d $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n<td>[ -f $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-g file</td>\n<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n<td>[ -g $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-k file</td>\n<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n<td>[ -k $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-p file</td>\n<td>检测文件是否是有名管道，如果是，则返回 true。</td>\n<td>[ -p $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-u file</td>\n<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n<td>[ -u $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>检测文件是否可读，如果是，则返回 true。</td>\n<td>[ -r $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>检测文件是否可写，如果是，则返回 true。</td>\n<td>[ -w $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检测文件是否可执行，如果是，则返回 true。</td>\n<td>[ -x $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>\n<td>[ -s $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n<td>[ -e $file ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"shell-内部命令\"><a href=\"#shell-内部命令\" class=\"headerlink\" title=\"shell 内部命令\"></a>shell 内部命令</h3><ul>\n<li><code>echo</code> 输出</li>\n<li><code>exec</code></li>\n<li><code>exit</code> 退出</li>\n<li><p><code>read</code> 从标准输入读取一行并且赋值给后面变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">read var</div><div class=\"line\">read var1 var2 var3</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>expr</code> 常见的算术运算 <code>+ ， - ， \\* ， / ， %</code><br>注意，运算符左右两边都需要有空格，否则会视为字符串连接</p>\n</li>\n<li><p><code>test</code> 测试结果也常常用来作为判断条件及结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test &quot;$answer&quot; = &quot;yes&quot;</div><div class=\"line\">test $num -eq 18</div><div class=\"line\">test -d temp</div></pre></td></tr></table></figure>\n<p>可以用[]代替test  ， 但需要左右留有一个空格 ，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ &quot;$answer&quot; = &quot;yes&quot; ]</div><div class=\"line\">if [ $num -eq 18 ]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"结构性语句\"><a href=\"#结构性语句\" class=\"headerlink\" title=\"结构性语句\"></a>结构性语句</h3><ul>\n<li><p>条件</p>\n<ol>\n<li><p><code>if</code>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if...then...fi</div><div class=\"line\">if [exp]</div><div class=\"line\">then [command]</div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>if else</code> 语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if [exp]</div><div class=\"line\">then [command]</div><div class=\"line\">else [command]</div><div class=\"line\">if</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>case...esac</code> 语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">case [var] in</div><div class=\"line\">[param1])</div><div class=\"line\">[command]</div><div class=\"line\">;;</div><div class=\"line\">[param2])</div><div class=\"line\">[command]</div><div class=\"line\">;;</div><div class=\"line\">[paramn])</div><div class=\"line\">[command】</div><div class=\"line\">;;</div><div class=\"line\">esac</div><div class=\"line\">注意：var只能是字符串型变量</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>循环</p>\n<ol>\n<li><p>for…do…done</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for [var] in [list]</div><div class=\"line\">do</div><div class=\"line\"> [command]</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n</li>\n<li><p>while…do…done</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">while [exp]</div><div class=\"line\">do</div><div class=\"line\">[command]</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n</li>\n<li><p>until…do…done</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">until [exp]</div><div class=\"line\">do</div><div class=\"line\">[command]</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n</li>\n<li><p>break, continue</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Shell-函数\"><a href=\"#Shell-函数\" class=\"headerlink\" title=\"Shell 函数\"></a>Shell 函数</h2><ul>\n<li><p>定义格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function_name()</div><div class=\"line\">&#123;</div><div class=\"line\">  command1</div><div class=\"line\">  ...</div><div class=\"line\">  commandn</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">function function_name()</div><div class=\"line\">&#123;</div><div class=\"line\">  command1</div><div class=\"line\">  ...</div><div class=\"line\">  commandn</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>\n<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li>\n</ul>\n</li>\n<li><p>调用函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[var]=`function_name [arg1,arg2...]` </div><div class=\"line\">do(fdf,dfdfd)</div><div class=\"line\">do fdf fdfdd</div><div class=\"line\">function_name [arg1,arg2...]</div><div class=\"line\">echo $?</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>函数返回值在调用该函数后通过 $? 来获得。</li>\n<li>所有函数在使用前必须定义。调用函数仅使用其函数名即可。</li>\n<li>调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，当n&gt;=10时，需要使用${n}来获取参数。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Shell-文件包含\"><a href=\"#Shell-文件包含\" class=\"headerlink\" title=\"Shell 文件包含\"></a>Shell 文件包含</h2><p>Shell 文件包含的语法格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">. filename # 注意点号(.)和文件名中间有一空格</div><div class=\"line\">或</div><div class=\"line\">source filename</div></pre></td></tr></table></figure></p>"},{"title":"Linux学习总结（三）——Shell常见命令解析","date":"2016-12-16T05:20:25.000Z","_content":"Shell 的命令有很多，再加上相关软件的命令，更是多不胜数，这里总结了一些常见的。\n<!--more-->\n常见的命令大致也就可以分为这五类：\n * 文件相关：诸如文件及目录的创建/编辑/传输等\n * 磁盘相关：磁盘的检查/挂载/查看等\n * 系统相关：系统的相关设置等\n * 网络相关：网络的相关设置\n * 用户相关：用户的几个命令\n \n从今天开始，逐步将常见的 Shell 命令的用法总结一下，简单的仅仅做个记录，复杂的分析下用法。\n## 文件的相关命令\n`cd` 切换目录，几个常用的用法是：\n````Shell\n    cd  进入家目录\n    cd / 根目录\n    cd - 进入上次工作的目录````\n\n`whereis` 查找文件，查找的文件属性只能是原始代码(s)/二进制文件(b)/帮助文档(m)。\n加相应的文件代码参数小写查找指定类型；\n加相应的文件代码参数大写加目录在指定文件夹下查找;\n\n`pwd` 显示工作目录\n\n`file` 辨识文件类型。 \n\n`ls` 列出目录内容。\n-a或--all   下所有文件和目录。\n\n`echo` 显示一段文字，经常配合使用 `|` 管道来使用\n\n`cat` 将文件内容输出到标准输出\n-n 或 --number 由 1 开始对所有输出的行数编号\n\n`cp` 复制文件或目录\n-f或--force 　强行复制文件或目录，不论目标文件或目录是否已存在。 \n-l或--link 　对源文件建立硬连接，而非复制文件。 \n-r 　递归处理，将指定目录下的文件与子目录一并处理。 \n\n`mv` 移动或更名现有的文件或目录。\n\n`rm` 删除文件或目录。\n-d或--directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。 \n-f或--force 　强制删除文件或目录。 \n-i或--interactive 　删除既有文件或目录之前先询问用户。 \n-r或-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 \n\n`mkdir` 建立文件夹\n-m<目录属性>或--mode<目录属性>   建立目录时同时设置目录的权限。\n-p或--parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。\n \n`rmdir` 删除文件夹\n-p或--parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。\n\n`chowm/chgrp` 变更文件或目录的拥有者或所属群组。\n\n`chmod` 变更文件或目录的权限。\n\n`grep` 查找文件里符合条件的字符串。\n-c或--count   计算符合范本样式的列数。\n\n`find` 查找文件或目录。  \n-amin<分钟> 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。 \n-exec<执行指令> 　假设find指令的回传值为True，就执行该指令。 \n-name<范本样式> 　指定字符串作为寻找文件或目录的范本样式。 \n-size<文件大小> 　查找符合指定的文件大小的文件。 \n-type<文件类型> 　只寻找符合指定的文件类型的文件。 \n\n`locate` 查找文件。 \n\n`ln` 连接文件或目录。\n\n## 系统相关命令\n`alias` 设置指令的别名。\n\n`export`  设置或显示环境变量。\n\n`insmod` 载入模块。\n \n`lsmod` 显示已载入系统的模块。\n \n`modinfo` 显示kernel模块的信息。\n \n`rmmod` 删除模块\n\n`setenv` 查询或显示环境变量。\n \n`adduser` 新增用户帐号。\n \n`groupmod` 更改群组识别码或名称。\n  \n`su(super user)` 变更用户身份。\n \n`sudo` 以其他身份来执行指令。\n \n`free` 显示内存状态。\n \n`ps` 报告程序状况。\n \n`top` 显示，管理执行中的程序。\nn<执行次数> 　设置监控信息的更新次数。 \n\n`exit` 退出当前shell\n\n`kill` 删除执行中的程序或工作。\n \n`halt` 关闭系统。\n \n`reboot` 重新开机。\n \n`shutdown` `poweroff` 系统关机指令。\n \n\n## 磁盘管理\n`du(disk usage)` 显示目录或文件的大小。\n \n`lndir(link directory)` 连接目录内容。\n \n`stat` 显示inode内容。\n \n`tree` 以树状图列出目录的内容。\n \n`mount`,`umount` 挂载/卸除文件系统。\n \n`mkfs(make file system)` 建立各种文件系统。\n\n## 网络配置管理\n`netstat` \n常用的网络状态：\n`LISTEN` ：在监听状态中。  \n`ESTABLISHED` ：已建立联机的联机情况。\n`TIME_WAIT` ：该联机在目前已经是等待的状态。\n常用命令：\n`netstat -e `显示关于以太网的统计数据\n`netstat -r`显示关于路由表的信息\n`netstat -a`显示一个所有的有效连接信息列表\n`netstat -n`显示所有已建立的有效连接\n \n> 配置 `IP`, `Netmask`, `Gateway` 在 `/etc/network/interfaces`\n 配置 `DNS` 在 `/etc/resolv.conf`","source":"_posts/Linux学习总结03.md","raw":"---\ntitle: Linux学习总结（三）——Shell常见命令解析\ndate: 2016-12-16 13:20:25\ncategories: Linux学习记录\ntags: [Shell, 命令]\n---\nShell 的命令有很多，再加上相关软件的命令，更是多不胜数，这里总结了一些常见的。\n<!--more-->\n常见的命令大致也就可以分为这五类：\n * 文件相关：诸如文件及目录的创建/编辑/传输等\n * 磁盘相关：磁盘的检查/挂载/查看等\n * 系统相关：系统的相关设置等\n * 网络相关：网络的相关设置\n * 用户相关：用户的几个命令\n \n从今天开始，逐步将常见的 Shell 命令的用法总结一下，简单的仅仅做个记录，复杂的分析下用法。\n## 文件的相关命令\n`cd` 切换目录，几个常用的用法是：\n````Shell\n    cd  进入家目录\n    cd / 根目录\n    cd - 进入上次工作的目录````\n\n`whereis` 查找文件，查找的文件属性只能是原始代码(s)/二进制文件(b)/帮助文档(m)。\n加相应的文件代码参数小写查找指定类型；\n加相应的文件代码参数大写加目录在指定文件夹下查找;\n\n`pwd` 显示工作目录\n\n`file` 辨识文件类型。 \n\n`ls` 列出目录内容。\n-a或--all   下所有文件和目录。\n\n`echo` 显示一段文字，经常配合使用 `|` 管道来使用\n\n`cat` 将文件内容输出到标准输出\n-n 或 --number 由 1 开始对所有输出的行数编号\n\n`cp` 复制文件或目录\n-f或--force 　强行复制文件或目录，不论目标文件或目录是否已存在。 \n-l或--link 　对源文件建立硬连接，而非复制文件。 \n-r 　递归处理，将指定目录下的文件与子目录一并处理。 \n\n`mv` 移动或更名现有的文件或目录。\n\n`rm` 删除文件或目录。\n-d或--directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。 \n-f或--force 　强制删除文件或目录。 \n-i或--interactive 　删除既有文件或目录之前先询问用户。 \n-r或-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 \n\n`mkdir` 建立文件夹\n-m<目录属性>或--mode<目录属性>   建立目录时同时设置目录的权限。\n-p或--parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。\n \n`rmdir` 删除文件夹\n-p或--parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。\n\n`chowm/chgrp` 变更文件或目录的拥有者或所属群组。\n\n`chmod` 变更文件或目录的权限。\n\n`grep` 查找文件里符合条件的字符串。\n-c或--count   计算符合范本样式的列数。\n\n`find` 查找文件或目录。  \n-amin<分钟> 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。 \n-exec<执行指令> 　假设find指令的回传值为True，就执行该指令。 \n-name<范本样式> 　指定字符串作为寻找文件或目录的范本样式。 \n-size<文件大小> 　查找符合指定的文件大小的文件。 \n-type<文件类型> 　只寻找符合指定的文件类型的文件。 \n\n`locate` 查找文件。 \n\n`ln` 连接文件或目录。\n\n## 系统相关命令\n`alias` 设置指令的别名。\n\n`export`  设置或显示环境变量。\n\n`insmod` 载入模块。\n \n`lsmod` 显示已载入系统的模块。\n \n`modinfo` 显示kernel模块的信息。\n \n`rmmod` 删除模块\n\n`setenv` 查询或显示环境变量。\n \n`adduser` 新增用户帐号。\n \n`groupmod` 更改群组识别码或名称。\n  \n`su(super user)` 变更用户身份。\n \n`sudo` 以其他身份来执行指令。\n \n`free` 显示内存状态。\n \n`ps` 报告程序状况。\n \n`top` 显示，管理执行中的程序。\nn<执行次数> 　设置监控信息的更新次数。 \n\n`exit` 退出当前shell\n\n`kill` 删除执行中的程序或工作。\n \n`halt` 关闭系统。\n \n`reboot` 重新开机。\n \n`shutdown` `poweroff` 系统关机指令。\n \n\n## 磁盘管理\n`du(disk usage)` 显示目录或文件的大小。\n \n`lndir(link directory)` 连接目录内容。\n \n`stat` 显示inode内容。\n \n`tree` 以树状图列出目录的内容。\n \n`mount`,`umount` 挂载/卸除文件系统。\n \n`mkfs(make file system)` 建立各种文件系统。\n\n## 网络配置管理\n`netstat` \n常用的网络状态：\n`LISTEN` ：在监听状态中。  \n`ESTABLISHED` ：已建立联机的联机情况。\n`TIME_WAIT` ：该联机在目前已经是等待的状态。\n常用命令：\n`netstat -e `显示关于以太网的统计数据\n`netstat -r`显示关于路由表的信息\n`netstat -a`显示一个所有的有效连接信息列表\n`netstat -n`显示所有已建立的有效连接\n \n> 配置 `IP`, `Netmask`, `Gateway` 在 `/etc/network/interfaces`\n 配置 `DNS` 在 `/etc/resolv.conf`","slug":"Linux学习总结03","published":1,"updated":"2017-12-06T13:38:42.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0p000ybkw16mgx24hl","content":"<p>Shell 的命令有很多，再加上相关软件的命令，更是多不胜数，这里总结了一些常见的。<br><a id=\"more\"></a><br>常见的命令大致也就可以分为这五类：</p>\n<ul>\n<li>文件相关：诸如文件及目录的创建/编辑/传输等</li>\n<li>磁盘相关：磁盘的检查/挂载/查看等</li>\n<li>系统相关：系统的相关设置等</li>\n<li>网络相关：网络的相关设置</li>\n<li>用户相关：用户的几个命令</li>\n</ul>\n<p>从今天开始，逐步将常见的 Shell 命令的用法总结一下，简单的仅仅做个记录，复杂的分析下用法。</p>\n<h2 id=\"文件的相关命令\"><a href=\"#文件的相关命令\" class=\"headerlink\" title=\"文件的相关命令\"></a>文件的相关命令</h2><p><code>cd</code> 切换目录，几个常用的用法是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd  进入家目录</div><div class=\"line\">cd / 根目录</div><div class=\"line\">cd - 进入上次工作的目录</div></pre></td></tr></table></figure></p>\n<p><code>whereis</code> 查找文件，查找的文件属性只能是原始代码(s)/二进制文件(b)/帮助文档(m)。<br>加相应的文件代码参数小写查找指定类型；<br>加相应的文件代码参数大写加目录在指定文件夹下查找;</p>\n<p><code>pwd</code> 显示工作目录</p>\n<p><code>file</code> 辨识文件类型。 </p>\n<p><code>ls</code> 列出目录内容。<br>-a或–all   下所有文件和目录。</p>\n<p><code>echo</code> 显示一段文字，经常配合使用 <code>|</code> 管道来使用</p>\n<p><code>cat</code> 将文件内容输出到标准输出<br>-n 或 –number 由 1 开始对所有输出的行数编号</p>\n<p><code>cp</code> 复制文件或目录<br>-f或–force 　强行复制文件或目录，不论目标文件或目录是否已存在。<br>-l或–link 　对源文件建立硬连接，而非复制文件。<br>-r 　递归处理，将指定目录下的文件与子目录一并处理。 </p>\n<p><code>mv</code> 移动或更名现有的文件或目录。</p>\n<p><code>rm</code> 删除文件或目录。<br>-d或–directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。<br>-f或–force 　强制删除文件或目录。<br>-i或–interactive 　删除既有文件或目录之前先询问用户。<br>-r或-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </p>\n<p><code>mkdir</code> 建立文件夹<br>-m&lt;目录属性&gt;或–mode&lt;目录属性&gt;   建立目录时同时设置目录的权限。<br>-p或–parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。</p>\n<p><code>rmdir</code> 删除文件夹<br>-p或–parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。</p>\n<p><code>chowm/chgrp</code> 变更文件或目录的拥有者或所属群组。</p>\n<p><code>chmod</code> 变更文件或目录的权限。</p>\n<p><code>grep</code> 查找文件里符合条件的字符串。<br>-c或–count   计算符合范本样式的列数。</p>\n<p><code>find</code> 查找文件或目录。<br>-amin&lt;分钟&gt; 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。<br>-exec&lt;执行指令&gt; 　假设find指令的回传值为True，就执行该指令。<br>-name&lt;范本样式&gt; 　指定字符串作为寻找文件或目录的范本样式。<br>-size&lt;文件大小&gt; 　查找符合指定的文件大小的文件。<br>-type&lt;文件类型&gt; 　只寻找符合指定的文件类型的文件。 </p>\n<p><code>locate</code> 查找文件。 </p>\n<p><code>ln</code> 连接文件或目录。</p>\n<h2 id=\"系统相关命令\"><a href=\"#系统相关命令\" class=\"headerlink\" title=\"系统相关命令\"></a>系统相关命令</h2><p><code>alias</code> 设置指令的别名。</p>\n<p><code>export</code>  设置或显示环境变量。</p>\n<p><code>insmod</code> 载入模块。</p>\n<p><code>lsmod</code> 显示已载入系统的模块。</p>\n<p><code>modinfo</code> 显示kernel模块的信息。</p>\n<p><code>rmmod</code> 删除模块</p>\n<p><code>setenv</code> 查询或显示环境变量。</p>\n<p><code>adduser</code> 新增用户帐号。</p>\n<p><code>groupmod</code> 更改群组识别码或名称。</p>\n<p><code>su(super user)</code> 变更用户身份。</p>\n<p><code>sudo</code> 以其他身份来执行指令。</p>\n<p><code>free</code> 显示内存状态。</p>\n<p><code>ps</code> 报告程序状况。</p>\n<p><code>top</code> 显示，管理执行中的程序。<br>n&lt;执行次数&gt; 　设置监控信息的更新次数。 </p>\n<p><code>exit</code> 退出当前shell</p>\n<p><code>kill</code> 删除执行中的程序或工作。</p>\n<p><code>halt</code> 关闭系统。</p>\n<p><code>reboot</code> 重新开机。</p>\n<p><code>shutdown</code> <code>poweroff</code> 系统关机指令。</p>\n<h2 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h2><p><code>du(disk usage)</code> 显示目录或文件的大小。</p>\n<p><code>lndir(link directory)</code> 连接目录内容。</p>\n<p><code>stat</code> 显示inode内容。</p>\n<p><code>tree</code> 以树状图列出目录的内容。</p>\n<p><code>mount</code>,<code>umount</code> 挂载/卸除文件系统。</p>\n<p><code>mkfs(make file system)</code> 建立各种文件系统。</p>\n<h2 id=\"网络配置管理\"><a href=\"#网络配置管理\" class=\"headerlink\" title=\"网络配置管理\"></a>网络配置管理</h2><p><code>netstat</code><br>常用的网络状态：<br><code>LISTEN</code> ：在监听状态中。<br><code>ESTABLISHED</code> ：已建立联机的联机情况。<br><code>TIME_WAIT</code> ：该联机在目前已经是等待的状态。<br>常用命令：<br><code>netstat -e</code>显示关于以太网的统计数据<br><code>netstat -r</code>显示关于路由表的信息<br><code>netstat -a</code>显示一个所有的有效连接信息列表<br><code>netstat -n</code>显示所有已建立的有效连接</p>\n<blockquote>\n<p>配置 <code>IP</code>, <code>Netmask</code>, <code>Gateway</code> 在 <code>/etc/network/interfaces</code><br> 配置 <code>DNS</code> 在 <code>/etc/resolv.conf</code></p>\n</blockquote>\n","excerpt":"<p>Shell 的命令有很多，再加上相关软件的命令，更是多不胜数，这里总结了一些常见的。<br>","more":"<br>常见的命令大致也就可以分为这五类：</p>\n<ul>\n<li>文件相关：诸如文件及目录的创建/编辑/传输等</li>\n<li>磁盘相关：磁盘的检查/挂载/查看等</li>\n<li>系统相关：系统的相关设置等</li>\n<li>网络相关：网络的相关设置</li>\n<li>用户相关：用户的几个命令</li>\n</ul>\n<p>从今天开始，逐步将常见的 Shell 命令的用法总结一下，简单的仅仅做个记录，复杂的分析下用法。</p>\n<h2 id=\"文件的相关命令\"><a href=\"#文件的相关命令\" class=\"headerlink\" title=\"文件的相关命令\"></a>文件的相关命令</h2><p><code>cd</code> 切换目录，几个常用的用法是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd  进入家目录</div><div class=\"line\">cd / 根目录</div><div class=\"line\">cd - 进入上次工作的目录</div></pre></td></tr></table></figure></p>\n<p><code>whereis</code> 查找文件，查找的文件属性只能是原始代码(s)/二进制文件(b)/帮助文档(m)。<br>加相应的文件代码参数小写查找指定类型；<br>加相应的文件代码参数大写加目录在指定文件夹下查找;</p>\n<p><code>pwd</code> 显示工作目录</p>\n<p><code>file</code> 辨识文件类型。 </p>\n<p><code>ls</code> 列出目录内容。<br>-a或–all   下所有文件和目录。</p>\n<p><code>echo</code> 显示一段文字，经常配合使用 <code>|</code> 管道来使用</p>\n<p><code>cat</code> 将文件内容输出到标准输出<br>-n 或 –number 由 1 开始对所有输出的行数编号</p>\n<p><code>cp</code> 复制文件或目录<br>-f或–force 　强行复制文件或目录，不论目标文件或目录是否已存在。<br>-l或–link 　对源文件建立硬连接，而非复制文件。<br>-r 　递归处理，将指定目录下的文件与子目录一并处理。 </p>\n<p><code>mv</code> 移动或更名现有的文件或目录。</p>\n<p><code>rm</code> 删除文件或目录。<br>-d或–directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。<br>-f或–force 　强制删除文件或目录。<br>-i或–interactive 　删除既有文件或目录之前先询问用户。<br>-r或-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </p>\n<p><code>mkdir</code> 建立文件夹<br>-m&lt;目录属性&gt;或–mode&lt;目录属性&gt;   建立目录时同时设置目录的权限。<br>-p或–parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。</p>\n<p><code>rmdir</code> 删除文件夹<br>-p或–parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。</p>\n<p><code>chowm/chgrp</code> 变更文件或目录的拥有者或所属群组。</p>\n<p><code>chmod</code> 变更文件或目录的权限。</p>\n<p><code>grep</code> 查找文件里符合条件的字符串。<br>-c或–count   计算符合范本样式的列数。</p>\n<p><code>find</code> 查找文件或目录。<br>-amin&lt;分钟&gt; 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。<br>-exec&lt;执行指令&gt; 　假设find指令的回传值为True，就执行该指令。<br>-name&lt;范本样式&gt; 　指定字符串作为寻找文件或目录的范本样式。<br>-size&lt;文件大小&gt; 　查找符合指定的文件大小的文件。<br>-type&lt;文件类型&gt; 　只寻找符合指定的文件类型的文件。 </p>\n<p><code>locate</code> 查找文件。 </p>\n<p><code>ln</code> 连接文件或目录。</p>\n<h2 id=\"系统相关命令\"><a href=\"#系统相关命令\" class=\"headerlink\" title=\"系统相关命令\"></a>系统相关命令</h2><p><code>alias</code> 设置指令的别名。</p>\n<p><code>export</code>  设置或显示环境变量。</p>\n<p><code>insmod</code> 载入模块。</p>\n<p><code>lsmod</code> 显示已载入系统的模块。</p>\n<p><code>modinfo</code> 显示kernel模块的信息。</p>\n<p><code>rmmod</code> 删除模块</p>\n<p><code>setenv</code> 查询或显示环境变量。</p>\n<p><code>adduser</code> 新增用户帐号。</p>\n<p><code>groupmod</code> 更改群组识别码或名称。</p>\n<p><code>su(super user)</code> 变更用户身份。</p>\n<p><code>sudo</code> 以其他身份来执行指令。</p>\n<p><code>free</code> 显示内存状态。</p>\n<p><code>ps</code> 报告程序状况。</p>\n<p><code>top</code> 显示，管理执行中的程序。<br>n&lt;执行次数&gt; 　设置监控信息的更新次数。 </p>\n<p><code>exit</code> 退出当前shell</p>\n<p><code>kill</code> 删除执行中的程序或工作。</p>\n<p><code>halt</code> 关闭系统。</p>\n<p><code>reboot</code> 重新开机。</p>\n<p><code>shutdown</code> <code>poweroff</code> 系统关机指令。</p>\n<h2 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h2><p><code>du(disk usage)</code> 显示目录或文件的大小。</p>\n<p><code>lndir(link directory)</code> 连接目录内容。</p>\n<p><code>stat</code> 显示inode内容。</p>\n<p><code>tree</code> 以树状图列出目录的内容。</p>\n<p><code>mount</code>,<code>umount</code> 挂载/卸除文件系统。</p>\n<p><code>mkfs(make file system)</code> 建立各种文件系统。</p>\n<h2 id=\"网络配置管理\"><a href=\"#网络配置管理\" class=\"headerlink\" title=\"网络配置管理\"></a>网络配置管理</h2><p><code>netstat</code><br>常用的网络状态：<br><code>LISTEN</code> ：在监听状态中。<br><code>ESTABLISHED</code> ：已建立联机的联机情况。<br><code>TIME_WAIT</code> ：该联机在目前已经是等待的状态。<br>常用命令：<br><code>netstat -e</code>显示关于以太网的统计数据<br><code>netstat -r</code>显示关于路由表的信息<br><code>netstat -a</code>显示一个所有的有效连接信息列表<br><code>netstat -n</code>显示所有已建立的有效连接</p>\n<blockquote>\n<p>配置 <code>IP</code>, <code>Netmask</code>, <code>Gateway</code> 在 <code>/etc/network/interfaces</code><br> 配置 <code>DNS</code> 在 <code>/etc/resolv.conf</code></p>\n</blockquote>"},{"title":"Linux学习总结（五）——高级I/O","date":"2016-12-16T06:54:55.000Z","_content":"\n高级I/O包含了很多内容，本篇会首先解释下几个相关的概念：阻塞、非阻塞、同步、异步等的概念；接着介绍下 Linux I/O 操作的具体过程；最后讨论下多路复用、记录锁等几个相关函数。\n<!--more-->\n\n## 一、概念说明\nLinux 的每个进程都是拥有自己的虚拟内存空间的，而一个进程的虚拟内存空间分为内核空间和用户空间两个部分，当进程的执行过程中期待的某种事情没有发生：请求系统资源失败、等待某种操作的完成、新数据尚未到达等。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：\n\n  1. 等待数据准备 (Waiting for the data to be ready)\n  2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)\n\n正式因为这两个阶段，Linux系统产生了下面五种I/O:\n\n### 1. 阻塞式I/O\n 通常来说，从普通文件读数据，无论你是采用 `fscanf`、 `fgets` 也好，`read` 也好，一定会在有限的时间内返回。但是如果你从设备，比如终端（标准输入设备）读数据，只要没有遇到换行符(`\\n`)，`read` 一定会**堵**在那而不返回。还有比如从网络读数据，如果网络一直没有数据到来，`read` 函数也会一直堵在那而不返回。\n `read` 的这种行为，称之为 block，一旦发生 block，本进程将会被操作系统投入睡眠，直到等待的事件发生了（比如有数据到来），进程才会被唤醒。\n 系统调用 `write` 同样有可能被阻塞，比如向网络写入数据，如果对方一直不接收，本端的缓冲区一旦被写满，就会被阻塞。\n \n### 2. 非阻塞式I/O\n 当用户进程发出 `read` 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个 `read` 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 `read` 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。\n \n > 所以:\n 非阻塞式I/O的特点是用户进程需要不断的主动询问 kernel 数据好了没有。\n 阻塞非阻塞是文件本身的特性，不是系统调用read/write本身可以控制的。\n\n### 3. I/O多路复用\n I/O多路复用（`IO multiplexing`）就是我们说的 `select`、 `poll`、 `epoll`，指的是单个 `process` 可以同时处理多个 IO 操作。它的基本原理就是 `select`、 `poll`、 `epoll` 会不断的轮询所负责的所有 I/O，当某个 I/O 有数据到达了，就通知用户进程。\n \n > 所以:\n I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，`select()` 函数就可以返回。\n \n### 4. 异步I/O\n 当用户进程发起 `read` 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。\n\n > 同步I/O 和 异步I/O 的区别：\n 两者之间的区别就在于同步I/O 做 I/O操作的时候会将进程阻塞，所以，按照这个定义，之前的**阻塞I/O、非阻塞I/O、I/O多路复用都属于同步I/O**。\n 非阻塞I/O 之所以属于同步I/O 是因为其非阻塞是因为并没有进行相应的IO操作，在其进行IO操作的时候，依旧是阻塞的。\n\n5. 信号驱动I/O\n\n## Linux 的 I/O 操作过程\n### 1. GNU Linux I/O操作类别\n Linux 的文件操作并不仅仅是对我们通常意义上的文件的读写，基于**一切接文件**的思想，Linux的I/O操作类别包含一下几类：\n\n  * 文件及流的标准输入输出\n  * 底层输入输出\n  * 文件系统接口\n  * 管道及FIFO（先入先出队列）\n  * Socket\n  * 底层终端接口（tty）\n\n### 2. 主要数据结构介绍\n1. `FD`\n  对于内核而言，所有打开文件都由文件描述符引用。\n  文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用`open`或`creat`返回的文件描述符`fd`标识该文件，将其作为参数传送给`read`或`write`。在 POSIX.1 应用程序中，文件描述符为常数 `0`、 `1` 和 `2` 分别代表 `STDIN_FILENO`、`STDOUT_FILENO` 和 `STDERR_FILENO`，意即标准输入，标准输出和标准出错输出，这些常数都定义在头文件 `<unistd.h>`中。文件描述符的范围是 `0~OPEN_MAX`，在目前常用的linux系统中，是32位整形所能表示的整数，即65535，64位机上则更多。\n\n1. 进程中文件相关结构体\n  * `struct file` 结构体定义在`include/linux/fs.h` 中。该结构体代表一个打开的文件，系统中每一个打开的文件在内核空间中都有一个关联的 `struct file`。它由内核在打开文件的时候创建，并传递给在该文件上进行操作的热河函数，在该文件的所有实例都关闭后，内核释放该数据结构。\n  ````C\n  struct file {\n    union {\n      struct list_head             fu_list;      //文件对象链表指针linux/include/linux/list.h\n      struct rcu_head              fu_rcuhead;   //RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制\n    } f_u;\n    struct path                    f_path;       //包含dentry和mnt两个成员，用于确定文件路径\n  #define f_dentry                 f_path.dentry //f_path的成员之一，当前文件的dentry结构\n  #define f_vfsmnt                 f_path.mnt    //表示当前文件所在文件系统的挂载根目录\n    const struct file_operations  *f_op;         //与该文件相关联的操作函数\n    atomic_t                       f_count;      //文件的引用计数(有多少进程打开该文件)\n    unsigned int                   f_flags;      //对应于open时指定的flag\n    mode_t                         f_mode;       //读写模式：open的mod_t mode参数\n    off_t                          f_pos;        //该文件在当前进程中的文件偏移量\n    struct fown_struct             f_owner;      //该结构的作用是通过信号进行I/O时间通知的数据。\n    unsigned int                   f_uid, f_gid; //文件所有者id，所有者组id\n    struct file_ra_state           f_ra;         //在linux/include/linux/fs.h中定义，文件预读相关\n  　unsigned long                  f_version;\n  #ifdef CONFIG_SECURITY\n    void                          *f_security;\n  #endif\n  　　\n    void                          *private_data;\n  #ifdef CONFIG_EPOLL\n    struct list_head               f_ep_links;\n    spinlock_t                     f_ep_lock;\n  #endif\n  　struct address_space *f_mapping;\n  };\n  ````\n  * `struct dentry`\n  `dentry` 是 Linux 文件系统中某个索引节点（`inode`）的链接。`inode` 对应于物理磁盘上的具体对象，`dentry` 是一个内存上的实体，其中的`d_inode` 指向对应的 `inode`。一个 `inode` 可以在运行的时候链接多个 `dentry`，而 `d_count` 记录了链接的具体数量。\n  ````C\n  struct dentry {\n    atomic_t                  d_count;    //目录项对象使用计数器,可以有未使用态,使用态和负状态\n  　unsigned int              d_flags;    //目录项标志\n  　struct inode *            d_inode;    //与文件名关联的索引节点\n  　struct dentry *           d_parent;   //父目录的目录项对象\n  　struct list_head          d_hash;     //散列表表项的指针\n  　struct list_head          d_lru;      //未使用链表的指针\n  　struct list_head          d_child;    //父目录中目录项对象的链表的指针\n  　struct list_head          d_subdirs;  //对目录而言，表示子目录目录项对象的链表\n  　struct list_head          d_alias;    //相关索引节点(别名)的链表\n  　int                       d_mounted;  //对于安装点而言，表示被安装文件系统根项\n  　struct qstr               d_name;     //文件名\n  　unsigned long             d_time;\n  　struct dentry_operations *d_op;       //目录项方法\n  　struct super_block       *d_sb;       //文件的超级块对象\n  　vunsigned long            d_vfs_flags;\n  　void                     *d_fsdata;   //与文件系统相关的数据\n  　unsigned char             d_iname [DNAME_INLINE_LEN]; //存放短文件名\n  };````\n  * `struct files_struct`\n  对于每个进程，包含一个`files_struct` 结构，用来记录文件描述符的使用情况。\n  ````C\n  struct files_struct\n  {\n    atomic_t               count;               //使用该表的进程数\n  　struct fdtable        *fdt;\n  　struct fdtable         fdtab;\n  　spinlock_t             file_lock ____cacheline_aligned_in_smp;\n  　int                    next_fd;              //数值最小的最近关闭文件的文件描述符,下一个可用的文件描述符\n  　struct embedded_fd_set close_on_exec_init;   //执行exec时需要关闭的文件描述符初值集合　struct embedded_fd_set open_fds_init;        //文件描述符的屏蔽字初值集合\n  　struct file           *fd_array[NR_OPEN_DEFAULT]; 默认打开的fd队列\n  };\n  struct fdtable {\n  　unsigned int      max_fds;\n  　struct file     **fd;            //指向打开的文件描述符列表的指针，开始的时候指向fd_array，\n  　当超过max_fds时，重新分配地址\n  　fd_set           *close_on_exec; //执行exec需要关闭的文件描述符位图(fork，exec即不被子进程继承的文件描述符)\n  　fd_set           *open_fds;      //打开的文件描述符位图\n  　struct rcu_head   rcu;\n  　struct fdtable   *next;\n  };````\n  * `struct fs_struct`\n  `fs_struct` 是文件系统相关信息结构体。\n  ````C\n  struct fs_struct {\n  atomic_t          count;     //共享表的进程个数\n  rwlock_t          lock;      //自旋锁\n  int               umask;     //文件权限掩码\n  struct dentry    *root,      //根目录目录项\n                    *pwd,       //当前目录目录项\n                    *altroot;   //模拟根目录目录项\n  struct vfsmount  *rootmnt,   //根目录文件系统对象\n                    *pwdmnt,    //\n                    *altrootmnt;//\n  };````\n\n  每个进程都有一个 `task_struct` 结构体，其中包含了一个 `fs_struct` 和一个 `files_struct` 结构体，其中 `files_struct` 中的 `fd_array` 记录了所有该进程打开的文件的 `file` 结构体，每个 `file` 结构体中的 `f_entry` 指向了当前文件的 `dentry` 结构体，`debtry` 结构体实际指向了相应的文件 `inode`。 \n\n3. `inode`\n  inode包含文件的元信息，具体来说有以下内容： \n  * 文件的字节数 文件的字节数 　　 　　\n  * 文件拥有者的 文件拥有者的User ID 　　 　　\n  * 文件的 文件的Group ID 　　 　　\n  * 文件的读、写、执行权限 文件的读、写、执行权限 　　 　　\n  * 文件的时间戳，共有三个： 文件的时间戳，共有三个：\n    ctime指 指inode上一次变动的时间， 上一次变动的时间，\n    mtime指文件内容上一次变动的时间， 指文件内容上一次变动的时间，\n    atime指文件上一 指文件上一 次打开的时间。 次打开的时间。 　　 　　\n  * 链接数，即有多少文件名指向这个 链接数，即有多少文件名指向这个inode 　　 　　\n  * 文件数据 文件数据block的位置 \n\n### 3. I/O操作过程\n  1. 打开文件\n  一个应用程序通过要求内核打开相应文件，宣告他要访问一个I/O设备 ，内核返回一个非负整数，叫描述符号(Descriptor）；\n\n  2. 改变文件位置\n  对于每个打开的文件，内核保持一个文件位置k，初始为0，这个文件位置是从文件头开始的偏移量。通过执行seek操作，显式地设置当前位置为k\n\n  3. 读写文件\n  读：从文件拷贝n>0个字节到存储器，写：从存储器拷贝n>0字节到文件\n\n  4. 关闭文件\n  通知内核关闭文件，作为响应，内核释放文件打开时创建的数据结构\n\n## 三、记录锁\n记录锁解决的是多个进程共同操作一个文件的问题，记录锁分为两种：\n * 建议性锁：建议性锁要求每个相关程序在访问文件前检查是否有锁存在，并尊重已有的锁。\n * 强制性锁：强制性锁是由内核执行的锁，当一个文件被上锁进行写操作时，内核将阻止任何其它的程序进行该文件的读写操作。\n\n我们通常使用的是强制性锁，强制性锁的上锁函数是：\n````C\nint fcntl(int fd, int cmd, ...);\n````\n第一个参数 `fd` 显然指的是需要操作的文件描述符，第二个参数 `cmd` 是 `F_GETLK` / `F_SETLK` / `F_SETLKW`，当进行锁操作的时候，第三个参数是一个指向 `flock` 结构的指针。\n````C\nstruct flock {\n  short l_type;   //希望的锁类型 F_RDLCK(读锁) F_WRLCK（写锁） F_UNLCK（解锁）\n  short l_whence; //区域的起始位置 SEEK_SET SEEK_CUR SEEK_END\n  off_t l_start;  //区域的起始字节\n  off_t l_len;    //区域的字节长度\n  pid_t l_pid;    //持有锁的进程IO\n}  ````\n\n当 `cmd` 是 `F_GETLK` 时，函数会检查当前锁是否能够创建，如果可以创建，则将 `1_type` 设置为 `F_UNLCK`，否则则将当前锁的信息重写。\n当 `cmd` 是 `F_SETLK` 时，设置相应的锁，如果不能创建，返回失败代码。\n当 `cmd` 是 `F_GETLK` 时，如果当前设置的锁无法设置，则休眠等待锁创建。\n\n记录锁的几个注意点：\n\n1. 检查锁是否存在，和加锁过程并不是原子操作，所以，当检查当前锁不存在后加锁，依旧有可能会失败。\n2. 如果两个进程相互等待对方持有并不释放（锁定）的资源时，造成死锁。\n3. 当进程终止时，它所建立的所有锁释放\n4. 当文件描述符关闭的时候，该文件描述符上的所有锁释放\n5. `fork` 不继承任何锁。\n\n## 四、I/O复用\n\nI/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。\n\n### 1. `select`\n````C\nint select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n````\n`select` 函数监视的文件描述符分3类，分别是 `writefds`、`readfds`、和 `exceptfds`。调用后 `select` 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（`timeout`指定等待时间，如果立即返回设为null即可），函数返回。当 `select` 函数返回后，可以 通过遍历 `fdset`，来找到就绪的描述符。\n\n函数的第一个参数 `n` 指的是**最大描述符编号加1**，即需要监视的3类文件描述符中的最大值加1.\n函数中间的三个参数指函数监视的3类文件描述符的集合，分别是 `writefds`（可写）、`readfds`（可写）、和 `exceptfds`（处于异常）。有几个相应的接口可以设置这三个集合：\n ````C\n int FD_ISSET(int fd, fd_set *fdset); //测试描述符集中的某一位是否开启\n int FD_CLR(int fd, fd_set *fdset);   //清除描述符集中的某一位\n int FD_SET(int fd, fd_set *fdset);   //开启描述符集中的某一位\n int FD_ZERO(fd_set *fdset);          //清空描述符集中的所有位\n ````\n函数的最后一个参数 `timeout` 指定等待的时间，当为 `NULL` 的时候，一直等待；当为 0 的时候，不等待。\n\n函数有三个可能的返回值：\n  * 返回-1；表示出错。\n  * 返回0；表示没有描述符准备好。\n  * 一个正的返回值：表示已经准备好的描述符数。\n    已经准备好指的是：相应的读写没有阻塞，或者某个描述符存在未决异常条件。\n\n### 2. `poll`\n````C\nint poll (struct pollfd *fds, unsigned int nfds, int timeout);\n````\n不同与 `select` 使用三个位图来表示三个 `fdset` 的方式，poll使用一个 pollfd的指针实现。\n````C\nstruct pollfd {\n    int fd;          /* file descriptor */\n    short events;    /* requested events to watch */\n    short revents;   /* returned events witnessed */\n};````\n`pollfd` 结构包含了要监视的 event 和发生的 event，不再使用 `select` **参数-值**传递的方式。\n`pollfd` 并没有最大数量限制（但是数量过大后性能也是会下降）。`timeout` 参数只当了我们等待的时间，为-1表示永远等待，为0表示不等待，为正表示等待的时间（毫秒）。\n和 `select` 函数一样，`poll` 返回后，需要轮询 `pollfd` 来获取就绪的描述符。\n\n\n### 3. epoll\n`epoll` 是在2.6内核中提出的，是之前的 `select` 和 `poll` 的增强版本。相对于 `select` 和 `poll` 来说，`epoll` 更加灵活，没有描述符限制。`epoll` 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。\n\n`epoll` 操作过程需要三个接口，分别如下：\n````C\nint epoll_create(int size)； //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n````\n* `int epoll_create(int size);`\n    创建一个 `epoll` 的句柄，`size` 用来告诉内核这个监听的数目一共有多大，这个参数不同于 `select()` 中的第一个参数，参数 `size` 并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。\n    当创建好 `epoll` 句柄后，它就会占用一个fd值，在 Linux 下如果查看 `/proc/进程id/fd/`，是能够看到这个 `fd` 的，所以在使用完 `epoll` 后，必须调用 `close()` 关闭，否则可能导致fd被耗尽。\n\n* `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；`\n    函数是对指定描述符 `fd` 执行 `op` 操作。\n    - `epfd`：是 `epoll_create()` 的返回值。\n    - `op`：表示 op 操作，用三个宏来表示：添加 `EPOLL_CTL_ADD`，删除 `EPOLL_CTL_DEL`，修改 `EPOLL_CTL_MOD`。分别添加、删除和修改对fd的监听事件。\n    - `fd`：是需要监听的 `fd`（文件描述符）\n    - `epoll_event`：是告诉内核需要监听什么事，`struct epoll_event`结构如下：\n    ````C\n    struct epoll_event {\n      __uint32_t events;  /* Epoll events */\n      epoll_data_t data;  /* User data variable */\n    };````\n  events可以是以下几个宏的集合：\n  `EPOLLIN`：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\n  `EPOLLOUT`：表示对应的文件描述符可以写；\n  `EPOLLPRI`：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\n  `EPOLLERR`：表示对应的文件描述符发生错误；\n  `EPOLLHUP`：表示对应的文件描述符被挂断；\n  `EPOLLET`： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\n  `EPOLLONESHOT`：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n* `int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);`\n    等待 `epfd` 上的 I/O 事件，最多返回 `maxevents` 个事件。\n    参数 `events` 用来存储从内核得到事件的集合，`maxevents` 告之内核这个 `events` 有多大，这个 `maxevents` 的值不能大于创建 `epoll_create()` 时的 `size`，参数`timeout` 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。","source":"_posts/Linux学习总结05.md","raw":"---\ntitle: Linux学习总结（五）——高级I/O\ndate: 2016-12-16 14:54:55\ncategories: Linux学习记录\ntags: [I/O, 阻塞式I/O, select, poll, epoll]\n---\n\n高级I/O包含了很多内容，本篇会首先解释下几个相关的概念：阻塞、非阻塞、同步、异步等的概念；接着介绍下 Linux I/O 操作的具体过程；最后讨论下多路复用、记录锁等几个相关函数。\n<!--more-->\n\n## 一、概念说明\nLinux 的每个进程都是拥有自己的虚拟内存空间的，而一个进程的虚拟内存空间分为内核空间和用户空间两个部分，当进程的执行过程中期待的某种事情没有发生：请求系统资源失败、等待某种操作的完成、新数据尚未到达等。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：\n\n  1. 等待数据准备 (Waiting for the data to be ready)\n  2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)\n\n正式因为这两个阶段，Linux系统产生了下面五种I/O:\n\n### 1. 阻塞式I/O\n 通常来说，从普通文件读数据，无论你是采用 `fscanf`、 `fgets` 也好，`read` 也好，一定会在有限的时间内返回。但是如果你从设备，比如终端（标准输入设备）读数据，只要没有遇到换行符(`\\n`)，`read` 一定会**堵**在那而不返回。还有比如从网络读数据，如果网络一直没有数据到来，`read` 函数也会一直堵在那而不返回。\n `read` 的这种行为，称之为 block，一旦发生 block，本进程将会被操作系统投入睡眠，直到等待的事件发生了（比如有数据到来），进程才会被唤醒。\n 系统调用 `write` 同样有可能被阻塞，比如向网络写入数据，如果对方一直不接收，本端的缓冲区一旦被写满，就会被阻塞。\n \n### 2. 非阻塞式I/O\n 当用户进程发出 `read` 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个 `read` 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 `read` 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。\n \n > 所以:\n 非阻塞式I/O的特点是用户进程需要不断的主动询问 kernel 数据好了没有。\n 阻塞非阻塞是文件本身的特性，不是系统调用read/write本身可以控制的。\n\n### 3. I/O多路复用\n I/O多路复用（`IO multiplexing`）就是我们说的 `select`、 `poll`、 `epoll`，指的是单个 `process` 可以同时处理多个 IO 操作。它的基本原理就是 `select`、 `poll`、 `epoll` 会不断的轮询所负责的所有 I/O，当某个 I/O 有数据到达了，就通知用户进程。\n \n > 所以:\n I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，`select()` 函数就可以返回。\n \n### 4. 异步I/O\n 当用户进程发起 `read` 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。\n\n > 同步I/O 和 异步I/O 的区别：\n 两者之间的区别就在于同步I/O 做 I/O操作的时候会将进程阻塞，所以，按照这个定义，之前的**阻塞I/O、非阻塞I/O、I/O多路复用都属于同步I/O**。\n 非阻塞I/O 之所以属于同步I/O 是因为其非阻塞是因为并没有进行相应的IO操作，在其进行IO操作的时候，依旧是阻塞的。\n\n5. 信号驱动I/O\n\n## Linux 的 I/O 操作过程\n### 1. GNU Linux I/O操作类别\n Linux 的文件操作并不仅仅是对我们通常意义上的文件的读写，基于**一切接文件**的思想，Linux的I/O操作类别包含一下几类：\n\n  * 文件及流的标准输入输出\n  * 底层输入输出\n  * 文件系统接口\n  * 管道及FIFO（先入先出队列）\n  * Socket\n  * 底层终端接口（tty）\n\n### 2. 主要数据结构介绍\n1. `FD`\n  对于内核而言，所有打开文件都由文件描述符引用。\n  文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用`open`或`creat`返回的文件描述符`fd`标识该文件，将其作为参数传送给`read`或`write`。在 POSIX.1 应用程序中，文件描述符为常数 `0`、 `1` 和 `2` 分别代表 `STDIN_FILENO`、`STDOUT_FILENO` 和 `STDERR_FILENO`，意即标准输入，标准输出和标准出错输出，这些常数都定义在头文件 `<unistd.h>`中。文件描述符的范围是 `0~OPEN_MAX`，在目前常用的linux系统中，是32位整形所能表示的整数，即65535，64位机上则更多。\n\n1. 进程中文件相关结构体\n  * `struct file` 结构体定义在`include/linux/fs.h` 中。该结构体代表一个打开的文件，系统中每一个打开的文件在内核空间中都有一个关联的 `struct file`。它由内核在打开文件的时候创建，并传递给在该文件上进行操作的热河函数，在该文件的所有实例都关闭后，内核释放该数据结构。\n  ````C\n  struct file {\n    union {\n      struct list_head             fu_list;      //文件对象链表指针linux/include/linux/list.h\n      struct rcu_head              fu_rcuhead;   //RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制\n    } f_u;\n    struct path                    f_path;       //包含dentry和mnt两个成员，用于确定文件路径\n  #define f_dentry                 f_path.dentry //f_path的成员之一，当前文件的dentry结构\n  #define f_vfsmnt                 f_path.mnt    //表示当前文件所在文件系统的挂载根目录\n    const struct file_operations  *f_op;         //与该文件相关联的操作函数\n    atomic_t                       f_count;      //文件的引用计数(有多少进程打开该文件)\n    unsigned int                   f_flags;      //对应于open时指定的flag\n    mode_t                         f_mode;       //读写模式：open的mod_t mode参数\n    off_t                          f_pos;        //该文件在当前进程中的文件偏移量\n    struct fown_struct             f_owner;      //该结构的作用是通过信号进行I/O时间通知的数据。\n    unsigned int                   f_uid, f_gid; //文件所有者id，所有者组id\n    struct file_ra_state           f_ra;         //在linux/include/linux/fs.h中定义，文件预读相关\n  　unsigned long                  f_version;\n  #ifdef CONFIG_SECURITY\n    void                          *f_security;\n  #endif\n  　　\n    void                          *private_data;\n  #ifdef CONFIG_EPOLL\n    struct list_head               f_ep_links;\n    spinlock_t                     f_ep_lock;\n  #endif\n  　struct address_space *f_mapping;\n  };\n  ````\n  * `struct dentry`\n  `dentry` 是 Linux 文件系统中某个索引节点（`inode`）的链接。`inode` 对应于物理磁盘上的具体对象，`dentry` 是一个内存上的实体，其中的`d_inode` 指向对应的 `inode`。一个 `inode` 可以在运行的时候链接多个 `dentry`，而 `d_count` 记录了链接的具体数量。\n  ````C\n  struct dentry {\n    atomic_t                  d_count;    //目录项对象使用计数器,可以有未使用态,使用态和负状态\n  　unsigned int              d_flags;    //目录项标志\n  　struct inode *            d_inode;    //与文件名关联的索引节点\n  　struct dentry *           d_parent;   //父目录的目录项对象\n  　struct list_head          d_hash;     //散列表表项的指针\n  　struct list_head          d_lru;      //未使用链表的指针\n  　struct list_head          d_child;    //父目录中目录项对象的链表的指针\n  　struct list_head          d_subdirs;  //对目录而言，表示子目录目录项对象的链表\n  　struct list_head          d_alias;    //相关索引节点(别名)的链表\n  　int                       d_mounted;  //对于安装点而言，表示被安装文件系统根项\n  　struct qstr               d_name;     //文件名\n  　unsigned long             d_time;\n  　struct dentry_operations *d_op;       //目录项方法\n  　struct super_block       *d_sb;       //文件的超级块对象\n  　vunsigned long            d_vfs_flags;\n  　void                     *d_fsdata;   //与文件系统相关的数据\n  　unsigned char             d_iname [DNAME_INLINE_LEN]; //存放短文件名\n  };````\n  * `struct files_struct`\n  对于每个进程，包含一个`files_struct` 结构，用来记录文件描述符的使用情况。\n  ````C\n  struct files_struct\n  {\n    atomic_t               count;               //使用该表的进程数\n  　struct fdtable        *fdt;\n  　struct fdtable         fdtab;\n  　spinlock_t             file_lock ____cacheline_aligned_in_smp;\n  　int                    next_fd;              //数值最小的最近关闭文件的文件描述符,下一个可用的文件描述符\n  　struct embedded_fd_set close_on_exec_init;   //执行exec时需要关闭的文件描述符初值集合　struct embedded_fd_set open_fds_init;        //文件描述符的屏蔽字初值集合\n  　struct file           *fd_array[NR_OPEN_DEFAULT]; 默认打开的fd队列\n  };\n  struct fdtable {\n  　unsigned int      max_fds;\n  　struct file     **fd;            //指向打开的文件描述符列表的指针，开始的时候指向fd_array，\n  　当超过max_fds时，重新分配地址\n  　fd_set           *close_on_exec; //执行exec需要关闭的文件描述符位图(fork，exec即不被子进程继承的文件描述符)\n  　fd_set           *open_fds;      //打开的文件描述符位图\n  　struct rcu_head   rcu;\n  　struct fdtable   *next;\n  };````\n  * `struct fs_struct`\n  `fs_struct` 是文件系统相关信息结构体。\n  ````C\n  struct fs_struct {\n  atomic_t          count;     //共享表的进程个数\n  rwlock_t          lock;      //自旋锁\n  int               umask;     //文件权限掩码\n  struct dentry    *root,      //根目录目录项\n                    *pwd,       //当前目录目录项\n                    *altroot;   //模拟根目录目录项\n  struct vfsmount  *rootmnt,   //根目录文件系统对象\n                    *pwdmnt,    //\n                    *altrootmnt;//\n  };````\n\n  每个进程都有一个 `task_struct` 结构体，其中包含了一个 `fs_struct` 和一个 `files_struct` 结构体，其中 `files_struct` 中的 `fd_array` 记录了所有该进程打开的文件的 `file` 结构体，每个 `file` 结构体中的 `f_entry` 指向了当前文件的 `dentry` 结构体，`debtry` 结构体实际指向了相应的文件 `inode`。 \n\n3. `inode`\n  inode包含文件的元信息，具体来说有以下内容： \n  * 文件的字节数 文件的字节数 　　 　　\n  * 文件拥有者的 文件拥有者的User ID 　　 　　\n  * 文件的 文件的Group ID 　　 　　\n  * 文件的读、写、执行权限 文件的读、写、执行权限 　　 　　\n  * 文件的时间戳，共有三个： 文件的时间戳，共有三个：\n    ctime指 指inode上一次变动的时间， 上一次变动的时间，\n    mtime指文件内容上一次变动的时间， 指文件内容上一次变动的时间，\n    atime指文件上一 指文件上一 次打开的时间。 次打开的时间。 　　 　　\n  * 链接数，即有多少文件名指向这个 链接数，即有多少文件名指向这个inode 　　 　　\n  * 文件数据 文件数据block的位置 \n\n### 3. I/O操作过程\n  1. 打开文件\n  一个应用程序通过要求内核打开相应文件，宣告他要访问一个I/O设备 ，内核返回一个非负整数，叫描述符号(Descriptor）；\n\n  2. 改变文件位置\n  对于每个打开的文件，内核保持一个文件位置k，初始为0，这个文件位置是从文件头开始的偏移量。通过执行seek操作，显式地设置当前位置为k\n\n  3. 读写文件\n  读：从文件拷贝n>0个字节到存储器，写：从存储器拷贝n>0字节到文件\n\n  4. 关闭文件\n  通知内核关闭文件，作为响应，内核释放文件打开时创建的数据结构\n\n## 三、记录锁\n记录锁解决的是多个进程共同操作一个文件的问题，记录锁分为两种：\n * 建议性锁：建议性锁要求每个相关程序在访问文件前检查是否有锁存在，并尊重已有的锁。\n * 强制性锁：强制性锁是由内核执行的锁，当一个文件被上锁进行写操作时，内核将阻止任何其它的程序进行该文件的读写操作。\n\n我们通常使用的是强制性锁，强制性锁的上锁函数是：\n````C\nint fcntl(int fd, int cmd, ...);\n````\n第一个参数 `fd` 显然指的是需要操作的文件描述符，第二个参数 `cmd` 是 `F_GETLK` / `F_SETLK` / `F_SETLKW`，当进行锁操作的时候，第三个参数是一个指向 `flock` 结构的指针。\n````C\nstruct flock {\n  short l_type;   //希望的锁类型 F_RDLCK(读锁) F_WRLCK（写锁） F_UNLCK（解锁）\n  short l_whence; //区域的起始位置 SEEK_SET SEEK_CUR SEEK_END\n  off_t l_start;  //区域的起始字节\n  off_t l_len;    //区域的字节长度\n  pid_t l_pid;    //持有锁的进程IO\n}  ````\n\n当 `cmd` 是 `F_GETLK` 时，函数会检查当前锁是否能够创建，如果可以创建，则将 `1_type` 设置为 `F_UNLCK`，否则则将当前锁的信息重写。\n当 `cmd` 是 `F_SETLK` 时，设置相应的锁，如果不能创建，返回失败代码。\n当 `cmd` 是 `F_GETLK` 时，如果当前设置的锁无法设置，则休眠等待锁创建。\n\n记录锁的几个注意点：\n\n1. 检查锁是否存在，和加锁过程并不是原子操作，所以，当检查当前锁不存在后加锁，依旧有可能会失败。\n2. 如果两个进程相互等待对方持有并不释放（锁定）的资源时，造成死锁。\n3. 当进程终止时，它所建立的所有锁释放\n4. 当文件描述符关闭的时候，该文件描述符上的所有锁释放\n5. `fork` 不继承任何锁。\n\n## 四、I/O复用\n\nI/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。\n\n### 1. `select`\n````C\nint select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n````\n`select` 函数监视的文件描述符分3类，分别是 `writefds`、`readfds`、和 `exceptfds`。调用后 `select` 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（`timeout`指定等待时间，如果立即返回设为null即可），函数返回。当 `select` 函数返回后，可以 通过遍历 `fdset`，来找到就绪的描述符。\n\n函数的第一个参数 `n` 指的是**最大描述符编号加1**，即需要监视的3类文件描述符中的最大值加1.\n函数中间的三个参数指函数监视的3类文件描述符的集合，分别是 `writefds`（可写）、`readfds`（可写）、和 `exceptfds`（处于异常）。有几个相应的接口可以设置这三个集合：\n ````C\n int FD_ISSET(int fd, fd_set *fdset); //测试描述符集中的某一位是否开启\n int FD_CLR(int fd, fd_set *fdset);   //清除描述符集中的某一位\n int FD_SET(int fd, fd_set *fdset);   //开启描述符集中的某一位\n int FD_ZERO(fd_set *fdset);          //清空描述符集中的所有位\n ````\n函数的最后一个参数 `timeout` 指定等待的时间，当为 `NULL` 的时候，一直等待；当为 0 的时候，不等待。\n\n函数有三个可能的返回值：\n  * 返回-1；表示出错。\n  * 返回0；表示没有描述符准备好。\n  * 一个正的返回值：表示已经准备好的描述符数。\n    已经准备好指的是：相应的读写没有阻塞，或者某个描述符存在未决异常条件。\n\n### 2. `poll`\n````C\nint poll (struct pollfd *fds, unsigned int nfds, int timeout);\n````\n不同与 `select` 使用三个位图来表示三个 `fdset` 的方式，poll使用一个 pollfd的指针实现。\n````C\nstruct pollfd {\n    int fd;          /* file descriptor */\n    short events;    /* requested events to watch */\n    short revents;   /* returned events witnessed */\n};````\n`pollfd` 结构包含了要监视的 event 和发生的 event，不再使用 `select` **参数-值**传递的方式。\n`pollfd` 并没有最大数量限制（但是数量过大后性能也是会下降）。`timeout` 参数只当了我们等待的时间，为-1表示永远等待，为0表示不等待，为正表示等待的时间（毫秒）。\n和 `select` 函数一样，`poll` 返回后，需要轮询 `pollfd` 来获取就绪的描述符。\n\n\n### 3. epoll\n`epoll` 是在2.6内核中提出的，是之前的 `select` 和 `poll` 的增强版本。相对于 `select` 和 `poll` 来说，`epoll` 更加灵活，没有描述符限制。`epoll` 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。\n\n`epoll` 操作过程需要三个接口，分别如下：\n````C\nint epoll_create(int size)； //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n````\n* `int epoll_create(int size);`\n    创建一个 `epoll` 的句柄，`size` 用来告诉内核这个监听的数目一共有多大，这个参数不同于 `select()` 中的第一个参数，参数 `size` 并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。\n    当创建好 `epoll` 句柄后，它就会占用一个fd值，在 Linux 下如果查看 `/proc/进程id/fd/`，是能够看到这个 `fd` 的，所以在使用完 `epoll` 后，必须调用 `close()` 关闭，否则可能导致fd被耗尽。\n\n* `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；`\n    函数是对指定描述符 `fd` 执行 `op` 操作。\n    - `epfd`：是 `epoll_create()` 的返回值。\n    - `op`：表示 op 操作，用三个宏来表示：添加 `EPOLL_CTL_ADD`，删除 `EPOLL_CTL_DEL`，修改 `EPOLL_CTL_MOD`。分别添加、删除和修改对fd的监听事件。\n    - `fd`：是需要监听的 `fd`（文件描述符）\n    - `epoll_event`：是告诉内核需要监听什么事，`struct epoll_event`结构如下：\n    ````C\n    struct epoll_event {\n      __uint32_t events;  /* Epoll events */\n      epoll_data_t data;  /* User data variable */\n    };````\n  events可以是以下几个宏的集合：\n  `EPOLLIN`：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\n  `EPOLLOUT`：表示对应的文件描述符可以写；\n  `EPOLLPRI`：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\n  `EPOLLERR`：表示对应的文件描述符发生错误；\n  `EPOLLHUP`：表示对应的文件描述符被挂断；\n  `EPOLLET`： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\n  `EPOLLONESHOT`：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n* `int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);`\n    等待 `epfd` 上的 I/O 事件，最多返回 `maxevents` 个事件。\n    参数 `events` 用来存储从内核得到事件的集合，`maxevents` 告之内核这个 `events` 有多大，这个 `maxevents` 的值不能大于创建 `epoll_create()` 时的 `size`，参数`timeout` 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。","slug":"Linux学习总结05","published":1,"updated":"2016-12-23T07:52:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0r0010bkw14u74smwt","content":"<p>高级I/O包含了很多内容，本篇会首先解释下几个相关的概念：阻塞、非阻塞、同步、异步等的概念；接着介绍下 Linux I/O 操作的具体过程；最后讨论下多路复用、记录锁等几个相关函数。<br><a id=\"more\"></a></p>\n<h2 id=\"一、概念说明\"><a href=\"#一、概念说明\" class=\"headerlink\" title=\"一、概念说明\"></a>一、概念说明</h2><p>Linux 的每个进程都是拥有自己的虚拟内存空间的，而一个进程的虚拟内存空间分为内核空间和用户空间两个部分，当进程的执行过程中期待的某种事情没有发生：请求系统资源失败、等待某种操作的完成、新数据尚未到达等。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>\n<ol>\n<li>等待数据准备 (Waiting for the data to be ready)</li>\n<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>\n</ol>\n<p>正式因为这两个阶段，Linux系统产生了下面五种I/O:</p>\n<h3 id=\"1-阻塞式I-O\"><a href=\"#1-阻塞式I-O\" class=\"headerlink\" title=\"1. 阻塞式I/O\"></a>1. 阻塞式I/O</h3><p> 通常来说，从普通文件读数据，无论你是采用 <code>fscanf</code>、 <code>fgets</code> 也好，<code>read</code> 也好，一定会在有限的时间内返回。但是如果你从设备，比如终端（标准输入设备）读数据，只要没有遇到换行符(<code>\\n</code>)，<code>read</code> 一定会<strong>堵</strong>在那而不返回。还有比如从网络读数据，如果网络一直没有数据到来，<code>read</code> 函数也会一直堵在那而不返回。<br> <code>read</code> 的这种行为，称之为 block，一旦发生 block，本进程将会被操作系统投入睡眠，直到等待的事件发生了（比如有数据到来），进程才会被唤醒。<br> 系统调用 <code>write</code> 同样有可能被阻塞，比如向网络写入数据，如果对方一直不接收，本端的缓冲区一旦被写满，就会被阻塞。</p>\n<h3 id=\"2-非阻塞式I-O\"><a href=\"#2-非阻塞式I-O\" class=\"headerlink\" title=\"2. 非阻塞式I/O\"></a>2. 非阻塞式I/O</h3><p> 当用户进程发出 <code>read</code> 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<blockquote>\n<p>所以:<br> 非阻塞式I/O的特点是用户进程需要不断的主动询问 kernel 数据好了没有。<br> 阻塞非阻塞是文件本身的特性，不是系统调用read/write本身可以控制的。</p>\n</blockquote>\n<h3 id=\"3-I-O多路复用\"><a href=\"#3-I-O多路复用\" class=\"headerlink\" title=\"3. I/O多路复用\"></a>3. I/O多路复用</h3><p> I/O多路复用（<code>IO multiplexing</code>）就是我们说的 <code>select</code>、 <code>poll</code>、 <code>epoll</code>，指的是单个 <code>process</code> 可以同时处理多个 IO 操作。它的基本原理就是 <code>select</code>、 <code>poll</code>、 <code>epoll</code> 会不断的轮询所负责的所有 I/O，当某个 I/O 有数据到达了，就通知用户进程。</p>\n<blockquote>\n<p>所以:<br> I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code> 函数就可以返回。</p>\n</blockquote>\n<h3 id=\"4-异步I-O\"><a href=\"#4-异步I-O\" class=\"headerlink\" title=\"4. 异步I/O\"></a>4. 异步I/O</h3><p> 当用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。</p>\n<blockquote>\n<p>同步I/O 和 异步I/O 的区别：<br> 两者之间的区别就在于同步I/O 做 I/O操作的时候会将进程阻塞，所以，按照这个定义，之前的<strong>阻塞I/O、非阻塞I/O、I/O多路复用都属于同步I/O</strong>。<br> 非阻塞I/O 之所以属于同步I/O 是因为其非阻塞是因为并没有进行相应的IO操作，在其进行IO操作的时候，依旧是阻塞的。</p>\n</blockquote>\n<ol>\n<li>信号驱动I/O</li>\n</ol>\n<h2 id=\"Linux-的-I-O-操作过程\"><a href=\"#Linux-的-I-O-操作过程\" class=\"headerlink\" title=\"Linux 的 I/O 操作过程\"></a>Linux 的 I/O 操作过程</h2><h3 id=\"1-GNU-Linux-I-O操作类别\"><a href=\"#1-GNU-Linux-I-O操作类别\" class=\"headerlink\" title=\"1. GNU Linux I/O操作类别\"></a>1. GNU Linux I/O操作类别</h3><p> Linux 的文件操作并不仅仅是对我们通常意义上的文件的读写，基于<strong>一切接文件</strong>的思想，Linux的I/O操作类别包含一下几类：</p>\n<ul>\n<li>文件及流的标准输入输出</li>\n<li>底层输入输出</li>\n<li>文件系统接口</li>\n<li>管道及FIFO（先入先出队列）</li>\n<li>Socket</li>\n<li>底层终端接口（tty）</li>\n</ul>\n<h3 id=\"2-主要数据结构介绍\"><a href=\"#2-主要数据结构介绍\" class=\"headerlink\" title=\"2. 主要数据结构介绍\"></a>2. 主要数据结构介绍</h3><ol>\n<li><p><code>FD</code><br>对于内核而言，所有打开文件都由文件描述符引用。<br>文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用<code>open</code>或<code>creat</code>返回的文件描述符<code>fd</code>标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。在 POSIX.1 应用程序中，文件描述符为常数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别代表 <code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code> 和 <code>STDERR_FILENO</code>，意即标准输入，标准输出和标准出错输出，这些常数都定义在头文件 <code>&lt;unistd.h&gt;</code>中。文件描述符的范围是 <code>0~OPEN_MAX</code>，在目前常用的linux系统中，是32位整形所能表示的整数，即65535，64位机上则更多。</p>\n</li>\n<li><p>进程中文件相关结构体</p>\n<ul>\n<li><p><code>struct file</code> 结构体定义在<code>include/linux/fs.h</code> 中。该结构体代表一个打开的文件，系统中每一个打开的文件在内核空间中都有一个关联的 <code>struct file</code>。它由内核在打开文件的时候创建，并传递给在该文件上进行操作的热河函数，在该文件的所有实例都关闭后，内核释放该数据结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> file &#123;</div><div class=\"line\">  <span class=\"keyword\">union</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> list_head             fu_list;      <span class=\"comment\">//文件对象链表指针linux/include/linux/list.h</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> rcu_head              fu_rcuhead;   <span class=\"comment\">//RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制</span></div><div class=\"line\">  &#125; f_u;</div><div class=\"line\">  <span class=\"keyword\">struct</span> path                    f_path;       <span class=\"comment\">//包含dentry和mnt两个成员，用于确定文件路径</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_dentry                 f_path.dentry <span class=\"comment\">//f_path的成员之一，当前文件的dentry结构</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_vfsmnt                 f_path.mnt    <span class=\"comment\">//表示当前文件所在文件系统的挂载根目录</span></span></div><div class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> file_operations  *f_op;         <span class=\"comment\">//与该文件相关联的操作函数</span></div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>                       f_count;      <span class=\"comment\">//文件的引用计数(有多少进程打开该文件)</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_flags;      <span class=\"comment\">//对应于open时指定的flag</span></div><div class=\"line\">  <span class=\"keyword\">mode_t</span>                         f_mode;       <span class=\"comment\">//读写模式：open的mod_t mode参数</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span>                          f_pos;        <span class=\"comment\">//该文件在当前进程中的文件偏移量</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> fown_struct             f_owner;      <span class=\"comment\">//该结构的作用是通过信号进行I/O时间通知的数据。</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_uid, f_gid; <span class=\"comment\">//文件所有者id，所有者组id</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> file_ra_state           f_ra;         <span class=\"comment\">//在linux/include/linux/fs.h中定义，文件预读相关</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>                  f_version;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SECURITY</span></div><div class=\"line\">  <span class=\"keyword\">void</span>                          *f_security;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　　</div><div class=\"line\">  <span class=\"keyword\">void</span>                          *private_data;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_EPOLL</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> list_head               f_ep_links;</div><div class=\"line\">  <span class=\"keyword\">spinlock_t</span>                     f_ep_lock;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　<span class=\"keyword\">struct</span> address_space *f_mapping;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>struct dentry</code><br><code>dentry</code> 是 Linux 文件系统中某个索引节点（<code>inode</code>）的链接。<code>inode</code> 对应于物理磁盘上的具体对象，<code>dentry</code> 是一个内存上的实体，其中的<code>d_inode</code> 指向对应的 <code>inode</code>。一个 <code>inode</code> 可以在运行的时候链接多个 <code>dentry</code>，而 <code>d_count</code> 记录了链接的具体数量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> dentry &#123;</div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>                  d_count;    <span class=\"comment\">//目录项对象使用计数器,可以有未使用态,使用态和负状态</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>              d_flags;    <span class=\"comment\">//目录项标志</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> inode *            d_inode;    <span class=\"comment\">//与文件名关联的索引节点</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> dentry *           d_parent;   <span class=\"comment\">//父目录的目录项对象</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_hash;     <span class=\"comment\">//散列表表项的指针</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_lru;      <span class=\"comment\">//未使用链表的指针</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_child;    <span class=\"comment\">//父目录中目录项对象的链表的指针</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_subdirs;  <span class=\"comment\">//对目录而言，表示子目录目录项对象的链表</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_alias;    <span class=\"comment\">//相关索引节点(别名)的链表</span></div><div class=\"line\">　<span class=\"keyword\">int</span>                       d_mounted;  <span class=\"comment\">//对于安装点而言，表示被安装文件系统根项</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> qstr               d_name;     <span class=\"comment\">//文件名</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>             d_time;</div><div class=\"line\">　<span class=\"keyword\">struct</span> dentry_operations *d_op;       <span class=\"comment\">//目录项方法</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> super_block       *d_sb;       <span class=\"comment\">//文件的超级块对象</span></div><div class=\"line\">　vunsigned <span class=\"keyword\">long</span>            d_vfs_flags;</div><div class=\"line\">　<span class=\"keyword\">void</span>                     *d_fsdata;   <span class=\"comment\">//与文件系统相关的数据</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>             d_iname [DNAME_INLINE_LEN]; <span class=\"comment\">//存放短文件名</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>struct files_struct</code><br>对于每个进程，包含一个<code>files_struct</code> 结构，用来记录文件描述符的使用情况。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> files_struct</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>               count;               <span class=\"comment\">//使用该表的进程数</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> fdtable        *fdt;</div><div class=\"line\">　<span class=\"keyword\">struct</span> fdtable         fdtab;</div><div class=\"line\">　<span class=\"keyword\">spinlock_t</span>             file_lock ____cacheline_aligned_in_smp;</div><div class=\"line\">　<span class=\"keyword\">int</span>                    next_fd;              <span class=\"comment\">//数值最小的最近关闭文件的文件描述符,下一个可用的文件描述符</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> embedded_fd_set close_on_exec_init;   <span class=\"comment\">//执行exec时需要关闭的文件描述符初值集合　struct embedded_fd_set open_fds_init;        //文件描述符的屏蔽字初值集合</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> file           *fd_array[NR_OPEN_DEFAULT]; 默认打开的fd队列</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">struct</span> fdtable &#123;</div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>      max_fds;</div><div class=\"line\">　<span class=\"keyword\">struct</span> file     **fd;            <span class=\"comment\">//指向打开的文件描述符列表的指针，开始的时候指向fd_array，</span></div><div class=\"line\">　当超过max_fds时，重新分配地址</div><div class=\"line\">　fd_set           *close_on_exec; <span class=\"comment\">//执行exec需要关闭的文件描述符位图(fork，exec即不被子进程继承的文件描述符)</span></div><div class=\"line\">　fd_set           *open_fds;      <span class=\"comment\">//打开的文件描述符位图</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> rcu_head   rcu;</div><div class=\"line\">　<span class=\"keyword\">struct</span> fdtable   *next;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>struct fs_struct</code><br><code>fs_struct</code> 是文件系统相关信息结构体。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> fs_struct &#123;</div><div class=\"line\"><span class=\"keyword\">atomic_t</span>          count;     <span class=\"comment\">//共享表的进程个数</span></div><div class=\"line\"><span class=\"keyword\">rwlock_t</span>          lock;      <span class=\"comment\">//自旋锁</span></div><div class=\"line\"><span class=\"keyword\">int</span>               umask;     <span class=\"comment\">//文件权限掩码</span></div><div class=\"line\"><span class=\"keyword\">struct</span> dentry    *root,      <span class=\"comment\">//根目录目录项</span></div><div class=\"line\">                  *pwd,       <span class=\"comment\">//当前目录目录项</span></div><div class=\"line\">                  *altroot;   <span class=\"comment\">//模拟根目录目录项</span></div><div class=\"line\"><span class=\"keyword\">struct</span> vfsmount  *rootmnt,   <span class=\"comment\">//根目录文件系统对象</span></div><div class=\"line\">                  *pwdmnt,    <span class=\"comment\">//</span></div><div class=\"line\">                  *altrootmnt;<span class=\"comment\">//</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个进程都有一个 <code>task_struct</code> 结构体，其中包含了一个 <code>fs_struct</code> 和一个 <code>files_struct</code> 结构体，其中 <code>files_struct</code> 中的 <code>fd_array</code> 记录了所有该进程打开的文件的 <code>file</code> 结构体，每个 <code>file</code> 结构体中的 <code>f_entry</code> 指向了当前文件的 <code>dentry</code> 结构体，<code>debtry</code> 结构体实际指向了相应的文件 <code>inode</code>。 </p>\n</li>\n<li><p><code>inode</code><br>inode包含文件的元信息，具体来说有以下内容： </p>\n<ul>\n<li>文件的字节数 文件的字节数 　　 　　</li>\n<li>文件拥有者的 文件拥有者的User ID 　　 　　</li>\n<li>文件的 文件的Group ID 　　 　　</li>\n<li>文件的读、写、执行权限 文件的读、写、执行权限 　　 　　</li>\n<li>文件的时间戳，共有三个： 文件的时间戳，共有三个：<br>ctime指 指inode上一次变动的时间， 上一次变动的时间，<br>mtime指文件内容上一次变动的时间， 指文件内容上一次变动的时间，<br>atime指文件上一 指文件上一 次打开的时间。 次打开的时间。 　　 　　</li>\n<li>链接数，即有多少文件名指向这个 链接数，即有多少文件名指向这个inode 　　 　　</li>\n<li>文件数据 文件数据block的位置 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-I-O操作过程\"><a href=\"#3-I-O操作过程\" class=\"headerlink\" title=\"3. I/O操作过程\"></a>3. I/O操作过程</h3><ol>\n<li><p>打开文件<br>一个应用程序通过要求内核打开相应文件，宣告他要访问一个I/O设备 ，内核返回一个非负整数，叫描述符号(Descriptor）；</p>\n</li>\n<li><p>改变文件位置<br>对于每个打开的文件，内核保持一个文件位置k，初始为0，这个文件位置是从文件头开始的偏移量。通过执行seek操作，显式地设置当前位置为k</p>\n</li>\n<li><p>读写文件<br>读：从文件拷贝n&gt;0个字节到存储器，写：从存储器拷贝n&gt;0字节到文件</p>\n</li>\n<li><p>关闭文件<br>通知内核关闭文件，作为响应，内核释放文件打开时创建的数据结构</p>\n</li>\n</ol>\n<h2 id=\"三、记录锁\"><a href=\"#三、记录锁\" class=\"headerlink\" title=\"三、记录锁\"></a>三、记录锁</h2><p>记录锁解决的是多个进程共同操作一个文件的问题，记录锁分为两种：</p>\n<ul>\n<li>建议性锁：建议性锁要求每个相关程序在访问文件前检查是否有锁存在，并尊重已有的锁。</li>\n<li>强制性锁：强制性锁是由内核执行的锁，当一个文件被上锁进行写操作时，内核将阻止任何其它的程序进行该文件的读写操作。</li>\n</ul>\n<p>我们通常使用的是强制性锁，强制性锁的上锁函数是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> cmd, ...)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>第一个参数 <code>fd</code> 显然指的是需要操作的文件描述符，第二个参数 <code>cmd</code> 是 <code>F_GETLK</code> / <code>F_SETLK</code> / <code>F_SETLKW</code>，当进行锁操作的时候，第三个参数是一个指向 <code>flock</code> 结构的指针。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> flock &#123;</div><div class=\"line\">  <span class=\"keyword\">short</span> l_type;   <span class=\"comment\">//希望的锁类型 F_RDLCK(读锁) F_WRLCK（写锁） F_UNLCK（解锁）</span></div><div class=\"line\">  <span class=\"keyword\">short</span> l_whence; <span class=\"comment\">//区域的起始位置 SEEK_SET SEEK_CUR SEEK_END</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span> l_start;  <span class=\"comment\">//区域的起始字节</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span> l_len;    <span class=\"comment\">//区域的字节长度</span></div><div class=\"line\">  <span class=\"keyword\">pid_t</span> l_pid;    <span class=\"comment\">//持有锁的进程IO</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当 <code>cmd</code> 是 <code>F_GETLK</code> 时，函数会检查当前锁是否能够创建，如果可以创建，则将 <code>1_type</code> 设置为 <code>F_UNLCK</code>，否则则将当前锁的信息重写。<br>当 <code>cmd</code> 是 <code>F_SETLK</code> 时，设置相应的锁，如果不能创建，返回失败代码。<br>当 <code>cmd</code> 是 <code>F_GETLK</code> 时，如果当前设置的锁无法设置，则休眠等待锁创建。</p>\n<p>记录锁的几个注意点：</p>\n<ol>\n<li>检查锁是否存在，和加锁过程并不是原子操作，所以，当检查当前锁不存在后加锁，依旧有可能会失败。</li>\n<li>如果两个进程相互等待对方持有并不释放（锁定）的资源时，造成死锁。</li>\n<li>当进程终止时，它所建立的所有锁释放</li>\n<li>当文件描述符关闭的时候，该文件描述符上的所有锁释放</li>\n<li><code>fork</code> 不继承任何锁。</li>\n</ol>\n<h2 id=\"四、I-O复用\"><a href=\"#四、I-O复用\" class=\"headerlink\" title=\"四、I/O复用\"></a>四、I/O复用</h2><p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>\n<h3 id=\"1-select\"><a href=\"#1-select\" class=\"headerlink\" title=\"1. select\"></a>1. <code>select</code></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span> <span class=\"params\">(<span class=\"keyword\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>select</code> 函数监视的文件描述符分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后 <code>select</code> 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（<code>timeout</code>指定等待时间，如果立即返回设为null即可），函数返回。当 <code>select</code> 函数返回后，可以 通过遍历 <code>fdset</code>，来找到就绪的描述符。</p>\n<p>函数的第一个参数 <code>n</code> 指的是<strong>最大描述符编号加1</strong>，即需要监视的3类文件描述符中的最大值加1.<br>函数中间的三个参数指函数监视的3类文件描述符的集合，分别是 <code>writefds</code>（可写）、<code>readfds</code>（可写）、和 <code>exceptfds</code>（处于异常）。有几个相应的接口可以设置这三个集合：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_ISSET</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>; <span class=\"comment\">//测试描述符集中的某一位是否开启</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_CLR</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>;   <span class=\"comment\">//清除描述符集中的某一位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_SET</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>;   <span class=\"comment\">//开启描述符集中的某一位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_ZERO</span><span class=\"params\">(fd_set *fdset)</span></span>;          <span class=\"comment\">//清空描述符集中的所有位</span></div></pre></td></tr></table></figure></p>\n<p>函数的最后一个参数 <code>timeout</code> 指定等待的时间，当为 <code>NULL</code> 的时候，一直等待；当为 0 的时候，不等待。</p>\n<p>函数有三个可能的返回值：</p>\n<ul>\n<li>返回-1；表示出错。</li>\n<li>返回0；表示没有描述符准备好。</li>\n<li>一个正的返回值：表示已经准备好的描述符数。<br>已经准备好指的是：相应的读写没有阻塞，或者某个描述符存在未决异常条件。</li>\n</ul>\n<h3 id=\"2-poll\"><a href=\"#2-poll\" class=\"headerlink\" title=\"2. poll\"></a>2. <code>poll</code></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span> <span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> nfds, <span class=\"keyword\">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>\n<p>不同与 <code>select</code> 使用三个位图来表示三个 <code>fdset</code> 的方式，poll使用一个 pollfd的指针实现。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> pollfd &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fd;          <span class=\"comment\">/* file descriptor */</span></div><div class=\"line\">    <span class=\"keyword\">short</span> events;    <span class=\"comment\">/* requested events to watch */</span></div><div class=\"line\">    <span class=\"keyword\">short</span> revents;   <span class=\"comment\">/* returned events witnessed */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><code>pollfd</code> 结构包含了要监视的 event 和发生的 event，不再使用 <code>select</code> <strong>参数-值</strong>传递的方式。<br><code>pollfd</code> 并没有最大数量限制（但是数量过大后性能也是会下降）。<code>timeout</code> 参数只当了我们等待的时间，为-1表示永远等待，为0表示不等待，为正表示等待的时间（毫秒）。<br>和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 <code>pollfd</code> 来获取就绪的描述符。</p>\n<h3 id=\"3-epoll\"><a href=\"#3-epoll\" class=\"headerlink\" title=\"3. epoll\"></a>3. epoll</h3><p><code>epoll</code> 是在2.6内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>\n<p><code>epoll</code> 操作过程需要三个接口，分别如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int epoll_create(int size)； //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</div><div class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</div><div class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>int epoll_create(int size);</code><br>  创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select()</code> 中的第一个参数，参数 <code>size</code> 并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>  当创建好 <code>epoll</code> 句柄后，它就会占用一个fd值，在 Linux 下如果查看 <code>/proc/进程id/fd/</code>，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致fd被耗尽。</p>\n</li>\n<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code><br>  函数是对指定描述符 <code>fd</code> 执行 <code>op</code> 操作。</p>\n<ul>\n<li><code>epfd</code>：是 <code>epoll_create()</code> 的返回值。</li>\n<li><code>op</code>：表示 op 操作，用三个宏来表示：添加 <code>EPOLL_CTL_ADD</code>，删除 <code>EPOLL_CTL_DEL</code>，修改 <code>EPOLL_CTL_MOD</code>。分别添加、删除和修改对fd的监听事件。</li>\n<li><code>fd</code>：是需要监听的 <code>fd</code>（文件描述符）</li>\n<li><code>epoll_event</code>：是告诉内核需要监听什么事，<code>struct epoll_event</code>结构如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> epoll_event &#123;</div><div class=\"line\">  <span class=\"keyword\">__uint32_t</span> events;  <span class=\"comment\">/* Epoll events */</span></div><div class=\"line\">  <span class=\"keyword\">epoll_data_t</span> data;  <span class=\"comment\">/* User data variable */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>events可以是以下几个宏的集合：<br><code>EPOLLIN</code>：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br><code>EPOLLOUT</code>：表示对应的文件描述符可以写；<br><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><code>EPOLLERR</code>：表示对应的文件描述符发生错误；<br><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；<br><code>EPOLLET</code>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>\n</li>\n<li><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>  等待 <code>epfd</code> 上的 I/O 事件，最多返回 <code>maxevents</code> 个事件。<br>  参数 <code>events</code> 用来存储从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code>，参数<code>timeout</code> 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>\n</ul>\n","excerpt":"<p>高级I/O包含了很多内容，本篇会首先解释下几个相关的概念：阻塞、非阻塞、同步、异步等的概念；接着介绍下 Linux I/O 操作的具体过程；最后讨论下多路复用、记录锁等几个相关函数。<br>","more":"</p>\n<h2 id=\"一、概念说明\"><a href=\"#一、概念说明\" class=\"headerlink\" title=\"一、概念说明\"></a>一、概念说明</h2><p>Linux 的每个进程都是拥有自己的虚拟内存空间的，而一个进程的虚拟内存空间分为内核空间和用户空间两个部分，当进程的执行过程中期待的某种事情没有发生：请求系统资源失败、等待某种操作的完成、新数据尚未到达等。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>\n<ol>\n<li>等待数据准备 (Waiting for the data to be ready)</li>\n<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>\n</ol>\n<p>正式因为这两个阶段，Linux系统产生了下面五种I/O:</p>\n<h3 id=\"1-阻塞式I-O\"><a href=\"#1-阻塞式I-O\" class=\"headerlink\" title=\"1. 阻塞式I/O\"></a>1. 阻塞式I/O</h3><p> 通常来说，从普通文件读数据，无论你是采用 <code>fscanf</code>、 <code>fgets</code> 也好，<code>read</code> 也好，一定会在有限的时间内返回。但是如果你从设备，比如终端（标准输入设备）读数据，只要没有遇到换行符(<code>\\n</code>)，<code>read</code> 一定会<strong>堵</strong>在那而不返回。还有比如从网络读数据，如果网络一直没有数据到来，<code>read</code> 函数也会一直堵在那而不返回。<br> <code>read</code> 的这种行为，称之为 block，一旦发生 block，本进程将会被操作系统投入睡眠，直到等待的事件发生了（比如有数据到来），进程才会被唤醒。<br> 系统调用 <code>write</code> 同样有可能被阻塞，比如向网络写入数据，如果对方一直不接收，本端的缓冲区一旦被写满，就会被阻塞。</p>\n<h3 id=\"2-非阻塞式I-O\"><a href=\"#2-非阻塞式I-O\" class=\"headerlink\" title=\"2. 非阻塞式I/O\"></a>2. 非阻塞式I/O</h3><p> 当用户进程发出 <code>read</code> 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<blockquote>\n<p>所以:<br> 非阻塞式I/O的特点是用户进程需要不断的主动询问 kernel 数据好了没有。<br> 阻塞非阻塞是文件本身的特性，不是系统调用read/write本身可以控制的。</p>\n</blockquote>\n<h3 id=\"3-I-O多路复用\"><a href=\"#3-I-O多路复用\" class=\"headerlink\" title=\"3. I/O多路复用\"></a>3. I/O多路复用</h3><p> I/O多路复用（<code>IO multiplexing</code>）就是我们说的 <code>select</code>、 <code>poll</code>、 <code>epoll</code>，指的是单个 <code>process</code> 可以同时处理多个 IO 操作。它的基本原理就是 <code>select</code>、 <code>poll</code>、 <code>epoll</code> 会不断的轮询所负责的所有 I/O，当某个 I/O 有数据到达了，就通知用户进程。</p>\n<blockquote>\n<p>所以:<br> I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code> 函数就可以返回。</p>\n</blockquote>\n<h3 id=\"4-异步I-O\"><a href=\"#4-异步I-O\" class=\"headerlink\" title=\"4. 异步I/O\"></a>4. 异步I/O</h3><p> 当用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。</p>\n<blockquote>\n<p>同步I/O 和 异步I/O 的区别：<br> 两者之间的区别就在于同步I/O 做 I/O操作的时候会将进程阻塞，所以，按照这个定义，之前的<strong>阻塞I/O、非阻塞I/O、I/O多路复用都属于同步I/O</strong>。<br> 非阻塞I/O 之所以属于同步I/O 是因为其非阻塞是因为并没有进行相应的IO操作，在其进行IO操作的时候，依旧是阻塞的。</p>\n</blockquote>\n<ol>\n<li>信号驱动I/O</li>\n</ol>\n<h2 id=\"Linux-的-I-O-操作过程\"><a href=\"#Linux-的-I-O-操作过程\" class=\"headerlink\" title=\"Linux 的 I/O 操作过程\"></a>Linux 的 I/O 操作过程</h2><h3 id=\"1-GNU-Linux-I-O操作类别\"><a href=\"#1-GNU-Linux-I-O操作类别\" class=\"headerlink\" title=\"1. GNU Linux I/O操作类别\"></a>1. GNU Linux I/O操作类别</h3><p> Linux 的文件操作并不仅仅是对我们通常意义上的文件的读写，基于<strong>一切接文件</strong>的思想，Linux的I/O操作类别包含一下几类：</p>\n<ul>\n<li>文件及流的标准输入输出</li>\n<li>底层输入输出</li>\n<li>文件系统接口</li>\n<li>管道及FIFO（先入先出队列）</li>\n<li>Socket</li>\n<li>底层终端接口（tty）</li>\n</ul>\n<h3 id=\"2-主要数据结构介绍\"><a href=\"#2-主要数据结构介绍\" class=\"headerlink\" title=\"2. 主要数据结构介绍\"></a>2. 主要数据结构介绍</h3><ol>\n<li><p><code>FD</code><br>对于内核而言，所有打开文件都由文件描述符引用。<br>文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用<code>open</code>或<code>creat</code>返回的文件描述符<code>fd</code>标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。在 POSIX.1 应用程序中，文件描述符为常数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别代表 <code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code> 和 <code>STDERR_FILENO</code>，意即标准输入，标准输出和标准出错输出，这些常数都定义在头文件 <code>&lt;unistd.h&gt;</code>中。文件描述符的范围是 <code>0~OPEN_MAX</code>，在目前常用的linux系统中，是32位整形所能表示的整数，即65535，64位机上则更多。</p>\n</li>\n<li><p>进程中文件相关结构体</p>\n<ul>\n<li><p><code>struct file</code> 结构体定义在<code>include/linux/fs.h</code> 中。该结构体代表一个打开的文件，系统中每一个打开的文件在内核空间中都有一个关联的 <code>struct file</code>。它由内核在打开文件的时候创建，并传递给在该文件上进行操作的热河函数，在该文件的所有实例都关闭后，内核释放该数据结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> file &#123;</div><div class=\"line\">  <span class=\"keyword\">union</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> list_head             fu_list;      <span class=\"comment\">//文件对象链表指针linux/include/linux/list.h</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> rcu_head              fu_rcuhead;   <span class=\"comment\">//RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制</span></div><div class=\"line\">  &#125; f_u;</div><div class=\"line\">  <span class=\"keyword\">struct</span> path                    f_path;       <span class=\"comment\">//包含dentry和mnt两个成员，用于确定文件路径</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_dentry                 f_path.dentry <span class=\"comment\">//f_path的成员之一，当前文件的dentry结构</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_vfsmnt                 f_path.mnt    <span class=\"comment\">//表示当前文件所在文件系统的挂载根目录</span></span></div><div class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> file_operations  *f_op;         <span class=\"comment\">//与该文件相关联的操作函数</span></div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>                       f_count;      <span class=\"comment\">//文件的引用计数(有多少进程打开该文件)</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_flags;      <span class=\"comment\">//对应于open时指定的flag</span></div><div class=\"line\">  <span class=\"keyword\">mode_t</span>                         f_mode;       <span class=\"comment\">//读写模式：open的mod_t mode参数</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span>                          f_pos;        <span class=\"comment\">//该文件在当前进程中的文件偏移量</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> fown_struct             f_owner;      <span class=\"comment\">//该结构的作用是通过信号进行I/O时间通知的数据。</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_uid, f_gid; <span class=\"comment\">//文件所有者id，所有者组id</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> file_ra_state           f_ra;         <span class=\"comment\">//在linux/include/linux/fs.h中定义，文件预读相关</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>                  f_version;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SECURITY</span></div><div class=\"line\">  <span class=\"keyword\">void</span>                          *f_security;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　　</div><div class=\"line\">  <span class=\"keyword\">void</span>                          *private_data;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_EPOLL</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> list_head               f_ep_links;</div><div class=\"line\">  <span class=\"keyword\">spinlock_t</span>                     f_ep_lock;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　<span class=\"keyword\">struct</span> address_space *f_mapping;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>struct dentry</code><br><code>dentry</code> 是 Linux 文件系统中某个索引节点（<code>inode</code>）的链接。<code>inode</code> 对应于物理磁盘上的具体对象，<code>dentry</code> 是一个内存上的实体，其中的<code>d_inode</code> 指向对应的 <code>inode</code>。一个 <code>inode</code> 可以在运行的时候链接多个 <code>dentry</code>，而 <code>d_count</code> 记录了链接的具体数量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> dentry &#123;</div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>                  d_count;    <span class=\"comment\">//目录项对象使用计数器,可以有未使用态,使用态和负状态</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>              d_flags;    <span class=\"comment\">//目录项标志</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> inode *            d_inode;    <span class=\"comment\">//与文件名关联的索引节点</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> dentry *           d_parent;   <span class=\"comment\">//父目录的目录项对象</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_hash;     <span class=\"comment\">//散列表表项的指针</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_lru;      <span class=\"comment\">//未使用链表的指针</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_child;    <span class=\"comment\">//父目录中目录项对象的链表的指针</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_subdirs;  <span class=\"comment\">//对目录而言，表示子目录目录项对象的链表</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> list_head          d_alias;    <span class=\"comment\">//相关索引节点(别名)的链表</span></div><div class=\"line\">　<span class=\"keyword\">int</span>                       d_mounted;  <span class=\"comment\">//对于安装点而言，表示被安装文件系统根项</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> qstr               d_name;     <span class=\"comment\">//文件名</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>             d_time;</div><div class=\"line\">　<span class=\"keyword\">struct</span> dentry_operations *d_op;       <span class=\"comment\">//目录项方法</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> super_block       *d_sb;       <span class=\"comment\">//文件的超级块对象</span></div><div class=\"line\">　vunsigned <span class=\"keyword\">long</span>            d_vfs_flags;</div><div class=\"line\">　<span class=\"keyword\">void</span>                     *d_fsdata;   <span class=\"comment\">//与文件系统相关的数据</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>             d_iname [DNAME_INLINE_LEN]; <span class=\"comment\">//存放短文件名</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>struct files_struct</code><br>对于每个进程，包含一个<code>files_struct</code> 结构，用来记录文件描述符的使用情况。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> files_struct</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>               count;               <span class=\"comment\">//使用该表的进程数</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> fdtable        *fdt;</div><div class=\"line\">　<span class=\"keyword\">struct</span> fdtable         fdtab;</div><div class=\"line\">　<span class=\"keyword\">spinlock_t</span>             file_lock ____cacheline_aligned_in_smp;</div><div class=\"line\">　<span class=\"keyword\">int</span>                    next_fd;              <span class=\"comment\">//数值最小的最近关闭文件的文件描述符,下一个可用的文件描述符</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> embedded_fd_set close_on_exec_init;   <span class=\"comment\">//执行exec时需要关闭的文件描述符初值集合　struct embedded_fd_set open_fds_init;        //文件描述符的屏蔽字初值集合</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> file           *fd_array[NR_OPEN_DEFAULT]; 默认打开的fd队列</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">struct</span> fdtable &#123;</div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>      max_fds;</div><div class=\"line\">　<span class=\"keyword\">struct</span> file     **fd;            <span class=\"comment\">//指向打开的文件描述符列表的指针，开始的时候指向fd_array，</span></div><div class=\"line\">　当超过max_fds时，重新分配地址</div><div class=\"line\">　fd_set           *close_on_exec; <span class=\"comment\">//执行exec需要关闭的文件描述符位图(fork，exec即不被子进程继承的文件描述符)</span></div><div class=\"line\">　fd_set           *open_fds;      <span class=\"comment\">//打开的文件描述符位图</span></div><div class=\"line\">　<span class=\"keyword\">struct</span> rcu_head   rcu;</div><div class=\"line\">　<span class=\"keyword\">struct</span> fdtable   *next;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>struct fs_struct</code><br><code>fs_struct</code> 是文件系统相关信息结构体。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> fs_struct &#123;</div><div class=\"line\"><span class=\"keyword\">atomic_t</span>          count;     <span class=\"comment\">//共享表的进程个数</span></div><div class=\"line\"><span class=\"keyword\">rwlock_t</span>          lock;      <span class=\"comment\">//自旋锁</span></div><div class=\"line\"><span class=\"keyword\">int</span>               umask;     <span class=\"comment\">//文件权限掩码</span></div><div class=\"line\"><span class=\"keyword\">struct</span> dentry    *root,      <span class=\"comment\">//根目录目录项</span></div><div class=\"line\">                  *pwd,       <span class=\"comment\">//当前目录目录项</span></div><div class=\"line\">                  *altroot;   <span class=\"comment\">//模拟根目录目录项</span></div><div class=\"line\"><span class=\"keyword\">struct</span> vfsmount  *rootmnt,   <span class=\"comment\">//根目录文件系统对象</span></div><div class=\"line\">                  *pwdmnt,    <span class=\"comment\">//</span></div><div class=\"line\">                  *altrootmnt;<span class=\"comment\">//</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个进程都有一个 <code>task_struct</code> 结构体，其中包含了一个 <code>fs_struct</code> 和一个 <code>files_struct</code> 结构体，其中 <code>files_struct</code> 中的 <code>fd_array</code> 记录了所有该进程打开的文件的 <code>file</code> 结构体，每个 <code>file</code> 结构体中的 <code>f_entry</code> 指向了当前文件的 <code>dentry</code> 结构体，<code>debtry</code> 结构体实际指向了相应的文件 <code>inode</code>。 </p>\n</li>\n<li><p><code>inode</code><br>inode包含文件的元信息，具体来说有以下内容： </p>\n<ul>\n<li>文件的字节数 文件的字节数 　　 　　</li>\n<li>文件拥有者的 文件拥有者的User ID 　　 　　</li>\n<li>文件的 文件的Group ID 　　 　　</li>\n<li>文件的读、写、执行权限 文件的读、写、执行权限 　　 　　</li>\n<li>文件的时间戳，共有三个： 文件的时间戳，共有三个：<br>ctime指 指inode上一次变动的时间， 上一次变动的时间，<br>mtime指文件内容上一次变动的时间， 指文件内容上一次变动的时间，<br>atime指文件上一 指文件上一 次打开的时间。 次打开的时间。 　　 　　</li>\n<li>链接数，即有多少文件名指向这个 链接数，即有多少文件名指向这个inode 　　 　　</li>\n<li>文件数据 文件数据block的位置 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-I-O操作过程\"><a href=\"#3-I-O操作过程\" class=\"headerlink\" title=\"3. I/O操作过程\"></a>3. I/O操作过程</h3><ol>\n<li><p>打开文件<br>一个应用程序通过要求内核打开相应文件，宣告他要访问一个I/O设备 ，内核返回一个非负整数，叫描述符号(Descriptor）；</p>\n</li>\n<li><p>改变文件位置<br>对于每个打开的文件，内核保持一个文件位置k，初始为0，这个文件位置是从文件头开始的偏移量。通过执行seek操作，显式地设置当前位置为k</p>\n</li>\n<li><p>读写文件<br>读：从文件拷贝n&gt;0个字节到存储器，写：从存储器拷贝n&gt;0字节到文件</p>\n</li>\n<li><p>关闭文件<br>通知内核关闭文件，作为响应，内核释放文件打开时创建的数据结构</p>\n</li>\n</ol>\n<h2 id=\"三、记录锁\"><a href=\"#三、记录锁\" class=\"headerlink\" title=\"三、记录锁\"></a>三、记录锁</h2><p>记录锁解决的是多个进程共同操作一个文件的问题，记录锁分为两种：</p>\n<ul>\n<li>建议性锁：建议性锁要求每个相关程序在访问文件前检查是否有锁存在，并尊重已有的锁。</li>\n<li>强制性锁：强制性锁是由内核执行的锁，当一个文件被上锁进行写操作时，内核将阻止任何其它的程序进行该文件的读写操作。</li>\n</ul>\n<p>我们通常使用的是强制性锁，强制性锁的上锁函数是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> cmd, ...)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>第一个参数 <code>fd</code> 显然指的是需要操作的文件描述符，第二个参数 <code>cmd</code> 是 <code>F_GETLK</code> / <code>F_SETLK</code> / <code>F_SETLKW</code>，当进行锁操作的时候，第三个参数是一个指向 <code>flock</code> 结构的指针。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> flock &#123;</div><div class=\"line\">  <span class=\"keyword\">short</span> l_type;   <span class=\"comment\">//希望的锁类型 F_RDLCK(读锁) F_WRLCK（写锁） F_UNLCK（解锁）</span></div><div class=\"line\">  <span class=\"keyword\">short</span> l_whence; <span class=\"comment\">//区域的起始位置 SEEK_SET SEEK_CUR SEEK_END</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span> l_start;  <span class=\"comment\">//区域的起始字节</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span> l_len;    <span class=\"comment\">//区域的字节长度</span></div><div class=\"line\">  <span class=\"keyword\">pid_t</span> l_pid;    <span class=\"comment\">//持有锁的进程IO</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当 <code>cmd</code> 是 <code>F_GETLK</code> 时，函数会检查当前锁是否能够创建，如果可以创建，则将 <code>1_type</code> 设置为 <code>F_UNLCK</code>，否则则将当前锁的信息重写。<br>当 <code>cmd</code> 是 <code>F_SETLK</code> 时，设置相应的锁，如果不能创建，返回失败代码。<br>当 <code>cmd</code> 是 <code>F_GETLK</code> 时，如果当前设置的锁无法设置，则休眠等待锁创建。</p>\n<p>记录锁的几个注意点：</p>\n<ol>\n<li>检查锁是否存在，和加锁过程并不是原子操作，所以，当检查当前锁不存在后加锁，依旧有可能会失败。</li>\n<li>如果两个进程相互等待对方持有并不释放（锁定）的资源时，造成死锁。</li>\n<li>当进程终止时，它所建立的所有锁释放</li>\n<li>当文件描述符关闭的时候，该文件描述符上的所有锁释放</li>\n<li><code>fork</code> 不继承任何锁。</li>\n</ol>\n<h2 id=\"四、I-O复用\"><a href=\"#四、I-O复用\" class=\"headerlink\" title=\"四、I/O复用\"></a>四、I/O复用</h2><p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>\n<h3 id=\"1-select\"><a href=\"#1-select\" class=\"headerlink\" title=\"1. select\"></a>1. <code>select</code></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span> <span class=\"params\">(<span class=\"keyword\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>select</code> 函数监视的文件描述符分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后 <code>select</code> 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（<code>timeout</code>指定等待时间，如果立即返回设为null即可），函数返回。当 <code>select</code> 函数返回后，可以 通过遍历 <code>fdset</code>，来找到就绪的描述符。</p>\n<p>函数的第一个参数 <code>n</code> 指的是<strong>最大描述符编号加1</strong>，即需要监视的3类文件描述符中的最大值加1.<br>函数中间的三个参数指函数监视的3类文件描述符的集合，分别是 <code>writefds</code>（可写）、<code>readfds</code>（可写）、和 <code>exceptfds</code>（处于异常）。有几个相应的接口可以设置这三个集合：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_ISSET</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>; <span class=\"comment\">//测试描述符集中的某一位是否开启</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_CLR</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>;   <span class=\"comment\">//清除描述符集中的某一位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_SET</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>;   <span class=\"comment\">//开启描述符集中的某一位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_ZERO</span><span class=\"params\">(fd_set *fdset)</span></span>;          <span class=\"comment\">//清空描述符集中的所有位</span></div></pre></td></tr></table></figure></p>\n<p>函数的最后一个参数 <code>timeout</code> 指定等待的时间，当为 <code>NULL</code> 的时候，一直等待；当为 0 的时候，不等待。</p>\n<p>函数有三个可能的返回值：</p>\n<ul>\n<li>返回-1；表示出错。</li>\n<li>返回0；表示没有描述符准备好。</li>\n<li>一个正的返回值：表示已经准备好的描述符数。<br>已经准备好指的是：相应的读写没有阻塞，或者某个描述符存在未决异常条件。</li>\n</ul>\n<h3 id=\"2-poll\"><a href=\"#2-poll\" class=\"headerlink\" title=\"2. poll\"></a>2. <code>poll</code></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span> <span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> nfds, <span class=\"keyword\">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>\n<p>不同与 <code>select</code> 使用三个位图来表示三个 <code>fdset</code> 的方式，poll使用一个 pollfd的指针实现。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> pollfd &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> fd;          <span class=\"comment\">/* file descriptor */</span></div><div class=\"line\">    <span class=\"keyword\">short</span> events;    <span class=\"comment\">/* requested events to watch */</span></div><div class=\"line\">    <span class=\"keyword\">short</span> revents;   <span class=\"comment\">/* returned events witnessed */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><code>pollfd</code> 结构包含了要监视的 event 和发生的 event，不再使用 <code>select</code> <strong>参数-值</strong>传递的方式。<br><code>pollfd</code> 并没有最大数量限制（但是数量过大后性能也是会下降）。<code>timeout</code> 参数只当了我们等待的时间，为-1表示永远等待，为0表示不等待，为正表示等待的时间（毫秒）。<br>和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 <code>pollfd</code> 来获取就绪的描述符。</p>\n<h3 id=\"3-epoll\"><a href=\"#3-epoll\" class=\"headerlink\" title=\"3. epoll\"></a>3. epoll</h3><p><code>epoll</code> 是在2.6内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>\n<p><code>epoll</code> 操作过程需要三个接口，分别如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int epoll_create(int size)； //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</div><div class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</div><div class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>int epoll_create(int size);</code><br>  创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select()</code> 中的第一个参数，参数 <code>size</code> 并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>  当创建好 <code>epoll</code> 句柄后，它就会占用一个fd值，在 Linux 下如果查看 <code>/proc/进程id/fd/</code>，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致fd被耗尽。</p>\n</li>\n<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code><br>  函数是对指定描述符 <code>fd</code> 执行 <code>op</code> 操作。</p>\n<ul>\n<li><code>epfd</code>：是 <code>epoll_create()</code> 的返回值。</li>\n<li><code>op</code>：表示 op 操作，用三个宏来表示：添加 <code>EPOLL_CTL_ADD</code>，删除 <code>EPOLL_CTL_DEL</code>，修改 <code>EPOLL_CTL_MOD</code>。分别添加、删除和修改对fd的监听事件。</li>\n<li><code>fd</code>：是需要监听的 <code>fd</code>（文件描述符）</li>\n<li><code>epoll_event</code>：是告诉内核需要监听什么事，<code>struct epoll_event</code>结构如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> epoll_event &#123;</div><div class=\"line\">  <span class=\"keyword\">__uint32_t</span> events;  <span class=\"comment\">/* Epoll events */</span></div><div class=\"line\">  <span class=\"keyword\">epoll_data_t</span> data;  <span class=\"comment\">/* User data variable */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>events可以是以下几个宏的集合：<br><code>EPOLLIN</code>：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br><code>EPOLLOUT</code>：表示对应的文件描述符可以写；<br><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><code>EPOLLERR</code>：表示对应的文件描述符发生错误；<br><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；<br><code>EPOLLET</code>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>\n</li>\n<li><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>  等待 <code>epfd</code> 上的 I/O 事件，最多返回 <code>maxevents</code> 个事件。<br>  参数 <code>events</code> 用来存储从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code>，参数<code>timeout</code> 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>\n</ul>"},{"title":"Linux学习总结（四）——标准I/O与文件I/O","date":"2016-12-16T06:54:55.000Z","_content":"\n在应用开发中，经常要访问文件，Linux 下的文件读写方式分为两大类：标准 I/O 和 文件 I/O，下面分别介绍下两种 I/O 的相关操作，并比较下两种 I/O 的特点。\n<!--more-->\n\n## 一、标准I/O\n标准I/O库接口由ANSI C标准定义，标准IO函数提供了一种对不用缓冲IO函数的带缓冲的接口。不仅在UNIX系统，在很多操作系统上都实现了标准I/O库，标准I/O库处理很多细节，如缓存分配、以优化长度执行I/O等，这样使用户不必关心如何选择合适的块长度。标准I/O在系统调用基础上构造的，它便于用户使用。标准I/O有两个很重要的定义。\n* 文件指针\n`FILE`：每个被打开的文件都在内存中开辟一个区域，用来存放文件的有关信息。这些信息保存在一个结构体类型的变量中，该结构体类型是由系统定义的，称为`FILE`。\n* 流\n`stream`：所有的I/O操作本质上都是从文件中输入或输出字节流，所以称为流。\n\n标准I/O预定义3个流，他们可以自动地为进程所使用：标准输入/标准输出/标准错误输出。\n\n### 1. 文件缓冲\n系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区在一起送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区逐个的将数据送到程序的数据区。这样的目的是尽量减少使用`read`/`write`的调用。文件缓冲可以分为三类：\n* 全缓冲\n当填满I/O缓存后才进行实际I/O操作，或者满足一定条件后，系统通过调用malloc来获得所需要的缓冲区域，默认值。\n刷新(`fflush`)：标准I/O的写操作。\n当缓冲区满了，或者满足一定的条件后，就会执行刷新操作。\n* 行缓冲\n当在输入和输出中遇到新行符(`\\n`)时，进行I/O操作。\n当流遇到一个终端时，典型的行缓存。\n* 无缓冲\n标准错误流`stderr`无缓冲。\n很多的人机交互界面要求不可全缓冲。\n\n### 2. 打开流\n````C\nFILE *fopen (const char *path, const char *mode);\nFILE *freopen(const char *restrict pathname, const char *restrict type, FILE* restrict fp)````\n`fopen()`打开由 `path` 指定的一个文件。\n`mode` 的值如下：\n`r`/`rb` 打开只读文件，该文件必须存在。\n`w`/`wb` 打开只写文件，若文件存在则文件长度清为0，若文件不存在则建立该文件。\n`a`/`ab` 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾。\n当给定 `b` 参数时，表示以二进制方式打开文件。\n\n### 3. 关闭流\n````C\nint fclose(FILE *stream);\n````\n`fclose()`用于关闭一个已经打开的流:调用成功返回0，失败返回EOF，并设置errno。\n在该文件被关闭之前，刷新缓存中的数据。如果标准I / O库已经为该流自动分配了一个缓存，则释放此缓存。\n当一个进程正常终止时(直接调用exit函数，或从main函数返回)，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭。\n在调用 `fclose()` 关闭流后对流所进行的任何操作，包括再次调用 `fclose()`，其结果都将是未知的\n\n### 4. 读写流\n调用 `fopen()` 成功打开流之后，可采用三种不同方式对其进行读写操作:\n* 每次一个字符的I/O。\n 使用 `fgetc()`/`fputc()` 一次读或写一个字符。\n* 每次一行的I/O。\n 使用 `fgets()` 和 `fputs()` 一次读或写一行。每行都以一个换行符终止。当调用 `fgets()` 时，应指明能处理的最大行长度。\n* 直接I/O。\n `fread()` 和 `fwrite()` 函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中读或写。\n\n1. 字符I/O\n\n ````C\nint getc(FILE *stream);\nint fgetc(FILE *stream);\nint getchar(void);\n````\n 三个函数的返回：若成功则为下一个字符，若已处文件尾端或出错则为`EOF`。\n 函数`getchar()`等同于`getc(stdin)`\n 注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用`ferror()`或`feof()`。\n `getc()`的实现是一个宏，而`fgetc()`是一个函数。\n 返回值为int类型。\n ````C\nint putc(int c, FILE *stream);\nint fputc(int c, FILE *stream);\nint putchar(int c);\n````\n `putchar(c)` 等价于 `putc(c,stdout)`。\n 出错返回 `EOF`。\n `putc()`实现为宏，`/fputc()`实现为函数。\n\n2. 行I/O\n\n ````C\nchar *gets(char *s);\nchar *fgets(char *s, int size, FILE *stream);\n````\n 两个函数返回：若成功则为`buf`，若已处文件尾端或出错则为`null`。\n 这两个函数都指定了缓存地址`s`，读入的行将送入其中。`gets()`从标准输入读，而`fgets()`则从指定的流读。\n 对于`fgets()`，必须指定缓存`s`的长度`n`。此函数一直读到下一个换行符为止，但是不超过`n-1`个字符，读入的字符被送入缓存。该缓存以`null`字符结尾。如若该行，包括最后一个换行符的字符数超过`n-1`，则只返回一个不完整的行，而且最后总是以`null`字符结尾。对`fgets()`的下一次调用会继续读该行。\n `gets()`是一个不推荐使用的函数，因为调用者在使用`gets()`时不能指定缓存的长度，这样就可能造成**缓存越界**（如若该行长于缓存长度），写到缓存之后的存储空间中，从而产生不可预料的后果。\n `gets()`与`fgets()`的另一个区别是，`gets()`并不将换行符存入缓存中。\n ````C\nint puts(const char *s);\nint fputs(const char *s, FILE *stream);\n````\n 两个函数返回：若成功则为非负值，若出错则为`EOF`。\n 函数`fputs()`将一个以`null`符终止的字符串写到指定的流，终止符`null`不输出。注意，并不一定是每次输出的字符串都包含一个换行符。\n `puts()`将一个以`null`符终止的字符串写到标准输出，终止符不输出。随后，`puts()`又将一个换行符写到标准输出。\n `puts()`并不像它所对应的`gets()`那样不安全。但是我们还是应避免使用它，以免需要记住它在最后又加上了一个换行符。如果总是使用`fgets()`和`fputs()`,那么就会熟知**在每行终止处我们必须自己加一个换行符**。\n\n3. 二进制I/O\n ````C\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n````\n 两个函数的返回：读或写的对象数\n 对于二进制数据我们更愿意一次读或写整个结构。\n 为了使用`getc()`或`putc()`做到这一点，必须循环读取整个结构，一次读或写一个字节。(效率低)\n `fputs()`在遇到`null`字节时就停止，而在结构中可能含有`null`字节，所以不能使用每次一行函数实现这种要求。如果输入数据中包含有`null`字节或换行符，则`fgets()`也不能正确工作。(实现限制)\n\n### 5. 刷新流\n` int fflush(FILE *fp);`\n可强制刷新一个流。此函数将流缓冲区中所有未写的数据写到文件中。\n\n### 6. 定位流\n````C\nint fseek(FILE *stream, long offset, int whence);\nlong ftell(FILE *stream);\nvoid rewind(FILE *stream);\n````\n`ftell()`用于取得当前的文件位置，调用成功则为当前文件位置指示，若出错则为`-1L`\n`fseek()`用户设定`stream`流的文件位置指示，调用成功返回0，失败返回-1，并设置`errno`\n`fseek()`的`whence`参数：`SEEK_SET`/ `SEEK_CUR`/ `SEEK_END`。\n`rewind()`用于设定流的文件位置指示为文件开始，该函数调用成功无返回值。\n`rewind()`等价于`(void)fseek(stream, 0L, SEEK_SET)`\n\n## 二、文件IO\n文件I/O用于应用层与内核层之间文件的输入输出，他的原理是内核通过inode号区分不同的文件，进程中对不同文件的区分使用ID号，来映射不同的inode。文件IO直接调用了系统接口 不需要依赖标准C库。文件I/O是不带缓冲的，对于Linux内核来讲，所有打开文件都由文件描述符表示。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。文件描述符的定义：\n * 内核顺序分配的非负整数\n * 内核用以标识一个特定进程正在访问的文件\n * 其他资源(socket、pipe等)的访问标识\n标准输入、标准输出和标准出错由shell默认打开，分别为0/1/2。\n\n### 1. 文件I/O的打开/创建/关闭\n````C\nint open(const char *pathname, int flags, mode_t mode);\nint creat(const char *pathname, mode_t mode);\nint close(int flags);\n````\n`open()`和`creat()`调用成功返回文件描述符，失败返回-1，并设置errno。\n`open()`/`creat()`调用返回的文件描述符一定是最小的可用文件描述符。\n`creat()`等价于`open(pathname, O_CREAT|O_WRONLY|O_TRUNC, mode)`\n`pathname`是需要打开的文件路径，`flags`是打开的模式：\n * `O_APPEND` 附加模式，在NFS文件系统下可能会出错，该模式可以自动置文件指针到文件末尾\n * `O_CREAT` 创建文件\n * `O_EXCL` 在CREAT后，若文件存在不创建，返回-1，否则创建\n * `O_RDWR` 读写模式打开\n * `O_RDONLY` 只读模式打开\n * `O_WRONLY` 只写模式打开\n * `O_TRUNC` 清零模式\n`mode`权限 仅在创建模式下使用,成功：返回ID号，失败返回文件标识号。\n\n`close()`调用成功返回0，出错返回-1，并设置errno。\n当一个进程终止时，该进程打开的所有文件都由内核自动关闭。\n关闭一个文件的同时，也释放该进程加在该文件上的所有记录锁。\n\n###  2. 文件I/O的读写\n````C\nssize_t read(int fd, void *buff, size_t count);\nssize_t write(int fd, void *buff, size_t count);\n````\n`write()`/`read()`调用成功返回已读/写的字节数，失败返回-1，并设置`errno`。\n`write()`的返回值通常与`count`不同，因此需要循环将全部待写的数据全部写入文件。\n`write()`出错的常见原因：**磁盘已满或者超过了一个给定进程的文件长度限制**。\n对于普通文件，写操作从文件的当前位移量处开始，如果在打开文件时，指定了O_APPEND参数，则每次写操作前，将文件位移量设置在文件的当前结尾处，在一次成功的写操作后，该文件的位移量增加实际写的字节数。读操作从文件的当前位移量处开始，在成功返回之前，该位移量增加实际读取的字节数。\n\n### 3. 文件I/O的定位\n````C\noff_t lseek(int fd, off_t offset, int whence);\n````\n每个打开的文件都有一个与其相关的“当前文件位移量”，它是一个非负整数，用以度量从文件开始处计算的字节数。\n通常，读/写操作都从当前文件位移量处开始，在读/写调用成功后，使位移量增加所读或者所写的字节数。\n`lseek()`调用成功为新的文件位移量，失败返回-1，并设置errno。\n`lseek()`只对常规文件有效，对socket、管道、FIFO等进行lseek()操作失败。\n`lseek()`仅将当前文件的位移量记录在内核中，它并不引起任何I/O操作。\n文件位移量可以大于文件的当前长度，在这种情况下，对该文件的写操作会延长文件，并形成空洞。\n\n## 三、两种I/O模型的比较\n\n|I/O模型|文件I/O|标准I/O|\n|--|--|--|\n|缓冲方式\t|非缓冲I/O\t|缓冲I/O|\n|操作对象\t|文件描述符\t|流(FILE )|\n|打开\t|open()\t|fopen()/freopen()/fdopen()|\n|读\t|read()\t|fread()/fgetc()/fgets()…|\n|写\t|write()\t|fwrite()/fputc()/fputs()…|\n|定位\t|lseek()\t|fseek()/ftell()/rewind()/fsetpos()/fgetpos()|\n|关闭\t|close()\t|fclose()|\n\n\n","source":"_posts/Linux学习总结04.md","raw":"---\ntitle: Linux学习总结（四）——标准I/O与文件I/O\ndate: 2016-12-16 14:54:55\ncategories: Linux学习记录\ntags: [I/O, select]\n---\n\n在应用开发中，经常要访问文件，Linux 下的文件读写方式分为两大类：标准 I/O 和 文件 I/O，下面分别介绍下两种 I/O 的相关操作，并比较下两种 I/O 的特点。\n<!--more-->\n\n## 一、标准I/O\n标准I/O库接口由ANSI C标准定义，标准IO函数提供了一种对不用缓冲IO函数的带缓冲的接口。不仅在UNIX系统，在很多操作系统上都实现了标准I/O库，标准I/O库处理很多细节，如缓存分配、以优化长度执行I/O等，这样使用户不必关心如何选择合适的块长度。标准I/O在系统调用基础上构造的，它便于用户使用。标准I/O有两个很重要的定义。\n* 文件指针\n`FILE`：每个被打开的文件都在内存中开辟一个区域，用来存放文件的有关信息。这些信息保存在一个结构体类型的变量中，该结构体类型是由系统定义的，称为`FILE`。\n* 流\n`stream`：所有的I/O操作本质上都是从文件中输入或输出字节流，所以称为流。\n\n标准I/O预定义3个流，他们可以自动地为进程所使用：标准输入/标准输出/标准错误输出。\n\n### 1. 文件缓冲\n系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区在一起送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区逐个的将数据送到程序的数据区。这样的目的是尽量减少使用`read`/`write`的调用。文件缓冲可以分为三类：\n* 全缓冲\n当填满I/O缓存后才进行实际I/O操作，或者满足一定条件后，系统通过调用malloc来获得所需要的缓冲区域，默认值。\n刷新(`fflush`)：标准I/O的写操作。\n当缓冲区满了，或者满足一定的条件后，就会执行刷新操作。\n* 行缓冲\n当在输入和输出中遇到新行符(`\\n`)时，进行I/O操作。\n当流遇到一个终端时，典型的行缓存。\n* 无缓冲\n标准错误流`stderr`无缓冲。\n很多的人机交互界面要求不可全缓冲。\n\n### 2. 打开流\n````C\nFILE *fopen (const char *path, const char *mode);\nFILE *freopen(const char *restrict pathname, const char *restrict type, FILE* restrict fp)````\n`fopen()`打开由 `path` 指定的一个文件。\n`mode` 的值如下：\n`r`/`rb` 打开只读文件，该文件必须存在。\n`w`/`wb` 打开只写文件，若文件存在则文件长度清为0，若文件不存在则建立该文件。\n`a`/`ab` 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾。\n当给定 `b` 参数时，表示以二进制方式打开文件。\n\n### 3. 关闭流\n````C\nint fclose(FILE *stream);\n````\n`fclose()`用于关闭一个已经打开的流:调用成功返回0，失败返回EOF，并设置errno。\n在该文件被关闭之前，刷新缓存中的数据。如果标准I / O库已经为该流自动分配了一个缓存，则释放此缓存。\n当一个进程正常终止时(直接调用exit函数，或从main函数返回)，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭。\n在调用 `fclose()` 关闭流后对流所进行的任何操作，包括再次调用 `fclose()`，其结果都将是未知的\n\n### 4. 读写流\n调用 `fopen()` 成功打开流之后，可采用三种不同方式对其进行读写操作:\n* 每次一个字符的I/O。\n 使用 `fgetc()`/`fputc()` 一次读或写一个字符。\n* 每次一行的I/O。\n 使用 `fgets()` 和 `fputs()` 一次读或写一行。每行都以一个换行符终止。当调用 `fgets()` 时，应指明能处理的最大行长度。\n* 直接I/O。\n `fread()` 和 `fwrite()` 函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中读或写。\n\n1. 字符I/O\n\n ````C\nint getc(FILE *stream);\nint fgetc(FILE *stream);\nint getchar(void);\n````\n 三个函数的返回：若成功则为下一个字符，若已处文件尾端或出错则为`EOF`。\n 函数`getchar()`等同于`getc(stdin)`\n 注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用`ferror()`或`feof()`。\n `getc()`的实现是一个宏，而`fgetc()`是一个函数。\n 返回值为int类型。\n ````C\nint putc(int c, FILE *stream);\nint fputc(int c, FILE *stream);\nint putchar(int c);\n````\n `putchar(c)` 等价于 `putc(c,stdout)`。\n 出错返回 `EOF`。\n `putc()`实现为宏，`/fputc()`实现为函数。\n\n2. 行I/O\n\n ````C\nchar *gets(char *s);\nchar *fgets(char *s, int size, FILE *stream);\n````\n 两个函数返回：若成功则为`buf`，若已处文件尾端或出错则为`null`。\n 这两个函数都指定了缓存地址`s`，读入的行将送入其中。`gets()`从标准输入读，而`fgets()`则从指定的流读。\n 对于`fgets()`，必须指定缓存`s`的长度`n`。此函数一直读到下一个换行符为止，但是不超过`n-1`个字符，读入的字符被送入缓存。该缓存以`null`字符结尾。如若该行，包括最后一个换行符的字符数超过`n-1`，则只返回一个不完整的行，而且最后总是以`null`字符结尾。对`fgets()`的下一次调用会继续读该行。\n `gets()`是一个不推荐使用的函数，因为调用者在使用`gets()`时不能指定缓存的长度，这样就可能造成**缓存越界**（如若该行长于缓存长度），写到缓存之后的存储空间中，从而产生不可预料的后果。\n `gets()`与`fgets()`的另一个区别是，`gets()`并不将换行符存入缓存中。\n ````C\nint puts(const char *s);\nint fputs(const char *s, FILE *stream);\n````\n 两个函数返回：若成功则为非负值，若出错则为`EOF`。\n 函数`fputs()`将一个以`null`符终止的字符串写到指定的流，终止符`null`不输出。注意，并不一定是每次输出的字符串都包含一个换行符。\n `puts()`将一个以`null`符终止的字符串写到标准输出，终止符不输出。随后，`puts()`又将一个换行符写到标准输出。\n `puts()`并不像它所对应的`gets()`那样不安全。但是我们还是应避免使用它，以免需要记住它在最后又加上了一个换行符。如果总是使用`fgets()`和`fputs()`,那么就会熟知**在每行终止处我们必须自己加一个换行符**。\n\n3. 二进制I/O\n ````C\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n````\n 两个函数的返回：读或写的对象数\n 对于二进制数据我们更愿意一次读或写整个结构。\n 为了使用`getc()`或`putc()`做到这一点，必须循环读取整个结构，一次读或写一个字节。(效率低)\n `fputs()`在遇到`null`字节时就停止，而在结构中可能含有`null`字节，所以不能使用每次一行函数实现这种要求。如果输入数据中包含有`null`字节或换行符，则`fgets()`也不能正确工作。(实现限制)\n\n### 5. 刷新流\n` int fflush(FILE *fp);`\n可强制刷新一个流。此函数将流缓冲区中所有未写的数据写到文件中。\n\n### 6. 定位流\n````C\nint fseek(FILE *stream, long offset, int whence);\nlong ftell(FILE *stream);\nvoid rewind(FILE *stream);\n````\n`ftell()`用于取得当前的文件位置，调用成功则为当前文件位置指示，若出错则为`-1L`\n`fseek()`用户设定`stream`流的文件位置指示，调用成功返回0，失败返回-1，并设置`errno`\n`fseek()`的`whence`参数：`SEEK_SET`/ `SEEK_CUR`/ `SEEK_END`。\n`rewind()`用于设定流的文件位置指示为文件开始，该函数调用成功无返回值。\n`rewind()`等价于`(void)fseek(stream, 0L, SEEK_SET)`\n\n## 二、文件IO\n文件I/O用于应用层与内核层之间文件的输入输出，他的原理是内核通过inode号区分不同的文件，进程中对不同文件的区分使用ID号，来映射不同的inode。文件IO直接调用了系统接口 不需要依赖标准C库。文件I/O是不带缓冲的，对于Linux内核来讲，所有打开文件都由文件描述符表示。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。文件描述符的定义：\n * 内核顺序分配的非负整数\n * 内核用以标识一个特定进程正在访问的文件\n * 其他资源(socket、pipe等)的访问标识\n标准输入、标准输出和标准出错由shell默认打开，分别为0/1/2。\n\n### 1. 文件I/O的打开/创建/关闭\n````C\nint open(const char *pathname, int flags, mode_t mode);\nint creat(const char *pathname, mode_t mode);\nint close(int flags);\n````\n`open()`和`creat()`调用成功返回文件描述符，失败返回-1，并设置errno。\n`open()`/`creat()`调用返回的文件描述符一定是最小的可用文件描述符。\n`creat()`等价于`open(pathname, O_CREAT|O_WRONLY|O_TRUNC, mode)`\n`pathname`是需要打开的文件路径，`flags`是打开的模式：\n * `O_APPEND` 附加模式，在NFS文件系统下可能会出错，该模式可以自动置文件指针到文件末尾\n * `O_CREAT` 创建文件\n * `O_EXCL` 在CREAT后，若文件存在不创建，返回-1，否则创建\n * `O_RDWR` 读写模式打开\n * `O_RDONLY` 只读模式打开\n * `O_WRONLY` 只写模式打开\n * `O_TRUNC` 清零模式\n`mode`权限 仅在创建模式下使用,成功：返回ID号，失败返回文件标识号。\n\n`close()`调用成功返回0，出错返回-1，并设置errno。\n当一个进程终止时，该进程打开的所有文件都由内核自动关闭。\n关闭一个文件的同时，也释放该进程加在该文件上的所有记录锁。\n\n###  2. 文件I/O的读写\n````C\nssize_t read(int fd, void *buff, size_t count);\nssize_t write(int fd, void *buff, size_t count);\n````\n`write()`/`read()`调用成功返回已读/写的字节数，失败返回-1，并设置`errno`。\n`write()`的返回值通常与`count`不同，因此需要循环将全部待写的数据全部写入文件。\n`write()`出错的常见原因：**磁盘已满或者超过了一个给定进程的文件长度限制**。\n对于普通文件，写操作从文件的当前位移量处开始，如果在打开文件时，指定了O_APPEND参数，则每次写操作前，将文件位移量设置在文件的当前结尾处，在一次成功的写操作后，该文件的位移量增加实际写的字节数。读操作从文件的当前位移量处开始，在成功返回之前，该位移量增加实际读取的字节数。\n\n### 3. 文件I/O的定位\n````C\noff_t lseek(int fd, off_t offset, int whence);\n````\n每个打开的文件都有一个与其相关的“当前文件位移量”，它是一个非负整数，用以度量从文件开始处计算的字节数。\n通常，读/写操作都从当前文件位移量处开始，在读/写调用成功后，使位移量增加所读或者所写的字节数。\n`lseek()`调用成功为新的文件位移量，失败返回-1，并设置errno。\n`lseek()`只对常规文件有效，对socket、管道、FIFO等进行lseek()操作失败。\n`lseek()`仅将当前文件的位移量记录在内核中，它并不引起任何I/O操作。\n文件位移量可以大于文件的当前长度，在这种情况下，对该文件的写操作会延长文件，并形成空洞。\n\n## 三、两种I/O模型的比较\n\n|I/O模型|文件I/O|标准I/O|\n|--|--|--|\n|缓冲方式\t|非缓冲I/O\t|缓冲I/O|\n|操作对象\t|文件描述符\t|流(FILE )|\n|打开\t|open()\t|fopen()/freopen()/fdopen()|\n|读\t|read()\t|fread()/fgetc()/fgets()…|\n|写\t|write()\t|fwrite()/fputc()/fputs()…|\n|定位\t|lseek()\t|fseek()/ftell()/rewind()/fsetpos()/fgetpos()|\n|关闭\t|close()\t|fclose()|\n\n\n","slug":"Linux学习总结04","published":1,"updated":"2016-12-21T14:07:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0s0013bkw1b1nqq3yy","content":"<p>在应用开发中，经常要访问文件，Linux 下的文件读写方式分为两大类：标准 I/O 和 文件 I/O，下面分别介绍下两种 I/O 的相关操作，并比较下两种 I/O 的特点。<br><a id=\"more\"></a></p>\n<h2 id=\"一、标准I-O\"><a href=\"#一、标准I-O\" class=\"headerlink\" title=\"一、标准I/O\"></a>一、标准I/O</h2><p>标准I/O库接口由ANSI C标准定义，标准IO函数提供了一种对不用缓冲IO函数的带缓冲的接口。不仅在UNIX系统，在很多操作系统上都实现了标准I/O库，标准I/O库处理很多细节，如缓存分配、以优化长度执行I/O等，这样使用户不必关心如何选择合适的块长度。标准I/O在系统调用基础上构造的，它便于用户使用。标准I/O有两个很重要的定义。</p>\n<ul>\n<li>文件指针<br><code>FILE</code>：每个被打开的文件都在内存中开辟一个区域，用来存放文件的有关信息。这些信息保存在一个结构体类型的变量中，该结构体类型是由系统定义的，称为<code>FILE</code>。</li>\n<li>流<br><code>stream</code>：所有的I/O操作本质上都是从文件中输入或输出字节流，所以称为流。</li>\n</ul>\n<p>标准I/O预定义3个流，他们可以自动地为进程所使用：标准输入/标准输出/标准错误输出。</p>\n<h3 id=\"1-文件缓冲\"><a href=\"#1-文件缓冲\" class=\"headerlink\" title=\"1. 文件缓冲\"></a>1. 文件缓冲</h3><p>系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区在一起送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区逐个的将数据送到程序的数据区。这样的目的是尽量减少使用<code>read</code>/<code>write</code>的调用。文件缓冲可以分为三类：</p>\n<ul>\n<li>全缓冲<br>当填满I/O缓存后才进行实际I/O操作，或者满足一定条件后，系统通过调用malloc来获得所需要的缓冲区域，默认值。<br>刷新(<code>fflush</code>)：标准I/O的写操作。<br>当缓冲区满了，或者满足一定的条件后，就会执行刷新操作。</li>\n<li>行缓冲<br>当在输入和输出中遇到新行符(<code>\\n</code>)时，进行I/O操作。<br>当流遇到一个终端时，典型的行缓存。</li>\n<li>无缓冲<br>标准错误流<code>stderr</code>无缓冲。<br>很多的人机交互界面要求不可全缓冲。</li>\n</ul>\n<h3 id=\"2-打开流\"><a href=\"#2-打开流\" class=\"headerlink\" title=\"2. 打开流\"></a>2. 打开流</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">FILE *<span class=\"title\">fopen</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mode)</span></span>;</div><div class=\"line\"><span class=\"function\">FILE *<span class=\"title\">freopen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"keyword\">restrict</span> pathname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"keyword\">restrict</span> type, FILE* <span class=\"keyword\">restrict</span> fp)</span></span></div></pre></td></tr></table></figure>\n<p><code>fopen()</code>打开由 <code>path</code> 指定的一个文件。<br><code>mode</code> 的值如下：<br><code>r</code>/<code>rb</code> 打开只读文件，该文件必须存在。<br><code>w</code>/<code>wb</code> 打开只写文件，若文件存在则文件长度清为0，若文件不存在则建立该文件。<br><code>a</code>/<code>ab</code> 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾。<br>当给定 <code>b</code> 参数时，表示以二进制方式打开文件。</p>\n<h3 id=\"3-关闭流\"><a href=\"#3-关闭流\" class=\"headerlink\" title=\"3. 关闭流\"></a>3. 关闭流</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fclose</span><span class=\"params\">(FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>fclose()</code>用于关闭一个已经打开的流:调用成功返回0，失败返回EOF，并设置errno。<br>在该文件被关闭之前，刷新缓存中的数据。如果标准I / O库已经为该流自动分配了一个缓存，则释放此缓存。<br>当一个进程正常终止时(直接调用exit函数，或从main函数返回)，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭。<br>在调用 <code>fclose()</code> 关闭流后对流所进行的任何操作，包括再次调用 <code>fclose()</code>，其结果都将是未知的</p>\n<h3 id=\"4-读写流\"><a href=\"#4-读写流\" class=\"headerlink\" title=\"4. 读写流\"></a>4. 读写流</h3><p>调用 <code>fopen()</code> 成功打开流之后，可采用三种不同方式对其进行读写操作:</p>\n<ul>\n<li>每次一个字符的I/O。<br>使用 <code>fgetc()</code>/<code>fputc()</code> 一次读或写一个字符。</li>\n<li>每次一行的I/O。<br>使用 <code>fgets()</code> 和 <code>fputs()</code> 一次读或写一行。每行都以一个换行符终止。当调用 <code>fgets()</code> 时，应指明能处理的最大行长度。</li>\n<li>直接I/O。<br><code>fread()</code> 和 <code>fwrite()</code> 函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中读或写。</li>\n</ul>\n<ol>\n<li><p>字符I/O</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getc</span><span class=\"params\">(FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fgetc</span><span class=\"params\">(FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getchar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure>\n<p>三个函数的返回：若成功则为下一个字符，若已处文件尾端或出错则为<code>EOF</code>。<br>函数<code>getchar()</code>等同于<code>getc(stdin)</code><br>注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用<code>ferror()</code>或<code>feof()</code>。<br><code>getc()</code>的实现是一个宏，而<code>fgetc()</code>是一个函数。<br>返回值为int类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">putc</span><span class=\"params\">(<span class=\"keyword\">int</span> c, FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fputc</span><span class=\"params\">(<span class=\"keyword\">int</span> c, FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">putchar</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>putchar(c)</code> 等价于 <code>putc(c,stdout)</code>。<br>出错返回 <code>EOF</code>。<br><code>putc()</code>实现为宏，<code>/fputc()</code>实现为函数。</p>\n</li>\n<li><p>行I/O</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">gets</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fgets</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> size, FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p>两个函数返回：若成功则为<code>buf</code>，若已处文件尾端或出错则为<code>null</code>。<br>这两个函数都指定了缓存地址<code>s</code>，读入的行将送入其中。<code>gets()</code>从标准输入读，而<code>fgets()</code>则从指定的流读。<br>对于<code>fgets()</code>，必须指定缓存<code>s</code>的长度<code>n</code>。此函数一直读到下一个换行符为止，但是不超过<code>n-1</code>个字符，读入的字符被送入缓存。该缓存以<code>null</code>字符结尾。如若该行，包括最后一个换行符的字符数超过<code>n-1</code>，则只返回一个不完整的行，而且最后总是以<code>null</code>字符结尾。对<code>fgets()</code>的下一次调用会继续读该行。<br><code>gets()</code>是一个不推荐使用的函数，因为调用者在使用<code>gets()</code>时不能指定缓存的长度，这样就可能造成<strong>缓存越界</strong>（如若该行长于缓存长度），写到缓存之后的存储空间中，从而产生不可预料的后果。<br><code>gets()</code>与<code>fgets()</code>的另一个区别是，<code>gets()</code>并不将换行符存入缓存中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">puts</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p>两个函数返回：若成功则为非负值，若出错则为<code>EOF</code>。<br>函数<code>fputs()</code>将一个以<code>null</code>符终止的字符串写到指定的流，终止符<code>null</code>不输出。注意，并不一定是每次输出的字符串都包含一个换行符。<br><code>puts()</code>将一个以<code>null</code>符终止的字符串写到标准输出，终止符不输出。随后，<code>puts()</code>又将一个换行符写到标准输出。<br><code>puts()</code>并不像它所对应的<code>gets()</code>那样不安全。但是我们还是应避免使用它，以免需要记住它在最后又加上了一个换行符。如果总是使用<code>fgets()</code>和<code>fputs()</code>,那么就会熟知<strong>在每行终止处我们必须自己加一个换行符</strong>。</p>\n</li>\n<li><p>二进制I/O</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> fread(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream);</div><div class=\"line\"><span class=\"keyword\">size_t</span> fwrite(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream);</div></pre></td></tr></table></figure>\n<p>两个函数的返回：读或写的对象数<br>对于二进制数据我们更愿意一次读或写整个结构。<br>为了使用<code>getc()</code>或<code>putc()</code>做到这一点，必须循环读取整个结构，一次读或写一个字节。(效率低)<br><code>fputs()</code>在遇到<code>null</code>字节时就停止，而在结构中可能含有<code>null</code>字节，所以不能使用每次一行函数实现这种要求。如果输入数据中包含有<code>null</code>字节或换行符，则<code>fgets()</code>也不能正确工作。(实现限制)</p>\n</li>\n</ol>\n<h3 id=\"5-刷新流\"><a href=\"#5-刷新流\" class=\"headerlink\" title=\"5. 刷新流\"></a>5. 刷新流</h3><p><code>int fflush(FILE *fp);</code><br>可强制刷新一个流。此函数将流缓冲区中所有未写的数据写到文件中。</p>\n<h3 id=\"6-定位流\"><a href=\"#6-定位流\" class=\"headerlink\" title=\"6. 定位流\"></a>6. 定位流</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fseek</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> whence)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">ftell</span><span class=\"params\">(FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rewind</span><span class=\"params\">(FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>ftell()</code>用于取得当前的文件位置，调用成功则为当前文件位置指示，若出错则为<code>-1L</code><br><code>fseek()</code>用户设定<code>stream</code>流的文件位置指示，调用成功返回0，失败返回-1，并设置<code>errno</code><br><code>fseek()</code>的<code>whence</code>参数：<code>SEEK_SET</code>/ <code>SEEK_CUR</code>/ <code>SEEK_END</code>。<br><code>rewind()</code>用于设定流的文件位置指示为文件开始，该函数调用成功无返回值。<br><code>rewind()</code>等价于<code>(void)fseek(stream, 0L, SEEK_SET)</code></p>\n<h2 id=\"二、文件IO\"><a href=\"#二、文件IO\" class=\"headerlink\" title=\"二、文件IO\"></a>二、文件IO</h2><p>文件I/O用于应用层与内核层之间文件的输入输出，他的原理是内核通过inode号区分不同的文件，进程中对不同文件的区分使用ID号，来映射不同的inode。文件IO直接调用了系统接口 不需要依赖标准C库。文件I/O是不带缓冲的，对于Linux内核来讲，所有打开文件都由文件描述符表示。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。文件描述符的定义：</p>\n<ul>\n<li>内核顺序分配的非负整数</li>\n<li>内核用以标识一个特定进程正在访问的文件</li>\n<li>其他资源(socket、pipe等)的访问标识<br>标准输入、标准输出和标准出错由shell默认打开，分别为0/1/2。</li>\n</ul>\n<h3 id=\"1-文件I-O的打开-创建-关闭\"><a href=\"#1-文件I-O的打开-创建-关闭\" class=\"headerlink\" title=\"1. 文件I/O的打开/创建/关闭\"></a>1. 文件I/O的打开/创建/关闭</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">mode_t</span> mode)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">creat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> flags)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>open()</code>和<code>creat()</code>调用成功返回文件描述符，失败返回-1，并设置errno。<br><code>open()</code>/<code>creat()</code>调用返回的文件描述符一定是最小的可用文件描述符。<br><code>creat()</code>等价于<code>open(pathname, O_CREAT|O_WRONLY|O_TRUNC, mode)</code><br><code>pathname</code>是需要打开的文件路径，<code>flags</code>是打开的模式：</p>\n<ul>\n<li><code>O_APPEND</code> 附加模式，在NFS文件系统下可能会出错，该模式可以自动置文件指针到文件末尾</li>\n<li><code>O_CREAT</code> 创建文件</li>\n<li><code>O_EXCL</code> 在CREAT后，若文件存在不创建，返回-1，否则创建</li>\n<li><code>O_RDWR</code> 读写模式打开</li>\n<li><code>O_RDONLY</code> 只读模式打开</li>\n<li><code>O_WRONLY</code> 只写模式打开</li>\n<li><code>O_TRUNC</code> 清零模式<br><code>mode</code>权限 仅在创建模式下使用,成功：返回ID号，失败返回文件标识号。</li>\n</ul>\n<p><code>close()</code>调用成功返回0，出错返回-1，并设置errno。<br>当一个进程终止时，该进程打开的所有文件都由内核自动关闭。<br>关闭一个文件的同时，也释放该进程加在该文件上的所有记录锁。</p>\n<h3 id=\"2-文件I-O的读写\"><a href=\"#2-文件I-O的读写\" class=\"headerlink\" title=\"2. 文件I/O的读写\"></a>2. 文件I/O的读写</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">ssize_t</span> read(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> count);</div><div class=\"line\"><span class=\"keyword\">ssize_t</span> write(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> count);</div></pre></td></tr></table></figure>\n<p><code>write()</code>/<code>read()</code>调用成功返回已读/写的字节数，失败返回-1，并设置<code>errno</code>。<br><code>write()</code>的返回值通常与<code>count</code>不同，因此需要循环将全部待写的数据全部写入文件。<br><code>write()</code>出错的常见原因：<strong>磁盘已满或者超过了一个给定进程的文件长度限制</strong>。<br>对于普通文件，写操作从文件的当前位移量处开始，如果在打开文件时，指定了O_APPEND参数，则每次写操作前，将文件位移量设置在文件的当前结尾处，在一次成功的写操作后，该文件的位移量增加实际写的字节数。读操作从文件的当前位移量处开始，在成功返回之前，该位移量增加实际读取的字节数。</p>\n<h3 id=\"3-文件I-O的定位\"><a href=\"#3-文件I-O的定位\" class=\"headerlink\" title=\"3. 文件I/O的定位\"></a>3. 文件I/O的定位</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">off_t</span> lseek(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> whence);</div></pre></td></tr></table></figure>\n<p>每个打开的文件都有一个与其相关的“当前文件位移量”，它是一个非负整数，用以度量从文件开始处计算的字节数。<br>通常，读/写操作都从当前文件位移量处开始，在读/写调用成功后，使位移量增加所读或者所写的字节数。<br><code>lseek()</code>调用成功为新的文件位移量，失败返回-1，并设置errno。<br><code>lseek()</code>只对常规文件有效，对socket、管道、FIFO等进行lseek()操作失败。<br><code>lseek()</code>仅将当前文件的位移量记录在内核中，它并不引起任何I/O操作。<br>文件位移量可以大于文件的当前长度，在这种情况下，对该文件的写操作会延长文件，并形成空洞。</p>\n<h2 id=\"三、两种I-O模型的比较\"><a href=\"#三、两种I-O模型的比较\" class=\"headerlink\" title=\"三、两种I/O模型的比较\"></a>三、两种I/O模型的比较</h2><table>\n<thead>\n<tr>\n<th>I/O模型</th>\n<th>文件I/O</th>\n<th>标准I/O</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>缓冲方式</td>\n<td>非缓冲I/O</td>\n<td>缓冲I/O</td>\n</tr>\n<tr>\n<td>操作对象</td>\n<td>文件描述符</td>\n<td>流(FILE )</td>\n</tr>\n<tr>\n<td>打开</td>\n<td>open()</td>\n<td>fopen()/freopen()/fdopen()</td>\n</tr>\n<tr>\n<td>读</td>\n<td>read()</td>\n<td>fread()/fgetc()/fgets()…</td>\n</tr>\n<tr>\n<td>写</td>\n<td>write()</td>\n<td>fwrite()/fputc()/fputs()…</td>\n</tr>\n<tr>\n<td>定位</td>\n<td>lseek()</td>\n<td>fseek()/ftell()/rewind()/fsetpos()/fgetpos()</td>\n</tr>\n<tr>\n<td>关闭</td>\n<td>close()</td>\n<td>fclose()</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"<p>在应用开发中，经常要访问文件，Linux 下的文件读写方式分为两大类：标准 I/O 和 文件 I/O，下面分别介绍下两种 I/O 的相关操作，并比较下两种 I/O 的特点。<br>","more":"</p>\n<h2 id=\"一、标准I-O\"><a href=\"#一、标准I-O\" class=\"headerlink\" title=\"一、标准I/O\"></a>一、标准I/O</h2><p>标准I/O库接口由ANSI C标准定义，标准IO函数提供了一种对不用缓冲IO函数的带缓冲的接口。不仅在UNIX系统，在很多操作系统上都实现了标准I/O库，标准I/O库处理很多细节，如缓存分配、以优化长度执行I/O等，这样使用户不必关心如何选择合适的块长度。标准I/O在系统调用基础上构造的，它便于用户使用。标准I/O有两个很重要的定义。</p>\n<ul>\n<li>文件指针<br><code>FILE</code>：每个被打开的文件都在内存中开辟一个区域，用来存放文件的有关信息。这些信息保存在一个结构体类型的变量中，该结构体类型是由系统定义的，称为<code>FILE</code>。</li>\n<li>流<br><code>stream</code>：所有的I/O操作本质上都是从文件中输入或输出字节流，所以称为流。</li>\n</ul>\n<p>标准I/O预定义3个流，他们可以自动地为进程所使用：标准输入/标准输出/标准错误输出。</p>\n<h3 id=\"1-文件缓冲\"><a href=\"#1-文件缓冲\" class=\"headerlink\" title=\"1. 文件缓冲\"></a>1. 文件缓冲</h3><p>系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区在一起送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区逐个的将数据送到程序的数据区。这样的目的是尽量减少使用<code>read</code>/<code>write</code>的调用。文件缓冲可以分为三类：</p>\n<ul>\n<li>全缓冲<br>当填满I/O缓存后才进行实际I/O操作，或者满足一定条件后，系统通过调用malloc来获得所需要的缓冲区域，默认值。<br>刷新(<code>fflush</code>)：标准I/O的写操作。<br>当缓冲区满了，或者满足一定的条件后，就会执行刷新操作。</li>\n<li>行缓冲<br>当在输入和输出中遇到新行符(<code>\\n</code>)时，进行I/O操作。<br>当流遇到一个终端时，典型的行缓存。</li>\n<li>无缓冲<br>标准错误流<code>stderr</code>无缓冲。<br>很多的人机交互界面要求不可全缓冲。</li>\n</ul>\n<h3 id=\"2-打开流\"><a href=\"#2-打开流\" class=\"headerlink\" title=\"2. 打开流\"></a>2. 打开流</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">FILE *<span class=\"title\">fopen</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mode)</span></span>;</div><div class=\"line\"><span class=\"function\">FILE *<span class=\"title\">freopen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"keyword\">restrict</span> pathname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"keyword\">restrict</span> type, FILE* <span class=\"keyword\">restrict</span> fp)</span></span></div></pre></td></tr></table></figure>\n<p><code>fopen()</code>打开由 <code>path</code> 指定的一个文件。<br><code>mode</code> 的值如下：<br><code>r</code>/<code>rb</code> 打开只读文件，该文件必须存在。<br><code>w</code>/<code>wb</code> 打开只写文件，若文件存在则文件长度清为0，若文件不存在则建立该文件。<br><code>a</code>/<code>ab</code> 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾。<br>当给定 <code>b</code> 参数时，表示以二进制方式打开文件。</p>\n<h3 id=\"3-关闭流\"><a href=\"#3-关闭流\" class=\"headerlink\" title=\"3. 关闭流\"></a>3. 关闭流</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fclose</span><span class=\"params\">(FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>fclose()</code>用于关闭一个已经打开的流:调用成功返回0，失败返回EOF，并设置errno。<br>在该文件被关闭之前，刷新缓存中的数据。如果标准I / O库已经为该流自动分配了一个缓存，则释放此缓存。<br>当一个进程正常终止时(直接调用exit函数，或从main函数返回)，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭。<br>在调用 <code>fclose()</code> 关闭流后对流所进行的任何操作，包括再次调用 <code>fclose()</code>，其结果都将是未知的</p>\n<h3 id=\"4-读写流\"><a href=\"#4-读写流\" class=\"headerlink\" title=\"4. 读写流\"></a>4. 读写流</h3><p>调用 <code>fopen()</code> 成功打开流之后，可采用三种不同方式对其进行读写操作:</p>\n<ul>\n<li>每次一个字符的I/O。<br>使用 <code>fgetc()</code>/<code>fputc()</code> 一次读或写一个字符。</li>\n<li>每次一行的I/O。<br>使用 <code>fgets()</code> 和 <code>fputs()</code> 一次读或写一行。每行都以一个换行符终止。当调用 <code>fgets()</code> 时，应指明能处理的最大行长度。</li>\n<li>直接I/O。<br><code>fread()</code> 和 <code>fwrite()</code> 函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中读或写。</li>\n</ul>\n<ol>\n<li><p>字符I/O</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getc</span><span class=\"params\">(FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fgetc</span><span class=\"params\">(FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getchar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure>\n<p>三个函数的返回：若成功则为下一个字符，若已处文件尾端或出错则为<code>EOF</code>。<br>函数<code>getchar()</code>等同于<code>getc(stdin)</code><br>注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用<code>ferror()</code>或<code>feof()</code>。<br><code>getc()</code>的实现是一个宏，而<code>fgetc()</code>是一个函数。<br>返回值为int类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">putc</span><span class=\"params\">(<span class=\"keyword\">int</span> c, FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fputc</span><span class=\"params\">(<span class=\"keyword\">int</span> c, FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">putchar</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>putchar(c)</code> 等价于 <code>putc(c,stdout)</code>。<br>出错返回 <code>EOF</code>。<br><code>putc()</code>实现为宏，<code>/fputc()</code>实现为函数。</p>\n</li>\n<li><p>行I/O</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">gets</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fgets</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> size, FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p>两个函数返回：若成功则为<code>buf</code>，若已处文件尾端或出错则为<code>null</code>。<br>这两个函数都指定了缓存地址<code>s</code>，读入的行将送入其中。<code>gets()</code>从标准输入读，而<code>fgets()</code>则从指定的流读。<br>对于<code>fgets()</code>，必须指定缓存<code>s</code>的长度<code>n</code>。此函数一直读到下一个换行符为止，但是不超过<code>n-1</code>个字符，读入的字符被送入缓存。该缓存以<code>null</code>字符结尾。如若该行，包括最后一个换行符的字符数超过<code>n-1</code>，则只返回一个不完整的行，而且最后总是以<code>null</code>字符结尾。对<code>fgets()</code>的下一次调用会继续读该行。<br><code>gets()</code>是一个不推荐使用的函数，因为调用者在使用<code>gets()</code>时不能指定缓存的长度，这样就可能造成<strong>缓存越界</strong>（如若该行长于缓存长度），写到缓存之后的存储空间中，从而产生不可预料的后果。<br><code>gets()</code>与<code>fgets()</code>的另一个区别是，<code>gets()</code>并不将换行符存入缓存中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">puts</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p>两个函数返回：若成功则为非负值，若出错则为<code>EOF</code>。<br>函数<code>fputs()</code>将一个以<code>null</code>符终止的字符串写到指定的流，终止符<code>null</code>不输出。注意，并不一定是每次输出的字符串都包含一个换行符。<br><code>puts()</code>将一个以<code>null</code>符终止的字符串写到标准输出，终止符不输出。随后，<code>puts()</code>又将一个换行符写到标准输出。<br><code>puts()</code>并不像它所对应的<code>gets()</code>那样不安全。但是我们还是应避免使用它，以免需要记住它在最后又加上了一个换行符。如果总是使用<code>fgets()</code>和<code>fputs()</code>,那么就会熟知<strong>在每行终止处我们必须自己加一个换行符</strong>。</p>\n</li>\n<li><p>二进制I/O</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> fread(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream);</div><div class=\"line\"><span class=\"keyword\">size_t</span> fwrite(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream);</div></pre></td></tr></table></figure>\n<p>两个函数的返回：读或写的对象数<br>对于二进制数据我们更愿意一次读或写整个结构。<br>为了使用<code>getc()</code>或<code>putc()</code>做到这一点，必须循环读取整个结构，一次读或写一个字节。(效率低)<br><code>fputs()</code>在遇到<code>null</code>字节时就停止，而在结构中可能含有<code>null</code>字节，所以不能使用每次一行函数实现这种要求。如果输入数据中包含有<code>null</code>字节或换行符，则<code>fgets()</code>也不能正确工作。(实现限制)</p>\n</li>\n</ol>\n<h3 id=\"5-刷新流\"><a href=\"#5-刷新流\" class=\"headerlink\" title=\"5. 刷新流\"></a>5. 刷新流</h3><p><code>int fflush(FILE *fp);</code><br>可强制刷新一个流。此函数将流缓冲区中所有未写的数据写到文件中。</p>\n<h3 id=\"6-定位流\"><a href=\"#6-定位流\" class=\"headerlink\" title=\"6. 定位流\"></a>6. 定位流</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fseek</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> whence)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">ftell</span><span class=\"params\">(FILE *stream)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rewind</span><span class=\"params\">(FILE *stream)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>ftell()</code>用于取得当前的文件位置，调用成功则为当前文件位置指示，若出错则为<code>-1L</code><br><code>fseek()</code>用户设定<code>stream</code>流的文件位置指示，调用成功返回0，失败返回-1，并设置<code>errno</code><br><code>fseek()</code>的<code>whence</code>参数：<code>SEEK_SET</code>/ <code>SEEK_CUR</code>/ <code>SEEK_END</code>。<br><code>rewind()</code>用于设定流的文件位置指示为文件开始，该函数调用成功无返回值。<br><code>rewind()</code>等价于<code>(void)fseek(stream, 0L, SEEK_SET)</code></p>\n<h2 id=\"二、文件IO\"><a href=\"#二、文件IO\" class=\"headerlink\" title=\"二、文件IO\"></a>二、文件IO</h2><p>文件I/O用于应用层与内核层之间文件的输入输出，他的原理是内核通过inode号区分不同的文件，进程中对不同文件的区分使用ID号，来映射不同的inode。文件IO直接调用了系统接口 不需要依赖标准C库。文件I/O是不带缓冲的，对于Linux内核来讲，所有打开文件都由文件描述符表示。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。文件描述符的定义：</p>\n<ul>\n<li>内核顺序分配的非负整数</li>\n<li>内核用以标识一个特定进程正在访问的文件</li>\n<li>其他资源(socket、pipe等)的访问标识<br>标准输入、标准输出和标准出错由shell默认打开，分别为0/1/2。</li>\n</ul>\n<h3 id=\"1-文件I-O的打开-创建-关闭\"><a href=\"#1-文件I-O的打开-创建-关闭\" class=\"headerlink\" title=\"1. 文件I/O的打开/创建/关闭\"></a>1. 文件I/O的打开/创建/关闭</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">mode_t</span> mode)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">creat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> flags)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>open()</code>和<code>creat()</code>调用成功返回文件描述符，失败返回-1，并设置errno。<br><code>open()</code>/<code>creat()</code>调用返回的文件描述符一定是最小的可用文件描述符。<br><code>creat()</code>等价于<code>open(pathname, O_CREAT|O_WRONLY|O_TRUNC, mode)</code><br><code>pathname</code>是需要打开的文件路径，<code>flags</code>是打开的模式：</p>\n<ul>\n<li><code>O_APPEND</code> 附加模式，在NFS文件系统下可能会出错，该模式可以自动置文件指针到文件末尾</li>\n<li><code>O_CREAT</code> 创建文件</li>\n<li><code>O_EXCL</code> 在CREAT后，若文件存在不创建，返回-1，否则创建</li>\n<li><code>O_RDWR</code> 读写模式打开</li>\n<li><code>O_RDONLY</code> 只读模式打开</li>\n<li><code>O_WRONLY</code> 只写模式打开</li>\n<li><code>O_TRUNC</code> 清零模式<br><code>mode</code>权限 仅在创建模式下使用,成功：返回ID号，失败返回文件标识号。</li>\n</ul>\n<p><code>close()</code>调用成功返回0，出错返回-1，并设置errno。<br>当一个进程终止时，该进程打开的所有文件都由内核自动关闭。<br>关闭一个文件的同时，也释放该进程加在该文件上的所有记录锁。</p>\n<h3 id=\"2-文件I-O的读写\"><a href=\"#2-文件I-O的读写\" class=\"headerlink\" title=\"2. 文件I/O的读写\"></a>2. 文件I/O的读写</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">ssize_t</span> read(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> count);</div><div class=\"line\"><span class=\"keyword\">ssize_t</span> write(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> count);</div></pre></td></tr></table></figure>\n<p><code>write()</code>/<code>read()</code>调用成功返回已读/写的字节数，失败返回-1，并设置<code>errno</code>。<br><code>write()</code>的返回值通常与<code>count</code>不同，因此需要循环将全部待写的数据全部写入文件。<br><code>write()</code>出错的常见原因：<strong>磁盘已满或者超过了一个给定进程的文件长度限制</strong>。<br>对于普通文件，写操作从文件的当前位移量处开始，如果在打开文件时，指定了O_APPEND参数，则每次写操作前，将文件位移量设置在文件的当前结尾处，在一次成功的写操作后，该文件的位移量增加实际写的字节数。读操作从文件的当前位移量处开始，在成功返回之前，该位移量增加实际读取的字节数。</p>\n<h3 id=\"3-文件I-O的定位\"><a href=\"#3-文件I-O的定位\" class=\"headerlink\" title=\"3. 文件I/O的定位\"></a>3. 文件I/O的定位</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">off_t</span> lseek(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> whence);</div></pre></td></tr></table></figure>\n<p>每个打开的文件都有一个与其相关的“当前文件位移量”，它是一个非负整数，用以度量从文件开始处计算的字节数。<br>通常，读/写操作都从当前文件位移量处开始，在读/写调用成功后，使位移量增加所读或者所写的字节数。<br><code>lseek()</code>调用成功为新的文件位移量，失败返回-1，并设置errno。<br><code>lseek()</code>只对常规文件有效，对socket、管道、FIFO等进行lseek()操作失败。<br><code>lseek()</code>仅将当前文件的位移量记录在内核中，它并不引起任何I/O操作。<br>文件位移量可以大于文件的当前长度，在这种情况下，对该文件的写操作会延长文件，并形成空洞。</p>\n<h2 id=\"三、两种I-O模型的比较\"><a href=\"#三、两种I-O模型的比较\" class=\"headerlink\" title=\"三、两种I/O模型的比较\"></a>三、两种I/O模型的比较</h2><table>\n<thead>\n<tr>\n<th>I/O模型</th>\n<th>文件I/O</th>\n<th>标准I/O</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>缓冲方式</td>\n<td>非缓冲I/O</td>\n<td>缓冲I/O</td>\n</tr>\n<tr>\n<td>操作对象</td>\n<td>文件描述符</td>\n<td>流(FILE )</td>\n</tr>\n<tr>\n<td>打开</td>\n<td>open()</td>\n<td>fopen()/freopen()/fdopen()</td>\n</tr>\n<tr>\n<td>读</td>\n<td>read()</td>\n<td>fread()/fgetc()/fgets()…</td>\n</tr>\n<tr>\n<td>写</td>\n<td>write()</td>\n<td>fwrite()/fputc()/fputs()…</td>\n</tr>\n<tr>\n<td>定位</td>\n<td>lseek()</td>\n<td>fseek()/ftell()/rewind()/fsetpos()/fgetpos()</td>\n</tr>\n<tr>\n<td>关闭</td>\n<td>close()</td>\n<td>fclose()</td>\n</tr>\n</tbody>\n</table>"},{"title":"Linux学习总结（六）——进程","date":"2016-12-16T07:54:55.000Z","_content":"\n进程是一个程序的一次执行的过程，它包括程序的创建，执行，调度，消亡。从宏观上讲进程是并行的，但微观层面是串行的。\n\n<!--more-->\n## 一、进程的概念      \n进程和程序的区别：     \n 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念。     \n 进程是一个动态的概念，它是程序执行的过程，包括创建、调度。\n常见的进程可以分为三类：\n* 交互进程            \n  该类进程是由shell控制和运行的。            \n  * 前台进程\n  例如：`./a.out`，既可以有输入，也可以有输出\n  * 后台进程\n  例如：`./a.out &`, 只有输出，没有输入\n* 批处理进程\n* 守护进程         \n  该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束。它是 提供服务的进程。\n\n## 二、进程的运行状态\n运行态：此时进程或者正在运行，或者准备运行。\n等待态：此时进程在等待一个事件的发生或某种系统资源。又分为可中断和不可中断两种。\n停止态：此时进程被中止。使用 `ctrl + Z` 时进程的状态。  \n僵尸态：这是一个已终止的进程，但还在进程向量数组中占有一个task_struct结构。\n\n|代码|英文|解释|\n|----|---|----|\n|D    |uninterruptible sleep (usually IO)|  不可中断的睡眠态       |\n|R    |running or runnable (on run queue)  |   运行态       |\n|S    |interruptible sleep (waiting for an event to complete) |可中断睡眠态       |\n|T    |stopped, either by a job control signal or because it is being traced. |停止态     |  \n|X    |dead (should never be seen)  |死亡态， 不可见       |\n|Z    |defunct (\"zombie\") process, terminated but not reaped by its parent. |僵尸态|\n||For BSD formats and when the stat keyword is used, additional characters may be displayed: |\n|<    |high-priority (not nice to other users)  | 高优先级     |  \n|L    |has pages locked into memory (for real-time and custom IO)   ||    \n|N    ||低优先级       |\n|s    |is a session leader   |回话组的组长       |\n|l    |is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)  |进程中包含线程    |   \n|+    |is in the foreground process group.  |前台进程|\n\n## 三、进程的创建\n`pid_t fork(void);`\n功能：创建子进程    \n返回值：成功时，在父亲进程中得到子进程进程号，在子进程中得到0；出错返回-1。\n\n子进程，精确复制了父亲进程的内容，包括父亲进程的缓存区  也拷贝。除了 父亲进程pid。。\n子进程从 fork 之后，pid 赋值之前进行执行的。\n\n`pid_t getpid(void);`     \n功能：得到正在调用此函数进程的进程号\n\n`pid_t getppid(void);`     \n功能：得到正在调用此函数进程父亲的进程号\n\n## 四、子进程的回收     \n`pid_t wait(int *status);`     \n功能：阻塞等待任意的儿子进程的结束，回收儿子进程的资源     \n返回值：成功返回子进程的进程号，失败返回-1;\n\n`pid_t waitpid(pid_t pid, int *status, int options);`     \n功能：等待指定的子进程的结束     \n参数：\n  `pid > 0` 等待指定的 `pid` 进程的结束；`pid = -1`等待任意的一个子进程的结束；\n  `status` 子进程退出的状态标识位            \n  `options` 为 `WNOHANG` 不阻塞，返回 `0`（没有回收到），`pid号`（成功回收到）；为 `0` 阻塞，失败返回 `-1` ，成功返回 `pid号`\n返回值：就是上面的情况\n\n僵尸进程：当父进程存在，子进程退出，父进程没有给子进程回收资源，子进程就变成了僵尸进程（`task_struct` 资源没有被释放）。\n\n如何避免僵尸的产生？     \n * 父亲先死，儿子活着，此时 儿子进程  /init 进程 收养。不会产生僵尸。（父亲的尸体 由 bash 给回收，儿子以后再死的话，init 进程收尸）\n * 父亲活着，儿子先死，父亲调用 wait函数进行收尸，所以没有僵尸产生。\n\n## 五、进程的退出    \n`void _exit(int status);`\n功能：结束正在调用的进程，程序结束前不刷新缓存区\n\n`void exit(int status);`\n功能：结束正在调用的进程，程序结束前会刷新缓存区\n\n## 六、exec 函数族      \n功能：在一个进程中，启动执行另外一个进程。没有产生新的进程，            \n将这个进程中img 镜像，替换掉原来执行进程的img 镜像。      \nl ：参数以列表形式，展现出来。\nv ：参数以数组形式表现。   \ne ：可传递新进程的环境变量。   \np ：执行文件查找方式为文件名。      \n\n\n## 七、守护进程的创建      \n1. 创建子进程，父进程退出。`fork();`\n2. 在子进程中创建新会话。`pid_t setsid(void);`\n3. 改变当前目录为根目录。`int chdir(const char *path);`\n4. 重设文件权限掩码。`umask(0);`\n5. 关闭文件描述符。`int getdtablesize(void);`\n\n一个完整的创建守护进程的代码如下所示：\n````C\nvoid init_demon(void) {\n  int pid;\n  int i;\n\n  //创建子进程,关闭父进程\n  if(pid=fork()) {\n    exit(0)；\n  } else if (pid< 0) {\n    perror(\"fail to fork\");\n    exit(1);\n  }\n\n\t//设置会话组组长\n  setsid();\n  if(pid=fork())\n    exit(0);\n  else if(pid< 0)\n    exit(1);\n\n\t//关闭打开的文件描述符, 改变工作目录到/tmp, 重设文件创建掩模\n  for(i=0;i< getdtablesize();++i)\n    close(i);\n\n  chdir(\"/tmp\");\n  umask(0);\n}\n````","source":"_posts/Linux学习总结06.md","raw":"---\ntitle: Linux学习总结（六）——进程\ndate: 2016-12-16 15:54:55\ncategories: Linux学习记录\ntags: [进程]\n---\n\n进程是一个程序的一次执行的过程，它包括程序的创建，执行，调度，消亡。从宏观上讲进程是并行的，但微观层面是串行的。\n\n<!--more-->\n## 一、进程的概念      \n进程和程序的区别：     \n 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念。     \n 进程是一个动态的概念，它是程序执行的过程，包括创建、调度。\n常见的进程可以分为三类：\n* 交互进程            \n  该类进程是由shell控制和运行的。            \n  * 前台进程\n  例如：`./a.out`，既可以有输入，也可以有输出\n  * 后台进程\n  例如：`./a.out &`, 只有输出，没有输入\n* 批处理进程\n* 守护进程         \n  该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束。它是 提供服务的进程。\n\n## 二、进程的运行状态\n运行态：此时进程或者正在运行，或者准备运行。\n等待态：此时进程在等待一个事件的发生或某种系统资源。又分为可中断和不可中断两种。\n停止态：此时进程被中止。使用 `ctrl + Z` 时进程的状态。  \n僵尸态：这是一个已终止的进程，但还在进程向量数组中占有一个task_struct结构。\n\n|代码|英文|解释|\n|----|---|----|\n|D    |uninterruptible sleep (usually IO)|  不可中断的睡眠态       |\n|R    |running or runnable (on run queue)  |   运行态       |\n|S    |interruptible sleep (waiting for an event to complete) |可中断睡眠态       |\n|T    |stopped, either by a job control signal or because it is being traced. |停止态     |  \n|X    |dead (should never be seen)  |死亡态， 不可见       |\n|Z    |defunct (\"zombie\") process, terminated but not reaped by its parent. |僵尸态|\n||For BSD formats and when the stat keyword is used, additional characters may be displayed: |\n|<    |high-priority (not nice to other users)  | 高优先级     |  \n|L    |has pages locked into memory (for real-time and custom IO)   ||    \n|N    ||低优先级       |\n|s    |is a session leader   |回话组的组长       |\n|l    |is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)  |进程中包含线程    |   \n|+    |is in the foreground process group.  |前台进程|\n\n## 三、进程的创建\n`pid_t fork(void);`\n功能：创建子进程    \n返回值：成功时，在父亲进程中得到子进程进程号，在子进程中得到0；出错返回-1。\n\n子进程，精确复制了父亲进程的内容，包括父亲进程的缓存区  也拷贝。除了 父亲进程pid。。\n子进程从 fork 之后，pid 赋值之前进行执行的。\n\n`pid_t getpid(void);`     \n功能：得到正在调用此函数进程的进程号\n\n`pid_t getppid(void);`     \n功能：得到正在调用此函数进程父亲的进程号\n\n## 四、子进程的回收     \n`pid_t wait(int *status);`     \n功能：阻塞等待任意的儿子进程的结束，回收儿子进程的资源     \n返回值：成功返回子进程的进程号，失败返回-1;\n\n`pid_t waitpid(pid_t pid, int *status, int options);`     \n功能：等待指定的子进程的结束     \n参数：\n  `pid > 0` 等待指定的 `pid` 进程的结束；`pid = -1`等待任意的一个子进程的结束；\n  `status` 子进程退出的状态标识位            \n  `options` 为 `WNOHANG` 不阻塞，返回 `0`（没有回收到），`pid号`（成功回收到）；为 `0` 阻塞，失败返回 `-1` ，成功返回 `pid号`\n返回值：就是上面的情况\n\n僵尸进程：当父进程存在，子进程退出，父进程没有给子进程回收资源，子进程就变成了僵尸进程（`task_struct` 资源没有被释放）。\n\n如何避免僵尸的产生？     \n * 父亲先死，儿子活着，此时 儿子进程  /init 进程 收养。不会产生僵尸。（父亲的尸体 由 bash 给回收，儿子以后再死的话，init 进程收尸）\n * 父亲活着，儿子先死，父亲调用 wait函数进行收尸，所以没有僵尸产生。\n\n## 五、进程的退出    \n`void _exit(int status);`\n功能：结束正在调用的进程，程序结束前不刷新缓存区\n\n`void exit(int status);`\n功能：结束正在调用的进程，程序结束前会刷新缓存区\n\n## 六、exec 函数族      \n功能：在一个进程中，启动执行另外一个进程。没有产生新的进程，            \n将这个进程中img 镜像，替换掉原来执行进程的img 镜像。      \nl ：参数以列表形式，展现出来。\nv ：参数以数组形式表现。   \ne ：可传递新进程的环境变量。   \np ：执行文件查找方式为文件名。      \n\n\n## 七、守护进程的创建      \n1. 创建子进程，父进程退出。`fork();`\n2. 在子进程中创建新会话。`pid_t setsid(void);`\n3. 改变当前目录为根目录。`int chdir(const char *path);`\n4. 重设文件权限掩码。`umask(0);`\n5. 关闭文件描述符。`int getdtablesize(void);`\n\n一个完整的创建守护进程的代码如下所示：\n````C\nvoid init_demon(void) {\n  int pid;\n  int i;\n\n  //创建子进程,关闭父进程\n  if(pid=fork()) {\n    exit(0)；\n  } else if (pid< 0) {\n    perror(\"fail to fork\");\n    exit(1);\n  }\n\n\t//设置会话组组长\n  setsid();\n  if(pid=fork())\n    exit(0);\n  else if(pid< 0)\n    exit(1);\n\n\t//关闭打开的文件描述符, 改变工作目录到/tmp, 重设文件创建掩模\n  for(i=0;i< getdtablesize();++i)\n    close(i);\n\n  chdir(\"/tmp\");\n  umask(0);\n}\n````","slug":"Linux学习总结06","published":1,"updated":"2017-12-06T13:48:51.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0s0015bkw1ur6g9dxz","content":"<p>进程是一个程序的一次执行的过程，它包括程序的创建，执行，调度，消亡。从宏观上讲进程是并行的，但微观层面是串行的。</p>\n<a id=\"more\"></a>\n<h2 id=\"一、进程的概念\"><a href=\"#一、进程的概念\" class=\"headerlink\" title=\"一、进程的概念\"></a>一、进程的概念</h2><p>进程和程序的区别：<br> 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念。<br> 进程是一个动态的概念，它是程序执行的过程，包括创建、调度。<br>常见的进程可以分为三类：</p>\n<ul>\n<li>交互进程<br>该类进程是由shell控制和运行的。            <ul>\n<li>前台进程<br>例如：<code>./a.out</code>，既可以有输入，也可以有输出</li>\n<li>后台进程<br>例如：<code>./a.out &amp;</code>, 只有输出，没有输入</li>\n</ul>\n</li>\n<li>批处理进程</li>\n<li>守护进程<br>该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束。它是 提供服务的进程。</li>\n</ul>\n<h2 id=\"二、进程的运行状态\"><a href=\"#二、进程的运行状态\" class=\"headerlink\" title=\"二、进程的运行状态\"></a>二、进程的运行状态</h2><p>运行态：此时进程或者正在运行，或者准备运行。<br>等待态：此时进程在等待一个事件的发生或某种系统资源。又分为可中断和不可中断两种。<br>停止态：此时进程被中止。使用 <code>ctrl + Z</code> 时进程的状态。<br>僵尸态：这是一个已终止的进程，但还在进程向量数组中占有一个task_struct结构。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>英文</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>D</td>\n<td>uninterruptible sleep (usually IO)</td>\n<td>不可中断的睡眠态</td>\n</tr>\n<tr>\n<td>R</td>\n<td>running or runnable (on run queue)</td>\n<td>运行态</td>\n</tr>\n<tr>\n<td>S</td>\n<td>interruptible sleep (waiting for an event to complete)</td>\n<td>可中断睡眠态</td>\n</tr>\n<tr>\n<td>T</td>\n<td>stopped, either by a job control signal or because it is being traced.</td>\n<td>停止态</td>\n</tr>\n<tr>\n<td>X</td>\n<td>dead (should never be seen)</td>\n<td>死亡态， 不可见</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>defunct (“zombie”) process, terminated but not reaped by its parent.</td>\n<td>僵尸态</td>\n</tr>\n<tr>\n<td></td>\n<td>For BSD formats and when the stat keyword is used, additional characters may be displayed:</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>high-priority (not nice to other users)</td>\n<td>高优先级</td>\n</tr>\n<tr>\n<td>L</td>\n<td>has pages locked into memory (for real-time and custom IO)</td>\n<td></td>\n</tr>\n<tr>\n<td>N</td>\n<td></td>\n<td>低优先级</td>\n</tr>\n<tr>\n<td>s</td>\n<td>is a session leader</td>\n<td>回话组的组长</td>\n</tr>\n<tr>\n<td>l</td>\n<td>is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</td>\n<td>进程中包含线程</td>\n</tr>\n<tr>\n<td>+</td>\n<td>is in the foreground process group.</td>\n<td>前台进程</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、进程的创建\"><a href=\"#三、进程的创建\" class=\"headerlink\" title=\"三、进程的创建\"></a>三、进程的创建</h2><p><code>pid_t fork(void);</code><br>功能：创建子进程<br>返回值：成功时，在父亲进程中得到子进程进程号，在子进程中得到0；出错返回-1。</p>\n<p>子进程，精确复制了父亲进程的内容，包括父亲进程的缓存区  也拷贝。除了 父亲进程pid。。<br>子进程从 fork 之后，pid 赋值之前进行执行的。</p>\n<p><code>pid_t getpid(void);</code><br>功能：得到正在调用此函数进程的进程号</p>\n<p><code>pid_t getppid(void);</code><br>功能：得到正在调用此函数进程父亲的进程号</p>\n<h2 id=\"四、子进程的回收\"><a href=\"#四、子进程的回收\" class=\"headerlink\" title=\"四、子进程的回收\"></a>四、子进程的回收</h2><p><code>pid_t wait(int *status);</code><br>功能：阻塞等待任意的儿子进程的结束，回收儿子进程的资源<br>返回值：成功返回子进程的进程号，失败返回-1;</p>\n<p><code>pid_t waitpid(pid_t pid, int *status, int options);</code><br>功能：等待指定的子进程的结束<br>参数：<br>  <code>pid &gt; 0</code> 等待指定的 <code>pid</code> 进程的结束；<code>pid = -1</code>等待任意的一个子进程的结束；<br>  <code>status</code> 子进程退出的状态标识位<br>  <code>options</code> 为 <code>WNOHANG</code> 不阻塞，返回 <code>0</code>（没有回收到），<code>pid号</code>（成功回收到）；为 <code>0</code> 阻塞，失败返回 <code>-1</code> ，成功返回 <code>pid号</code><br>返回值：就是上面的情况</p>\n<p>僵尸进程：当父进程存在，子进程退出，父进程没有给子进程回收资源，子进程就变成了僵尸进程（<code>task_struct</code> 资源没有被释放）。</p>\n<p>如何避免僵尸的产生？     </p>\n<ul>\n<li>父亲先死，儿子活着，此时 儿子进程  /init 进程 收养。不会产生僵尸。（父亲的尸体 由 bash 给回收，儿子以后再死的话，init 进程收尸）</li>\n<li>父亲活着，儿子先死，父亲调用 wait函数进行收尸，所以没有僵尸产生。</li>\n</ul>\n<h2 id=\"五、进程的退出\"><a href=\"#五、进程的退出\" class=\"headerlink\" title=\"五、进程的退出\"></a>五、进程的退出</h2><p><code>void _exit(int status);</code><br>功能：结束正在调用的进程，程序结束前不刷新缓存区</p>\n<p><code>void exit(int status);</code><br>功能：结束正在调用的进程，程序结束前会刷新缓存区</p>\n<h2 id=\"六、exec-函数族\"><a href=\"#六、exec-函数族\" class=\"headerlink\" title=\"六、exec 函数族\"></a>六、exec 函数族</h2><p>功能：在一个进程中，启动执行另外一个进程。没有产生新的进程，<br>将这个进程中img 镜像，替换掉原来执行进程的img 镜像。<br>l ：参数以列表形式，展现出来。<br>v ：参数以数组形式表现。<br>e ：可传递新进程的环境变量。<br>p ：执行文件查找方式为文件名。      </p>\n<h2 id=\"七、守护进程的创建\"><a href=\"#七、守护进程的创建\" class=\"headerlink\" title=\"七、守护进程的创建\"></a>七、守护进程的创建</h2><ol>\n<li>创建子进程，父进程退出。<code>fork();</code></li>\n<li>在子进程中创建新会话。<code>pid_t setsid(void);</code></li>\n<li>改变当前目录为根目录。<code>int chdir(const char *path);</code></li>\n<li>重设文件权限掩码。<code>umask(0);</code></li>\n<li>关闭文件描述符。<code>int getdtablesize(void);</code></li>\n</ol>\n<p>一个完整的创建守护进程的代码如下所示：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_demon</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> pid;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//创建子进程,关闭父进程</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(pid=fork()) &#123;</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>)；</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid&lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    perror(<span class=\"string\">\"fail to fork\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//设置会话组组长</span></div><div class=\"line\">  setsid();</div><div class=\"line\">  <span class=\"keyword\">if</span>(pid=fork())</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid&lt; <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//关闭打开的文件描述符, 改变工作目录到/tmp, 重设文件创建掩模</span></div><div class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt; getdtablesize();++i)</div><div class=\"line\">    close(i);</div><div class=\"line\"></div><div class=\"line\">  chdir(<span class=\"string\">\"/tmp\"</span>);</div><div class=\"line\">  umask(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>进程是一个程序的一次执行的过程，它包括程序的创建，执行，调度，消亡。从宏观上讲进程是并行的，但微观层面是串行的。</p>","more":"<h2 id=\"一、进程的概念\"><a href=\"#一、进程的概念\" class=\"headerlink\" title=\"一、进程的概念\"></a>一、进程的概念</h2><p>进程和程序的区别：<br> 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念。<br> 进程是一个动态的概念，它是程序执行的过程，包括创建、调度。<br>常见的进程可以分为三类：</p>\n<ul>\n<li>交互进程<br>该类进程是由shell控制和运行的。            <ul>\n<li>前台进程<br>例如：<code>./a.out</code>，既可以有输入，也可以有输出</li>\n<li>后台进程<br>例如：<code>./a.out &amp;</code>, 只有输出，没有输入</li>\n</ul>\n</li>\n<li>批处理进程</li>\n<li>守护进程<br>该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束。它是 提供服务的进程。</li>\n</ul>\n<h2 id=\"二、进程的运行状态\"><a href=\"#二、进程的运行状态\" class=\"headerlink\" title=\"二、进程的运行状态\"></a>二、进程的运行状态</h2><p>运行态：此时进程或者正在运行，或者准备运行。<br>等待态：此时进程在等待一个事件的发生或某种系统资源。又分为可中断和不可中断两种。<br>停止态：此时进程被中止。使用 <code>ctrl + Z</code> 时进程的状态。<br>僵尸态：这是一个已终止的进程，但还在进程向量数组中占有一个task_struct结构。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>英文</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>D</td>\n<td>uninterruptible sleep (usually IO)</td>\n<td>不可中断的睡眠态</td>\n</tr>\n<tr>\n<td>R</td>\n<td>running or runnable (on run queue)</td>\n<td>运行态</td>\n</tr>\n<tr>\n<td>S</td>\n<td>interruptible sleep (waiting for an event to complete)</td>\n<td>可中断睡眠态</td>\n</tr>\n<tr>\n<td>T</td>\n<td>stopped, either by a job control signal or because it is being traced.</td>\n<td>停止态</td>\n</tr>\n<tr>\n<td>X</td>\n<td>dead (should never be seen)</td>\n<td>死亡态， 不可见</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>defunct (“zombie”) process, terminated but not reaped by its parent.</td>\n<td>僵尸态</td>\n</tr>\n<tr>\n<td></td>\n<td>For BSD formats and when the stat keyword is used, additional characters may be displayed:</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>high-priority (not nice to other users)</td>\n<td>高优先级</td>\n</tr>\n<tr>\n<td>L</td>\n<td>has pages locked into memory (for real-time and custom IO)</td>\n<td></td>\n</tr>\n<tr>\n<td>N</td>\n<td></td>\n<td>低优先级</td>\n</tr>\n<tr>\n<td>s</td>\n<td>is a session leader</td>\n<td>回话组的组长</td>\n</tr>\n<tr>\n<td>l</td>\n<td>is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</td>\n<td>进程中包含线程</td>\n</tr>\n<tr>\n<td>+</td>\n<td>is in the foreground process group.</td>\n<td>前台进程</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、进程的创建\"><a href=\"#三、进程的创建\" class=\"headerlink\" title=\"三、进程的创建\"></a>三、进程的创建</h2><p><code>pid_t fork(void);</code><br>功能：创建子进程<br>返回值：成功时，在父亲进程中得到子进程进程号，在子进程中得到0；出错返回-1。</p>\n<p>子进程，精确复制了父亲进程的内容，包括父亲进程的缓存区  也拷贝。除了 父亲进程pid。。<br>子进程从 fork 之后，pid 赋值之前进行执行的。</p>\n<p><code>pid_t getpid(void);</code><br>功能：得到正在调用此函数进程的进程号</p>\n<p><code>pid_t getppid(void);</code><br>功能：得到正在调用此函数进程父亲的进程号</p>\n<h2 id=\"四、子进程的回收\"><a href=\"#四、子进程的回收\" class=\"headerlink\" title=\"四、子进程的回收\"></a>四、子进程的回收</h2><p><code>pid_t wait(int *status);</code><br>功能：阻塞等待任意的儿子进程的结束，回收儿子进程的资源<br>返回值：成功返回子进程的进程号，失败返回-1;</p>\n<p><code>pid_t waitpid(pid_t pid, int *status, int options);</code><br>功能：等待指定的子进程的结束<br>参数：<br>  <code>pid &gt; 0</code> 等待指定的 <code>pid</code> 进程的结束；<code>pid = -1</code>等待任意的一个子进程的结束；<br>  <code>status</code> 子进程退出的状态标识位<br>  <code>options</code> 为 <code>WNOHANG</code> 不阻塞，返回 <code>0</code>（没有回收到），<code>pid号</code>（成功回收到）；为 <code>0</code> 阻塞，失败返回 <code>-1</code> ，成功返回 <code>pid号</code><br>返回值：就是上面的情况</p>\n<p>僵尸进程：当父进程存在，子进程退出，父进程没有给子进程回收资源，子进程就变成了僵尸进程（<code>task_struct</code> 资源没有被释放）。</p>\n<p>如何避免僵尸的产生？     </p>\n<ul>\n<li>父亲先死，儿子活着，此时 儿子进程  /init 进程 收养。不会产生僵尸。（父亲的尸体 由 bash 给回收，儿子以后再死的话，init 进程收尸）</li>\n<li>父亲活着，儿子先死，父亲调用 wait函数进行收尸，所以没有僵尸产生。</li>\n</ul>\n<h2 id=\"五、进程的退出\"><a href=\"#五、进程的退出\" class=\"headerlink\" title=\"五、进程的退出\"></a>五、进程的退出</h2><p><code>void _exit(int status);</code><br>功能：结束正在调用的进程，程序结束前不刷新缓存区</p>\n<p><code>void exit(int status);</code><br>功能：结束正在调用的进程，程序结束前会刷新缓存区</p>\n<h2 id=\"六、exec-函数族\"><a href=\"#六、exec-函数族\" class=\"headerlink\" title=\"六、exec 函数族\"></a>六、exec 函数族</h2><p>功能：在一个进程中，启动执行另外一个进程。没有产生新的进程，<br>将这个进程中img 镜像，替换掉原来执行进程的img 镜像。<br>l ：参数以列表形式，展现出来。<br>v ：参数以数组形式表现。<br>e ：可传递新进程的环境变量。<br>p ：执行文件查找方式为文件名。      </p>\n<h2 id=\"七、守护进程的创建\"><a href=\"#七、守护进程的创建\" class=\"headerlink\" title=\"七、守护进程的创建\"></a>七、守护进程的创建</h2><ol>\n<li>创建子进程，父进程退出。<code>fork();</code></li>\n<li>在子进程中创建新会话。<code>pid_t setsid(void);</code></li>\n<li>改变当前目录为根目录。<code>int chdir(const char *path);</code></li>\n<li>重设文件权限掩码。<code>umask(0);</code></li>\n<li>关闭文件描述符。<code>int getdtablesize(void);</code></li>\n</ol>\n<p>一个完整的创建守护进程的代码如下所示：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_demon</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> pid;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//创建子进程,关闭父进程</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(pid=fork()) &#123;</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>)；</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid&lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    perror(<span class=\"string\">\"fail to fork\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//设置会话组组长</span></div><div class=\"line\">  setsid();</div><div class=\"line\">  <span class=\"keyword\">if</span>(pid=fork())</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid&lt; <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//关闭打开的文件描述符, 改变工作目录到/tmp, 重设文件创建掩模</span></div><div class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt; getdtablesize();++i)</div><div class=\"line\">    close(i);</div><div class=\"line\"></div><div class=\"line\">  chdir(<span class=\"string\">\"/tmp\"</span>);</div><div class=\"line\">  umask(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"Linux驱动开发（一）——驱动开发基础","date":"2016-12-19T16:08:01.000Z","_content":"\n从本篇博客开始，尝试给自己掌握的 Linux 设备驱动开发进行一个总结，这并不是一个很简单的工作，因为自己的确目前对 Linux 驱动开发也只是一知半解。尽自己所能吧。今天是第一天，先来谈谈 Linux 驱动开发的基础知识。\n<!--more-->\n## 一、设备驱动程序简介\n设备驱动程序是十分重要的，它是连接硬件与软件的桥梁。无操作系统的设备需要单独开发设备驱动，并以相应的驱动模块存在，这样可以更好的划分应用工程师的工作。而在有操作系统的设备上，驱动则是**连接硬件和内核的桥梁**。\nLinux 设备驱大致可以分为三类： \n  **字符设备** 可以顺序访问的设备，通常字符设备至少要实现 `open()`、`close()`、`read()`、`write()` 等系统调用。\n  **块设备** 块设备和字符设备类似，他们的区别是块设备上可以容纳文件系统，块设备和字符设备在内核内部管理数据的方式不同。\n  **网络设备** 网络设备和字符以及块设备完全不同，它是围绕数据包的传输和接收来设计的。\n所有的块设备和字符设备均被映射到 LInux 的文件系统中去。\n\n## 二、Linux 内核简介\n### 2.1 内核功能的划分\n根据内核完成任务的不同，可以将内核功能划分为以下几部分：\n* **进程管理**\n  进程管理功能负责创建和销毁进程，并处理他们和外部世界的连接，不同进程的通信，CPU调度等功能。\n* **内存管理**\n  内存管理的策略是一个决定系统性能的关键因素。\n* **文件系统**\n  Unix 的每个对象几乎都可以当作文件来看待，Unix 没有在结构的硬件上构造文件系统，而是抽象在整个系统中广泛使用。\n* **设备控制**\n  内核必须为系统中的每件外设嵌入相关的驱动程序。\n* **网络功能**\n  内核负责在应用程序和网络接口之间传递数据包，路由和地址解析功能也是内核处理的工作。\n\n### 2.2 内核的源代码\n\n针对上面的相应功能，Linux内核源码的各个目录大致与此相对应，其组成如下： \n * **arch** 目录包括了所有和体系结构相关的核心代码。它下面的每一个子目录都代表一种Linux支持的体系结构。 \n * **include** 目录包括编译核心所需要的大部分头文件。 \n * **init** 目录包含核心的初始化代码（不是系统的引导代码），有main.c和Version.c两个文件。\n * **mm** 目录包含了所有的内存管理代码。与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下。 \n * **drivers** 目录中是系统中所有的设备驱动程序。\n * **ipc** 目录包含了核心进程间的通信代码。 \n * **modules** 目录存放了已建好的、可动态加载的模块。 \n * **fs** 目录存放Linux支持的文件系统代码。\n * **Kernel** 内核管理的核心代码放在这里，如进程调度，定时器等。\n * **net** 目录里是核心的网络部分代码，其每个子目录对应于网络的一个方面。 \n * **lib** 目录包含了核心的库代码。 \n * **scripts** 目录包含用于配置核心的脚本文件。 \n * **documentation** 目录下是一些文档，是对每个目录作用的具体说明。 \n\n内核源码的编译系统由三个部分组成：分散在源码各个目录的 Makefile 文件，内核的配置文件，以及我们的配置工具。具体的步骤为：\n * 首先使用 menuconfig 等配置工具配置内核。\n * 然后进行相应的编译工作\n\n### 2.3 内核的引导过程\n整体的 Linux 系统的开机过程如下：\n加载BIOS -> 读取MBR -> Boot Loader -> 用户层init依据inittab文件来设定运行等级 -> init进程执行rc.sysinit -> 启动内核模块 ->执行不同运行级别的脚本程序 -> 执行/etc/rc.d/rc.local -> 执行/bin/login程序，进入登录状态\n而详细的内核启动流程为：\n1. 实模式的入口函数 `_start()`：在 header.S 中，这里会进入众所周知的 main 函数，它拷贝 bootloader 的各个参数，执行基本硬件设置，解析命令行参数。\n2. 保护模式的入口函数 `startup_32()`：在 compressed/header_32.S 中，这里会解压 bzImage 内核映像，加载 vmlinux 内核文件。\n3. 内核入口函数 `startup_32()`：在 kernel/header_32.S 中，这就是所谓的进程0，它会进入体系结构无关的 `start_kernel()` 函数，即众所周知的 Linux 内核启动函数。`start_kernel()` 会做大量的内核初始化操作，解析内核启动的命令行参数，并启动一个内核线程来完成内核模块初始化的过程，然后进入空闲循环。\n4. 内核模块初始化的入口函数 `kernel_init()` ：在 init/main.c 中，这里会启动内核模块、创建基于内存的 rootfs、加载 initramfs 文件或cpio-initrd，并启动一个内核线程来运行其中的 init 脚本，完成真正根文件系统的挂载。\n5. 根文件系统挂载脚本`/init`：这里会挂载根文件系统、运行 /sbin/init，从而启动众所周知的进程1。\n6. init进程的系统初始化过程：执行相关脚本，以完成系统初始化，如设置键盘、字体，装载模块，设置网络等，最后运行登录程序，出现登录界面。\n\n## 三、Linux 内核编程\n### 3.1 Linux 内核模块的构成\n一个 Linux 大致由下面几个部分构成：\n * 模块加载函数\n   Linux 模块加载函数一般以 `__init` 标识声明，并以 `module_init(函数名)` 的形式被指定，典型的模块加载函数如下所示：\n   ````c\n   static int __init initialization_function(void) {\n     /*初始化代码*/\n   }\n   module_init(initialization_function);````\n   `module_init` 成功返回0，失败会返回相应的错误编码。\n\n * 模块卸载函数\n   Linux 模块卸载函数一般以 `__exit` 标识声明，并以 `module_exit(函数名)` 的形式被指定，典型的模块卸载函数如下所示：\n   ````c\n   static int __exit cleanup_function(void) {\n     /*初始化代码*/\n   }\n   module_exit(cleanup_function);````\n   `module_exit` 不返回任何值。\n\n * 模块参数\n   我们可以用 `moudule_param(参数名, 参数类型, 参数读写权限)` 为模块定义一个参数。\n   在装载模块的时候，我们可以使用 `insmode 模块名 参数名=参数值` 的方式为模块传递参数。\n\n * 模块导出符号 \n   模块可以使用相应的宏导出符号到内核符号表。\n   ````c\n   EXPORT_SYMBOL(符号名);\n   EXPORT_SYMBOL_GPL(符号名);````\n   导出的符号可以被其他模块使用。\n\n * 模块信息声明\n   我们可以使用相应的宏来声明模块的作者等信息：\n   ````c\n   MODULE_AUTHOR(author);\n   MODULE_DESCRIPTION(description);\n   MODULE_VERSION(version);\n   MODULE_DEVICE_TABLE(table_info);\n   MODULE_ALIAS(alternate_name);````\n   `MODULE_DEVICE_TABLE` 是用来为 USB PCI 等设备驱动声明模块支持设备的。\n\n * 模块许可证声明\n   大多数情况下，我们遵循 GPL兼容许可证，使用 `MODULE_LICENSE(\"Dual BSD/GPL\")` 来声明模块采用 BSD/GPL 双 LICENSE。\n\n## 四、Linux文件系统\n字符设备和块设备都良好的体现了 UNIX **一切皆文件** 的设计思想。我们写的所有驱动最终都是通过操作系统的文件操作来调用访问，所以我们必须了解 Linux 的文件系统组成，和设备驱动与文件系统的关系。\n\n### 4.1 Linxu 文件系统结构\n1. `/` \n文件系统的入口，最高一级目录；\n\n2. `/bin`\n基础系统所需要的命令位于此目录，是最小系统所需要的命令，如：ls, cp, mkdir等。\n这个目录中的文件都是可执行的，一般的用户都可以使用。\n\n3. `/sbin`\n包含系统的命令，如 modprobe、hwclock、ifconfig 等，大多是涉及系统管理的命令。\n这个目录中的文件都是可执行的。\n\n3. `/boot` \n包含Linux内核及系统引导程序所需要的文件，比如 vmlinuz initrd.img 文件都位于这个目录中。\n在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；\n\n4. `/dev` \n设备文件存储目录，应用程序可以通过对这些文件的读写和控制来访问实际的设备。\n\n5. `/etc` \n存放系统程序或者一般工具的配置文件。\n如 /etc/init.d 这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。\n如apache2的/etc/init.d apache2 start|stop|restart MySQL为/etc/init.d mysql start|stop|restart 6. /home 普通用户默认存放目录 Linux 是多用户环境，所以每一个用户都有一个只有自己可以访问的目录（当然管理员也可以访问）。它们以 /home/username 的方式存在。这个目录也保存一些应用对于这个用户的配置，比如 IRC, X 等。\n\n7. `/lib` \n库文件存放目录这里包含了系统程序所需要的所有共享库文件，类似于 Windows 的共享库 DLL 文件。\n\n8. `/lost+found` \n在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。\nLinux 应该正确的关机。但有时你的系统也可能崩溃掉或突然断电使系统意外关机。那么启动的时候 fsck 将会进行长时间的文件系统检查。Fsck 会检测并试图恢复所发现的不正确的文件。被恢复的文件会放置在这个目录中。所恢复的文件也许并不完整或并不合理，但毕竟提供了一些恢复数据的机会。\n\n\n9. `/media` \n即插即用型存储设备的挂载点自动在这个目录下创建，比如USB盘系统自动挂载后，会在这个目录下产生一个目录 ；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，类似cdrom 的目录。这个只有在最新的发行套件上才有. \n\n10. `/mnt` \n这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。比如光驱可以挂载到/mnt/cdrom 。在这里你可以加载你的文件系统或设备。加载是使一个文件系统对于系统可用的过程。在加载后你的文件可以在加载目录下访问。这个目录通常包含加载目录或用于加载软驱和光驱的子目录。\n\n11. `/opt` \n表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过 ./configure --prefix=/opt/，将软件安装到opt目录。\n\n12. `/proc` \n操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。这是系统中极为特殊的一个目录，实际上任何分区上都不存在这个目录。它实际是个实时的、驻留在内存中的文件系统。\n\n\n13. `/root` \nLinux超级权限用户root的家目录；\n\n15. `/tmp` \n临时文件目录，有时用户运行程序的时候，会产生临时文件。 /tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。\n许多程序在这里建立lock文件和存储临时数据。有些系统会在启动或关机时清空此目录。\n\n16. `/usr` \n这个是系统存放程序的目录，比如命令、帮助文件等。\n这个目录下有很多的文件和目录。\n当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。\n如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。\n\n17. `/var`\nvar 表示变化的意思，这里通常会存储日志文件。\n\n18. `/sys`\nLinxu 2.6 内核所支持的 sysfs 文件系统被映射到这个目录。Linux 设备驱动模型中的总线、驱动和设备都可以在这个文件系统中找到相应的节点。\n\n### 4.2 Linux 文件系统和设备驱动的关系\nLinux 系统中应用程序、虚拟文件系统（VFS）、和磁盘文件以及一般的设备文件与设备驱动程序之间的关系如下图所示：\n![Linux 文件系统和设备驱动的关系](http://ogf054qp1.bkt.clouddn.com/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png)\n\n应用程序使用系统调用调用 VFS 中的文件，而 VFS 是通过 file_operations 结构体的成员函数来调用磁盘文件系统中的文件和普通文件的。\n字符设备驱动直接提供了相应的 file_operations 成员函数，而块设备因为上面承载的文件系统中会实现相应的 file_operations 成员函数，所以块设备驱动会将对磁盘文件的访问最终转换为对磁盘上相应柱面和扇面的访问。\n\n而与设备驱动开发紧密相关的两个对象是 file 结构体和 inode 结构体。\nfile 结构体的定义是：\n````C\nstruct file {\n  union {\n    struct list_head             fu_list;      //文件对象链表指针linux/include/linux/list.h\n    struct rcu_head              fu_rcuhead;   //RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制\n  } f_u;\n  struct path                    f_path;       //包含dentry和mnt两个成员，用于确定文件路径\n#define f_dentry                 f_path.dentry //f_path的成员之一，当前文件的dentry结构\n#define f_vfsmnt                 f_path.mnt    //表示当前文件所在文件系统的挂载根目录\n  const struct file_operations  *f_op;         //与该文件相关联的操作函数\n  atomic_t                       f_count;      //文件的引用计数(有多少进程打开该文件)\n  unsigned int                   f_flags;      //对应于open时指定的flag\n  mode_t                         f_mode;       //读写模式：open的mod_t mode参数\n  off_t                          f_pos;        //该文件在当前进程中的文件偏移量\n  struct fown_struct             f_owner;      //该结构的作用是通过信号进行I/O时间通知的数据。\n  unsigned int                   f_uid, f_gid; //文件所有者id，所有者组id\n  struct file_ra_state           f_ra;         //在linux/include/linux/fs.h中定义，文件预读相关\n　unsigned long                  f_version;\n#ifdef CONFIG_SECURITY\n  void                          *f_security;\n#endif\n　　\n  void                          *private_data;  //私有数据指针\n#ifdef CONFIG_EPOLL\n  struct list_head               f_ep_links;\n  spinlock_t                     f_ep_lock;\n#endif\n　struct address_space *f_mapping;\n};\n````\n其中设备驱动最为关心的几个内容是：读写模式 `f_mode`，标志 `f_flags`，而 `private_data` 私有数据指针通常被用来指向设备驱动自定义用于描述设备的结构体。\n\ninode 结构体的具体定义如下：\n````C\nstruct inode {\n  ...\n  umode_t imode;                //inode 的权限\n  uid_t i_uid;                  //inode 拥有者的id\n  gid_t i_gid;                  //inode 所属群组的id\n  dev_t i_rdev;                 //如果是设备文件，这里代表设备的设备号\n  loff_t i_size;                //inode 所代表的文件的大小\n\n  struct timespec i_atime;      //inode 最近一次的存取时间\n  struct timespec i_mtime;      //inode 最近一次的修改时间\n  struct timespec i_ctime;      //inode 的产生时间\n\n  unsigned long i_blksize;      //inode 在做I/O时的区块大小\n  unsigned long i_blocks;       //inode 所使用的block数\n\n  struct block_device *i_bdev;  //如果是块设备，对应block_device结构体指针\n  struct cdev *i_cdev;          //如果是字符设备，对应cdev结构体指针\n}\n\ninode 中的 i_rdev 代表设备号，Linux 2.6 设备编号分为主设备号和次设备号，前者为 dev_t 的高12位，后者为低12位。可以使用下面的函数来获取相应的设备号：\n````C\nunsigned int iminor(struct inode *inode);\nunsigned int imajor(struct inode *inode);````\n\n设备号是与驱动对应的概念，同一类设备一般使用相同的主设备号，因为同一驱动往往可以支持多个同类的设备。\n\n### 4.3 Linux 设备文件系统\nLinux 2.6 引入了 `sysfs` 文件系统，该文件系统是一个虚拟的文件系统。它可以产生一个包括所有系统硬件层级的视图。\n`sysfs` 把连接在系统上的设备和总线组织成了一分级的文件。它的顶级目录如下：\n * **block** 包含所有的块设备\n * **device** 包含所有的设备\n * **bus** 包含所有的总线类型\n * **drivers** 包含内核中所有已注册的设备驱动程序\n * **class** 包含系统中的设备类型\n\n在 Linux 内核中，分别使用 `bus_type` `device_driver` `device` 来描述总线/驱动/设备。后两者都必须依赖于一种总线，其相应的结构体中都含有一个 `bus_type` 指针。而驱动和设备是分开注册的，他们通过 `bus_type` 结构体中的 `match()` 成员函数进行配对。\n\nLinux 2.6 使用了 udev 设备模型，udev 根据系统的硬件设备状态变化动态更新设备文件，进行设备的创建和删除等。因此，/dev目录就可以只包含系统中真正存在的文件了。 udev设备在设备被发现的时候加载驱动模块。udev 设计达到下面的目标：\n 1. 在用户空间执行\n 2. 动态的创建删除文件\n 3. 不关心主次设备号\n 4. 提供LSB标准名称\n 5. 可以提供固定名称\n\nudev 分为三个模块 namedev、libsysfs、udev。他们的工作过程是：\n当内核检测到系统出现了新的设备，内核在 sysfs 文件系统中生成相应的记录，并导出一些设备特定的信息。udev 获取内核导出的信息，调用 namedev 给设备指定名称，调用 libsysfs 给设备指定主次设备号，并分析相应的信息来创建/dev中的设备文件。","source":"_posts/Linux驱动开发01.md","raw":"---\ntitle: Linux驱动开发（一）——驱动开发基础\ndate: 2016-12-20 00:08:01\ncategories: 驱动开发\ntags: [驱动, 内核, 设备文件系统, udev]\n---\n\n从本篇博客开始，尝试给自己掌握的 Linux 设备驱动开发进行一个总结，这并不是一个很简单的工作，因为自己的确目前对 Linux 驱动开发也只是一知半解。尽自己所能吧。今天是第一天，先来谈谈 Linux 驱动开发的基础知识。\n<!--more-->\n## 一、设备驱动程序简介\n设备驱动程序是十分重要的，它是连接硬件与软件的桥梁。无操作系统的设备需要单独开发设备驱动，并以相应的驱动模块存在，这样可以更好的划分应用工程师的工作。而在有操作系统的设备上，驱动则是**连接硬件和内核的桥梁**。\nLinux 设备驱大致可以分为三类： \n  **字符设备** 可以顺序访问的设备，通常字符设备至少要实现 `open()`、`close()`、`read()`、`write()` 等系统调用。\n  **块设备** 块设备和字符设备类似，他们的区别是块设备上可以容纳文件系统，块设备和字符设备在内核内部管理数据的方式不同。\n  **网络设备** 网络设备和字符以及块设备完全不同，它是围绕数据包的传输和接收来设计的。\n所有的块设备和字符设备均被映射到 LInux 的文件系统中去。\n\n## 二、Linux 内核简介\n### 2.1 内核功能的划分\n根据内核完成任务的不同，可以将内核功能划分为以下几部分：\n* **进程管理**\n  进程管理功能负责创建和销毁进程，并处理他们和外部世界的连接，不同进程的通信，CPU调度等功能。\n* **内存管理**\n  内存管理的策略是一个决定系统性能的关键因素。\n* **文件系统**\n  Unix 的每个对象几乎都可以当作文件来看待，Unix 没有在结构的硬件上构造文件系统，而是抽象在整个系统中广泛使用。\n* **设备控制**\n  内核必须为系统中的每件外设嵌入相关的驱动程序。\n* **网络功能**\n  内核负责在应用程序和网络接口之间传递数据包，路由和地址解析功能也是内核处理的工作。\n\n### 2.2 内核的源代码\n\n针对上面的相应功能，Linux内核源码的各个目录大致与此相对应，其组成如下： \n * **arch** 目录包括了所有和体系结构相关的核心代码。它下面的每一个子目录都代表一种Linux支持的体系结构。 \n * **include** 目录包括编译核心所需要的大部分头文件。 \n * **init** 目录包含核心的初始化代码（不是系统的引导代码），有main.c和Version.c两个文件。\n * **mm** 目录包含了所有的内存管理代码。与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下。 \n * **drivers** 目录中是系统中所有的设备驱动程序。\n * **ipc** 目录包含了核心进程间的通信代码。 \n * **modules** 目录存放了已建好的、可动态加载的模块。 \n * **fs** 目录存放Linux支持的文件系统代码。\n * **Kernel** 内核管理的核心代码放在这里，如进程调度，定时器等。\n * **net** 目录里是核心的网络部分代码，其每个子目录对应于网络的一个方面。 \n * **lib** 目录包含了核心的库代码。 \n * **scripts** 目录包含用于配置核心的脚本文件。 \n * **documentation** 目录下是一些文档，是对每个目录作用的具体说明。 \n\n内核源码的编译系统由三个部分组成：分散在源码各个目录的 Makefile 文件，内核的配置文件，以及我们的配置工具。具体的步骤为：\n * 首先使用 menuconfig 等配置工具配置内核。\n * 然后进行相应的编译工作\n\n### 2.3 内核的引导过程\n整体的 Linux 系统的开机过程如下：\n加载BIOS -> 读取MBR -> Boot Loader -> 用户层init依据inittab文件来设定运行等级 -> init进程执行rc.sysinit -> 启动内核模块 ->执行不同运行级别的脚本程序 -> 执行/etc/rc.d/rc.local -> 执行/bin/login程序，进入登录状态\n而详细的内核启动流程为：\n1. 实模式的入口函数 `_start()`：在 header.S 中，这里会进入众所周知的 main 函数，它拷贝 bootloader 的各个参数，执行基本硬件设置，解析命令行参数。\n2. 保护模式的入口函数 `startup_32()`：在 compressed/header_32.S 中，这里会解压 bzImage 内核映像，加载 vmlinux 内核文件。\n3. 内核入口函数 `startup_32()`：在 kernel/header_32.S 中，这就是所谓的进程0，它会进入体系结构无关的 `start_kernel()` 函数，即众所周知的 Linux 内核启动函数。`start_kernel()` 会做大量的内核初始化操作，解析内核启动的命令行参数，并启动一个内核线程来完成内核模块初始化的过程，然后进入空闲循环。\n4. 内核模块初始化的入口函数 `kernel_init()` ：在 init/main.c 中，这里会启动内核模块、创建基于内存的 rootfs、加载 initramfs 文件或cpio-initrd，并启动一个内核线程来运行其中的 init 脚本，完成真正根文件系统的挂载。\n5. 根文件系统挂载脚本`/init`：这里会挂载根文件系统、运行 /sbin/init，从而启动众所周知的进程1。\n6. init进程的系统初始化过程：执行相关脚本，以完成系统初始化，如设置键盘、字体，装载模块，设置网络等，最后运行登录程序，出现登录界面。\n\n## 三、Linux 内核编程\n### 3.1 Linux 内核模块的构成\n一个 Linux 大致由下面几个部分构成：\n * 模块加载函数\n   Linux 模块加载函数一般以 `__init` 标识声明，并以 `module_init(函数名)` 的形式被指定，典型的模块加载函数如下所示：\n   ````c\n   static int __init initialization_function(void) {\n     /*初始化代码*/\n   }\n   module_init(initialization_function);````\n   `module_init` 成功返回0，失败会返回相应的错误编码。\n\n * 模块卸载函数\n   Linux 模块卸载函数一般以 `__exit` 标识声明，并以 `module_exit(函数名)` 的形式被指定，典型的模块卸载函数如下所示：\n   ````c\n   static int __exit cleanup_function(void) {\n     /*初始化代码*/\n   }\n   module_exit(cleanup_function);````\n   `module_exit` 不返回任何值。\n\n * 模块参数\n   我们可以用 `moudule_param(参数名, 参数类型, 参数读写权限)` 为模块定义一个参数。\n   在装载模块的时候，我们可以使用 `insmode 模块名 参数名=参数值` 的方式为模块传递参数。\n\n * 模块导出符号 \n   模块可以使用相应的宏导出符号到内核符号表。\n   ````c\n   EXPORT_SYMBOL(符号名);\n   EXPORT_SYMBOL_GPL(符号名);````\n   导出的符号可以被其他模块使用。\n\n * 模块信息声明\n   我们可以使用相应的宏来声明模块的作者等信息：\n   ````c\n   MODULE_AUTHOR(author);\n   MODULE_DESCRIPTION(description);\n   MODULE_VERSION(version);\n   MODULE_DEVICE_TABLE(table_info);\n   MODULE_ALIAS(alternate_name);````\n   `MODULE_DEVICE_TABLE` 是用来为 USB PCI 等设备驱动声明模块支持设备的。\n\n * 模块许可证声明\n   大多数情况下，我们遵循 GPL兼容许可证，使用 `MODULE_LICENSE(\"Dual BSD/GPL\")` 来声明模块采用 BSD/GPL 双 LICENSE。\n\n## 四、Linux文件系统\n字符设备和块设备都良好的体现了 UNIX **一切皆文件** 的设计思想。我们写的所有驱动最终都是通过操作系统的文件操作来调用访问，所以我们必须了解 Linux 的文件系统组成，和设备驱动与文件系统的关系。\n\n### 4.1 Linxu 文件系统结构\n1. `/` \n文件系统的入口，最高一级目录；\n\n2. `/bin`\n基础系统所需要的命令位于此目录，是最小系统所需要的命令，如：ls, cp, mkdir等。\n这个目录中的文件都是可执行的，一般的用户都可以使用。\n\n3. `/sbin`\n包含系统的命令，如 modprobe、hwclock、ifconfig 等，大多是涉及系统管理的命令。\n这个目录中的文件都是可执行的。\n\n3. `/boot` \n包含Linux内核及系统引导程序所需要的文件，比如 vmlinuz initrd.img 文件都位于这个目录中。\n在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；\n\n4. `/dev` \n设备文件存储目录，应用程序可以通过对这些文件的读写和控制来访问实际的设备。\n\n5. `/etc` \n存放系统程序或者一般工具的配置文件。\n如 /etc/init.d 这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。\n如apache2的/etc/init.d apache2 start|stop|restart MySQL为/etc/init.d mysql start|stop|restart 6. /home 普通用户默认存放目录 Linux 是多用户环境，所以每一个用户都有一个只有自己可以访问的目录（当然管理员也可以访问）。它们以 /home/username 的方式存在。这个目录也保存一些应用对于这个用户的配置，比如 IRC, X 等。\n\n7. `/lib` \n库文件存放目录这里包含了系统程序所需要的所有共享库文件，类似于 Windows 的共享库 DLL 文件。\n\n8. `/lost+found` \n在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。\nLinux 应该正确的关机。但有时你的系统也可能崩溃掉或突然断电使系统意外关机。那么启动的时候 fsck 将会进行长时间的文件系统检查。Fsck 会检测并试图恢复所发现的不正确的文件。被恢复的文件会放置在这个目录中。所恢复的文件也许并不完整或并不合理，但毕竟提供了一些恢复数据的机会。\n\n\n9. `/media` \n即插即用型存储设备的挂载点自动在这个目录下创建，比如USB盘系统自动挂载后，会在这个目录下产生一个目录 ；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，类似cdrom 的目录。这个只有在最新的发行套件上才有. \n\n10. `/mnt` \n这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。比如光驱可以挂载到/mnt/cdrom 。在这里你可以加载你的文件系统或设备。加载是使一个文件系统对于系统可用的过程。在加载后你的文件可以在加载目录下访问。这个目录通常包含加载目录或用于加载软驱和光驱的子目录。\n\n11. `/opt` \n表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过 ./configure --prefix=/opt/，将软件安装到opt目录。\n\n12. `/proc` \n操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。这是系统中极为特殊的一个目录，实际上任何分区上都不存在这个目录。它实际是个实时的、驻留在内存中的文件系统。\n\n\n13. `/root` \nLinux超级权限用户root的家目录；\n\n15. `/tmp` \n临时文件目录，有时用户运行程序的时候，会产生临时文件。 /tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。\n许多程序在这里建立lock文件和存储临时数据。有些系统会在启动或关机时清空此目录。\n\n16. `/usr` \n这个是系统存放程序的目录，比如命令、帮助文件等。\n这个目录下有很多的文件和目录。\n当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。\n如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。\n\n17. `/var`\nvar 表示变化的意思，这里通常会存储日志文件。\n\n18. `/sys`\nLinxu 2.6 内核所支持的 sysfs 文件系统被映射到这个目录。Linux 设备驱动模型中的总线、驱动和设备都可以在这个文件系统中找到相应的节点。\n\n### 4.2 Linux 文件系统和设备驱动的关系\nLinux 系统中应用程序、虚拟文件系统（VFS）、和磁盘文件以及一般的设备文件与设备驱动程序之间的关系如下图所示：\n![Linux 文件系统和设备驱动的关系](http://ogf054qp1.bkt.clouddn.com/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png)\n\n应用程序使用系统调用调用 VFS 中的文件，而 VFS 是通过 file_operations 结构体的成员函数来调用磁盘文件系统中的文件和普通文件的。\n字符设备驱动直接提供了相应的 file_operations 成员函数，而块设备因为上面承载的文件系统中会实现相应的 file_operations 成员函数，所以块设备驱动会将对磁盘文件的访问最终转换为对磁盘上相应柱面和扇面的访问。\n\n而与设备驱动开发紧密相关的两个对象是 file 结构体和 inode 结构体。\nfile 结构体的定义是：\n````C\nstruct file {\n  union {\n    struct list_head             fu_list;      //文件对象链表指针linux/include/linux/list.h\n    struct rcu_head              fu_rcuhead;   //RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制\n  } f_u;\n  struct path                    f_path;       //包含dentry和mnt两个成员，用于确定文件路径\n#define f_dentry                 f_path.dentry //f_path的成员之一，当前文件的dentry结构\n#define f_vfsmnt                 f_path.mnt    //表示当前文件所在文件系统的挂载根目录\n  const struct file_operations  *f_op;         //与该文件相关联的操作函数\n  atomic_t                       f_count;      //文件的引用计数(有多少进程打开该文件)\n  unsigned int                   f_flags;      //对应于open时指定的flag\n  mode_t                         f_mode;       //读写模式：open的mod_t mode参数\n  off_t                          f_pos;        //该文件在当前进程中的文件偏移量\n  struct fown_struct             f_owner;      //该结构的作用是通过信号进行I/O时间通知的数据。\n  unsigned int                   f_uid, f_gid; //文件所有者id，所有者组id\n  struct file_ra_state           f_ra;         //在linux/include/linux/fs.h中定义，文件预读相关\n　unsigned long                  f_version;\n#ifdef CONFIG_SECURITY\n  void                          *f_security;\n#endif\n　　\n  void                          *private_data;  //私有数据指针\n#ifdef CONFIG_EPOLL\n  struct list_head               f_ep_links;\n  spinlock_t                     f_ep_lock;\n#endif\n　struct address_space *f_mapping;\n};\n````\n其中设备驱动最为关心的几个内容是：读写模式 `f_mode`，标志 `f_flags`，而 `private_data` 私有数据指针通常被用来指向设备驱动自定义用于描述设备的结构体。\n\ninode 结构体的具体定义如下：\n````C\nstruct inode {\n  ...\n  umode_t imode;                //inode 的权限\n  uid_t i_uid;                  //inode 拥有者的id\n  gid_t i_gid;                  //inode 所属群组的id\n  dev_t i_rdev;                 //如果是设备文件，这里代表设备的设备号\n  loff_t i_size;                //inode 所代表的文件的大小\n\n  struct timespec i_atime;      //inode 最近一次的存取时间\n  struct timespec i_mtime;      //inode 最近一次的修改时间\n  struct timespec i_ctime;      //inode 的产生时间\n\n  unsigned long i_blksize;      //inode 在做I/O时的区块大小\n  unsigned long i_blocks;       //inode 所使用的block数\n\n  struct block_device *i_bdev;  //如果是块设备，对应block_device结构体指针\n  struct cdev *i_cdev;          //如果是字符设备，对应cdev结构体指针\n}\n\ninode 中的 i_rdev 代表设备号，Linux 2.6 设备编号分为主设备号和次设备号，前者为 dev_t 的高12位，后者为低12位。可以使用下面的函数来获取相应的设备号：\n````C\nunsigned int iminor(struct inode *inode);\nunsigned int imajor(struct inode *inode);````\n\n设备号是与驱动对应的概念，同一类设备一般使用相同的主设备号，因为同一驱动往往可以支持多个同类的设备。\n\n### 4.3 Linux 设备文件系统\nLinux 2.6 引入了 `sysfs` 文件系统，该文件系统是一个虚拟的文件系统。它可以产生一个包括所有系统硬件层级的视图。\n`sysfs` 把连接在系统上的设备和总线组织成了一分级的文件。它的顶级目录如下：\n * **block** 包含所有的块设备\n * **device** 包含所有的设备\n * **bus** 包含所有的总线类型\n * **drivers** 包含内核中所有已注册的设备驱动程序\n * **class** 包含系统中的设备类型\n\n在 Linux 内核中，分别使用 `bus_type` `device_driver` `device` 来描述总线/驱动/设备。后两者都必须依赖于一种总线，其相应的结构体中都含有一个 `bus_type` 指针。而驱动和设备是分开注册的，他们通过 `bus_type` 结构体中的 `match()` 成员函数进行配对。\n\nLinux 2.6 使用了 udev 设备模型，udev 根据系统的硬件设备状态变化动态更新设备文件，进行设备的创建和删除等。因此，/dev目录就可以只包含系统中真正存在的文件了。 udev设备在设备被发现的时候加载驱动模块。udev 设计达到下面的目标：\n 1. 在用户空间执行\n 2. 动态的创建删除文件\n 3. 不关心主次设备号\n 4. 提供LSB标准名称\n 5. 可以提供固定名称\n\nudev 分为三个模块 namedev、libsysfs、udev。他们的工作过程是：\n当内核检测到系统出现了新的设备，内核在 sysfs 文件系统中生成相应的记录，并导出一些设备特定的信息。udev 获取内核导出的信息，调用 namedev 给设备指定名称，调用 libsysfs 给设备指定主次设备号，并分析相应的信息来创建/dev中的设备文件。","slug":"Linux驱动开发01","published":1,"updated":"2016-12-25T08:10:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0s0018bkw1bdcac090","content":"<p>从本篇博客开始，尝试给自己掌握的 Linux 设备驱动开发进行一个总结，这并不是一个很简单的工作，因为自己的确目前对 Linux 驱动开发也只是一知半解。尽自己所能吧。今天是第一天，先来谈谈 Linux 驱动开发的基础知识。<br><a id=\"more\"></a></p>\n<h2 id=\"一、设备驱动程序简介\"><a href=\"#一、设备驱动程序简介\" class=\"headerlink\" title=\"一、设备驱动程序简介\"></a>一、设备驱动程序简介</h2><p>设备驱动程序是十分重要的，它是连接硬件与软件的桥梁。无操作系统的设备需要单独开发设备驱动，并以相应的驱动模块存在，这样可以更好的划分应用工程师的工作。而在有操作系统的设备上，驱动则是<strong>连接硬件和内核的桥梁</strong>。<br>Linux 设备驱大致可以分为三类：<br>  <strong>字符设备</strong> 可以顺序访问的设备，通常字符设备至少要实现 <code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code> 等系统调用。<br>  <strong>块设备</strong> 块设备和字符设备类似，他们的区别是块设备上可以容纳文件系统，块设备和字符设备在内核内部管理数据的方式不同。<br>  <strong>网络设备</strong> 网络设备和字符以及块设备完全不同，它是围绕数据包的传输和接收来设计的。<br>所有的块设备和字符设备均被映射到 LInux 的文件系统中去。</p>\n<h2 id=\"二、Linux-内核简介\"><a href=\"#二、Linux-内核简介\" class=\"headerlink\" title=\"二、Linux 内核简介\"></a>二、Linux 内核简介</h2><h3 id=\"2-1-内核功能的划分\"><a href=\"#2-1-内核功能的划分\" class=\"headerlink\" title=\"2.1 内核功能的划分\"></a>2.1 内核功能的划分</h3><p>根据内核完成任务的不同，可以将内核功能划分为以下几部分：</p>\n<ul>\n<li><strong>进程管理</strong><br>进程管理功能负责创建和销毁进程，并处理他们和外部世界的连接，不同进程的通信，CPU调度等功能。</li>\n<li><strong>内存管理</strong><br>内存管理的策略是一个决定系统性能的关键因素。</li>\n<li><strong>文件系统</strong><br>Unix 的每个对象几乎都可以当作文件来看待，Unix 没有在结构的硬件上构造文件系统，而是抽象在整个系统中广泛使用。</li>\n<li><strong>设备控制</strong><br>内核必须为系统中的每件外设嵌入相关的驱动程序。</li>\n<li><strong>网络功能</strong><br>内核负责在应用程序和网络接口之间传递数据包，路由和地址解析功能也是内核处理的工作。</li>\n</ul>\n<h3 id=\"2-2-内核的源代码\"><a href=\"#2-2-内核的源代码\" class=\"headerlink\" title=\"2.2 内核的源代码\"></a>2.2 内核的源代码</h3><p>针对上面的相应功能，Linux内核源码的各个目录大致与此相对应，其组成如下： </p>\n<ul>\n<li><strong>arch</strong> 目录包括了所有和体系结构相关的核心代码。它下面的每一个子目录都代表一种Linux支持的体系结构。 </li>\n<li><strong>include</strong> 目录包括编译核心所需要的大部分头文件。 </li>\n<li><strong>init</strong> 目录包含核心的初始化代码（不是系统的引导代码），有main.c和Version.c两个文件。</li>\n<li><strong>mm</strong> 目录包含了所有的内存管理代码。与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下。 </li>\n<li><strong>drivers</strong> 目录中是系统中所有的设备驱动程序。</li>\n<li><strong>ipc</strong> 目录包含了核心进程间的通信代码。 </li>\n<li><strong>modules</strong> 目录存放了已建好的、可动态加载的模块。 </li>\n<li><strong>fs</strong> 目录存放Linux支持的文件系统代码。</li>\n<li><strong>Kernel</strong> 内核管理的核心代码放在这里，如进程调度，定时器等。</li>\n<li><strong>net</strong> 目录里是核心的网络部分代码，其每个子目录对应于网络的一个方面。 </li>\n<li><strong>lib</strong> 目录包含了核心的库代码。 </li>\n<li><strong>scripts</strong> 目录包含用于配置核心的脚本文件。 </li>\n<li><strong>documentation</strong> 目录下是一些文档，是对每个目录作用的具体说明。 </li>\n</ul>\n<p>内核源码的编译系统由三个部分组成：分散在源码各个目录的 Makefile 文件，内核的配置文件，以及我们的配置工具。具体的步骤为：</p>\n<ul>\n<li>首先使用 menuconfig 等配置工具配置内核。</li>\n<li>然后进行相应的编译工作</li>\n</ul>\n<h3 id=\"2-3-内核的引导过程\"><a href=\"#2-3-内核的引导过程\" class=\"headerlink\" title=\"2.3 内核的引导过程\"></a>2.3 内核的引导过程</h3><p>整体的 Linux 系统的开机过程如下：<br>加载BIOS -&gt; 读取MBR -&gt; Boot Loader -&gt; 用户层init依据inittab文件来设定运行等级 -&gt; init进程执行rc.sysinit -&gt; 启动内核模块 -&gt;执行不同运行级别的脚本程序 -&gt; 执行/etc/rc.d/rc.local -&gt; 执行/bin/login程序，进入登录状态<br>而详细的内核启动流程为：</p>\n<ol>\n<li>实模式的入口函数 <code>_start()</code>：在 header.S 中，这里会进入众所周知的 main 函数，它拷贝 bootloader 的各个参数，执行基本硬件设置，解析命令行参数。</li>\n<li>保护模式的入口函数 <code>startup_32()</code>：在 compressed/header_32.S 中，这里会解压 bzImage 内核映像，加载 vmlinux 内核文件。</li>\n<li>内核入口函数 <code>startup_32()</code>：在 kernel/header_32.S 中，这就是所谓的进程0，它会进入体系结构无关的 <code>start_kernel()</code> 函数，即众所周知的 Linux 内核启动函数。<code>start_kernel()</code> 会做大量的内核初始化操作，解析内核启动的命令行参数，并启动一个内核线程来完成内核模块初始化的过程，然后进入空闲循环。</li>\n<li>内核模块初始化的入口函数 <code>kernel_init()</code> ：在 init/main.c 中，这里会启动内核模块、创建基于内存的 rootfs、加载 initramfs 文件或cpio-initrd，并启动一个内核线程来运行其中的 init 脚本，完成真正根文件系统的挂载。</li>\n<li>根文件系统挂载脚本<code>/init</code>：这里会挂载根文件系统、运行 /sbin/init，从而启动众所周知的进程1。</li>\n<li>init进程的系统初始化过程：执行相关脚本，以完成系统初始化，如设置键盘、字体，装载模块，设置网络等，最后运行登录程序，出现登录界面。</li>\n</ol>\n<h2 id=\"三、Linux-内核编程\"><a href=\"#三、Linux-内核编程\" class=\"headerlink\" title=\"三、Linux 内核编程\"></a>三、Linux 内核编程</h2><h3 id=\"3-1-Linux-内核模块的构成\"><a href=\"#3-1-Linux-内核模块的构成\" class=\"headerlink\" title=\"3.1 Linux 内核模块的构成\"></a>3.1 Linux 内核模块的构成</h3><p>一个 Linux 大致由下面几个部分构成：</p>\n<ul>\n<li><p>模块加载函数<br>Linux 模块加载函数一般以 <code>__init</code> 标识声明，并以 <code>module_init(函数名)</code> 的形式被指定，典型的模块加载函数如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">initialization_function</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/*初始化代码*/</span></div><div class=\"line\">&#125;</div><div class=\"line\">module_init(initialization_function);</div></pre></td></tr></table></figure>\n<p><code>module_init</code> 成功返回0，失败会返回相应的错误编码。</p>\n</li>\n<li><p>模块卸载函数<br>Linux 模块卸载函数一般以 <code>__exit</code> 标识声明，并以 <code>module_exit(函数名)</code> 的形式被指定，典型的模块卸载函数如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">cleanup_function</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/*初始化代码*/</span></div><div class=\"line\">&#125;</div><div class=\"line\">module_exit(cleanup_function);</div></pre></td></tr></table></figure>\n<p><code>module_exit</code> 不返回任何值。</p>\n</li>\n<li><p>模块参数<br>我们可以用 <code>moudule_param(参数名, 参数类型, 参数读写权限)</code> 为模块定义一个参数。<br>在装载模块的时候，我们可以使用 <code>insmode 模块名 参数名=参数值</code> 的方式为模块传递参数。</p>\n</li>\n<li><p>模块导出符号<br>模块可以使用相应的宏导出符号到内核符号表。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">EXPORT_SYMBOL(符号名);</div><div class=\"line\">EXPORT_SYMBOL_GPL(符号名);</div></pre></td></tr></table></figure>\n<p>导出的符号可以被其他模块使用。</p>\n</li>\n<li><p>模块信息声明<br>我们可以使用相应的宏来声明模块的作者等信息：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MODULE_AUTHOR(author);</div><div class=\"line\">MODULE_DESCRIPTION(description);</div><div class=\"line\">MODULE_VERSION(version);</div><div class=\"line\">MODULE_DEVICE_TABLE(table_info);</div><div class=\"line\">MODULE_ALIAS(alternate_name);</div></pre></td></tr></table></figure>\n<p><code>MODULE_DEVICE_TABLE</code> 是用来为 USB PCI 等设备驱动声明模块支持设备的。</p>\n</li>\n<li><p>模块许可证声明<br>大多数情况下，我们遵循 GPL兼容许可证，使用 <code>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;)</code> 来声明模块采用 BSD/GPL 双 LICENSE。</p>\n</li>\n</ul>\n<h2 id=\"四、Linux文件系统\"><a href=\"#四、Linux文件系统\" class=\"headerlink\" title=\"四、Linux文件系统\"></a>四、Linux文件系统</h2><p>字符设备和块设备都良好的体现了 UNIX <strong>一切皆文件</strong> 的设计思想。我们写的所有驱动最终都是通过操作系统的文件操作来调用访问，所以我们必须了解 Linux 的文件系统组成，和设备驱动与文件系统的关系。</p>\n<h3 id=\"4-1-Linxu-文件系统结构\"><a href=\"#4-1-Linxu-文件系统结构\" class=\"headerlink\" title=\"4.1 Linxu 文件系统结构\"></a>4.1 Linxu 文件系统结构</h3><ol>\n<li><p><code>/</code><br>文件系统的入口，最高一级目录；</p>\n</li>\n<li><p><code>/bin</code><br>基础系统所需要的命令位于此目录，是最小系统所需要的命令，如：ls, cp, mkdir等。<br>这个目录中的文件都是可执行的，一般的用户都可以使用。</p>\n</li>\n<li><p><code>/sbin</code><br>包含系统的命令，如 modprobe、hwclock、ifconfig 等，大多是涉及系统管理的命令。<br>这个目录中的文件都是可执行的。</p>\n</li>\n<li><p><code>/boot</code><br>包含Linux内核及系统引导程序所需要的文件，比如 vmlinuz initrd.img 文件都位于这个目录中。<br>在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；</p>\n</li>\n<li><p><code>/dev</code><br>设备文件存储目录，应用程序可以通过对这些文件的读写和控制来访问实际的设备。</p>\n</li>\n<li><p><code>/etc</code><br>存放系统程序或者一般工具的配置文件。<br>如 /etc/init.d 这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。<br>如apache2的/etc/init.d apache2 start|stop|restart MySQL为/etc/init.d mysql start|stop|restart 6. /home 普通用户默认存放目录 Linux 是多用户环境，所以每一个用户都有一个只有自己可以访问的目录（当然管理员也可以访问）。它们以 /home/username 的方式存在。这个目录也保存一些应用对于这个用户的配置，比如 IRC, X 等。</p>\n</li>\n<li><p><code>/lib</code><br>库文件存放目录这里包含了系统程序所需要的所有共享库文件，类似于 Windows 的共享库 DLL 文件。</p>\n</li>\n<li><p><code>/lost+found</code><br>在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。<br>Linux 应该正确的关机。但有时你的系统也可能崩溃掉或突然断电使系统意外关机。那么启动的时候 fsck 将会进行长时间的文件系统检查。Fsck 会检测并试图恢复所发现的不正确的文件。被恢复的文件会放置在这个目录中。所恢复的文件也许并不完整或并不合理，但毕竟提供了一些恢复数据的机会。</p>\n</li>\n</ol>\n<ol>\n<li><p><code>/media</code><br>即插即用型存储设备的挂载点自动在这个目录下创建，比如USB盘系统自动挂载后，会在这个目录下产生一个目录 ；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，类似cdrom 的目录。这个只有在最新的发行套件上才有. </p>\n</li>\n<li><p><code>/mnt</code><br>这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。比如光驱可以挂载到/mnt/cdrom 。在这里你可以加载你的文件系统或设备。加载是使一个文件系统对于系统可用的过程。在加载后你的文件可以在加载目录下访问。这个目录通常包含加载目录或用于加载软驱和光驱的子目录。</p>\n</li>\n<li><p><code>/opt</code><br>表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过 ./configure –prefix=/opt/，将软件安装到opt目录。</p>\n</li>\n<li><p><code>/proc</code><br>操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。这是系统中极为特殊的一个目录，实际上任何分区上都不存在这个目录。它实际是个实时的、驻留在内存中的文件系统。</p>\n</li>\n</ol>\n<ol>\n<li><p><code>/root</code><br>Linux超级权限用户root的家目录；</p>\n</li>\n<li><p><code>/tmp</code><br>临时文件目录，有时用户运行程序的时候，会产生临时文件。 /tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。<br>许多程序在这里建立lock文件和存储临时数据。有些系统会在启动或关机时清空此目录。</p>\n</li>\n<li><p><code>/usr</code><br>这个是系统存放程序的目录，比如命令、帮助文件等。<br>这个目录下有很多的文件和目录。<br>当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。<br>如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。</p>\n</li>\n<li><p><code>/var</code><br>var 表示变化的意思，这里通常会存储日志文件。</p>\n</li>\n<li><p><code>/sys</code><br>Linxu 2.6 内核所支持的 sysfs 文件系统被映射到这个目录。Linux 设备驱动模型中的总线、驱动和设备都可以在这个文件系统中找到相应的节点。</p>\n</li>\n</ol>\n<h3 id=\"4-2-Linux-文件系统和设备驱动的关系\"><a href=\"#4-2-Linux-文件系统和设备驱动的关系\" class=\"headerlink\" title=\"4.2 Linux 文件系统和设备驱动的关系\"></a>4.2 Linux 文件系统和设备驱动的关系</h3><p>Linux 系统中应用程序、虚拟文件系统（VFS）、和磁盘文件以及一般的设备文件与设备驱动程序之间的关系如下图所示：<br><img src=\"http://ogf054qp1.bkt.clouddn.com/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"Linux 文件系统和设备驱动的关系\"></p>\n<p>应用程序使用系统调用调用 VFS 中的文件，而 VFS 是通过 file_operations 结构体的成员函数来调用磁盘文件系统中的文件和普通文件的。<br>字符设备驱动直接提供了相应的 file_operations 成员函数，而块设备因为上面承载的文件系统中会实现相应的 file_operations 成员函数，所以块设备驱动会将对磁盘文件的访问最终转换为对磁盘上相应柱面和扇面的访问。</p>\n<p>而与设备驱动开发紧密相关的两个对象是 file 结构体和 inode 结构体。<br>file 结构体的定义是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> file &#123;</div><div class=\"line\">  <span class=\"keyword\">union</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> list_head             fu_list;      <span class=\"comment\">//文件对象链表指针linux/include/linux/list.h</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> rcu_head              fu_rcuhead;   <span class=\"comment\">//RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制</span></div><div class=\"line\">  &#125; f_u;</div><div class=\"line\">  <span class=\"keyword\">struct</span> path                    f_path;       <span class=\"comment\">//包含dentry和mnt两个成员，用于确定文件路径</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_dentry                 f_path.dentry <span class=\"comment\">//f_path的成员之一，当前文件的dentry结构</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_vfsmnt                 f_path.mnt    <span class=\"comment\">//表示当前文件所在文件系统的挂载根目录</span></span></div><div class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> file_operations  *f_op;         <span class=\"comment\">//与该文件相关联的操作函数</span></div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>                       f_count;      <span class=\"comment\">//文件的引用计数(有多少进程打开该文件)</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_flags;      <span class=\"comment\">//对应于open时指定的flag</span></div><div class=\"line\">  <span class=\"keyword\">mode_t</span>                         f_mode;       <span class=\"comment\">//读写模式：open的mod_t mode参数</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span>                          f_pos;        <span class=\"comment\">//该文件在当前进程中的文件偏移量</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> fown_struct             f_owner;      <span class=\"comment\">//该结构的作用是通过信号进行I/O时间通知的数据。</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_uid, f_gid; <span class=\"comment\">//文件所有者id，所有者组id</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> file_ra_state           f_ra;         <span class=\"comment\">//在linux/include/linux/fs.h中定义，文件预读相关</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>                  f_version;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SECURITY</span></div><div class=\"line\">  <span class=\"keyword\">void</span>                          *f_security;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　　</div><div class=\"line\">  <span class=\"keyword\">void</span>                          *private_data;  <span class=\"comment\">//私有数据指针</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_EPOLL</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> list_head               f_ep_links;</div><div class=\"line\">  <span class=\"keyword\">spinlock_t</span>                     f_ep_lock;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　<span class=\"keyword\">struct</span> address_space *f_mapping;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>其中设备驱动最为关心的几个内容是：读写模式 <code>f_mode</code>，标志 <code>f_flags</code>，而 <code>private_data</code> 私有数据指针通常被用来指向设备驱动自定义用于描述设备的结构体。</p>\n<p>inode 结构体的具体定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> inode &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"keyword\">umode_t</span> imode;                <span class=\"comment\">//inode 的权限</span></div><div class=\"line\">  <span class=\"keyword\">uid_t</span> i_uid;                  <span class=\"comment\">//inode 拥有者的id</span></div><div class=\"line\">  <span class=\"keyword\">gid_t</span> i_gid;                  <span class=\"comment\">//inode 所属群组的id</span></div><div class=\"line\">  <span class=\"keyword\">dev_t</span> i_rdev;                 <span class=\"comment\">//如果是设备文件，这里代表设备的设备号</span></div><div class=\"line\">  <span class=\"keyword\">loff_t</span> i_size;                <span class=\"comment\">//inode 所代表的文件的大小</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">struct</span> timespec i_atime;      <span class=\"comment\">//inode 最近一次的存取时间</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> timespec i_mtime;      <span class=\"comment\">//inode 最近一次的修改时间</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> timespec i_ctime;      <span class=\"comment\">//inode 的产生时间</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i_blksize;      <span class=\"comment\">//inode 在做I/O时的区块大小</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i_blocks;       <span class=\"comment\">//inode 所使用的block数</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">struct</span> block_device *i_bdev;  <span class=\"comment\">//如果是块设备，对应block_device结构体指针</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cdev *i_cdev;          <span class=\"comment\">//如果是字符设备，对应cdev结构体指针</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">inode 中的 i_rdev 代表设备号，Linux <span class=\"number\">2.6</span> 设备编号分为主设备号和次设备号，前者为 <span class=\"keyword\">dev_t</span> 的高<span class=\"number\">12</span>位，后者为低<span class=\"number\">12</span>位。可以使用下面的函数来获取相应的设备号：</div><div class=\"line\">````<span class=\"function\">C</span></div><div class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">iminor</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode)</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">imajor</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>设备号是与驱动对应的概念，同一类设备一般使用相同的主设备号，因为同一驱动往往可以支持多个同类的设备。</p>\n<h3 id=\"4-3-Linux-设备文件系统\"><a href=\"#4-3-Linux-设备文件系统\" class=\"headerlink\" title=\"4.3 Linux 设备文件系统\"></a>4.3 Linux 设备文件系统</h3><p>Linux 2.6 引入了 <code>sysfs</code> 文件系统，该文件系统是一个虚拟的文件系统。它可以产生一个包括所有系统硬件层级的视图。<br><code>sysfs</code> 把连接在系统上的设备和总线组织成了一分级的文件。它的顶级目录如下：</p>\n<ul>\n<li><strong>block</strong> 包含所有的块设备</li>\n<li><strong>device</strong> 包含所有的设备</li>\n<li><strong>bus</strong> 包含所有的总线类型</li>\n<li><strong>drivers</strong> 包含内核中所有已注册的设备驱动程序</li>\n<li><strong>class</strong> 包含系统中的设备类型</li>\n</ul>\n<p>在 Linux 内核中，分别使用 <code>bus_type</code> <code>device_driver</code> <code>device</code> 来描述总线/驱动/设备。后两者都必须依赖于一种总线，其相应的结构体中都含有一个 <code>bus_type</code> 指针。而驱动和设备是分开注册的，他们通过 <code>bus_type</code> 结构体中的 <code>match()</code> 成员函数进行配对。</p>\n<p>Linux 2.6 使用了 udev 设备模型，udev 根据系统的硬件设备状态变化动态更新设备文件，进行设备的创建和删除等。因此，/dev目录就可以只包含系统中真正存在的文件了。 udev设备在设备被发现的时候加载驱动模块。udev 设计达到下面的目标：</p>\n<ol>\n<li>在用户空间执行</li>\n<li>动态的创建删除文件</li>\n<li>不关心主次设备号</li>\n<li>提供LSB标准名称</li>\n<li>可以提供固定名称</li>\n</ol>\n<p>udev 分为三个模块 namedev、libsysfs、udev。他们的工作过程是：<br>当内核检测到系统出现了新的设备，内核在 sysfs 文件系统中生成相应的记录，并导出一些设备特定的信息。udev 获取内核导出的信息，调用 namedev 给设备指定名称，调用 libsysfs 给设备指定主次设备号，并分析相应的信息来创建/dev中的设备文件。</p>\n","excerpt":"<p>从本篇博客开始，尝试给自己掌握的 Linux 设备驱动开发进行一个总结，这并不是一个很简单的工作，因为自己的确目前对 Linux 驱动开发也只是一知半解。尽自己所能吧。今天是第一天，先来谈谈 Linux 驱动开发的基础知识。<br>","more":"</p>\n<h2 id=\"一、设备驱动程序简介\"><a href=\"#一、设备驱动程序简介\" class=\"headerlink\" title=\"一、设备驱动程序简介\"></a>一、设备驱动程序简介</h2><p>设备驱动程序是十分重要的，它是连接硬件与软件的桥梁。无操作系统的设备需要单独开发设备驱动，并以相应的驱动模块存在，这样可以更好的划分应用工程师的工作。而在有操作系统的设备上，驱动则是<strong>连接硬件和内核的桥梁</strong>。<br>Linux 设备驱大致可以分为三类：<br>  <strong>字符设备</strong> 可以顺序访问的设备，通常字符设备至少要实现 <code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code> 等系统调用。<br>  <strong>块设备</strong> 块设备和字符设备类似，他们的区别是块设备上可以容纳文件系统，块设备和字符设备在内核内部管理数据的方式不同。<br>  <strong>网络设备</strong> 网络设备和字符以及块设备完全不同，它是围绕数据包的传输和接收来设计的。<br>所有的块设备和字符设备均被映射到 LInux 的文件系统中去。</p>\n<h2 id=\"二、Linux-内核简介\"><a href=\"#二、Linux-内核简介\" class=\"headerlink\" title=\"二、Linux 内核简介\"></a>二、Linux 内核简介</h2><h3 id=\"2-1-内核功能的划分\"><a href=\"#2-1-内核功能的划分\" class=\"headerlink\" title=\"2.1 内核功能的划分\"></a>2.1 内核功能的划分</h3><p>根据内核完成任务的不同，可以将内核功能划分为以下几部分：</p>\n<ul>\n<li><strong>进程管理</strong><br>进程管理功能负责创建和销毁进程，并处理他们和外部世界的连接，不同进程的通信，CPU调度等功能。</li>\n<li><strong>内存管理</strong><br>内存管理的策略是一个决定系统性能的关键因素。</li>\n<li><strong>文件系统</strong><br>Unix 的每个对象几乎都可以当作文件来看待，Unix 没有在结构的硬件上构造文件系统，而是抽象在整个系统中广泛使用。</li>\n<li><strong>设备控制</strong><br>内核必须为系统中的每件外设嵌入相关的驱动程序。</li>\n<li><strong>网络功能</strong><br>内核负责在应用程序和网络接口之间传递数据包，路由和地址解析功能也是内核处理的工作。</li>\n</ul>\n<h3 id=\"2-2-内核的源代码\"><a href=\"#2-2-内核的源代码\" class=\"headerlink\" title=\"2.2 内核的源代码\"></a>2.2 内核的源代码</h3><p>针对上面的相应功能，Linux内核源码的各个目录大致与此相对应，其组成如下： </p>\n<ul>\n<li><strong>arch</strong> 目录包括了所有和体系结构相关的核心代码。它下面的每一个子目录都代表一种Linux支持的体系结构。 </li>\n<li><strong>include</strong> 目录包括编译核心所需要的大部分头文件。 </li>\n<li><strong>init</strong> 目录包含核心的初始化代码（不是系统的引导代码），有main.c和Version.c两个文件。</li>\n<li><strong>mm</strong> 目录包含了所有的内存管理代码。与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下。 </li>\n<li><strong>drivers</strong> 目录中是系统中所有的设备驱动程序。</li>\n<li><strong>ipc</strong> 目录包含了核心进程间的通信代码。 </li>\n<li><strong>modules</strong> 目录存放了已建好的、可动态加载的模块。 </li>\n<li><strong>fs</strong> 目录存放Linux支持的文件系统代码。</li>\n<li><strong>Kernel</strong> 内核管理的核心代码放在这里，如进程调度，定时器等。</li>\n<li><strong>net</strong> 目录里是核心的网络部分代码，其每个子目录对应于网络的一个方面。 </li>\n<li><strong>lib</strong> 目录包含了核心的库代码。 </li>\n<li><strong>scripts</strong> 目录包含用于配置核心的脚本文件。 </li>\n<li><strong>documentation</strong> 目录下是一些文档，是对每个目录作用的具体说明。 </li>\n</ul>\n<p>内核源码的编译系统由三个部分组成：分散在源码各个目录的 Makefile 文件，内核的配置文件，以及我们的配置工具。具体的步骤为：</p>\n<ul>\n<li>首先使用 menuconfig 等配置工具配置内核。</li>\n<li>然后进行相应的编译工作</li>\n</ul>\n<h3 id=\"2-3-内核的引导过程\"><a href=\"#2-3-内核的引导过程\" class=\"headerlink\" title=\"2.3 内核的引导过程\"></a>2.3 内核的引导过程</h3><p>整体的 Linux 系统的开机过程如下：<br>加载BIOS -&gt; 读取MBR -&gt; Boot Loader -&gt; 用户层init依据inittab文件来设定运行等级 -&gt; init进程执行rc.sysinit -&gt; 启动内核模块 -&gt;执行不同运行级别的脚本程序 -&gt; 执行/etc/rc.d/rc.local -&gt; 执行/bin/login程序，进入登录状态<br>而详细的内核启动流程为：</p>\n<ol>\n<li>实模式的入口函数 <code>_start()</code>：在 header.S 中，这里会进入众所周知的 main 函数，它拷贝 bootloader 的各个参数，执行基本硬件设置，解析命令行参数。</li>\n<li>保护模式的入口函数 <code>startup_32()</code>：在 compressed/header_32.S 中，这里会解压 bzImage 内核映像，加载 vmlinux 内核文件。</li>\n<li>内核入口函数 <code>startup_32()</code>：在 kernel/header_32.S 中，这就是所谓的进程0，它会进入体系结构无关的 <code>start_kernel()</code> 函数，即众所周知的 Linux 内核启动函数。<code>start_kernel()</code> 会做大量的内核初始化操作，解析内核启动的命令行参数，并启动一个内核线程来完成内核模块初始化的过程，然后进入空闲循环。</li>\n<li>内核模块初始化的入口函数 <code>kernel_init()</code> ：在 init/main.c 中，这里会启动内核模块、创建基于内存的 rootfs、加载 initramfs 文件或cpio-initrd，并启动一个内核线程来运行其中的 init 脚本，完成真正根文件系统的挂载。</li>\n<li>根文件系统挂载脚本<code>/init</code>：这里会挂载根文件系统、运行 /sbin/init，从而启动众所周知的进程1。</li>\n<li>init进程的系统初始化过程：执行相关脚本，以完成系统初始化，如设置键盘、字体，装载模块，设置网络等，最后运行登录程序，出现登录界面。</li>\n</ol>\n<h2 id=\"三、Linux-内核编程\"><a href=\"#三、Linux-内核编程\" class=\"headerlink\" title=\"三、Linux 内核编程\"></a>三、Linux 内核编程</h2><h3 id=\"3-1-Linux-内核模块的构成\"><a href=\"#3-1-Linux-内核模块的构成\" class=\"headerlink\" title=\"3.1 Linux 内核模块的构成\"></a>3.1 Linux 内核模块的构成</h3><p>一个 Linux 大致由下面几个部分构成：</p>\n<ul>\n<li><p>模块加载函数<br>Linux 模块加载函数一般以 <code>__init</code> 标识声明，并以 <code>module_init(函数名)</code> 的形式被指定，典型的模块加载函数如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">initialization_function</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/*初始化代码*/</span></div><div class=\"line\">&#125;</div><div class=\"line\">module_init(initialization_function);</div></pre></td></tr></table></figure>\n<p><code>module_init</code> 成功返回0，失败会返回相应的错误编码。</p>\n</li>\n<li><p>模块卸载函数<br>Linux 模块卸载函数一般以 <code>__exit</code> 标识声明，并以 <code>module_exit(函数名)</code> 的形式被指定，典型的模块卸载函数如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">cleanup_function</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/*初始化代码*/</span></div><div class=\"line\">&#125;</div><div class=\"line\">module_exit(cleanup_function);</div></pre></td></tr></table></figure>\n<p><code>module_exit</code> 不返回任何值。</p>\n</li>\n<li><p>模块参数<br>我们可以用 <code>moudule_param(参数名, 参数类型, 参数读写权限)</code> 为模块定义一个参数。<br>在装载模块的时候，我们可以使用 <code>insmode 模块名 参数名=参数值</code> 的方式为模块传递参数。</p>\n</li>\n<li><p>模块导出符号<br>模块可以使用相应的宏导出符号到内核符号表。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">EXPORT_SYMBOL(符号名);</div><div class=\"line\">EXPORT_SYMBOL_GPL(符号名);</div></pre></td></tr></table></figure>\n<p>导出的符号可以被其他模块使用。</p>\n</li>\n<li><p>模块信息声明<br>我们可以使用相应的宏来声明模块的作者等信息：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MODULE_AUTHOR(author);</div><div class=\"line\">MODULE_DESCRIPTION(description);</div><div class=\"line\">MODULE_VERSION(version);</div><div class=\"line\">MODULE_DEVICE_TABLE(table_info);</div><div class=\"line\">MODULE_ALIAS(alternate_name);</div></pre></td></tr></table></figure>\n<p><code>MODULE_DEVICE_TABLE</code> 是用来为 USB PCI 等设备驱动声明模块支持设备的。</p>\n</li>\n<li><p>模块许可证声明<br>大多数情况下，我们遵循 GPL兼容许可证，使用 <code>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;)</code> 来声明模块采用 BSD/GPL 双 LICENSE。</p>\n</li>\n</ul>\n<h2 id=\"四、Linux文件系统\"><a href=\"#四、Linux文件系统\" class=\"headerlink\" title=\"四、Linux文件系统\"></a>四、Linux文件系统</h2><p>字符设备和块设备都良好的体现了 UNIX <strong>一切皆文件</strong> 的设计思想。我们写的所有驱动最终都是通过操作系统的文件操作来调用访问，所以我们必须了解 Linux 的文件系统组成，和设备驱动与文件系统的关系。</p>\n<h3 id=\"4-1-Linxu-文件系统结构\"><a href=\"#4-1-Linxu-文件系统结构\" class=\"headerlink\" title=\"4.1 Linxu 文件系统结构\"></a>4.1 Linxu 文件系统结构</h3><ol>\n<li><p><code>/</code><br>文件系统的入口，最高一级目录；</p>\n</li>\n<li><p><code>/bin</code><br>基础系统所需要的命令位于此目录，是最小系统所需要的命令，如：ls, cp, mkdir等。<br>这个目录中的文件都是可执行的，一般的用户都可以使用。</p>\n</li>\n<li><p><code>/sbin</code><br>包含系统的命令，如 modprobe、hwclock、ifconfig 等，大多是涉及系统管理的命令。<br>这个目录中的文件都是可执行的。</p>\n</li>\n<li><p><code>/boot</code><br>包含Linux内核及系统引导程序所需要的文件，比如 vmlinuz initrd.img 文件都位于这个目录中。<br>在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；</p>\n</li>\n<li><p><code>/dev</code><br>设备文件存储目录，应用程序可以通过对这些文件的读写和控制来访问实际的设备。</p>\n</li>\n<li><p><code>/etc</code><br>存放系统程序或者一般工具的配置文件。<br>如 /etc/init.d 这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。<br>如apache2的/etc/init.d apache2 start|stop|restart MySQL为/etc/init.d mysql start|stop|restart 6. /home 普通用户默认存放目录 Linux 是多用户环境，所以每一个用户都有一个只有自己可以访问的目录（当然管理员也可以访问）。它们以 /home/username 的方式存在。这个目录也保存一些应用对于这个用户的配置，比如 IRC, X 等。</p>\n</li>\n<li><p><code>/lib</code><br>库文件存放目录这里包含了系统程序所需要的所有共享库文件，类似于 Windows 的共享库 DLL 文件。</p>\n</li>\n<li><p><code>/lost+found</code><br>在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。<br>Linux 应该正确的关机。但有时你的系统也可能崩溃掉或突然断电使系统意外关机。那么启动的时候 fsck 将会进行长时间的文件系统检查。Fsck 会检测并试图恢复所发现的不正确的文件。被恢复的文件会放置在这个目录中。所恢复的文件也许并不完整或并不合理，但毕竟提供了一些恢复数据的机会。</p>\n</li>\n</ol>\n<ol>\n<li><p><code>/media</code><br>即插即用型存储设备的挂载点自动在这个目录下创建，比如USB盘系统自动挂载后，会在这个目录下产生一个目录 ；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，类似cdrom 的目录。这个只有在最新的发行套件上才有. </p>\n</li>\n<li><p><code>/mnt</code><br>这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。比如光驱可以挂载到/mnt/cdrom 。在这里你可以加载你的文件系统或设备。加载是使一个文件系统对于系统可用的过程。在加载后你的文件可以在加载目录下访问。这个目录通常包含加载目录或用于加载软驱和光驱的子目录。</p>\n</li>\n<li><p><code>/opt</code><br>表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过 ./configure –prefix=/opt/，将软件安装到opt目录。</p>\n</li>\n<li><p><code>/proc</code><br>操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。这是系统中极为特殊的一个目录，实际上任何分区上都不存在这个目录。它实际是个实时的、驻留在内存中的文件系统。</p>\n</li>\n</ol>\n<ol>\n<li><p><code>/root</code><br>Linux超级权限用户root的家目录；</p>\n</li>\n<li><p><code>/tmp</code><br>临时文件目录，有时用户运行程序的时候，会产生临时文件。 /tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。<br>许多程序在这里建立lock文件和存储临时数据。有些系统会在启动或关机时清空此目录。</p>\n</li>\n<li><p><code>/usr</code><br>这个是系统存放程序的目录，比如命令、帮助文件等。<br>这个目录下有很多的文件和目录。<br>当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。<br>如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。</p>\n</li>\n<li><p><code>/var</code><br>var 表示变化的意思，这里通常会存储日志文件。</p>\n</li>\n<li><p><code>/sys</code><br>Linxu 2.6 内核所支持的 sysfs 文件系统被映射到这个目录。Linux 设备驱动模型中的总线、驱动和设备都可以在这个文件系统中找到相应的节点。</p>\n</li>\n</ol>\n<h3 id=\"4-2-Linux-文件系统和设备驱动的关系\"><a href=\"#4-2-Linux-文件系统和设备驱动的关系\" class=\"headerlink\" title=\"4.2 Linux 文件系统和设备驱动的关系\"></a>4.2 Linux 文件系统和设备驱动的关系</h3><p>Linux 系统中应用程序、虚拟文件系统（VFS）、和磁盘文件以及一般的设备文件与设备驱动程序之间的关系如下图所示：<br><img src=\"http://ogf054qp1.bkt.clouddn.com/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"Linux 文件系统和设备驱动的关系\"></p>\n<p>应用程序使用系统调用调用 VFS 中的文件，而 VFS 是通过 file_operations 结构体的成员函数来调用磁盘文件系统中的文件和普通文件的。<br>字符设备驱动直接提供了相应的 file_operations 成员函数，而块设备因为上面承载的文件系统中会实现相应的 file_operations 成员函数，所以块设备驱动会将对磁盘文件的访问最终转换为对磁盘上相应柱面和扇面的访问。</p>\n<p>而与设备驱动开发紧密相关的两个对象是 file 结构体和 inode 结构体。<br>file 结构体的定义是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> file &#123;</div><div class=\"line\">  <span class=\"keyword\">union</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> list_head             fu_list;      <span class=\"comment\">//文件对象链表指针linux/include/linux/list.h</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> rcu_head              fu_rcuhead;   <span class=\"comment\">//RCU(Read-Copy Update)是Linux 2.6内核中新的锁机制</span></div><div class=\"line\">  &#125; f_u;</div><div class=\"line\">  <span class=\"keyword\">struct</span> path                    f_path;       <span class=\"comment\">//包含dentry和mnt两个成员，用于确定文件路径</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_dentry                 f_path.dentry <span class=\"comment\">//f_path的成员之一，当前文件的dentry结构</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> f_vfsmnt                 f_path.mnt    <span class=\"comment\">//表示当前文件所在文件系统的挂载根目录</span></span></div><div class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> file_operations  *f_op;         <span class=\"comment\">//与该文件相关联的操作函数</span></div><div class=\"line\">  <span class=\"keyword\">atomic_t</span>                       f_count;      <span class=\"comment\">//文件的引用计数(有多少进程打开该文件)</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_flags;      <span class=\"comment\">//对应于open时指定的flag</span></div><div class=\"line\">  <span class=\"keyword\">mode_t</span>                         f_mode;       <span class=\"comment\">//读写模式：open的mod_t mode参数</span></div><div class=\"line\">  <span class=\"keyword\">off_t</span>                          f_pos;        <span class=\"comment\">//该文件在当前进程中的文件偏移量</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> fown_struct             f_owner;      <span class=\"comment\">//该结构的作用是通过信号进行I/O时间通知的数据。</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>                   f_uid, f_gid; <span class=\"comment\">//文件所有者id，所有者组id</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> file_ra_state           f_ra;         <span class=\"comment\">//在linux/include/linux/fs.h中定义，文件预读相关</span></div><div class=\"line\">　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>                  f_version;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SECURITY</span></div><div class=\"line\">  <span class=\"keyword\">void</span>                          *f_security;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　　</div><div class=\"line\">  <span class=\"keyword\">void</span>                          *private_data;  <span class=\"comment\">//私有数据指针</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_EPOLL</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> list_head               f_ep_links;</div><div class=\"line\">  <span class=\"keyword\">spinlock_t</span>                     f_ep_lock;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">　<span class=\"keyword\">struct</span> address_space *f_mapping;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>其中设备驱动最为关心的几个内容是：读写模式 <code>f_mode</code>，标志 <code>f_flags</code>，而 <code>private_data</code> 私有数据指针通常被用来指向设备驱动自定义用于描述设备的结构体。</p>\n<p>inode 结构体的具体定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> inode &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"keyword\">umode_t</span> imode;                <span class=\"comment\">//inode 的权限</span></div><div class=\"line\">  <span class=\"keyword\">uid_t</span> i_uid;                  <span class=\"comment\">//inode 拥有者的id</span></div><div class=\"line\">  <span class=\"keyword\">gid_t</span> i_gid;                  <span class=\"comment\">//inode 所属群组的id</span></div><div class=\"line\">  <span class=\"keyword\">dev_t</span> i_rdev;                 <span class=\"comment\">//如果是设备文件，这里代表设备的设备号</span></div><div class=\"line\">  <span class=\"keyword\">loff_t</span> i_size;                <span class=\"comment\">//inode 所代表的文件的大小</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">struct</span> timespec i_atime;      <span class=\"comment\">//inode 最近一次的存取时间</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> timespec i_mtime;      <span class=\"comment\">//inode 最近一次的修改时间</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> timespec i_ctime;      <span class=\"comment\">//inode 的产生时间</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i_blksize;      <span class=\"comment\">//inode 在做I/O时的区块大小</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i_blocks;       <span class=\"comment\">//inode 所使用的block数</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">struct</span> block_device *i_bdev;  <span class=\"comment\">//如果是块设备，对应block_device结构体指针</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cdev *i_cdev;          <span class=\"comment\">//如果是字符设备，对应cdev结构体指针</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">inode 中的 i_rdev 代表设备号，Linux <span class=\"number\">2.6</span> 设备编号分为主设备号和次设备号，前者为 <span class=\"keyword\">dev_t</span> 的高<span class=\"number\">12</span>位，后者为低<span class=\"number\">12</span>位。可以使用下面的函数来获取相应的设备号：</div><div class=\"line\">````<span class=\"function\">C</div><div class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">iminor</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">imajor</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>设备号是与驱动对应的概念，同一类设备一般使用相同的主设备号，因为同一驱动往往可以支持多个同类的设备。</p>\n<h3 id=\"4-3-Linux-设备文件系统\"><a href=\"#4-3-Linux-设备文件系统\" class=\"headerlink\" title=\"4.3 Linux 设备文件系统\"></a>4.3 Linux 设备文件系统</h3><p>Linux 2.6 引入了 <code>sysfs</code> 文件系统，该文件系统是一个虚拟的文件系统。它可以产生一个包括所有系统硬件层级的视图。<br><code>sysfs</code> 把连接在系统上的设备和总线组织成了一分级的文件。它的顶级目录如下：</p>\n<ul>\n<li><strong>block</strong> 包含所有的块设备</li>\n<li><strong>device</strong> 包含所有的设备</li>\n<li><strong>bus</strong> 包含所有的总线类型</li>\n<li><strong>drivers</strong> 包含内核中所有已注册的设备驱动程序</li>\n<li><strong>class</strong> 包含系统中的设备类型</li>\n</ul>\n<p>在 Linux 内核中，分别使用 <code>bus_type</code> <code>device_driver</code> <code>device</code> 来描述总线/驱动/设备。后两者都必须依赖于一种总线，其相应的结构体中都含有一个 <code>bus_type</code> 指针。而驱动和设备是分开注册的，他们通过 <code>bus_type</code> 结构体中的 <code>match()</code> 成员函数进行配对。</p>\n<p>Linux 2.6 使用了 udev 设备模型，udev 根据系统的硬件设备状态变化动态更新设备文件，进行设备的创建和删除等。因此，/dev目录就可以只包含系统中真正存在的文件了。 udev设备在设备被发现的时候加载驱动模块。udev 设计达到下面的目标：</p>\n<ol>\n<li>在用户空间执行</li>\n<li>动态的创建删除文件</li>\n<li>不关心主次设备号</li>\n<li>提供LSB标准名称</li>\n<li>可以提供固定名称</li>\n</ol>\n<p>udev 分为三个模块 namedev、libsysfs、udev。他们的工作过程是：<br>当内核检测到系统出现了新的设备，内核在 sysfs 文件系统中生成相应的记录，并导出一些设备特定的信息。udev 获取内核导出的信息，调用 namedev 给设备指定名称，调用 libsysfs 给设备指定主次设备号，并分析相应的信息来创建/dev中的设备文件。</p>"},{"title":"Linux学习总结（七）——进程间通信","date":"2016-12-16T07:54:55.000Z","_content":"Linux 的进程间通信方式是从 UNIX 平台继承而来的。传统的 UNIX 进程间通信方式有三种：管道、FIFO、信号。System V 进程间通信包括 System V 消息队列、 System V 信号量和 System V 共享内存。POSIX 进程间通信机制包括 POSIX 消息队列、POSIX 信号量和 POSIX 共享内存区。\n <!--more-->\n现在 Linux 中主要使用的进程间通信方式有：\n * 无名管道（pipe）和有名管道（fifo）\n * 信号（signal）\n * 消息队列（message queue）\n * 共享内存（shared memory）\n * 信号量（semaphore）\n * 套接字（socket）\n\n\n## 一、管道通信\n1. 无名管道 pipe \n 无名管道是 Linux 中管道通信的一种原始方式，只能在具有亲缘关系的进程间进行通信。它是基于文件描述符的通信方式。相应的创建函数为：\n\n ````c     \nint pipe(int pipefd[2]);````\n 功能：在内核中创建一个管道，用来进行进程间通信。      \n 参数：`pipefd[]`数组 ，用来保存2个文件描述符的。            \n    pipefd[0]  读端            \n    pipefd[1]  写端\n 返回： 成功返回0， 出错返回-1\n\n 需要注意的有以下几点： \n  * 无名管道的大小只有64K。\n  * 管道中没有数据 ，读阻塞            \n  * 管道中装满数据， 写阻塞。一旦有空闲空间（4k），写操作继续进行。            \n  * 写端关闭，管道有部分数据，读端可以把数据读出。            \n  * 读端关闭，向管道写数据，没有任何的意义，会造成管道破裂，内核会向进程发送一个SIGPIPE 信号。进程被杀死。\n  * 无名管道通信，只能用于具有亲缘关系的进程间通信。\n\n2. 有名管道 fifo     \n 有名管道可以使互不相关的两个进程互相通信。有名管道可以通过路径名来指出，并且在文件系统中可见，使用 `mkfifo()` 函数创建管道后，就可以使用 `open();` `read();` `write()` 等函数来进行进程间通信了。\n\n ````c\n int mkfifo(const char *pathname, mode_t mode);````\n 功能：创建一个有名管道。  \n 参数：`pathname`管道名；`mode`权限。\n 返回值：成功返回0，出错返回-1。\n \n > 缺省情况下，如果当前 FIFO 没有数据，读进程会一直阻塞，直到有数据写入或是所有的写端都被关闭。\n 对于写进程，只要 FIFO 有数据，就可以进行写入，空间不足时，写进程会阻塞到全部数据写入。\n\n## 二、信号\n信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。产生信号的来源可以是硬件：比如键盘操作等，也可以是软件。产生信号的事件对进程来讲是随机出现的，进程不能通过检测某个标志等方式判断是否产生了一个信号，而是应该告诉内核**当某个信号产生时，执行下列动作**。当信号产生时，有三种处理方式：\n  * 忽略信号：对信号不做任何处理，但是有两个信号不能忽略：即 `SIGKILL` 及 `SIGSTOP`。        \n  * 捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。        \n  * 执行缺省操作：Linux 对每种信号都规定了默认操作。\n\n1. 信号的发送\n 信号的发送有两个函数 `kill()` 和 `raise()`。\n\n ````C\n int kill(pid_t pid, int sig);````\n 功能：给指定的进程，发送信号    \n 参数： `pid` 指定的进程，当 `pid` 为0的时候，信号发送给当前进程组的所有进程，等于-1的时候，发送给所有进程（系统进程集中的除外）；`sig` 需要发送的信号。\n 返回值：成功返回0， 出错返回-1\n\n ````C     \n int raise(int sig);````\n 功能：给正在调用此函数的进程发送信号。\n    \n2. 定时器信号\n 使用 `alarm()` 函数可以设置一个定时器，在将来某个时刻定时器超时的时候，产生一个 `SIGALARM` 信号。进程被杀死。\n\n ````C\n    unsigned int alarm(unsigned int seconds);````\n 功能：定义一个闹钟， 注意它没有阻塞功能    \n 参数：`seconds` 秒数\n 返回值：如果之前没有定义闹钟，成功返回0 ，出错返回-1。如果 `alarm` 之前定义过闹钟，成功返回上一次闹钟距离这一次闹钟所剩下的时间，出错返回-1。\n\n 使用 `pause()` 函数可以使当前进程挂起直到捕捉到相应的信号。\n\n3. 信号的设置\n ````C\n typedef void (*sighandler_t)(int);   /\n sighandler_t signal(int signum, sighandler_t handler);````\n 功能：注册一个信号     \n 参数：`signum` 信号, `handler` 函数指针变量     \n 返回值：函数指针\n\n > 子进程会继承父进程对信号的设置。\n\n ````C\n int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);````\n 参数： `signum` 信号类型， `act` 对特定信号的处理，`oldact` 保留信号原来的处理方式。\n `struct sigaction` 结构体定义如下：\n   ````C\n   struct sigaction {\n       void (*sa_handler)(int signo); //信号处理函数\n       sigset_t sa_mask;              //信号集合，那些信号被屏蔽\n       int sa_flags;                  //标志位 SA_NODEFER/SA_NOMASK(执行处理函数时，不屏蔽当前信号) \n                                      //       SA_NOCLDSTOP（忽略子进程的信号） \n                                      //       SA_RESTART （重新执行被信号中断的系统调用）\n                                      //       SA_ONESHOT/SA_RESETHAND（自定义信号处理函数只生效一次）\n       void (*sa_restore)(void);\n   }````\n 返回值：成功返回0，失败返回-1.\n\n## 三、IPC对象\n接下来讲的三种通信方式都是基于 SystemV IPC 对象的，每个内核中的 IPC结构（共享内存，消息队列，信号灯集）都用一个非负整数的标识符加以引用。标识符是 IPC 对象的内部名，每个 IPC 对象都与一个键 `key` 相关联，`key` 值相当于是 IPC 对象通信的外部名字。使用下面的函数生成一个 `key`。\n\n````C       \nkey_t ftok(const char *pathname, int proj_id);````\n\n功能：产生一个独一无二的key值       \n参数：`pathname` 已经存在的可访问文件的名字，`proj_id`一个字符（只用低8位）       \n返回值：成功返回相应的 `key`，出错返回-1。\n\n## 四、信号灯集     \n信号灯(semaphore)，也叫信号量。它是不同进程间或一个给定进程内部不同线程间同步的机制。\n\n1. PV 原子操作\n  P 操作，如果有可用资源，则占用一个资源，如果没有可用资源，则阻塞\n  V 操作，如果该信号量的等待队列中有任务在等待资源，则唤醒一个阻塞任务，如果没有，则释放一个资源。\n\n2. 信号量的使用步骤\n   1. 创建或者打开信号灯         \n      ````C\n      int semget(key_t key, int nsems, int semflg);````\n     参数：`key` 键值；`nsems` 信号灯的数目；`semflg` 同 `open()` 函数的权限位。  \n     返回值：成功返回相应的 `shmid`，出错返回-1。\n   2. 资源申请，释放资源\n     ````C         \n     int semop(int semid, struct sembuf *sops, unsigned nsops);````\n     参数：`semid` 信号灯集ID；`sops` 指向信号量操作数组，`nops`  要操作的信号灯的个数        \n     `struct sembuf` 结构体定义如下\n     ````C\n    struct sembuf {         \n    short  sem_num;  //  要操作的信号灯的编号         \n    short  sem_op;   //    0 :  等待，直到信号灯的值变成0                               \n                     //    1 :  释放资源，V操作                               \n                     //   -1 :  分配资源，P操作                              \n    short  sem_flg;  // 0,  IPC_NOWAIT,  SEM_UNDO        \n    };````\n     返回：成功 0， 失败 -1\n  3. 信号灯的控制操作   \n     ````C      \n     int semctl ( int semid, int semnum,  int cmd，…/*union semun arg*/);````\n     功能：信号灯的操作         \n     参数：`semid` 信号灯集id号；`semnum` 要对第几个信号灯进行操作，信号灯的编号（从0 开始；`cmd` 为 `IPC_STAT` 表示获取信号量 `IPC_SETVAL` 表示设置为 `arg` 的值 `IPC_GETVAL` 表示返回当前值 `IPC_RMID` 表示删除信号量；`arg` 信号量结构体，定义如下：          \n     ````C\n     union semun {               \n      int              val;    /* Value for SETVAL */               \n      struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */               \n      unsigned short  *array;  /* Array for GETALL, SETALL */               \n      struct seminfo  *__buf;  /* Buffer for IPC_INFO                                           \n      (Linux-specific) */           \n    };````\n    返回值：成功 0， 出错 -1\n\n## 五、消息队列     \n消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。\n\n1. 创建或打开消息队列          \n ````C\n int msgget(key_t key, int msgflg);````\n 参数： `key` 键值；`msgflg` 打开的方式。\n 返回值：成功 msgid，出错 -1\n\n2. 添加消息\n ````C\n int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);````\n 参数：`msgid` 消息队列的id号；`msgp` 发送的消息的结构体地址；`msgsz` 消息正文的大小；`msgflg`  0 阻塞，如果队列中的消息满了，它会阻塞等待，`IPC_NOWAIT` 如果添加消息不成功，立即返回。          \n 返回值：成功 0， 出错 -1\n 用户自定义消息结构体:\n ````C\n struct msgbuf {               \n   long mtype;       /* message type, must be > 0 */               \n   char mtext[1];    /* message data */           \n  };````\n\n3. 读取消息          \n ````C\n ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);````\n 功能：从消息队列中，取出消息          \n 参数：`msgid` 消息id号；`msgp` 接收消息结构体；`msgsz` 消息正文的大小；`msgtyp` 消息的类型，0 表示从第一个开始读取，按队列的规则，> 0 表示按照指定的type类型进行读取，<0 　表示和他的绝对值相等的类型进行读取；`msgflg` 0 阻塞， `IPC_NOWAIT` 不阻塞。\n 返回值：成功 表示读取消息正文的字节数，出错 -1\n\n4. 控制消息队列          \n ````C\n int msgctl(int msqid, int cmd, struct msqid_ds *buf);````\n 参数：`msgid`  消息队列的id号                `cmd`    `IPC_STAT`  获取                       `IPC_SET `  设置                       `IPC_RMID`  删除                buf    属性信息          返回值：成功 0，出错 -1\n\n5. 对消息队列的手动处理\n`ipcs  -q`   查看系统中共享内存的使用情况信息        \n`ipcrm  -q  msgid`   手动删除共享内存        \n`ipcrm  -Q  key`     手动删除共享内存\n\n\n## 六、共享内存通信     \n\n共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等。 \n\n\n1. 生成 IPC 对象: `ftok()`\n2. 创建或者打开共享内存\n    ````C\n    int shmget(key_t key, size_t size, int shmflg);````\n    参数：`key` 键值，`size` 共享内存的大小，`shmflg` 同 `open()` 函数的权限位。         \n    返回值：成功返回相应的 `shmid`，出错返回-1。\n3. 映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问\n    ````C\n    void *shmat(int shmid, const void *shmaddr, int shmflg);````         \n    参数：`shmid` 共享内存的 id 号；`shmaddr` 一般为NULL，表示映射到进程的地址，由操作系统自由选择；`shmflg` 为 `SHM_RDONLY` 表示内存只读，默认为0 可读写。\n    返回值：成功返回映射后的地址， 出错返回-1。\n4. 撤销共享内存映射         \n    ````C\n    int shmdt(const void *shmaddr);````\n6. 删除共享内存         \n    ````C\n    int shmctl(int shmid, int cmd, struct shmid_ds *buf);````         \n    功能：对共享内存进行各种操作         \n    参数：`shmid` 共享内存的id号；`cmd` 为 `IPC_STAT` 表示要获取 `shmid` 属性信息，为 `IPC_SET` 表示设置 `shmid` 属性信息，为 `IPC_RMID` 表示删除共享内存;`buf` 属性信息结构体。\n    返回值：成功返回0，出错返回-1。\n\n2. 对共享内存的手动处理\n `ipcs  -m`   查看系统中共享内存的使用情况信息       \n `ipcrm  -m  shmid`   手动删除共享内存       \n `ipcrm  -M  key`     手动删除共享内存\n\n\n## 七、六种通信方式的对比\n\n|通信类型|描述|\n|--|--|\n|pipe:|具有亲缘关系的进程间，单工，数据在内存中|\n|fifo:| 可用于任意进程间，双工，有文件名，数据在内存|\n|signal:|唯一的异步通信方式|\n|msg:|常用于cs模式中， 按消息类型访问 ，可有优先级|\n|shm:|效率最高(直接访问内存) ，需要同步、互斥机制|\n|sem:|配合共享内存使用，用以实现同步和互斥|","source":"_posts/Linux学习总结07.md","raw":"---\ntitle: Linux学习总结（七）——进程间通信\ndate: 2016-12-16 15:54:55\ncategories: Linux学习记录\ntags: [进程间通信, 消息队列, 共享内存, 信号量]\n---\nLinux 的进程间通信方式是从 UNIX 平台继承而来的。传统的 UNIX 进程间通信方式有三种：管道、FIFO、信号。System V 进程间通信包括 System V 消息队列、 System V 信号量和 System V 共享内存。POSIX 进程间通信机制包括 POSIX 消息队列、POSIX 信号量和 POSIX 共享内存区。\n <!--more-->\n现在 Linux 中主要使用的进程间通信方式有：\n * 无名管道（pipe）和有名管道（fifo）\n * 信号（signal）\n * 消息队列（message queue）\n * 共享内存（shared memory）\n * 信号量（semaphore）\n * 套接字（socket）\n\n\n## 一、管道通信\n1. 无名管道 pipe \n 无名管道是 Linux 中管道通信的一种原始方式，只能在具有亲缘关系的进程间进行通信。它是基于文件描述符的通信方式。相应的创建函数为：\n\n ````c     \nint pipe(int pipefd[2]);````\n 功能：在内核中创建一个管道，用来进行进程间通信。      \n 参数：`pipefd[]`数组 ，用来保存2个文件描述符的。            \n    pipefd[0]  读端            \n    pipefd[1]  写端\n 返回： 成功返回0， 出错返回-1\n\n 需要注意的有以下几点： \n  * 无名管道的大小只有64K。\n  * 管道中没有数据 ，读阻塞            \n  * 管道中装满数据， 写阻塞。一旦有空闲空间（4k），写操作继续进行。            \n  * 写端关闭，管道有部分数据，读端可以把数据读出。            \n  * 读端关闭，向管道写数据，没有任何的意义，会造成管道破裂，内核会向进程发送一个SIGPIPE 信号。进程被杀死。\n  * 无名管道通信，只能用于具有亲缘关系的进程间通信。\n\n2. 有名管道 fifo     \n 有名管道可以使互不相关的两个进程互相通信。有名管道可以通过路径名来指出，并且在文件系统中可见，使用 `mkfifo()` 函数创建管道后，就可以使用 `open();` `read();` `write()` 等函数来进行进程间通信了。\n\n ````c\n int mkfifo(const char *pathname, mode_t mode);````\n 功能：创建一个有名管道。  \n 参数：`pathname`管道名；`mode`权限。\n 返回值：成功返回0，出错返回-1。\n \n > 缺省情况下，如果当前 FIFO 没有数据，读进程会一直阻塞，直到有数据写入或是所有的写端都被关闭。\n 对于写进程，只要 FIFO 有数据，就可以进行写入，空间不足时，写进程会阻塞到全部数据写入。\n\n## 二、信号\n信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。产生信号的来源可以是硬件：比如键盘操作等，也可以是软件。产生信号的事件对进程来讲是随机出现的，进程不能通过检测某个标志等方式判断是否产生了一个信号，而是应该告诉内核**当某个信号产生时，执行下列动作**。当信号产生时，有三种处理方式：\n  * 忽略信号：对信号不做任何处理，但是有两个信号不能忽略：即 `SIGKILL` 及 `SIGSTOP`。        \n  * 捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。        \n  * 执行缺省操作：Linux 对每种信号都规定了默认操作。\n\n1. 信号的发送\n 信号的发送有两个函数 `kill()` 和 `raise()`。\n\n ````C\n int kill(pid_t pid, int sig);````\n 功能：给指定的进程，发送信号    \n 参数： `pid` 指定的进程，当 `pid` 为0的时候，信号发送给当前进程组的所有进程，等于-1的时候，发送给所有进程（系统进程集中的除外）；`sig` 需要发送的信号。\n 返回值：成功返回0， 出错返回-1\n\n ````C     \n int raise(int sig);````\n 功能：给正在调用此函数的进程发送信号。\n    \n2. 定时器信号\n 使用 `alarm()` 函数可以设置一个定时器，在将来某个时刻定时器超时的时候，产生一个 `SIGALARM` 信号。进程被杀死。\n\n ````C\n    unsigned int alarm(unsigned int seconds);````\n 功能：定义一个闹钟， 注意它没有阻塞功能    \n 参数：`seconds` 秒数\n 返回值：如果之前没有定义闹钟，成功返回0 ，出错返回-1。如果 `alarm` 之前定义过闹钟，成功返回上一次闹钟距离这一次闹钟所剩下的时间，出错返回-1。\n\n 使用 `pause()` 函数可以使当前进程挂起直到捕捉到相应的信号。\n\n3. 信号的设置\n ````C\n typedef void (*sighandler_t)(int);   /\n sighandler_t signal(int signum, sighandler_t handler);````\n 功能：注册一个信号     \n 参数：`signum` 信号, `handler` 函数指针变量     \n 返回值：函数指针\n\n > 子进程会继承父进程对信号的设置。\n\n ````C\n int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);````\n 参数： `signum` 信号类型， `act` 对特定信号的处理，`oldact` 保留信号原来的处理方式。\n `struct sigaction` 结构体定义如下：\n   ````C\n   struct sigaction {\n       void (*sa_handler)(int signo); //信号处理函数\n       sigset_t sa_mask;              //信号集合，那些信号被屏蔽\n       int sa_flags;                  //标志位 SA_NODEFER/SA_NOMASK(执行处理函数时，不屏蔽当前信号) \n                                      //       SA_NOCLDSTOP（忽略子进程的信号） \n                                      //       SA_RESTART （重新执行被信号中断的系统调用）\n                                      //       SA_ONESHOT/SA_RESETHAND（自定义信号处理函数只生效一次）\n       void (*sa_restore)(void);\n   }````\n 返回值：成功返回0，失败返回-1.\n\n## 三、IPC对象\n接下来讲的三种通信方式都是基于 SystemV IPC 对象的，每个内核中的 IPC结构（共享内存，消息队列，信号灯集）都用一个非负整数的标识符加以引用。标识符是 IPC 对象的内部名，每个 IPC 对象都与一个键 `key` 相关联，`key` 值相当于是 IPC 对象通信的外部名字。使用下面的函数生成一个 `key`。\n\n````C       \nkey_t ftok(const char *pathname, int proj_id);````\n\n功能：产生一个独一无二的key值       \n参数：`pathname` 已经存在的可访问文件的名字，`proj_id`一个字符（只用低8位）       \n返回值：成功返回相应的 `key`，出错返回-1。\n\n## 四、信号灯集     \n信号灯(semaphore)，也叫信号量。它是不同进程间或一个给定进程内部不同线程间同步的机制。\n\n1. PV 原子操作\n  P 操作，如果有可用资源，则占用一个资源，如果没有可用资源，则阻塞\n  V 操作，如果该信号量的等待队列中有任务在等待资源，则唤醒一个阻塞任务，如果没有，则释放一个资源。\n\n2. 信号量的使用步骤\n   1. 创建或者打开信号灯         \n      ````C\n      int semget(key_t key, int nsems, int semflg);````\n     参数：`key` 键值；`nsems` 信号灯的数目；`semflg` 同 `open()` 函数的权限位。  \n     返回值：成功返回相应的 `shmid`，出错返回-1。\n   2. 资源申请，释放资源\n     ````C         \n     int semop(int semid, struct sembuf *sops, unsigned nsops);````\n     参数：`semid` 信号灯集ID；`sops` 指向信号量操作数组，`nops`  要操作的信号灯的个数        \n     `struct sembuf` 结构体定义如下\n     ````C\n    struct sembuf {         \n    short  sem_num;  //  要操作的信号灯的编号         \n    short  sem_op;   //    0 :  等待，直到信号灯的值变成0                               \n                     //    1 :  释放资源，V操作                               \n                     //   -1 :  分配资源，P操作                              \n    short  sem_flg;  // 0,  IPC_NOWAIT,  SEM_UNDO        \n    };````\n     返回：成功 0， 失败 -1\n  3. 信号灯的控制操作   \n     ````C      \n     int semctl ( int semid, int semnum,  int cmd，…/*union semun arg*/);````\n     功能：信号灯的操作         \n     参数：`semid` 信号灯集id号；`semnum` 要对第几个信号灯进行操作，信号灯的编号（从0 开始；`cmd` 为 `IPC_STAT` 表示获取信号量 `IPC_SETVAL` 表示设置为 `arg` 的值 `IPC_GETVAL` 表示返回当前值 `IPC_RMID` 表示删除信号量；`arg` 信号量结构体，定义如下：          \n     ````C\n     union semun {               \n      int              val;    /* Value for SETVAL */               \n      struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */               \n      unsigned short  *array;  /* Array for GETALL, SETALL */               \n      struct seminfo  *__buf;  /* Buffer for IPC_INFO                                           \n      (Linux-specific) */           \n    };````\n    返回值：成功 0， 出错 -1\n\n## 五、消息队列     \n消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。\n\n1. 创建或打开消息队列          \n ````C\n int msgget(key_t key, int msgflg);````\n 参数： `key` 键值；`msgflg` 打开的方式。\n 返回值：成功 msgid，出错 -1\n\n2. 添加消息\n ````C\n int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);````\n 参数：`msgid` 消息队列的id号；`msgp` 发送的消息的结构体地址；`msgsz` 消息正文的大小；`msgflg`  0 阻塞，如果队列中的消息满了，它会阻塞等待，`IPC_NOWAIT` 如果添加消息不成功，立即返回。          \n 返回值：成功 0， 出错 -1\n 用户自定义消息结构体:\n ````C\n struct msgbuf {               \n   long mtype;       /* message type, must be > 0 */               \n   char mtext[1];    /* message data */           \n  };````\n\n3. 读取消息          \n ````C\n ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);````\n 功能：从消息队列中，取出消息          \n 参数：`msgid` 消息id号；`msgp` 接收消息结构体；`msgsz` 消息正文的大小；`msgtyp` 消息的类型，0 表示从第一个开始读取，按队列的规则，> 0 表示按照指定的type类型进行读取，<0 　表示和他的绝对值相等的类型进行读取；`msgflg` 0 阻塞， `IPC_NOWAIT` 不阻塞。\n 返回值：成功 表示读取消息正文的字节数，出错 -1\n\n4. 控制消息队列          \n ````C\n int msgctl(int msqid, int cmd, struct msqid_ds *buf);````\n 参数：`msgid`  消息队列的id号                `cmd`    `IPC_STAT`  获取                       `IPC_SET `  设置                       `IPC_RMID`  删除                buf    属性信息          返回值：成功 0，出错 -1\n\n5. 对消息队列的手动处理\n`ipcs  -q`   查看系统中共享内存的使用情况信息        \n`ipcrm  -q  msgid`   手动删除共享内存        \n`ipcrm  -Q  key`     手动删除共享内存\n\n\n## 六、共享内存通信     \n\n共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等。 \n\n\n1. 生成 IPC 对象: `ftok()`\n2. 创建或者打开共享内存\n    ````C\n    int shmget(key_t key, size_t size, int shmflg);````\n    参数：`key` 键值，`size` 共享内存的大小，`shmflg` 同 `open()` 函数的权限位。         \n    返回值：成功返回相应的 `shmid`，出错返回-1。\n3. 映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问\n    ````C\n    void *shmat(int shmid, const void *shmaddr, int shmflg);````         \n    参数：`shmid` 共享内存的 id 号；`shmaddr` 一般为NULL，表示映射到进程的地址，由操作系统自由选择；`shmflg` 为 `SHM_RDONLY` 表示内存只读，默认为0 可读写。\n    返回值：成功返回映射后的地址， 出错返回-1。\n4. 撤销共享内存映射         \n    ````C\n    int shmdt(const void *shmaddr);````\n6. 删除共享内存         \n    ````C\n    int shmctl(int shmid, int cmd, struct shmid_ds *buf);````         \n    功能：对共享内存进行各种操作         \n    参数：`shmid` 共享内存的id号；`cmd` 为 `IPC_STAT` 表示要获取 `shmid` 属性信息，为 `IPC_SET` 表示设置 `shmid` 属性信息，为 `IPC_RMID` 表示删除共享内存;`buf` 属性信息结构体。\n    返回值：成功返回0，出错返回-1。\n\n2. 对共享内存的手动处理\n `ipcs  -m`   查看系统中共享内存的使用情况信息       \n `ipcrm  -m  shmid`   手动删除共享内存       \n `ipcrm  -M  key`     手动删除共享内存\n\n\n## 七、六种通信方式的对比\n\n|通信类型|描述|\n|--|--|\n|pipe:|具有亲缘关系的进程间，单工，数据在内存中|\n|fifo:| 可用于任意进程间，双工，有文件名，数据在内存|\n|signal:|唯一的异步通信方式|\n|msg:|常用于cs模式中， 按消息类型访问 ，可有优先级|\n|shm:|效率最高(直接访问内存) ，需要同步、互斥机制|\n|sem:|配合共享内存使用，用以实现同步和互斥|","slug":"Linux学习总结07","published":1,"updated":"2017-12-06T13:40:08.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0s001abkw1q1puu8uh","content":"<p>Linux 的进程间通信方式是从 UNIX 平台继承而来的。传统的 UNIX 进程间通信方式有三种：管道、FIFO、信号。System V 进程间通信包括 System V 消息队列、 System V 信号量和 System V 共享内存。POSIX 进程间通信机制包括 POSIX 消息队列、POSIX 信号量和 POSIX 共享内存区。<br> <a id=\"more\"></a><br>现在 Linux 中主要使用的进程间通信方式有：</p>\n<ul>\n<li>无名管道（pipe）和有名管道（fifo）</li>\n<li>信号（signal）</li>\n<li>消息队列（message queue）</li>\n<li>共享内存（shared memory）</li>\n<li>信号量（semaphore）</li>\n<li>套接字（socket）</li>\n</ul>\n<h2 id=\"一、管道通信\"><a href=\"#一、管道通信\" class=\"headerlink\" title=\"一、管道通信\"></a>一、管道通信</h2><ol>\n<li><p>无名管道 pipe<br>无名管道是 Linux 中管道通信的一种原始方式，只能在具有亲缘关系的进程间进行通信。它是基于文件描述符的通信方式。相应的创建函数为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>])</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：在内核中创建一个管道，用来进行进程间通信。<br>参数：<code>pipefd[]</code>数组 ，用来保存2个文件描述符的。<br> pipefd[0]  读端<br> pipefd[1]  写端<br>返回： 成功返回0， 出错返回-1</p>\n<p>需要注意的有以下几点： </p>\n<ul>\n<li>无名管道的大小只有64K。</li>\n<li>管道中没有数据 ，读阻塞            </li>\n<li>管道中装满数据， 写阻塞。一旦有空闲空间（4k），写操作继续进行。            </li>\n<li>写端关闭，管道有部分数据，读端可以把数据读出。            </li>\n<li>读端关闭，向管道写数据，没有任何的意义，会造成管道破裂，内核会向进程发送一个SIGPIPE 信号。进程被杀死。</li>\n<li>无名管道通信，只能用于具有亲缘关系的进程间通信。</li>\n</ul>\n</li>\n<li><p>有名管道 fifo<br>有名管道可以使互不相关的两个进程互相通信。有名管道可以通过路径名来指出，并且在文件系统中可见，使用 <code>mkfifo()</code> 函数创建管道后，就可以使用 <code>open();</code> <code>read();</code> <code>write()</code> 等函数来进行进程间通信了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mkfifo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：创建一个有名管道。<br>参数：<code>pathname</code>管道名；<code>mode</code>权限。<br>返回值：成功返回0，出错返回-1。</p>\n<blockquote>\n<p>缺省情况下，如果当前 FIFO 没有数据，读进程会一直阻塞，直到有数据写入或是所有的写端都被关闭。<br>对于写进程，只要 FIFO 有数据，就可以进行写入，空间不足时，写进程会阻塞到全部数据写入。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"二、信号\"><a href=\"#二、信号\" class=\"headerlink\" title=\"二、信号\"></a>二、信号</h2><p>信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。产生信号的来源可以是硬件：比如键盘操作等，也可以是软件。产生信号的事件对进程来讲是随机出现的，进程不能通过检测某个标志等方式判断是否产生了一个信号，而是应该告诉内核<strong>当某个信号产生时，执行下列动作</strong>。当信号产生时，有三种处理方式：</p>\n<ul>\n<li>忽略信号：对信号不做任何处理，但是有两个信号不能忽略：即 <code>SIGKILL</code> 及 <code>SIGSTOP</code>。        </li>\n<li>捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。        </li>\n<li>执行缺省操作：Linux 对每种信号都规定了默认操作。</li>\n</ul>\n<ol>\n<li><p>信号的发送<br>信号的发送有两个函数 <code>kill()</code> 和 <code>raise()</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：给指定的进程，发送信号<br>参数： <code>pid</code> 指定的进程，当 <code>pid</code> 为0的时候，信号发送给当前进程组的所有进程，等于-1的时候，发送给所有进程（系统进程集中的除外）；<code>sig</code> 需要发送的信号。<br>返回值：成功返回0， 出错返回-1</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">raise</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：给正在调用此函数的进程发送信号。</p>\n</li>\n<li><p>定时器信号<br>使用 <code>alarm()</code> 函数可以设置一个定时器，在将来某个时刻定时器超时的时候，产生一个 <code>SIGALARM</code> 信号。进程被杀死。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">alarm</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seconds)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：定义一个闹钟， 注意它没有阻塞功能<br>参数：<code>seconds</code> 秒数<br>返回值：如果之前没有定义闹钟，成功返回0 ，出错返回-1。如果 <code>alarm</code> 之前定义过闹钟，成功返回上一次闹钟距离这一次闹钟所剩下的时间，出错返回-1。</p>\n<p>使用 <code>pause()</code> 函数可以使当前进程挂起直到捕捉到相应的信号。</p>\n</li>\n<li><p>信号的设置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*<span class=\"keyword\">sighandler_t</span>)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;   /</div><div class=\"line\"><span class=\"keyword\">sighandler_t</span> signal(<span class=\"keyword\">int</span> signum, <span class=\"keyword\">sighandler_t</span> handler);</div></pre></td></tr></table></figure>\n<p>功能：注册一个信号<br>参数：<code>signum</code> 信号, <code>handler</code> 函数指针变量<br>返回值：函数指针</p>\n<blockquote>\n<p>子进程会继承父进程对信号的设置。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sigaction</span><span class=\"params\">(<span class=\"keyword\">int</span> signum, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sigaction *act, <span class=\"keyword\">struct</span> sigaction *oldact)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数： <code>signum</code> 信号类型， <code>act</code> 对特定信号的处理，<code>oldact</code> 保留信号原来的处理方式。<br><code>struct sigaction</code> 结构体定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> sigaction &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*sa_handler)(<span class=\"keyword\">int</span> signo); <span class=\"comment\">//信号处理函数</span></div><div class=\"line\">    <span class=\"keyword\">sigset_t</span> sa_mask;              <span class=\"comment\">//信号集合，那些信号被屏蔽</span></div><div class=\"line\">    <span class=\"keyword\">int</span> sa_flags;                  <span class=\"comment\">//标志位 SA_NODEFER/SA_NOMASK(执行处理函数时，不屏蔽当前信号) </span></div><div class=\"line\">                                   <span class=\"comment\">//       SA_NOCLDSTOP（忽略子进程的信号） </span></div><div class=\"line\">                                   <span class=\"comment\">//       SA_RESTART （重新执行被信号中断的系统调用）</span></div><div class=\"line\">                                   <span class=\"comment\">//       SA_ONESHOT/SA_RESETHAND（自定义信号处理函数只生效一次）</span></div><div class=\"line\">    <span class=\"keyword\">void</span> (*sa_restore)(<span class=\"keyword\">void</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回值：成功返回0，失败返回-1.</p>\n</li>\n</ol>\n<h2 id=\"三、IPC对象\"><a href=\"#三、IPC对象\" class=\"headerlink\" title=\"三、IPC对象\"></a>三、IPC对象</h2><p>接下来讲的三种通信方式都是基于 SystemV IPC 对象的，每个内核中的 IPC结构（共享内存，消息队列，信号灯集）都用一个非负整数的标识符加以引用。标识符是 IPC 对象的内部名，每个 IPC 对象都与一个键 <code>key</code> 相关联，<code>key</code> 值相当于是 IPC 对象通信的外部名字。使用下面的函数生成一个 <code>key</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">key_t</span> ftok(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> proj_id);</div></pre></td></tr></table></figure>\n<p>功能：产生一个独一无二的key值<br>参数：<code>pathname</code> 已经存在的可访问文件的名字，<code>proj_id</code>一个字符（只用低8位）<br>返回值：成功返回相应的 <code>key</code>，出错返回-1。</p>\n<h2 id=\"四、信号灯集\"><a href=\"#四、信号灯集\" class=\"headerlink\" title=\"四、信号灯集\"></a>四、信号灯集</h2><p>信号灯(semaphore)，也叫信号量。它是不同进程间或一个给定进程内部不同线程间同步的机制。</p>\n<ol>\n<li><p>PV 原子操作<br>P 操作，如果有可用资源，则占用一个资源，如果没有可用资源，则阻塞<br>V 操作，如果该信号量的等待队列中有任务在等待资源，则唤醒一个阻塞任务，如果没有，则释放一个资源。</p>\n</li>\n<li><p>信号量的使用步骤</p>\n<ol>\n<li><p>创建或者打开信号灯         </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> nsems, <span class=\"keyword\">int</span> semflg)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>key</code> 键值；<code>nsems</code> 信号灯的数目；<code>semflg</code> 同 <code>open()</code> 函数的权限位。<br>返回值：成功返回相应的 <code>shmid</code>，出错返回-1。</p>\n</li>\n<li><p>资源申请，释放资源</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semop</span><span class=\"params\">(<span class=\"keyword\">int</span> semid, <span class=\"keyword\">struct</span> sembuf *sops, <span class=\"keyword\">unsigned</span> nsops)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>semid</code> 信号灯集ID；<code>sops</code> 指向信号量操作数组，<code>nops</code>  要操作的信号灯的个数<br><code>struct sembuf</code> 结构体定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> sembuf &#123;         </div><div class=\"line\"><span class=\"keyword\">short</span>  sem_num;  <span class=\"comment\">//  要操作的信号灯的编号         </span></div><div class=\"line\"><span class=\"keyword\">short</span>  sem_op;   <span class=\"comment\">//    0 :  等待，直到信号灯的值变成0                               </span></div><div class=\"line\">                 <span class=\"comment\">//    1 :  释放资源，V操作                               </span></div><div class=\"line\">                 <span class=\"comment\">//   -1 :  分配资源，P操作                              </span></div><div class=\"line\"><span class=\"keyword\">short</span>  sem_flg;  <span class=\"comment\">// 0,  IPC_NOWAIT,  SEM_UNDO        </span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>返回：成功 0， 失败 -1</p>\n</li>\n<li><p>信号灯的控制操作   </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semctl</span> <span class=\"params\">( <span class=\"keyword\">int</span> semid, <span class=\"keyword\">int</span> semnum,  <span class=\"keyword\">int</span> cmd，…<span class=\"comment\">/*union semun arg*/</span>)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：信号灯的操作<br>参数：<code>semid</code> 信号灯集id号；<code>semnum</code> 要对第几个信号灯进行操作，信号灯的编号（从0 开始；<code>cmd</code> 为 <code>IPC_STAT</code> 表示获取信号量 <code>IPC_SETVAL</code> 表示设置为 <code>arg</code> 的值 <code>IPC_GETVAL</code> 表示返回当前值 <code>IPC_RMID</code> 表示删除信号量；<code>arg</code> 信号量结构体，定义如下：          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">union</span> semun &#123;               </div><div class=\"line\">  <span class=\"keyword\">int</span>              val;    <span class=\"comment\">/* Value for SETVAL */</span>               </div><div class=\"line\">  <span class=\"keyword\">struct</span> semid_ds *buf;    <span class=\"comment\">/* Buffer for IPC_STAT, IPC_SET */</span>               </div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>  *<span class=\"built_in\">array</span>;  <span class=\"comment\">/* Array for GETALL, SETALL */</span>               </div><div class=\"line\">  <span class=\"keyword\">struct</span> seminfo  *__buf;  <span class=\"comment\">/* Buffer for IPC_INFO                                           </span></div><div class=\"line\">  (Linux-specific) */           </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>返回值：成功 0， 出错 -1</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"五、消息队列\"><a href=\"#五、消息队列\" class=\"headerlink\" title=\"五、消息队列\"></a>五、消息队列</h2><p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。</p>\n<ol>\n<li><p>创建或打开消息队列          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数： <code>key</code> 键值；<code>msgflg</code> 打开的方式。<br>返回值：成功 msgid，出错 -1</p>\n</li>\n<li><p>添加消息</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msgp, <span class=\"keyword\">size_t</span> msgsz, <span class=\"keyword\">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>msgid</code> 消息队列的id号；<code>msgp</code> 发送的消息的结构体地址；<code>msgsz</code> 消息正文的大小；<code>msgflg</code>  0 阻塞，如果队列中的消息满了，它会阻塞等待，<code>IPC_NOWAIT</code> 如果添加消息不成功，立即返回。<br>返回值：成功 0， 出错 -1<br>用户自定义消息结构体:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> msgbuf &#123;               </div><div class=\"line\">  <span class=\"keyword\">long</span> mtype;       <span class=\"comment\">/* message type, must be &gt; 0 */</span>               </div><div class=\"line\">  <span class=\"keyword\">char</span> mtext[<span class=\"number\">1</span>];    <span class=\"comment\">/* message data */</span>           </div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>读取消息          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">ssize_t</span> msgrcv(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">void</span> *msgp, <span class=\"keyword\">size_t</span> msgsz, <span class=\"keyword\">long</span> msgtyp, <span class=\"keyword\">int</span> msgflg);</div></pre></td></tr></table></figure>\n<p>功能：从消息队列中，取出消息<br>参数：<code>msgid</code> 消息id号；<code>msgp</code> 接收消息结构体；<code>msgsz</code> 消息正文的大小；<code>msgtyp</code> 消息的类型，0 表示从第一个开始读取，按队列的规则，&gt; 0 表示按照指定的type类型进行读取，&lt;0 　表示和他的绝对值相等的类型进行读取；<code>msgflg</code> 0 阻塞， <code>IPC_NOWAIT</code> 不阻塞。<br>返回值：成功 表示读取消息正文的字节数，出错 -1</p>\n</li>\n<li><p>控制消息队列          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">struct</span> msqid_ds *buf)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>msgid</code>  消息队列的id号                <code>cmd</code>    <code>IPC_STAT</code>  获取                       <code>IPC_SET</code>  设置                       <code>IPC_RMID</code>  删除                buf    属性信息          返回值：成功 0，出错 -1</p>\n</li>\n<li><p>对消息队列的手动处理<br><code>ipcs  -q</code>   查看系统中共享内存的使用情况信息<br><code>ipcrm  -q  msgid</code>   手动删除共享内存<br><code>ipcrm  -Q  key</code>     手动删除共享内存</p>\n</li>\n</ol>\n<h2 id=\"六、共享内存通信\"><a href=\"#六、共享内存通信\" class=\"headerlink\" title=\"六、共享内存通信\"></a>六、共享内存通信</h2><p>共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等。 </p>\n<ol>\n<li>生成 IPC 对象: <code>ftok()</code></li>\n<li><p>创建或者打开共享内存</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">int</span> shmflg)</span></span>;</div></pre></td></tr></table></figure>\n<p> 参数：<code>key</code> 键值，<code>size</code> 共享内存的大小，<code>shmflg</code> 同 <code>open()</code> 函数的权限位。<br> 返回值：成功返回相应的 <code>shmid</code>，出错返回-1。</p>\n</li>\n<li><p>映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr, <span class=\"keyword\">int</span> shmflg)</span></span>;````         </div><div class=\"line\">    参数：`shmid` 共享内存的 id 号；`shmaddr` 一般为<span class=\"literal\">NULL</span>，表示映射到进程的地址，由操作系统自由选择；`shmflg` 为 `SHM_RDONLY` 表示内存只读，默认为<span class=\"number\">0</span> 可读写。</div><div class=\"line\">    返回值：成功返回映射后的地址， 出错返回<span class=\"number\">-1</span>。</div><div class=\"line\"><span class=\"number\">4.</span> 撤销共享内存映射         </div><div class=\"line\">    ````<span class=\"function\">C</span></div><div class=\"line\">    <span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr)</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除共享内存         </p>\n<pre><code class=\"C\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">struct</span> shmid_ds *buf)</span></span>;\n</code></pre>\n<p> 功能：对共享内存进行各种操作<br> 参数：<code>shmid</code> 共享内存的id号；<code>cmd</code> 为 <code>IPC_STAT</code> 表示要获取 <code>shmid</code> 属性信息，为 <code>IPC_SET</code> 表示设置 <code>shmid</code> 属性信息，为 <code>IPC_RMID</code> 表示删除共享内存;<code>buf</code> 属性信息结构体。<br> 返回值：成功返回0，出错返回-1。</p>\n</li>\n<li><p>对共享内存的手动处理<br><code>ipcs  -m</code>   查看系统中共享内存的使用情况信息<br><code>ipcrm  -m  shmid</code>   手动删除共享内存<br><code>ipcrm  -M  key</code>     手动删除共享内存</p>\n</li>\n</ol>\n<h2 id=\"七、六种通信方式的对比\"><a href=\"#七、六种通信方式的对比\" class=\"headerlink\" title=\"七、六种通信方式的对比\"></a>七、六种通信方式的对比</h2><table>\n<thead>\n<tr>\n<th>通信类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pipe:</td>\n<td>具有亲缘关系的进程间，单工，数据在内存中</td>\n</tr>\n<tr>\n<td>fifo:</td>\n<td>可用于任意进程间，双工，有文件名，数据在内存</td>\n</tr>\n<tr>\n<td>signal:</td>\n<td>唯一的异步通信方式</td>\n</tr>\n<tr>\n<td>msg:</td>\n<td>常用于cs模式中， 按消息类型访问 ，可有优先级</td>\n</tr>\n<tr>\n<td>shm:</td>\n<td>效率最高(直接访问内存) ，需要同步、互斥机制</td>\n</tr>\n<tr>\n<td>sem:</td>\n<td>配合共享内存使用，用以实现同步和互斥</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"<p>Linux 的进程间通信方式是从 UNIX 平台继承而来的。传统的 UNIX 进程间通信方式有三种：管道、FIFO、信号。System V 进程间通信包括 System V 消息队列、 System V 信号量和 System V 共享内存。POSIX 进程间通信机制包括 POSIX 消息队列、POSIX 信号量和 POSIX 共享内存区。<br>","more":"<br>现在 Linux 中主要使用的进程间通信方式有：</p>\n<ul>\n<li>无名管道（pipe）和有名管道（fifo）</li>\n<li>信号（signal）</li>\n<li>消息队列（message queue）</li>\n<li>共享内存（shared memory）</li>\n<li>信号量（semaphore）</li>\n<li>套接字（socket）</li>\n</ul>\n<h2 id=\"一、管道通信\"><a href=\"#一、管道通信\" class=\"headerlink\" title=\"一、管道通信\"></a>一、管道通信</h2><ol>\n<li><p>无名管道 pipe<br>无名管道是 Linux 中管道通信的一种原始方式，只能在具有亲缘关系的进程间进行通信。它是基于文件描述符的通信方式。相应的创建函数为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>])</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：在内核中创建一个管道，用来进行进程间通信。<br>参数：<code>pipefd[]</code>数组 ，用来保存2个文件描述符的。<br> pipefd[0]  读端<br> pipefd[1]  写端<br>返回： 成功返回0， 出错返回-1</p>\n<p>需要注意的有以下几点： </p>\n<ul>\n<li>无名管道的大小只有64K。</li>\n<li>管道中没有数据 ，读阻塞            </li>\n<li>管道中装满数据， 写阻塞。一旦有空闲空间（4k），写操作继续进行。            </li>\n<li>写端关闭，管道有部分数据，读端可以把数据读出。            </li>\n<li>读端关闭，向管道写数据，没有任何的意义，会造成管道破裂，内核会向进程发送一个SIGPIPE 信号。进程被杀死。</li>\n<li>无名管道通信，只能用于具有亲缘关系的进程间通信。</li>\n</ul>\n</li>\n<li><p>有名管道 fifo<br>有名管道可以使互不相关的两个进程互相通信。有名管道可以通过路径名来指出，并且在文件系统中可见，使用 <code>mkfifo()</code> 函数创建管道后，就可以使用 <code>open();</code> <code>read();</code> <code>write()</code> 等函数来进行进程间通信了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mkfifo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：创建一个有名管道。<br>参数：<code>pathname</code>管道名；<code>mode</code>权限。<br>返回值：成功返回0，出错返回-1。</p>\n<blockquote>\n<p>缺省情况下，如果当前 FIFO 没有数据，读进程会一直阻塞，直到有数据写入或是所有的写端都被关闭。<br>对于写进程，只要 FIFO 有数据，就可以进行写入，空间不足时，写进程会阻塞到全部数据写入。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"二、信号\"><a href=\"#二、信号\" class=\"headerlink\" title=\"二、信号\"></a>二、信号</h2><p>信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。产生信号的来源可以是硬件：比如键盘操作等，也可以是软件。产生信号的事件对进程来讲是随机出现的，进程不能通过检测某个标志等方式判断是否产生了一个信号，而是应该告诉内核<strong>当某个信号产生时，执行下列动作</strong>。当信号产生时，有三种处理方式：</p>\n<ul>\n<li>忽略信号：对信号不做任何处理，但是有两个信号不能忽略：即 <code>SIGKILL</code> 及 <code>SIGSTOP</code>。        </li>\n<li>捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。        </li>\n<li>执行缺省操作：Linux 对每种信号都规定了默认操作。</li>\n</ul>\n<ol>\n<li><p>信号的发送<br>信号的发送有两个函数 <code>kill()</code> 和 <code>raise()</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：给指定的进程，发送信号<br>参数： <code>pid</code> 指定的进程，当 <code>pid</code> 为0的时候，信号发送给当前进程组的所有进程，等于-1的时候，发送给所有进程（系统进程集中的除外）；<code>sig</code> 需要发送的信号。<br>返回值：成功返回0， 出错返回-1</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">raise</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：给正在调用此函数的进程发送信号。</p>\n</li>\n<li><p>定时器信号<br>使用 <code>alarm()</code> 函数可以设置一个定时器，在将来某个时刻定时器超时的时候，产生一个 <code>SIGALARM</code> 信号。进程被杀死。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">alarm</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seconds)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：定义一个闹钟， 注意它没有阻塞功能<br>参数：<code>seconds</code> 秒数<br>返回值：如果之前没有定义闹钟，成功返回0 ，出错返回-1。如果 <code>alarm</code> 之前定义过闹钟，成功返回上一次闹钟距离这一次闹钟所剩下的时间，出错返回-1。</p>\n<p>使用 <code>pause()</code> 函数可以使当前进程挂起直到捕捉到相应的信号。</p>\n</li>\n<li><p>信号的设置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*<span class=\"keyword\">sighandler_t</span>)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;   /</div><div class=\"line\"><span class=\"keyword\">sighandler_t</span> signal(<span class=\"keyword\">int</span> signum, <span class=\"keyword\">sighandler_t</span> handler);</div></pre></td></tr></table></figure>\n<p>功能：注册一个信号<br>参数：<code>signum</code> 信号, <code>handler</code> 函数指针变量<br>返回值：函数指针</p>\n<blockquote>\n<p>子进程会继承父进程对信号的设置。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sigaction</span><span class=\"params\">(<span class=\"keyword\">int</span> signum, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sigaction *act, <span class=\"keyword\">struct</span> sigaction *oldact)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数： <code>signum</code> 信号类型， <code>act</code> 对特定信号的处理，<code>oldact</code> 保留信号原来的处理方式。<br><code>struct sigaction</code> 结构体定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> sigaction &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*sa_handler)(<span class=\"keyword\">int</span> signo); <span class=\"comment\">//信号处理函数</span></div><div class=\"line\">    <span class=\"keyword\">sigset_t</span> sa_mask;              <span class=\"comment\">//信号集合，那些信号被屏蔽</span></div><div class=\"line\">    <span class=\"keyword\">int</span> sa_flags;                  <span class=\"comment\">//标志位 SA_NODEFER/SA_NOMASK(执行处理函数时，不屏蔽当前信号) </span></div><div class=\"line\">                                   <span class=\"comment\">//       SA_NOCLDSTOP（忽略子进程的信号） </span></div><div class=\"line\">                                   <span class=\"comment\">//       SA_RESTART （重新执行被信号中断的系统调用）</span></div><div class=\"line\">                                   <span class=\"comment\">//       SA_ONESHOT/SA_RESETHAND（自定义信号处理函数只生效一次）</span></div><div class=\"line\">    <span class=\"keyword\">void</span> (*sa_restore)(<span class=\"keyword\">void</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回值：成功返回0，失败返回-1.</p>\n</li>\n</ol>\n<h2 id=\"三、IPC对象\"><a href=\"#三、IPC对象\" class=\"headerlink\" title=\"三、IPC对象\"></a>三、IPC对象</h2><p>接下来讲的三种通信方式都是基于 SystemV IPC 对象的，每个内核中的 IPC结构（共享内存，消息队列，信号灯集）都用一个非负整数的标识符加以引用。标识符是 IPC 对象的内部名，每个 IPC 对象都与一个键 <code>key</code> 相关联，<code>key</code> 值相当于是 IPC 对象通信的外部名字。使用下面的函数生成一个 <code>key</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">key_t</span> ftok(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> proj_id);</div></pre></td></tr></table></figure>\n<p>功能：产生一个独一无二的key值<br>参数：<code>pathname</code> 已经存在的可访问文件的名字，<code>proj_id</code>一个字符（只用低8位）<br>返回值：成功返回相应的 <code>key</code>，出错返回-1。</p>\n<h2 id=\"四、信号灯集\"><a href=\"#四、信号灯集\" class=\"headerlink\" title=\"四、信号灯集\"></a>四、信号灯集</h2><p>信号灯(semaphore)，也叫信号量。它是不同进程间或一个给定进程内部不同线程间同步的机制。</p>\n<ol>\n<li><p>PV 原子操作<br>P 操作，如果有可用资源，则占用一个资源，如果没有可用资源，则阻塞<br>V 操作，如果该信号量的等待队列中有任务在等待资源，则唤醒一个阻塞任务，如果没有，则释放一个资源。</p>\n</li>\n<li><p>信号量的使用步骤</p>\n<ol>\n<li><p>创建或者打开信号灯         </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> nsems, <span class=\"keyword\">int</span> semflg)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>key</code> 键值；<code>nsems</code> 信号灯的数目；<code>semflg</code> 同 <code>open()</code> 函数的权限位。<br>返回值：成功返回相应的 <code>shmid</code>，出错返回-1。</p>\n</li>\n<li><p>资源申请，释放资源</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semop</span><span class=\"params\">(<span class=\"keyword\">int</span> semid, <span class=\"keyword\">struct</span> sembuf *sops, <span class=\"keyword\">unsigned</span> nsops)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>semid</code> 信号灯集ID；<code>sops</code> 指向信号量操作数组，<code>nops</code>  要操作的信号灯的个数<br><code>struct sembuf</code> 结构体定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> sembuf &#123;         </div><div class=\"line\"><span class=\"keyword\">short</span>  sem_num;  <span class=\"comment\">//  要操作的信号灯的编号         </span></div><div class=\"line\"><span class=\"keyword\">short</span>  sem_op;   <span class=\"comment\">//    0 :  等待，直到信号灯的值变成0                               </span></div><div class=\"line\">                 <span class=\"comment\">//    1 :  释放资源，V操作                               </span></div><div class=\"line\">                 <span class=\"comment\">//   -1 :  分配资源，P操作                              </span></div><div class=\"line\"><span class=\"keyword\">short</span>  sem_flg;  <span class=\"comment\">// 0,  IPC_NOWAIT,  SEM_UNDO        </span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>返回：成功 0， 失败 -1</p>\n</li>\n<li><p>信号灯的控制操作   </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semctl</span> <span class=\"params\">( <span class=\"keyword\">int</span> semid, <span class=\"keyword\">int</span> semnum,  <span class=\"keyword\">int</span> cmd，…<span class=\"comment\">/*union semun arg*/</span>)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：信号灯的操作<br>参数：<code>semid</code> 信号灯集id号；<code>semnum</code> 要对第几个信号灯进行操作，信号灯的编号（从0 开始；<code>cmd</code> 为 <code>IPC_STAT</code> 表示获取信号量 <code>IPC_SETVAL</code> 表示设置为 <code>arg</code> 的值 <code>IPC_GETVAL</code> 表示返回当前值 <code>IPC_RMID</code> 表示删除信号量；<code>arg</code> 信号量结构体，定义如下：          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">union</span> semun &#123;               </div><div class=\"line\">  <span class=\"keyword\">int</span>              val;    <span class=\"comment\">/* Value for SETVAL */</span>               </div><div class=\"line\">  <span class=\"keyword\">struct</span> semid_ds *buf;    <span class=\"comment\">/* Buffer for IPC_STAT, IPC_SET */</span>               </div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>  *<span class=\"built_in\">array</span>;  <span class=\"comment\">/* Array for GETALL, SETALL */</span>               </div><div class=\"line\">  <span class=\"keyword\">struct</span> seminfo  *__buf;  <span class=\"comment\">/* Buffer for IPC_INFO                                           </div><div class=\"line\">  (Linux-specific) */</span>           </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>返回值：成功 0， 出错 -1</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"五、消息队列\"><a href=\"#五、消息队列\" class=\"headerlink\" title=\"五、消息队列\"></a>五、消息队列</h2><p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。</p>\n<ol>\n<li><p>创建或打开消息队列          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数： <code>key</code> 键值；<code>msgflg</code> 打开的方式。<br>返回值：成功 msgid，出错 -1</p>\n</li>\n<li><p>添加消息</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msgp, <span class=\"keyword\">size_t</span> msgsz, <span class=\"keyword\">int</span> msgflg)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>msgid</code> 消息队列的id号；<code>msgp</code> 发送的消息的结构体地址；<code>msgsz</code> 消息正文的大小；<code>msgflg</code>  0 阻塞，如果队列中的消息满了，它会阻塞等待，<code>IPC_NOWAIT</code> 如果添加消息不成功，立即返回。<br>返回值：成功 0， 出错 -1<br>用户自定义消息结构体:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> msgbuf &#123;               </div><div class=\"line\">  <span class=\"keyword\">long</span> mtype;       <span class=\"comment\">/* message type, must be &gt; 0 */</span>               </div><div class=\"line\">  <span class=\"keyword\">char</span> mtext[<span class=\"number\">1</span>];    <span class=\"comment\">/* message data */</span>           </div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>读取消息          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">ssize_t</span> msgrcv(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">void</span> *msgp, <span class=\"keyword\">size_t</span> msgsz, <span class=\"keyword\">long</span> msgtyp, <span class=\"keyword\">int</span> msgflg);</div></pre></td></tr></table></figure>\n<p>功能：从消息队列中，取出消息<br>参数：<code>msgid</code> 消息id号；<code>msgp</code> 接收消息结构体；<code>msgsz</code> 消息正文的大小；<code>msgtyp</code> 消息的类型，0 表示从第一个开始读取，按队列的规则，&gt; 0 表示按照指定的type类型进行读取，&lt;0 　表示和他的绝对值相等的类型进行读取；<code>msgflg</code> 0 阻塞， <code>IPC_NOWAIT</code> 不阻塞。<br>返回值：成功 表示读取消息正文的字节数，出错 -1</p>\n</li>\n<li><p>控制消息队列          </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">struct</span> msqid_ds *buf)</span></span>;</div></pre></td></tr></table></figure>\n<p>参数：<code>msgid</code>  消息队列的id号                <code>cmd</code>    <code>IPC_STAT</code>  获取                       <code>IPC_SET</code>  设置                       <code>IPC_RMID</code>  删除                buf    属性信息          返回值：成功 0，出错 -1</p>\n</li>\n<li><p>对消息队列的手动处理<br><code>ipcs  -q</code>   查看系统中共享内存的使用情况信息<br><code>ipcrm  -q  msgid</code>   手动删除共享内存<br><code>ipcrm  -Q  key</code>     手动删除共享内存</p>\n</li>\n</ol>\n<h2 id=\"六、共享内存通信\"><a href=\"#六、共享内存通信\" class=\"headerlink\" title=\"六、共享内存通信\"></a>六、共享内存通信</h2><p>共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等。 </p>\n<ol>\n<li>生成 IPC 对象: <code>ftok()</code></li>\n<li><p>创建或者打开共享内存</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">int</span> shmflg)</span></span>;</div></pre></td></tr></table></figure>\n<p> 参数：<code>key</code> 键值，<code>size</code> 共享内存的大小，<code>shmflg</code> 同 <code>open()</code> 函数的权限位。<br> 返回值：成功返回相应的 <code>shmid</code>，出错返回-1。</p>\n</li>\n<li><p>映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr, <span class=\"keyword\">int</span> shmflg)</span></span>;````         </div><div class=\"line\">    参数：`shmid` 共享内存的 id 号；`shmaddr` 一般为<span class=\"literal\">NULL</span>，表示映射到进程的地址，由操作系统自由选择；`shmflg` 为 `SHM_RDONLY` 表示内存只读，默认为<span class=\"number\">0</span> 可读写。</div><div class=\"line\">    返回值：成功返回映射后的地址， 出错返回<span class=\"number\">-1</span>。</div><div class=\"line\"><span class=\"number\">4.</span> 撤销共享内存映射         </div><div class=\"line\">    ````<span class=\"function\">C</div><div class=\"line\">    <span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除共享内存         </p>\n<pre><code class=\"C\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">struct</span> shmid_ds *buf)</span></span>;\n</code></pre>\n<p> 功能：对共享内存进行各种操作<br> 参数：<code>shmid</code> 共享内存的id号；<code>cmd</code> 为 <code>IPC_STAT</code> 表示要获取 <code>shmid</code> 属性信息，为 <code>IPC_SET</code> 表示设置 <code>shmid</code> 属性信息，为 <code>IPC_RMID</code> 表示删除共享内存;<code>buf</code> 属性信息结构体。<br> 返回值：成功返回0，出错返回-1。</p>\n</li>\n<li><p>对共享内存的手动处理<br><code>ipcs  -m</code>   查看系统中共享内存的使用情况信息<br><code>ipcrm  -m  shmid</code>   手动删除共享内存<br><code>ipcrm  -M  key</code>     手动删除共享内存</p>\n</li>\n</ol>\n<h2 id=\"七、六种通信方式的对比\"><a href=\"#七、六种通信方式的对比\" class=\"headerlink\" title=\"七、六种通信方式的对比\"></a>七、六种通信方式的对比</h2><table>\n<thead>\n<tr>\n<th>通信类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pipe:</td>\n<td>具有亲缘关系的进程间，单工，数据在内存中</td>\n</tr>\n<tr>\n<td>fifo:</td>\n<td>可用于任意进程间，双工，有文件名，数据在内存</td>\n</tr>\n<tr>\n<td>signal:</td>\n<td>唯一的异步通信方式</td>\n</tr>\n<tr>\n<td>msg:</td>\n<td>常用于cs模式中， 按消息类型访问 ，可有优先级</td>\n</tr>\n<tr>\n<td>shm:</td>\n<td>效率最高(直接访问内存) ，需要同步、互斥机制</td>\n</tr>\n<tr>\n<td>sem:</td>\n<td>配合共享内存使用，用以实现同步和互斥</td>\n</tr>\n</tbody>\n</table>"},{"title":"Linux学习总结（九）——网络编程","date":"2016-12-18T03:52:36.000Z","_content":"\n网络编程离不开的基础是网络体系结构，通常说的是 OSI协议参考模型，它是一个七层网络协议模型。而我们通常使用的 Internet 是基于 TCP/IP 协议的，TCP/IP 协议是 OSI 协议的一个4层简化模型。\n<!--more-->\n他们之间的对应关系如下图：\n![网络协议模型](http://ogf054qp1.bkt.clouddn.com/OSI.png)\n\n自下而上，简单介绍下相应各层在整体架构中的作用:\n 1. **网络接口层**：\n    `Network Interface Layer` 是 TCP/IP 的最底层，负责将二进制转换为数据帧，并进行数据帧的发送和接收。\n 2. **网络层**：\n    `Internet Layer` 负责在主机之间的通信中选择数据包的传输路径。网络互连层定义了分组格式和协议，即 IP协议（Internet Protocol）。\n 3. **传输层**：\n    在 TCP/IP 模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。\n    即：传输控制协议 **TCP**（`transmission control protocol`）和用户数据报协议 **UDP**（`user datagram Protocol`）。\n 4. **应用层**：\n    TCP/IP 模型将 OSI 参考模型中的会话层和表示层的功能合并到应用层实现。应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于 TCP 协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于 UDP 协议的。\n\n我们在这里主要讨论的是第三层传输层的具体内容，即 TCP 和 UDP。\n\n## 一、网络编程基础知识\n### 1. 套接字\n套接字（Socket）是一种特殊的 I/O 接口，也是一种文件描述符。可以用于本地和网络通信，对于网络通信而言，每一个 Socket 都可以用网路地址结构（协议，本地地址，本地端口）来表示。Socket 通过一个特殊的函数创建，并返回一个整形的 Socket 描述符。\n > 套接字分为三种：\n * 流式套接字（SOCK_STREAM）：TCP 通信使用的就是流式套接字。\n * 数据包套接字（SOCK_DGRAM)：UDP 通信使用的就是数据包套接字。\n * 原始套接字（SOCKRAW）：原始套接字允许对底层协议进行直接的访问，主要用于协议的开发。\n\n套接字有几个相关函数：\n\n* 套接字的创建：\n  ````C\n  #include <sys/socket.h>\n  int socket(int family, int type, int protocol);````\n  功能：创建一个套接字。\n  参数：`family` 指定相应的协议族，`type` 指定套接字类型，`protocol` 为0,(原始套接字除外)。\n  返回值：成功返回非负的描述符，失败返回-1。\n\n* 获取套接字选项：\n  ````C\n  #include <sys/types.h>\n  #include <sys/socket.h>\n  int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);````\n  功能：获取套接字选项\n  参数：`sockfd` 套接字描述符；`level` 选项所属协议层；`optname` 选项名称；`optval` 保存选项的缓存区；`optlen` 选项值长度。\n  返回值：成功返回0，失败返回-1，并设置 errno。\n\n* 设置套接字选项：\n  ````C\n  #include <sys/types.h>\n  #include <sys/socket.h>\n  int setsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);````\n  功能：设置套接字选项\n  参数：`sockfd` 套接字描述符；`level` 选项所属协议层；`optname` 选项名称；`optval` 保存选项的缓存区；`optlen` 选项值长度。\n  返回值：成功返回0，失败返回-1，并设置 errno。\n\n相应的套接字选项及说明如下：\n\n|选项名称|说明|数据类型|\n|---|-------|-------|\n|**LEVEL**|**SOL_SOCKET**||\n|SO_BROADCAST|允许发送广播数据报|int|\n|SO_DEBUG|使能调试跟踪|int|\n|SO_DONTROUTE|旁路路由表查询|int|\n|SO_ERROR| \t获取待处理错误并消除\t| \tint|\n|SO_KEEPALIVE|周期性测试连接是否存活|int|\n|SO_LINGER|若有数据待发送则延迟关闭\t| \tlinger{}|\n|SO_OOBINLINE|让接收到的带外数据继续在线存放|int|\n|SO_RCVBUF|接收缓冲区大小\t |\tint|\n|SO_SNDBUF|发送缓冲区大小\t |\tint|\n|SO_RCVTIMEO|接收超时\t |\ttimeval{}|\n|SO_SNDTIMEO|发送超时\t |\ttimeval{}|\n|SO_REUSEADDR|允许重用本地地址|int|\n|SO_REUSEPORT|允许重用本地地址|int|\n|SO_TYPE| \t取得套接口类型\t \t|int|\n|**LEVEL**|**IPPROTO_IP**||\t\n|IP_HDRINCL|IP头部包括数据|int|\n|IP_OPTIONS|IP头部选项\t| \t见后面说明|\n|IP_TOS|服务类型和优先权|\t \tint|\n|IP_TTL|存活时间\t| \tint|\n|IP_ADD_MEMBERSHIP\t |加入多播组\t |\tip_mreq{}|\n|IP_DROP_MEMBERSHIP\t |离开多播组\t| \tip_mreq{}|\n|**LEVEL**|**IPPROTO_TCP**||\t\n|TCP_KEEPALIVE|控测对方是否存活前连接闲置秒数|\t \tint|\n|TCP_MAXRT|TCP最大重传时间\t| \tint|\n|TCP_MAXSEG|TCP最大分节大小| \tint|\n|TCP_NODELAY|禁止Nagle算法|int|\n\n\n### 2. IP/端口和网络字节序\n\nIP 地址用来标识网络中的一台主机，端口用来标识主机内部的某个套接字。下面介绍几个相关的函数：\n\n1. 地址格式转换函数：\n   ````C\n   #include <arpa/inet.h>\n   int inet_addr(const char *strptr);                            \n   int inet_pton(int family, const char *src, void *dst);\n   char* inet_ntop(int family, void *src, char *dst, size_t len);````\n\n   函数 `inet_addr()`/ `inet_pton` 用来要转换的字符串转换为 32 二进制IP地址（网络字节序）。函数 `inet_ntop` 是相应的反向操作。\n   `family` 指的是地址族，用来区分 IPv4（AF_INET）和 IPv6（AF_INET6）。\n   `inet_addr()` 成功返回相应的地址，失败返回-1；`inet_pton` 成功返回0，失败返回-1； `inet_ntop` 成功返回 dst，失败返回NULL。\n\n2. 地址结构\n   地址信息有两个相关的结构体：\n   ````C\n   struct sockaddr {\n     unsigned short sa_family; //地址族\n     char sa_data[14];         //14字节的协议地址\n   }\n\n   struct sockaddr_in {\n     shor int sin_family;         //地址族\n     unsigned short int sin_port; //端口号\n     struct in_addr sin_addr;     //IP地址\n     unsigned char sin_zero[8];   //填充0\n   }````\n\n   这两个数据类型大小相同，通常用 `sockaddr_in` 来保存某个网络地址，使用是强转成 `sockaddr`。`sa_family` 常见值有：\n   * `AF_INET`  IPv4 协议\n   * `AF_INET6` IPv6 协议\n   * `AF_LOCAL` UNIX域协议\n   * `AF_LINK` 链路地址协议\n   * `AF_KEY` 密钥套接字\n\n3. 网络字节序\n   计算机的多字节整形存储方式有两种：大端（高位字节存储在地位地址）小端（高位字节存储在高位地址）。为了保证网络通信的一致性，数据以大端方式传输，所以需要相应的转换函数：\n   ````C\n   #include <netinet/in.h>\n   uint16_t htons(uint16_t hostshort);\n   uint32_t htonl(uint32_t hostlong);\n   uint16_t ntohs(uint16_t netshort);\n   uint32_t ntohl(uint32_t netlong);````\n\n\n## 二、TCP 网络编程\nTCP 向应用层提供可靠的面向链接的全双工数据流传输服务。它能提供高可靠性通信（数据无误，数据无丢失，数据无失序，数据无重复到达）。\n\n### 1. 3次握手协议和两次挥手\nTCP 的面向连接指的是：当计算机双方通信的时候必须先建立连接，然后进行数据通信，最后关闭连接。TCP 在建立连接时有三个步骤：\n* **第一步** ： （客户端 -> 服务端）客户端向服务端发送一个包含 SYN 标志的 TCP 报文，并进入 SYN_SEND 状态，等待确认。\n* **第二步** ： （服务端 -> 客户端）服务端在收到客户端的 SYN 报文之后，返回一个 SYN+ACK 的报文，表示服务端收到客户端的 SYN，服务端进入 SYN_RECV 状态。\n* **第三步** ： （客户端 -> 服务端）客户端在收到服务端的 SYN+ACK 报文之后，向确认端发送确认 ACK 报文，客户端和服务端都进入 ESTABLISHED 状态。\n\n在发送方发送一个数据包之后，会启动一个定时器，当数据包到达目的地之后，接收方会返回一个数据包，其中含有一个确认序号，如果发送方的定时器在确认信息到达之前超时，发送方会重发数据。\n\n由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n* **第一步** 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 \n* **第二步** 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 \n* **第三步** 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 \n* **第四步** 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。  \n\n### 2. TCP 的数据包头\n![TCP 包头](http://ogf054qp1.bkt.clouddn.com/TCP%E5%8C%85%E5%A4%B4.png)\n1. **源端口/目的端口**：16bit，标识本地和远端的端口号。\n2. **顺序号**：32bit，标识发送的数据包的顺序。\n3. **确认号**：32bit，希望收到的下一包数据的序列号。\n4. **TCP头长**：4bit，表明 TCP 头中包含多少个32bit。\n5. **6bit 未用**。\n6. **URG**：表示紧急指针字段有效。\n7. **ACK**：置位表示确认号字段有效；\n8. **PSH**：表示当前报文需要请求推（push）操作；\n9. **RST**：置位表示复位TCP连接；\n10. **SYN**：用于建立TCP连接时同步序号；\n11. **FIN**：用于释放TCP连接时标识发送方比特流结束。 \n12. **窗口**：16位，表示源主机在请求接收端等待确认之前需要接收的字节数。它用于流量控制。\n13. **校验位**：16位。用于检查TCP数据包头和数据的一致性。\n14. **紧急指针**：16位。当URG码有效时只向紧急数据字节。\n15. **可选项**：存在时表示TCP包头后还有另外的4字节数据。包括最大 TCP 载荷/窗口比例/选择重发数据包等选项。\n\n\n### 3. 服务器端 TCP 网络编程：\nTCP编程模型可分为服务器端和客户端两种，一个完整的服务器端 TCP 编程模型有6步：\n\n1. 创建一个套接字 `socket()`\n2. 连接到指定的地址和端口\n    ````C\n    #include <sys/socket.h>\n    int bind(int sockfd, const struct sockaddr *myaddr, socket_t addrlen);````\n    功能：将一个本地协议赋予一个套接字。\n    参数：`sockfd` 套接字描述符，`myaddr` 指定的地址结构的指针，`addrlen` 该地址结构长度。\n    返回值：成功返回0，失败返回-1；\n\n3. 设置为监听模式\n    ````C\n    #include <sys/socket.h>\n    int listen(int sockfd, int backlog);````\n    功能：将一个未连接的套接字转换为一个被动套接字\n    参数：`sockfd` 套接字描述符，`backlog` 相应的套接字排队的最大连接个数。\n    返回值：成功返回0，失败返回-1；\n\n4. 等待接收客户端的连接请求\n    ````C\n    #include <sys/socket.h>\n    int accept(int sockfd, const struct sockaddr *cliaddr, socket_t addrlen);````\n    功能：从已完成的链接队列队头返回下一个已完成连接，如果队列为空，进程进入睡眠（默认为阻塞模式）。\n    参数：`sockfd` 套接字描述符，`cliaddr`/`addrlen` 用来存储对端的地址结构和长度\n    返回值：成功返回非负的描述符，失败返回-1；\n\n5. 发送和接收数据：`send()`/`recv()`\n    ````C\n    #include <sys/socket.h>\n    int recvform(int sockfd, void *buff, size_t nbytes, int flags);\n    int sendto(int sockfd, void *buff, size_t nbytes, int flags);````\n    功能：类似标准的 `read()` 和 `write()` 函数。\n    参数：前三个函数同 `read()`/`write()`， `flags` 一般是0。\n    返回值：成功返回读或写的字节数，失败返回-1。\n\n6. 关闭套接字 `close()`\n\n### 4. 客户端的 TCP 编程模型\n1. 创建一个套接字：`socket()`\n2. 建立连接\n    ````C\n    #include <sys/socket.h>\n    int connect(int sockfd, const struct sockaddr *servaddr, socket_t addrlen);````\n    功能：建立与 TCP 服务器的连接\n    参数：`sockfd` 套接字描述符，`servaddr`/`addrlen` 用来存储服务器端的地址结构和长度\n    返回值：成功返回0，失败返回-1；\n5. 发送和接收数据:`send()`/`recv()`\n6. 关闭套接字 `close()`\n  \n## 三、UDP编程模型\n\nUDP 即用户数据报协议，是一种面向无连接的不可靠的传输协议，具有消耗资源少，处理速度快的特点。\nUDP 的数据包头比较简单，包含源和目的的地址（各16bit）8位空位，8位协议位，16位 UDP 长度。\nUDP 网络编程和 TCP 网络编程的区别在于：UDP 是不可靠的数据报协议，客户端不与服务器建立连接，直接使用 `sendto()` 函数向服务器发送数据，而服务器同样不用接收连接，使用 `recvform` 返回相应的数据。\n### 1. UDP 网络编程模型\n* UDP 服务器端编程模型\n  1. 创建一个套接字：同 TCP。\n  2. 连接到指定的地址和端口 `bind()`\n  5. 发送和接收数据 用 `sendto()`/`recvform()`\n      ````C\n     #include <sys/socket.h>\n     int recvform(int sockfd, void *buff, size_t nbytes, int flags,\n                  struct sockaddr *from, socklen_t *addrlen);\n     int sendto(int sockfd, void *buff, size_t nbytes, int flags,\n                  struct sockaddr *to, socklen_t *addrlen);````\n     功能：类似标准的 `read()` 和 `write()` 函数。\n     参数：前三个函数同 `read()`/`write()`， `flags` 一般是0， `from`/`to` 分别是对端的地址结构指针， `addrlen` 是对端的地址结构长度。\n     返回值：成功返回读或写的字节数，失败返回-1。\n\n  6. 关闭套接字 `close()`\n\n* UDP 客户端编程模型\n  1. 创建一个套接字：同 TCP。\n  5. 发送和接收数据 用 `sendto()`/`recvform()`\n  6. 关闭套接字 `close()`\n\n### 2. 组播与广播编程\n之前我们处理的都是单播程序：一个进程就与另一个进程通信。TCP 只支持单播寻址，而 UDP 还支持其他的寻址类型。\n\n   * 单播（unicast）：向标识的单独接口递送数据，TCP 仅支持此种\n   * 任播（anycast）：向标识的一组接口中的一个递送数据\n   * 组播（multicast）：向标识的一组中的所有接口递送数据\n   * 广播（broadcast）：向全体递送数据\n\n广播和组播都需要使用UDP，都不能使用TCP。IPv4地址可以使用｛子网id，主机id｝来表示，-1表示所有位都为1的字段，广播可以分为几种： \n\n  * 子网定向广播地址，｛子网id，-1｝，指定子网上所有接口的广播地址\n    > 192.168.1.0/24 该子网上的广播地址192.168.1.255 \n\n  * 受限广播地址｛-1，-1｝即 `255.255.255.255`。\n\n1. 广播的流程\n  发送广播的流程是：\n    * 创建 UDP 套接字\n    * 指定目标地址和端口\n    * 设置套接字选项允许发送广播包\n      ````C\n      setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on));````\n    * 发送广播包\n  \n  接收广播包的流程是：\n    * 创建 UDP 套接字\n    * 绑定目标地址和端口\n    * 接收广播包\n\n2. 广播的缺点\n  * 当使用单播时：\n  发送端UDP 套接字承载了目的 IP，比如 192.168.32.3，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成 相应的以太网地址，并标识相应的帧类型为 IPv4（0x0800）。\n  该数据在接口层传输，相应的主机接口首先判断该帧的以太网地址是否和本机一致：不一致忽略，一致读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，把数据置于相应的套接字接收队列。\n\n  * 当使用广播时：\n  发送端UDP 套接字承载了目的 IP，比如 192.168.32.255，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成所在以太网的子网的以太网地址，此时这个以太网地址为全1的地址，并标识相应的帧类型为 IPv4（0x0800）。\n  该数据在接口层传输，该子网内所有的主机接口都会判断该帧的以太网地址是和本机一致，读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，如果有相应端口的应用进程，执行相应的接收程序，如果没有相应的进程，则 UDP 丢弃当前数据包。\n\n  所以广播存在的问题是：子网上所有使用 IP 协议的主机都必须沿相应的协议传输到 UDP 层判断自己是否参加了相应的广播。所有不使用 IP 协议的主机也都必须在接口层接收所用的数据，并在网络层读取判断。\n\n2. 组播地址\n  IPv4 地址可以分为五类：\n    * A 类：最高位0，主机号占 24 位，地址范围为：1.0.0.1 到 126.255.255.254\n    * B 类：最高两位10，主机号占 16 位，地址范围为：128.0.0.1 到 191.255.255.254\n    * C 类：最高三位110，主机号占 8 位，地址范围为：192.0.1.1 到 223.255.255.254\n    * D 类：最高四位1110，地址范围为：224.0.0.1 到 239.255.255.254\n    * E 类：保留\n    其中，D类地址为组播地址，每一个组播地址代表一个多播组。\n\n3. 组播的流程\n  发送组播的流程是：\n    * 创建 UDP 套接字\n    * 指定目标地址和端口\n    * 发送组播包\n\n  接收组播的流程是：\n    * 创建 UDP 套接字\n    * 加入多播组\n      ````C\n      setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));````\n    * 绑定地址和端口\n    * 发送组播包\n\n## 四、本地套接字\n套接字的引用本来就只支持本地通信，目前很多前台后台进程依旧使用 UNIX 域套接字进行通信，本地套接字的特点是使用简单，效率高。本地套接字也分为流式套接字和用户数据报两种类型。具体的编程方法和相应 TCP / UDP 套接字基本一致，区别仅是使用的协议和地址不同，这里就不再详细描述。\n\n","source":"_posts/Linux学习总结09.md","raw":"---\ntitle: Linux学习总结（九）——网络编程\ndate: 2016-12-18 11:52:36\ncategories: Linux学习记录\ntags: [网络, TCP, UDP, 组播, 广播]\n---\n\n网络编程离不开的基础是网络体系结构，通常说的是 OSI协议参考模型，它是一个七层网络协议模型。而我们通常使用的 Internet 是基于 TCP/IP 协议的，TCP/IP 协议是 OSI 协议的一个4层简化模型。\n<!--more-->\n他们之间的对应关系如下图：\n![网络协议模型](http://ogf054qp1.bkt.clouddn.com/OSI.png)\n\n自下而上，简单介绍下相应各层在整体架构中的作用:\n 1. **网络接口层**：\n    `Network Interface Layer` 是 TCP/IP 的最底层，负责将二进制转换为数据帧，并进行数据帧的发送和接收。\n 2. **网络层**：\n    `Internet Layer` 负责在主机之间的通信中选择数据包的传输路径。网络互连层定义了分组格式和协议，即 IP协议（Internet Protocol）。\n 3. **传输层**：\n    在 TCP/IP 模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。\n    即：传输控制协议 **TCP**（`transmission control protocol`）和用户数据报协议 **UDP**（`user datagram Protocol`）。\n 4. **应用层**：\n    TCP/IP 模型将 OSI 参考模型中的会话层和表示层的功能合并到应用层实现。应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于 TCP 协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于 UDP 协议的。\n\n我们在这里主要讨论的是第三层传输层的具体内容，即 TCP 和 UDP。\n\n## 一、网络编程基础知识\n### 1. 套接字\n套接字（Socket）是一种特殊的 I/O 接口，也是一种文件描述符。可以用于本地和网络通信，对于网络通信而言，每一个 Socket 都可以用网路地址结构（协议，本地地址，本地端口）来表示。Socket 通过一个特殊的函数创建，并返回一个整形的 Socket 描述符。\n > 套接字分为三种：\n * 流式套接字（SOCK_STREAM）：TCP 通信使用的就是流式套接字。\n * 数据包套接字（SOCK_DGRAM)：UDP 通信使用的就是数据包套接字。\n * 原始套接字（SOCKRAW）：原始套接字允许对底层协议进行直接的访问，主要用于协议的开发。\n\n套接字有几个相关函数：\n\n* 套接字的创建：\n  ````C\n  #include <sys/socket.h>\n  int socket(int family, int type, int protocol);````\n  功能：创建一个套接字。\n  参数：`family` 指定相应的协议族，`type` 指定套接字类型，`protocol` 为0,(原始套接字除外)。\n  返回值：成功返回非负的描述符，失败返回-1。\n\n* 获取套接字选项：\n  ````C\n  #include <sys/types.h>\n  #include <sys/socket.h>\n  int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);````\n  功能：获取套接字选项\n  参数：`sockfd` 套接字描述符；`level` 选项所属协议层；`optname` 选项名称；`optval` 保存选项的缓存区；`optlen` 选项值长度。\n  返回值：成功返回0，失败返回-1，并设置 errno。\n\n* 设置套接字选项：\n  ````C\n  #include <sys/types.h>\n  #include <sys/socket.h>\n  int setsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);````\n  功能：设置套接字选项\n  参数：`sockfd` 套接字描述符；`level` 选项所属协议层；`optname` 选项名称；`optval` 保存选项的缓存区；`optlen` 选项值长度。\n  返回值：成功返回0，失败返回-1，并设置 errno。\n\n相应的套接字选项及说明如下：\n\n|选项名称|说明|数据类型|\n|---|-------|-------|\n|**LEVEL**|**SOL_SOCKET**||\n|SO_BROADCAST|允许发送广播数据报|int|\n|SO_DEBUG|使能调试跟踪|int|\n|SO_DONTROUTE|旁路路由表查询|int|\n|SO_ERROR| \t获取待处理错误并消除\t| \tint|\n|SO_KEEPALIVE|周期性测试连接是否存活|int|\n|SO_LINGER|若有数据待发送则延迟关闭\t| \tlinger{}|\n|SO_OOBINLINE|让接收到的带外数据继续在线存放|int|\n|SO_RCVBUF|接收缓冲区大小\t |\tint|\n|SO_SNDBUF|发送缓冲区大小\t |\tint|\n|SO_RCVTIMEO|接收超时\t |\ttimeval{}|\n|SO_SNDTIMEO|发送超时\t |\ttimeval{}|\n|SO_REUSEADDR|允许重用本地地址|int|\n|SO_REUSEPORT|允许重用本地地址|int|\n|SO_TYPE| \t取得套接口类型\t \t|int|\n|**LEVEL**|**IPPROTO_IP**||\t\n|IP_HDRINCL|IP头部包括数据|int|\n|IP_OPTIONS|IP头部选项\t| \t见后面说明|\n|IP_TOS|服务类型和优先权|\t \tint|\n|IP_TTL|存活时间\t| \tint|\n|IP_ADD_MEMBERSHIP\t |加入多播组\t |\tip_mreq{}|\n|IP_DROP_MEMBERSHIP\t |离开多播组\t| \tip_mreq{}|\n|**LEVEL**|**IPPROTO_TCP**||\t\n|TCP_KEEPALIVE|控测对方是否存活前连接闲置秒数|\t \tint|\n|TCP_MAXRT|TCP最大重传时间\t| \tint|\n|TCP_MAXSEG|TCP最大分节大小| \tint|\n|TCP_NODELAY|禁止Nagle算法|int|\n\n\n### 2. IP/端口和网络字节序\n\nIP 地址用来标识网络中的一台主机，端口用来标识主机内部的某个套接字。下面介绍几个相关的函数：\n\n1. 地址格式转换函数：\n   ````C\n   #include <arpa/inet.h>\n   int inet_addr(const char *strptr);                            \n   int inet_pton(int family, const char *src, void *dst);\n   char* inet_ntop(int family, void *src, char *dst, size_t len);````\n\n   函数 `inet_addr()`/ `inet_pton` 用来要转换的字符串转换为 32 二进制IP地址（网络字节序）。函数 `inet_ntop` 是相应的反向操作。\n   `family` 指的是地址族，用来区分 IPv4（AF_INET）和 IPv6（AF_INET6）。\n   `inet_addr()` 成功返回相应的地址，失败返回-1；`inet_pton` 成功返回0，失败返回-1； `inet_ntop` 成功返回 dst，失败返回NULL。\n\n2. 地址结构\n   地址信息有两个相关的结构体：\n   ````C\n   struct sockaddr {\n     unsigned short sa_family; //地址族\n     char sa_data[14];         //14字节的协议地址\n   }\n\n   struct sockaddr_in {\n     shor int sin_family;         //地址族\n     unsigned short int sin_port; //端口号\n     struct in_addr sin_addr;     //IP地址\n     unsigned char sin_zero[8];   //填充0\n   }````\n\n   这两个数据类型大小相同，通常用 `sockaddr_in` 来保存某个网络地址，使用是强转成 `sockaddr`。`sa_family` 常见值有：\n   * `AF_INET`  IPv4 协议\n   * `AF_INET6` IPv6 协议\n   * `AF_LOCAL` UNIX域协议\n   * `AF_LINK` 链路地址协议\n   * `AF_KEY` 密钥套接字\n\n3. 网络字节序\n   计算机的多字节整形存储方式有两种：大端（高位字节存储在地位地址）小端（高位字节存储在高位地址）。为了保证网络通信的一致性，数据以大端方式传输，所以需要相应的转换函数：\n   ````C\n   #include <netinet/in.h>\n   uint16_t htons(uint16_t hostshort);\n   uint32_t htonl(uint32_t hostlong);\n   uint16_t ntohs(uint16_t netshort);\n   uint32_t ntohl(uint32_t netlong);````\n\n\n## 二、TCP 网络编程\nTCP 向应用层提供可靠的面向链接的全双工数据流传输服务。它能提供高可靠性通信（数据无误，数据无丢失，数据无失序，数据无重复到达）。\n\n### 1. 3次握手协议和两次挥手\nTCP 的面向连接指的是：当计算机双方通信的时候必须先建立连接，然后进行数据通信，最后关闭连接。TCP 在建立连接时有三个步骤：\n* **第一步** ： （客户端 -> 服务端）客户端向服务端发送一个包含 SYN 标志的 TCP 报文，并进入 SYN_SEND 状态，等待确认。\n* **第二步** ： （服务端 -> 客户端）服务端在收到客户端的 SYN 报文之后，返回一个 SYN+ACK 的报文，表示服务端收到客户端的 SYN，服务端进入 SYN_RECV 状态。\n* **第三步** ： （客户端 -> 服务端）客户端在收到服务端的 SYN+ACK 报文之后，向确认端发送确认 ACK 报文，客户端和服务端都进入 ESTABLISHED 状态。\n\n在发送方发送一个数据包之后，会启动一个定时器，当数据包到达目的地之后，接收方会返回一个数据包，其中含有一个确认序号，如果发送方的定时器在确认信息到达之前超时，发送方会重发数据。\n\n由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n* **第一步** 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 \n* **第二步** 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 \n* **第三步** 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 \n* **第四步** 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。  \n\n### 2. TCP 的数据包头\n![TCP 包头](http://ogf054qp1.bkt.clouddn.com/TCP%E5%8C%85%E5%A4%B4.png)\n1. **源端口/目的端口**：16bit，标识本地和远端的端口号。\n2. **顺序号**：32bit，标识发送的数据包的顺序。\n3. **确认号**：32bit，希望收到的下一包数据的序列号。\n4. **TCP头长**：4bit，表明 TCP 头中包含多少个32bit。\n5. **6bit 未用**。\n6. **URG**：表示紧急指针字段有效。\n7. **ACK**：置位表示确认号字段有效；\n8. **PSH**：表示当前报文需要请求推（push）操作；\n9. **RST**：置位表示复位TCP连接；\n10. **SYN**：用于建立TCP连接时同步序号；\n11. **FIN**：用于释放TCP连接时标识发送方比特流结束。 \n12. **窗口**：16位，表示源主机在请求接收端等待确认之前需要接收的字节数。它用于流量控制。\n13. **校验位**：16位。用于检查TCP数据包头和数据的一致性。\n14. **紧急指针**：16位。当URG码有效时只向紧急数据字节。\n15. **可选项**：存在时表示TCP包头后还有另外的4字节数据。包括最大 TCP 载荷/窗口比例/选择重发数据包等选项。\n\n\n### 3. 服务器端 TCP 网络编程：\nTCP编程模型可分为服务器端和客户端两种，一个完整的服务器端 TCP 编程模型有6步：\n\n1. 创建一个套接字 `socket()`\n2. 连接到指定的地址和端口\n    ````C\n    #include <sys/socket.h>\n    int bind(int sockfd, const struct sockaddr *myaddr, socket_t addrlen);````\n    功能：将一个本地协议赋予一个套接字。\n    参数：`sockfd` 套接字描述符，`myaddr` 指定的地址结构的指针，`addrlen` 该地址结构长度。\n    返回值：成功返回0，失败返回-1；\n\n3. 设置为监听模式\n    ````C\n    #include <sys/socket.h>\n    int listen(int sockfd, int backlog);````\n    功能：将一个未连接的套接字转换为一个被动套接字\n    参数：`sockfd` 套接字描述符，`backlog` 相应的套接字排队的最大连接个数。\n    返回值：成功返回0，失败返回-1；\n\n4. 等待接收客户端的连接请求\n    ````C\n    #include <sys/socket.h>\n    int accept(int sockfd, const struct sockaddr *cliaddr, socket_t addrlen);````\n    功能：从已完成的链接队列队头返回下一个已完成连接，如果队列为空，进程进入睡眠（默认为阻塞模式）。\n    参数：`sockfd` 套接字描述符，`cliaddr`/`addrlen` 用来存储对端的地址结构和长度\n    返回值：成功返回非负的描述符，失败返回-1；\n\n5. 发送和接收数据：`send()`/`recv()`\n    ````C\n    #include <sys/socket.h>\n    int recvform(int sockfd, void *buff, size_t nbytes, int flags);\n    int sendto(int sockfd, void *buff, size_t nbytes, int flags);````\n    功能：类似标准的 `read()` 和 `write()` 函数。\n    参数：前三个函数同 `read()`/`write()`， `flags` 一般是0。\n    返回值：成功返回读或写的字节数，失败返回-1。\n\n6. 关闭套接字 `close()`\n\n### 4. 客户端的 TCP 编程模型\n1. 创建一个套接字：`socket()`\n2. 建立连接\n    ````C\n    #include <sys/socket.h>\n    int connect(int sockfd, const struct sockaddr *servaddr, socket_t addrlen);````\n    功能：建立与 TCP 服务器的连接\n    参数：`sockfd` 套接字描述符，`servaddr`/`addrlen` 用来存储服务器端的地址结构和长度\n    返回值：成功返回0，失败返回-1；\n5. 发送和接收数据:`send()`/`recv()`\n6. 关闭套接字 `close()`\n  \n## 三、UDP编程模型\n\nUDP 即用户数据报协议，是一种面向无连接的不可靠的传输协议，具有消耗资源少，处理速度快的特点。\nUDP 的数据包头比较简单，包含源和目的的地址（各16bit）8位空位，8位协议位，16位 UDP 长度。\nUDP 网络编程和 TCP 网络编程的区别在于：UDP 是不可靠的数据报协议，客户端不与服务器建立连接，直接使用 `sendto()` 函数向服务器发送数据，而服务器同样不用接收连接，使用 `recvform` 返回相应的数据。\n### 1. UDP 网络编程模型\n* UDP 服务器端编程模型\n  1. 创建一个套接字：同 TCP。\n  2. 连接到指定的地址和端口 `bind()`\n  5. 发送和接收数据 用 `sendto()`/`recvform()`\n      ````C\n     #include <sys/socket.h>\n     int recvform(int sockfd, void *buff, size_t nbytes, int flags,\n                  struct sockaddr *from, socklen_t *addrlen);\n     int sendto(int sockfd, void *buff, size_t nbytes, int flags,\n                  struct sockaddr *to, socklen_t *addrlen);````\n     功能：类似标准的 `read()` 和 `write()` 函数。\n     参数：前三个函数同 `read()`/`write()`， `flags` 一般是0， `from`/`to` 分别是对端的地址结构指针， `addrlen` 是对端的地址结构长度。\n     返回值：成功返回读或写的字节数，失败返回-1。\n\n  6. 关闭套接字 `close()`\n\n* UDP 客户端编程模型\n  1. 创建一个套接字：同 TCP。\n  5. 发送和接收数据 用 `sendto()`/`recvform()`\n  6. 关闭套接字 `close()`\n\n### 2. 组播与广播编程\n之前我们处理的都是单播程序：一个进程就与另一个进程通信。TCP 只支持单播寻址，而 UDP 还支持其他的寻址类型。\n\n   * 单播（unicast）：向标识的单独接口递送数据，TCP 仅支持此种\n   * 任播（anycast）：向标识的一组接口中的一个递送数据\n   * 组播（multicast）：向标识的一组中的所有接口递送数据\n   * 广播（broadcast）：向全体递送数据\n\n广播和组播都需要使用UDP，都不能使用TCP。IPv4地址可以使用｛子网id，主机id｝来表示，-1表示所有位都为1的字段，广播可以分为几种： \n\n  * 子网定向广播地址，｛子网id，-1｝，指定子网上所有接口的广播地址\n    > 192.168.1.0/24 该子网上的广播地址192.168.1.255 \n\n  * 受限广播地址｛-1，-1｝即 `255.255.255.255`。\n\n1. 广播的流程\n  发送广播的流程是：\n    * 创建 UDP 套接字\n    * 指定目标地址和端口\n    * 设置套接字选项允许发送广播包\n      ````C\n      setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on));````\n    * 发送广播包\n  \n  接收广播包的流程是：\n    * 创建 UDP 套接字\n    * 绑定目标地址和端口\n    * 接收广播包\n\n2. 广播的缺点\n  * 当使用单播时：\n  发送端UDP 套接字承载了目的 IP，比如 192.168.32.3，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成 相应的以太网地址，并标识相应的帧类型为 IPv4（0x0800）。\n  该数据在接口层传输，相应的主机接口首先判断该帧的以太网地址是否和本机一致：不一致忽略，一致读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，把数据置于相应的套接字接收队列。\n\n  * 当使用广播时：\n  发送端UDP 套接字承载了目的 IP，比如 192.168.32.255，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成所在以太网的子网的以太网地址，此时这个以太网地址为全1的地址，并标识相应的帧类型为 IPv4（0x0800）。\n  该数据在接口层传输，该子网内所有的主机接口都会判断该帧的以太网地址是和本机一致，读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，如果有相应端口的应用进程，执行相应的接收程序，如果没有相应的进程，则 UDP 丢弃当前数据包。\n\n  所以广播存在的问题是：子网上所有使用 IP 协议的主机都必须沿相应的协议传输到 UDP 层判断自己是否参加了相应的广播。所有不使用 IP 协议的主机也都必须在接口层接收所用的数据，并在网络层读取判断。\n\n2. 组播地址\n  IPv4 地址可以分为五类：\n    * A 类：最高位0，主机号占 24 位，地址范围为：1.0.0.1 到 126.255.255.254\n    * B 类：最高两位10，主机号占 16 位，地址范围为：128.0.0.1 到 191.255.255.254\n    * C 类：最高三位110，主机号占 8 位，地址范围为：192.0.1.1 到 223.255.255.254\n    * D 类：最高四位1110，地址范围为：224.0.0.1 到 239.255.255.254\n    * E 类：保留\n    其中，D类地址为组播地址，每一个组播地址代表一个多播组。\n\n3. 组播的流程\n  发送组播的流程是：\n    * 创建 UDP 套接字\n    * 指定目标地址和端口\n    * 发送组播包\n\n  接收组播的流程是：\n    * 创建 UDP 套接字\n    * 加入多播组\n      ````C\n      setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));````\n    * 绑定地址和端口\n    * 发送组播包\n\n## 四、本地套接字\n套接字的引用本来就只支持本地通信，目前很多前台后台进程依旧使用 UNIX 域套接字进行通信，本地套接字的特点是使用简单，效率高。本地套接字也分为流式套接字和用户数据报两种类型。具体的编程方法和相应 TCP / UDP 套接字基本一致，区别仅是使用的协议和地址不同，这里就不再详细描述。\n\n","slug":"Linux学习总结09","published":1,"updated":"2017-12-06T13:42:16.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n0s001ebkw1sztk77q8","content":"<p>网络编程离不开的基础是网络体系结构，通常说的是 OSI协议参考模型，它是一个七层网络协议模型。而我们通常使用的 Internet 是基于 TCP/IP 协议的，TCP/IP 协议是 OSI 协议的一个4层简化模型。<br><a id=\"more\"></a><br>他们之间的对应关系如下图：<br><img src=\"http://ogf054qp1.bkt.clouddn.com/OSI.png\" alt=\"网络协议模型\"></p>\n<p>自下而上，简单介绍下相应各层在整体架构中的作用:</p>\n<ol>\n<li><strong>网络接口层</strong>：<br><code>Network Interface Layer</code> 是 TCP/IP 的最底层，负责将二进制转换为数据帧，并进行数据帧的发送和接收。</li>\n<li><strong>网络层</strong>：<br><code>Internet Layer</code> 负责在主机之间的通信中选择数据包的传输路径。网络互连层定义了分组格式和协议，即 IP协议（Internet Protocol）。</li>\n<li><strong>传输层</strong>：<br>在 TCP/IP 模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。<br>即：传输控制协议 <strong>TCP</strong>（<code>transmission control protocol</code>）和用户数据报协议 <strong>UDP</strong>（<code>user datagram Protocol</code>）。</li>\n<li><strong>应用层</strong>：<br>TCP/IP 模型将 OSI 参考模型中的会话层和表示层的功能合并到应用层实现。应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于 TCP 协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于 UDP 协议的。</li>\n</ol>\n<p>我们在这里主要讨论的是第三层传输层的具体内容，即 TCP 和 UDP。</p>\n<h2 id=\"一、网络编程基础知识\"><a href=\"#一、网络编程基础知识\" class=\"headerlink\" title=\"一、网络编程基础知识\"></a>一、网络编程基础知识</h2><h3 id=\"1-套接字\"><a href=\"#1-套接字\" class=\"headerlink\" title=\"1. 套接字\"></a>1. 套接字</h3><p>套接字（Socket）是一种特殊的 I/O 接口，也是一种文件描述符。可以用于本地和网络通信，对于网络通信而言，每一个 Socket 都可以用网路地址结构（协议，本地地址，本地端口）来表示。Socket 通过一个特殊的函数创建，并返回一个整形的 Socket 描述符。</p>\n<blockquote>\n<p>套接字分为三种：</p>\n<ul>\n<li>流式套接字（SOCK_STREAM）：TCP 通信使用的就是流式套接字。</li>\n<li>数据包套接字（SOCK_DGRAM)：UDP 通信使用的就是数据包套接字。</li>\n<li>原始套接字（SOCKRAW）：原始套接字允许对底层协议进行直接的访问，主要用于协议的开发。</li>\n</ul>\n</blockquote>\n<p>套接字有几个相关函数：</p>\n<ul>\n<li><p>套接字的创建：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：创建一个套接字。<br>参数：<code>family</code> 指定相应的协议族，<code>type</code> 指定套接字类型，<code>protocol</code> 为0,(原始套接字除外)。<br>返回值：成功返回非负的描述符，失败返回-1。</p>\n</li>\n<li><p>获取套接字选项：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname, <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> *optlen)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：获取套接字选项<br>参数：<code>sockfd</code> 套接字描述符；<code>level</code> 选项所属协议层；<code>optname</code> 选项名称；<code>optval</code> 保存选项的缓存区；<code>optlen</code> 选项值长度。<br>返回值：成功返回0，失败返回-1，并设置 errno。</p>\n</li>\n<li><p>设置套接字选项：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname, <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> *optlen)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：设置套接字选项<br>参数：<code>sockfd</code> 套接字描述符；<code>level</code> 选项所属协议层；<code>optname</code> 选项名称；<code>optval</code> 保存选项的缓存区；<code>optlen</code> 选项值长度。<br>返回值：成功返回0，失败返回-1，并设置 errno。</p>\n</li>\n</ul>\n<p>相应的套接字选项及说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>选项名称</th>\n<th>说明</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>LEVEL</strong></td>\n<td><strong>SOL_SOCKET</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>SO_BROADCAST</td>\n<td>允许发送广播数据报</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_DEBUG</td>\n<td>使能调试跟踪</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_DONTROUTE</td>\n<td>旁路路由表查询</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_ERROR</td>\n<td>获取待处理错误并消除</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_KEEPALIVE</td>\n<td>周期性测试连接是否存活</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_LINGER</td>\n<td>若有数据待发送则延迟关闭</td>\n<td>linger{}</td>\n</tr>\n<tr>\n<td>SO_OOBINLINE</td>\n<td>让接收到的带外数据继续在线存放</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_RCVBUF</td>\n<td>接收缓冲区大小</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_SNDBUF</td>\n<td>发送缓冲区大小</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_RCVTIMEO</td>\n<td>接收超时</td>\n<td>timeval{}</td>\n</tr>\n<tr>\n<td>SO_SNDTIMEO</td>\n<td>发送超时</td>\n<td>timeval{}</td>\n</tr>\n<tr>\n<td>SO_REUSEADDR</td>\n<td>允许重用本地地址</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_REUSEPORT</td>\n<td>允许重用本地地址</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_TYPE</td>\n<td>取得套接口类型</td>\n<td>int</td>\n</tr>\n<tr>\n<td><strong>LEVEL</strong></td>\n<td><strong>IPPROTO_IP</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>IP_HDRINCL</td>\n<td>IP头部包括数据</td>\n<td>int</td>\n</tr>\n<tr>\n<td>IP_OPTIONS</td>\n<td>IP头部选项</td>\n<td>见后面说明</td>\n</tr>\n<tr>\n<td>IP_TOS</td>\n<td>服务类型和优先权</td>\n<td>int</td>\n</tr>\n<tr>\n<td>IP_TTL</td>\n<td>存活时间</td>\n<td>int</td>\n</tr>\n<tr>\n<td>IP_ADD_MEMBERSHIP</td>\n<td>加入多播组</td>\n<td>ip_mreq{}</td>\n</tr>\n<tr>\n<td>IP_DROP_MEMBERSHIP</td>\n<td>离开多播组</td>\n<td>ip_mreq{}</td>\n</tr>\n<tr>\n<td><strong>LEVEL</strong></td>\n<td><strong>IPPROTO_TCP</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>TCP_KEEPALIVE</td>\n<td>控测对方是否存活前连接闲置秒数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>TCP_MAXRT</td>\n<td>TCP最大重传时间</td>\n<td>int</td>\n</tr>\n<tr>\n<td>TCP_MAXSEG</td>\n<td>TCP最大分节大小</td>\n<td>int</td>\n</tr>\n<tr>\n<td>TCP_NODELAY</td>\n<td>禁止Nagle算法</td>\n<td>int</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-IP-端口和网络字节序\"><a href=\"#2-IP-端口和网络字节序\" class=\"headerlink\" title=\"2. IP/端口和网络字节序\"></a>2. IP/端口和网络字节序</h3><p>IP 地址用来标识网络中的一台主机，端口用来标识主机内部的某个套接字。下面介绍几个相关的函数：</p>\n<ol>\n<li><p>地址格式转换函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_addr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *strptr)</span></span>;                            </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_pton</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src, <span class=\"keyword\">void</span> *dst)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">inet_ntop</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">void</span> *src, <span class=\"keyword\">char</span> *dst, <span class=\"keyword\">size_t</span> len)</span></span>;</div></pre></td></tr></table></figure>\n<p>函数 <code>inet_addr()</code>/ <code>inet_pton</code> 用来要转换的字符串转换为 32 二进制IP地址（网络字节序）。函数 <code>inet_ntop</code> 是相应的反向操作。<br><code>family</code> 指的是地址族，用来区分 IPv4（AF_INET）和 IPv6（AF_INET6）。<br><code>inet_addr()</code> 成功返回相应的地址，失败返回-1；<code>inet_pton</code> 成功返回0，失败返回-1； <code>inet_ntop</code> 成功返回 dst，失败返回NULL。</p>\n</li>\n<li><p>地址结构<br>地址信息有两个相关的结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> sockaddr &#123;</div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> sa_family; <span class=\"comment\">//地址族</span></div><div class=\"line\">  <span class=\"keyword\">char</span> sa_data[<span class=\"number\">14</span>];         <span class=\"comment\">//14字节的协议地址</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> sockaddr_in &#123;</div><div class=\"line\">  shor <span class=\"keyword\">int</span> sin_family;         <span class=\"comment\">//地址族</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> <span class=\"keyword\">int</span> sin_port; <span class=\"comment\">//端口号</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> in_addr sin_addr;     <span class=\"comment\">//IP地址</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sin_zero[<span class=\"number\">8</span>];   <span class=\"comment\">//填充0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这两个数据类型大小相同，通常用 <code>sockaddr_in</code> 来保存某个网络地址，使用是强转成 <code>sockaddr</code>。<code>sa_family</code> 常见值有：</p>\n<ul>\n<li><code>AF_INET</code>  IPv4 协议</li>\n<li><code>AF_INET6</code> IPv6 协议</li>\n<li><code>AF_LOCAL</code> UNIX域协议</li>\n<li><code>AF_LINK</code> 链路地址协议</li>\n<li><code>AF_KEY</code> 密钥套接字</li>\n</ul>\n</li>\n<li><p>网络字节序<br>计算机的多字节整形存储方式有两种：大端（高位字节存储在地位地址）小端（高位字节存储在高位地址）。为了保证网络通信的一致性，数据以大端方式传输，所以需要相应的转换函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">uint16_t</span> htons(<span class=\"keyword\">uint16_t</span> hostshort);</div><div class=\"line\"><span class=\"keyword\">uint32_t</span> htonl(<span class=\"keyword\">uint32_t</span> hostlong);</div><div class=\"line\"><span class=\"keyword\">uint16_t</span> ntohs(<span class=\"keyword\">uint16_t</span> netshort);</div><div class=\"line\"><span class=\"keyword\">uint32_t</span> ntohl(<span class=\"keyword\">uint32_t</span> netlong);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"二、TCP-网络编程\"><a href=\"#二、TCP-网络编程\" class=\"headerlink\" title=\"二、TCP 网络编程\"></a>二、TCP 网络编程</h2><p>TCP 向应用层提供可靠的面向链接的全双工数据流传输服务。它能提供高可靠性通信（数据无误，数据无丢失，数据无失序，数据无重复到达）。</p>\n<h3 id=\"1-3次握手协议和两次挥手\"><a href=\"#1-3次握手协议和两次挥手\" class=\"headerlink\" title=\"1. 3次握手协议和两次挥手\"></a>1. 3次握手协议和两次挥手</h3><p>TCP 的面向连接指的是：当计算机双方通信的时候必须先建立连接，然后进行数据通信，最后关闭连接。TCP 在建立连接时有三个步骤：</p>\n<ul>\n<li><strong>第一步</strong> ： （客户端 -&gt; 服务端）客户端向服务端发送一个包含 SYN 标志的 TCP 报文，并进入 SYN_SEND 状态，等待确认。</li>\n<li><strong>第二步</strong> ： （服务端 -&gt; 客户端）服务端在收到客户端的 SYN 报文之后，返回一个 SYN+ACK 的报文，表示服务端收到客户端的 SYN，服务端进入 SYN_RECV 状态。</li>\n<li><strong>第三步</strong> ： （客户端 -&gt; 服务端）客户端在收到服务端的 SYN+ACK 报文之后，向确认端发送确认 ACK 报文，客户端和服务端都进入 ESTABLISHED 状态。</li>\n</ul>\n<p>在发送方发送一个数据包之后，会启动一个定时器，当数据包到达目的地之后，接收方会返回一个数据包，其中含有一个确认序号，如果发送方的定时器在确认信息到达之前超时，发送方会重发数据。</p>\n<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>\n<ul>\n<li><strong>第一步</strong> 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 </li>\n<li><strong>第二步</strong> 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 </li>\n<li><strong>第三步</strong> 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 </li>\n<li><strong>第四步</strong> 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。  </li>\n</ul>\n<h3 id=\"2-TCP-的数据包头\"><a href=\"#2-TCP-的数据包头\" class=\"headerlink\" title=\"2. TCP 的数据包头\"></a>2. TCP 的数据包头</h3><p><img src=\"http://ogf054qp1.bkt.clouddn.com/TCP%E5%8C%85%E5%A4%B4.png\" alt=\"TCP 包头\"></p>\n<ol>\n<li><strong>源端口/目的端口</strong>：16bit，标识本地和远端的端口号。</li>\n<li><strong>顺序号</strong>：32bit，标识发送的数据包的顺序。</li>\n<li><strong>确认号</strong>：32bit，希望收到的下一包数据的序列号。</li>\n<li><strong>TCP头长</strong>：4bit，表明 TCP 头中包含多少个32bit。</li>\n<li><strong>6bit 未用</strong>。</li>\n<li><strong>URG</strong>：表示紧急指针字段有效。</li>\n<li><strong>ACK</strong>：置位表示确认号字段有效；</li>\n<li><strong>PSH</strong>：表示当前报文需要请求推（push）操作；</li>\n<li><strong>RST</strong>：置位表示复位TCP连接；</li>\n<li><strong>SYN</strong>：用于建立TCP连接时同步序号；</li>\n<li><strong>FIN</strong>：用于释放TCP连接时标识发送方比特流结束。 </li>\n<li><strong>窗口</strong>：16位，表示源主机在请求接收端等待确认之前需要接收的字节数。它用于流量控制。</li>\n<li><strong>校验位</strong>：16位。用于检查TCP数据包头和数据的一致性。</li>\n<li><strong>紧急指针</strong>：16位。当URG码有效时只向紧急数据字节。</li>\n<li><strong>可选项</strong>：存在时表示TCP包头后还有另外的4字节数据。包括最大 TCP 载荷/窗口比例/选择重发数据包等选项。</li>\n</ol>\n<h3 id=\"3-服务器端-TCP-网络编程：\"><a href=\"#3-服务器端-TCP-网络编程：\" class=\"headerlink\" title=\"3. 服务器端 TCP 网络编程：\"></a>3. 服务器端 TCP 网络编程：</h3><p>TCP编程模型可分为服务器端和客户端两种，一个完整的服务器端 TCP 编程模型有6步：</p>\n<ol>\n<li>创建一个套接字 <code>socket()</code></li>\n<li><p>连接到指定的地址和端口</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *myaddr, <span class=\"keyword\">socket_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：将一个本地协议赋予一个套接字。<br> 参数：<code>sockfd</code> 套接字描述符，<code>myaddr</code> 指定的地址结构的指针，<code>addrlen</code> 该地址结构长度。<br> 返回值：成功返回0，失败返回-1；</p>\n</li>\n<li><p>设置为监听模式</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：将一个未连接的套接字转换为一个被动套接字<br> 参数：<code>sockfd</code> 套接字描述符，<code>backlog</code> 相应的套接字排队的最大连接个数。<br> 返回值：成功返回0，失败返回-1；</p>\n</li>\n<li><p>等待接收客户端的连接请求</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *cliaddr, <span class=\"keyword\">socket_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：从已完成的链接队列队头返回下一个已完成连接，如果队列为空，进程进入睡眠（默认为阻塞模式）。<br> 参数：<code>sockfd</code> 套接字描述符，<code>cliaddr</code>/<code>addrlen</code> 用来存储对端的地址结构和长度<br> 返回值：成功返回非负的描述符，失败返回-1；</p>\n</li>\n<li><p>发送和接收数据：<code>send()</code>/<code>recv()</code></p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recvform</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：类似标准的 <code>read()</code> 和 <code>write()</code> 函数。<br> 参数：前三个函数同 <code>read()</code>/<code>write()</code>， <code>flags</code> 一般是0。<br> 返回值：成功返回读或写的字节数，失败返回-1。</p>\n</li>\n<li><p>关闭套接字 <code>close()</code></p>\n</li>\n</ol>\n<h3 id=\"4-客户端的-TCP-编程模型\"><a href=\"#4-客户端的-TCP-编程模型\" class=\"headerlink\" title=\"4. 客户端的 TCP 编程模型\"></a>4. 客户端的 TCP 编程模型</h3><ol>\n<li>创建一个套接字：<code>socket()</code></li>\n<li><p>建立连接</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *servaddr, <span class=\"keyword\">socket_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：建立与 TCP 服务器的连接<br> 参数：<code>sockfd</code> 套接字描述符，<code>servaddr</code>/<code>addrlen</code> 用来存储服务器端的地址结构和长度<br> 返回值：成功返回0，失败返回-1；</p>\n</li>\n<li>发送和接收数据:<code>send()</code>/<code>recv()</code></li>\n<li>关闭套接字 <code>close()</code></li>\n</ol>\n<h2 id=\"三、UDP编程模型\"><a href=\"#三、UDP编程模型\" class=\"headerlink\" title=\"三、UDP编程模型\"></a>三、UDP编程模型</h2><p>UDP 即用户数据报协议，是一种面向无连接的不可靠的传输协议，具有消耗资源少，处理速度快的特点。<br>UDP 的数据包头比较简单，包含源和目的的地址（各16bit）8位空位，8位协议位，16位 UDP 长度。<br>UDP 网络编程和 TCP 网络编程的区别在于：UDP 是不可靠的数据报协议，客户端不与服务器建立连接，直接使用 <code>sendto()</code> 函数向服务器发送数据，而服务器同样不用接收连接，使用 <code>recvform</code> 返回相应的数据。</p>\n<h3 id=\"1-UDP-网络编程模型\"><a href=\"#1-UDP-网络编程模型\" class=\"headerlink\" title=\"1. UDP 网络编程模型\"></a>1. UDP 网络编程模型</h3><ul>\n<li><p>UDP 服务器端编程模型</p>\n<ol>\n<li>创建一个套接字：同 TCP。</li>\n<li>连接到指定的地址和端口 <code>bind()</code></li>\n<li><p>发送和接收数据 用 <code>sendto()</code>/<code>recvform()</code></p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recvform</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags,</span></span></div><div class=\"line\">             <span class=\"keyword\">struct</span> sockaddr *from, <span class=\"keyword\">socklen_t</span> *addrlen);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags,</span></span></div><div class=\"line\">             <span class=\"keyword\">struct</span> sockaddr *to, <span class=\"keyword\">socklen_t</span> *addrlen);</div></pre></td></tr></table></figure>\n<p>功能：类似标准的 <code>read()</code> 和 <code>write()</code> 函数。<br>参数：前三个函数同 <code>read()</code>/<code>write()</code>， <code>flags</code> 一般是0， <code>from</code>/<code>to</code> 分别是对端的地址结构指针， <code>addrlen</code> 是对端的地址结构长度。<br>返回值：成功返回读或写的字节数，失败返回-1。</p>\n</li>\n<li><p>关闭套接字 <code>close()</code></p>\n</li>\n</ol>\n</li>\n<li><p>UDP 客户端编程模型</p>\n<ol>\n<li>创建一个套接字：同 TCP。</li>\n<li>发送和接收数据 用 <code>sendto()</code>/<code>recvform()</code></li>\n<li>关闭套接字 <code>close()</code></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-组播与广播编程\"><a href=\"#2-组播与广播编程\" class=\"headerlink\" title=\"2. 组播与广播编程\"></a>2. 组播与广播编程</h3><p>之前我们处理的都是单播程序：一个进程就与另一个进程通信。TCP 只支持单播寻址，而 UDP 还支持其他的寻址类型。</p>\n<ul>\n<li>单播（unicast）：向标识的单独接口递送数据，TCP 仅支持此种</li>\n<li>任播（anycast）：向标识的一组接口中的一个递送数据</li>\n<li>组播（multicast）：向标识的一组中的所有接口递送数据</li>\n<li>广播（broadcast）：向全体递送数据</li>\n</ul>\n<p>广播和组播都需要使用UDP，都不能使用TCP。IPv4地址可以使用｛子网id，主机id｝来表示，-1表示所有位都为1的字段，广播可以分为几种： </p>\n<ul>\n<li><p>子网定向广播地址，｛子网id，-1｝，指定子网上所有接口的广播地址</p>\n<blockquote>\n<p>192.168.1.0/24 该子网上的广播地址192.168.1.255 </p>\n</blockquote>\n</li>\n<li><p>受限广播地址｛-1，-1｝即 <code>255.255.255.255</code>。</p>\n</li>\n</ul>\n<ol>\n<li><p>广播的流程<br>发送广播的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li>指定目标地址和端口</li>\n<li><p>设置套接字选项允许发送广播包</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;on, <span class=\"keyword\">sizeof</span>(on));</div></pre></td></tr></table></figure>\n</li>\n<li><p>发送广播包</p>\n</li>\n</ul>\n<p>接收广播包的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li>绑定目标地址和端口</li>\n<li>接收广播包</li>\n</ul>\n</li>\n<li><p>广播的缺点</p>\n<ul>\n<li><p>当使用单播时：<br>发送端UDP 套接字承载了目的 IP，比如 192.168.32.3，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成 相应的以太网地址，并标识相应的帧类型为 IPv4（0x0800）。<br>该数据在接口层传输，相应的主机接口首先判断该帧的以太网地址是否和本机一致：不一致忽略，一致读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，把数据置于相应的套接字接收队列。</p>\n</li>\n<li><p>当使用广播时：<br>发送端UDP 套接字承载了目的 IP，比如 192.168.32.255，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成所在以太网的子网的以太网地址，此时这个以太网地址为全1的地址，并标识相应的帧类型为 IPv4（0x0800）。<br>该数据在接口层传输，该子网内所有的主机接口都会判断该帧的以太网地址是和本机一致，读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，如果有相应端口的应用进程，执行相应的接收程序，如果没有相应的进程，则 UDP 丢弃当前数据包。</p>\n</li>\n</ul>\n<p>所以广播存在的问题是：子网上所有使用 IP 协议的主机都必须沿相应的协议传输到 UDP 层判断自己是否参加了相应的广播。所有不使用 IP 协议的主机也都必须在接口层接收所用的数据，并在网络层读取判断。</p>\n</li>\n<li><p>组播地址<br>IPv4 地址可以分为五类：</p>\n<ul>\n<li>A 类：最高位0，主机号占 24 位，地址范围为：1.0.0.1 到 126.255.255.254</li>\n<li>B 类：最高两位10，主机号占 16 位，地址范围为：128.0.0.1 到 191.255.255.254</li>\n<li>C 类：最高三位110，主机号占 8 位，地址范围为：192.0.1.1 到 223.255.255.254</li>\n<li>D 类：最高四位1110，地址范围为：224.0.0.1 到 239.255.255.254</li>\n<li>E 类：保留<br>其中，D类地址为组播地址，每一个组播地址代表一个多播组。</li>\n</ul>\n</li>\n<li><p>组播的流程<br>发送组播的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li>指定目标地址和端口</li>\n<li>发送组播包</li>\n</ul>\n<p>接收组播的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li><p>加入多播组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class=\"keyword\">sizeof</span>(mreq));</div></pre></td></tr></table></figure>\n</li>\n<li><p>绑定地址和端口</p>\n</li>\n<li>发送组播包</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、本地套接字\"><a href=\"#四、本地套接字\" class=\"headerlink\" title=\"四、本地套接字\"></a>四、本地套接字</h2><p>套接字的引用本来就只支持本地通信，目前很多前台后台进程依旧使用 UNIX 域套接字进行通信，本地套接字的特点是使用简单，效率高。本地套接字也分为流式套接字和用户数据报两种类型。具体的编程方法和相应 TCP / UDP 套接字基本一致，区别仅是使用的协议和地址不同，这里就不再详细描述。</p>\n","excerpt":"<p>网络编程离不开的基础是网络体系结构，通常说的是 OSI协议参考模型，它是一个七层网络协议模型。而我们通常使用的 Internet 是基于 TCP/IP 协议的，TCP/IP 协议是 OSI 协议的一个4层简化模型。<br>","more":"<br>他们之间的对应关系如下图：<br><img src=\"http://ogf054qp1.bkt.clouddn.com/OSI.png\" alt=\"网络协议模型\"></p>\n<p>自下而上，简单介绍下相应各层在整体架构中的作用:</p>\n<ol>\n<li><strong>网络接口层</strong>：<br><code>Network Interface Layer</code> 是 TCP/IP 的最底层，负责将二进制转换为数据帧，并进行数据帧的发送和接收。</li>\n<li><strong>网络层</strong>：<br><code>Internet Layer</code> 负责在主机之间的通信中选择数据包的传输路径。网络互连层定义了分组格式和协议，即 IP协议（Internet Protocol）。</li>\n<li><strong>传输层</strong>：<br>在 TCP/IP 模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。<br>即：传输控制协议 <strong>TCP</strong>（<code>transmission control protocol</code>）和用户数据报协议 <strong>UDP</strong>（<code>user datagram Protocol</code>）。</li>\n<li><strong>应用层</strong>：<br>TCP/IP 模型将 OSI 参考模型中的会话层和表示层的功能合并到应用层实现。应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于 TCP 协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于 UDP 协议的。</li>\n</ol>\n<p>我们在这里主要讨论的是第三层传输层的具体内容，即 TCP 和 UDP。</p>\n<h2 id=\"一、网络编程基础知识\"><a href=\"#一、网络编程基础知识\" class=\"headerlink\" title=\"一、网络编程基础知识\"></a>一、网络编程基础知识</h2><h3 id=\"1-套接字\"><a href=\"#1-套接字\" class=\"headerlink\" title=\"1. 套接字\"></a>1. 套接字</h3><p>套接字（Socket）是一种特殊的 I/O 接口，也是一种文件描述符。可以用于本地和网络通信，对于网络通信而言，每一个 Socket 都可以用网路地址结构（协议，本地地址，本地端口）来表示。Socket 通过一个特殊的函数创建，并返回一个整形的 Socket 描述符。</p>\n<blockquote>\n<p>套接字分为三种：</p>\n<ul>\n<li>流式套接字（SOCK_STREAM）：TCP 通信使用的就是流式套接字。</li>\n<li>数据包套接字（SOCK_DGRAM)：UDP 通信使用的就是数据包套接字。</li>\n<li>原始套接字（SOCKRAW）：原始套接字允许对底层协议进行直接的访问，主要用于协议的开发。</li>\n</ul>\n</blockquote>\n<p>套接字有几个相关函数：</p>\n<ul>\n<li><p>套接字的创建：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：创建一个套接字。<br>参数：<code>family</code> 指定相应的协议族，<code>type</code> 指定套接字类型，<code>protocol</code> 为0,(原始套接字除外)。<br>返回值：成功返回非负的描述符，失败返回-1。</p>\n</li>\n<li><p>获取套接字选项：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname, <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> *optlen)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：获取套接字选项<br>参数：<code>sockfd</code> 套接字描述符；<code>level</code> 选项所属协议层；<code>optname</code> 选项名称；<code>optval</code> 保存选项的缓存区；<code>optlen</code> 选项值长度。<br>返回值：成功返回0，失败返回-1，并设置 errno。</p>\n</li>\n<li><p>设置套接字选项：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> optname, <span class=\"keyword\">void</span> *optval, <span class=\"keyword\">socklen_t</span> *optlen)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：设置套接字选项<br>参数：<code>sockfd</code> 套接字描述符；<code>level</code> 选项所属协议层；<code>optname</code> 选项名称；<code>optval</code> 保存选项的缓存区；<code>optlen</code> 选项值长度。<br>返回值：成功返回0，失败返回-1，并设置 errno。</p>\n</li>\n</ul>\n<p>相应的套接字选项及说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>选项名称</th>\n<th>说明</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>LEVEL</strong></td>\n<td><strong>SOL_SOCKET</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>SO_BROADCAST</td>\n<td>允许发送广播数据报</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_DEBUG</td>\n<td>使能调试跟踪</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_DONTROUTE</td>\n<td>旁路路由表查询</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_ERROR</td>\n<td>获取待处理错误并消除</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_KEEPALIVE</td>\n<td>周期性测试连接是否存活</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_LINGER</td>\n<td>若有数据待发送则延迟关闭</td>\n<td>linger{}</td>\n</tr>\n<tr>\n<td>SO_OOBINLINE</td>\n<td>让接收到的带外数据继续在线存放</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_RCVBUF</td>\n<td>接收缓冲区大小</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_SNDBUF</td>\n<td>发送缓冲区大小</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_RCVTIMEO</td>\n<td>接收超时</td>\n<td>timeval{}</td>\n</tr>\n<tr>\n<td>SO_SNDTIMEO</td>\n<td>发送超时</td>\n<td>timeval{}</td>\n</tr>\n<tr>\n<td>SO_REUSEADDR</td>\n<td>允许重用本地地址</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_REUSEPORT</td>\n<td>允许重用本地地址</td>\n<td>int</td>\n</tr>\n<tr>\n<td>SO_TYPE</td>\n<td>取得套接口类型</td>\n<td>int</td>\n</tr>\n<tr>\n<td><strong>LEVEL</strong></td>\n<td><strong>IPPROTO_IP</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>IP_HDRINCL</td>\n<td>IP头部包括数据</td>\n<td>int</td>\n</tr>\n<tr>\n<td>IP_OPTIONS</td>\n<td>IP头部选项</td>\n<td>见后面说明</td>\n</tr>\n<tr>\n<td>IP_TOS</td>\n<td>服务类型和优先权</td>\n<td>int</td>\n</tr>\n<tr>\n<td>IP_TTL</td>\n<td>存活时间</td>\n<td>int</td>\n</tr>\n<tr>\n<td>IP_ADD_MEMBERSHIP</td>\n<td>加入多播组</td>\n<td>ip_mreq{}</td>\n</tr>\n<tr>\n<td>IP_DROP_MEMBERSHIP</td>\n<td>离开多播组</td>\n<td>ip_mreq{}</td>\n</tr>\n<tr>\n<td><strong>LEVEL</strong></td>\n<td><strong>IPPROTO_TCP</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>TCP_KEEPALIVE</td>\n<td>控测对方是否存活前连接闲置秒数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>TCP_MAXRT</td>\n<td>TCP最大重传时间</td>\n<td>int</td>\n</tr>\n<tr>\n<td>TCP_MAXSEG</td>\n<td>TCP最大分节大小</td>\n<td>int</td>\n</tr>\n<tr>\n<td>TCP_NODELAY</td>\n<td>禁止Nagle算法</td>\n<td>int</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-IP-端口和网络字节序\"><a href=\"#2-IP-端口和网络字节序\" class=\"headerlink\" title=\"2. IP/端口和网络字节序\"></a>2. IP/端口和网络字节序</h3><p>IP 地址用来标识网络中的一台主机，端口用来标识主机内部的某个套接字。下面介绍几个相关的函数：</p>\n<ol>\n<li><p>地址格式转换函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_addr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *strptr)</span></span>;                            </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_pton</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src, <span class=\"keyword\">void</span> *dst)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">inet_ntop</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">void</span> *src, <span class=\"keyword\">char</span> *dst, <span class=\"keyword\">size_t</span> len)</span></span>;</div></pre></td></tr></table></figure>\n<p>函数 <code>inet_addr()</code>/ <code>inet_pton</code> 用来要转换的字符串转换为 32 二进制IP地址（网络字节序）。函数 <code>inet_ntop</code> 是相应的反向操作。<br><code>family</code> 指的是地址族，用来区分 IPv4（AF_INET）和 IPv6（AF_INET6）。<br><code>inet_addr()</code> 成功返回相应的地址，失败返回-1；<code>inet_pton</code> 成功返回0，失败返回-1； <code>inet_ntop</code> 成功返回 dst，失败返回NULL。</p>\n</li>\n<li><p>地址结构<br>地址信息有两个相关的结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> sockaddr &#123;</div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> sa_family; <span class=\"comment\">//地址族</span></div><div class=\"line\">  <span class=\"keyword\">char</span> sa_data[<span class=\"number\">14</span>];         <span class=\"comment\">//14字节的协议地址</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> sockaddr_in &#123;</div><div class=\"line\">  shor <span class=\"keyword\">int</span> sin_family;         <span class=\"comment\">//地址族</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> <span class=\"keyword\">int</span> sin_port; <span class=\"comment\">//端口号</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> in_addr sin_addr;     <span class=\"comment\">//IP地址</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sin_zero[<span class=\"number\">8</span>];   <span class=\"comment\">//填充0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这两个数据类型大小相同，通常用 <code>sockaddr_in</code> 来保存某个网络地址，使用是强转成 <code>sockaddr</code>。<code>sa_family</code> 常见值有：</p>\n<ul>\n<li><code>AF_INET</code>  IPv4 协议</li>\n<li><code>AF_INET6</code> IPv6 协议</li>\n<li><code>AF_LOCAL</code> UNIX域协议</li>\n<li><code>AF_LINK</code> 链路地址协议</li>\n<li><code>AF_KEY</code> 密钥套接字</li>\n</ul>\n</li>\n<li><p>网络字节序<br>计算机的多字节整形存储方式有两种：大端（高位字节存储在地位地址）小端（高位字节存储在高位地址）。为了保证网络通信的一致性，数据以大端方式传输，所以需要相应的转换函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">uint16_t</span> htons(<span class=\"keyword\">uint16_t</span> hostshort);</div><div class=\"line\"><span class=\"keyword\">uint32_t</span> htonl(<span class=\"keyword\">uint32_t</span> hostlong);</div><div class=\"line\"><span class=\"keyword\">uint16_t</span> ntohs(<span class=\"keyword\">uint16_t</span> netshort);</div><div class=\"line\"><span class=\"keyword\">uint32_t</span> ntohl(<span class=\"keyword\">uint32_t</span> netlong);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"二、TCP-网络编程\"><a href=\"#二、TCP-网络编程\" class=\"headerlink\" title=\"二、TCP 网络编程\"></a>二、TCP 网络编程</h2><p>TCP 向应用层提供可靠的面向链接的全双工数据流传输服务。它能提供高可靠性通信（数据无误，数据无丢失，数据无失序，数据无重复到达）。</p>\n<h3 id=\"1-3次握手协议和两次挥手\"><a href=\"#1-3次握手协议和两次挥手\" class=\"headerlink\" title=\"1. 3次握手协议和两次挥手\"></a>1. 3次握手协议和两次挥手</h3><p>TCP 的面向连接指的是：当计算机双方通信的时候必须先建立连接，然后进行数据通信，最后关闭连接。TCP 在建立连接时有三个步骤：</p>\n<ul>\n<li><strong>第一步</strong> ： （客户端 -&gt; 服务端）客户端向服务端发送一个包含 SYN 标志的 TCP 报文，并进入 SYN_SEND 状态，等待确认。</li>\n<li><strong>第二步</strong> ： （服务端 -&gt; 客户端）服务端在收到客户端的 SYN 报文之后，返回一个 SYN+ACK 的报文，表示服务端收到客户端的 SYN，服务端进入 SYN_RECV 状态。</li>\n<li><strong>第三步</strong> ： （客户端 -&gt; 服务端）客户端在收到服务端的 SYN+ACK 报文之后，向确认端发送确认 ACK 报文，客户端和服务端都进入 ESTABLISHED 状态。</li>\n</ul>\n<p>在发送方发送一个数据包之后，会启动一个定时器，当数据包到达目的地之后，接收方会返回一个数据包，其中含有一个确认序号，如果发送方的定时器在确认信息到达之前超时，发送方会重发数据。</p>\n<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>\n<ul>\n<li><strong>第一步</strong> 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 </li>\n<li><strong>第二步</strong> 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 </li>\n<li><strong>第三步</strong> 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 </li>\n<li><strong>第四步</strong> 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。  </li>\n</ul>\n<h3 id=\"2-TCP-的数据包头\"><a href=\"#2-TCP-的数据包头\" class=\"headerlink\" title=\"2. TCP 的数据包头\"></a>2. TCP 的数据包头</h3><p><img src=\"http://ogf054qp1.bkt.clouddn.com/TCP%E5%8C%85%E5%A4%B4.png\" alt=\"TCP 包头\"></p>\n<ol>\n<li><strong>源端口/目的端口</strong>：16bit，标识本地和远端的端口号。</li>\n<li><strong>顺序号</strong>：32bit，标识发送的数据包的顺序。</li>\n<li><strong>确认号</strong>：32bit，希望收到的下一包数据的序列号。</li>\n<li><strong>TCP头长</strong>：4bit，表明 TCP 头中包含多少个32bit。</li>\n<li><strong>6bit 未用</strong>。</li>\n<li><strong>URG</strong>：表示紧急指针字段有效。</li>\n<li><strong>ACK</strong>：置位表示确认号字段有效；</li>\n<li><strong>PSH</strong>：表示当前报文需要请求推（push）操作；</li>\n<li><strong>RST</strong>：置位表示复位TCP连接；</li>\n<li><strong>SYN</strong>：用于建立TCP连接时同步序号；</li>\n<li><strong>FIN</strong>：用于释放TCP连接时标识发送方比特流结束。 </li>\n<li><strong>窗口</strong>：16位，表示源主机在请求接收端等待确认之前需要接收的字节数。它用于流量控制。</li>\n<li><strong>校验位</strong>：16位。用于检查TCP数据包头和数据的一致性。</li>\n<li><strong>紧急指针</strong>：16位。当URG码有效时只向紧急数据字节。</li>\n<li><strong>可选项</strong>：存在时表示TCP包头后还有另外的4字节数据。包括最大 TCP 载荷/窗口比例/选择重发数据包等选项。</li>\n</ol>\n<h3 id=\"3-服务器端-TCP-网络编程：\"><a href=\"#3-服务器端-TCP-网络编程：\" class=\"headerlink\" title=\"3. 服务器端 TCP 网络编程：\"></a>3. 服务器端 TCP 网络编程：</h3><p>TCP编程模型可分为服务器端和客户端两种，一个完整的服务器端 TCP 编程模型有6步：</p>\n<ol>\n<li>创建一个套接字 <code>socket()</code></li>\n<li><p>连接到指定的地址和端口</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *myaddr, <span class=\"keyword\">socket_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：将一个本地协议赋予一个套接字。<br> 参数：<code>sockfd</code> 套接字描述符，<code>myaddr</code> 指定的地址结构的指针，<code>addrlen</code> 该地址结构长度。<br> 返回值：成功返回0，失败返回-1；</p>\n</li>\n<li><p>设置为监听模式</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：将一个未连接的套接字转换为一个被动套接字<br> 参数：<code>sockfd</code> 套接字描述符，<code>backlog</code> 相应的套接字排队的最大连接个数。<br> 返回值：成功返回0，失败返回-1；</p>\n</li>\n<li><p>等待接收客户端的连接请求</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *cliaddr, <span class=\"keyword\">socket_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：从已完成的链接队列队头返回下一个已完成连接，如果队列为空，进程进入睡眠（默认为阻塞模式）。<br> 参数：<code>sockfd</code> 套接字描述符，<code>cliaddr</code>/<code>addrlen</code> 用来存储对端的地址结构和长度<br> 返回值：成功返回非负的描述符，失败返回-1；</p>\n</li>\n<li><p>发送和接收数据：<code>send()</code>/<code>recv()</code></p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recvform</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：类似标准的 <code>read()</code> 和 <code>write()</code> 函数。<br> 参数：前三个函数同 <code>read()</code>/<code>write()</code>， <code>flags</code> 一般是0。<br> 返回值：成功返回读或写的字节数，失败返回-1。</p>\n</li>\n<li><p>关闭套接字 <code>close()</code></p>\n</li>\n</ol>\n<h3 id=\"4-客户端的-TCP-编程模型\"><a href=\"#4-客户端的-TCP-编程模型\" class=\"headerlink\" title=\"4. 客户端的 TCP 编程模型\"></a>4. 客户端的 TCP 编程模型</h3><ol>\n<li>创建一个套接字：<code>socket()</code></li>\n<li><p>建立连接</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> sockaddr *servaddr, <span class=\"keyword\">socket_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：建立与 TCP 服务器的连接<br> 参数：<code>sockfd</code> 套接字描述符，<code>servaddr</code>/<code>addrlen</code> 用来存储服务器端的地址结构和长度<br> 返回值：成功返回0，失败返回-1；</p>\n</li>\n<li>发送和接收数据:<code>send()</code>/<code>recv()</code></li>\n<li>关闭套接字 <code>close()</code></li>\n</ol>\n<h2 id=\"三、UDP编程模型\"><a href=\"#三、UDP编程模型\" class=\"headerlink\" title=\"三、UDP编程模型\"></a>三、UDP编程模型</h2><p>UDP 即用户数据报协议，是一种面向无连接的不可靠的传输协议，具有消耗资源少，处理速度快的特点。<br>UDP 的数据包头比较简单，包含源和目的的地址（各16bit）8位空位，8位协议位，16位 UDP 长度。<br>UDP 网络编程和 TCP 网络编程的区别在于：UDP 是不可靠的数据报协议，客户端不与服务器建立连接，直接使用 <code>sendto()</code> 函数向服务器发送数据，而服务器同样不用接收连接，使用 <code>recvform</code> 返回相应的数据。</p>\n<h3 id=\"1-UDP-网络编程模型\"><a href=\"#1-UDP-网络编程模型\" class=\"headerlink\" title=\"1. UDP 网络编程模型\"></a>1. UDP 网络编程模型</h3><ul>\n<li><p>UDP 服务器端编程模型</p>\n<ol>\n<li>创建一个套接字：同 TCP。</li>\n<li>连接到指定的地址和端口 <code>bind()</code></li>\n<li><p>发送和接收数据 用 <code>sendto()</code>/<code>recvform()</code></p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recvform</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags,</div><div class=\"line\">             <span class=\"keyword\">struct</span> sockaddr *from, <span class=\"keyword\">socklen_t</span> *addrlen)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buff, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">int</span> flags,</div><div class=\"line\">             <span class=\"keyword\">struct</span> sockaddr *to, <span class=\"keyword\">socklen_t</span> *addrlen)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：类似标准的 <code>read()</code> 和 <code>write()</code> 函数。<br>参数：前三个函数同 <code>read()</code>/<code>write()</code>， <code>flags</code> 一般是0， <code>from</code>/<code>to</code> 分别是对端的地址结构指针， <code>addrlen</code> 是对端的地址结构长度。<br>返回值：成功返回读或写的字节数，失败返回-1。</p>\n</li>\n<li><p>关闭套接字 <code>close()</code></p>\n</li>\n</ol>\n</li>\n<li><p>UDP 客户端编程模型</p>\n<ol>\n<li>创建一个套接字：同 TCP。</li>\n<li>发送和接收数据 用 <code>sendto()</code>/<code>recvform()</code></li>\n<li>关闭套接字 <code>close()</code></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-组播与广播编程\"><a href=\"#2-组播与广播编程\" class=\"headerlink\" title=\"2. 组播与广播编程\"></a>2. 组播与广播编程</h3><p>之前我们处理的都是单播程序：一个进程就与另一个进程通信。TCP 只支持单播寻址，而 UDP 还支持其他的寻址类型。</p>\n<ul>\n<li>单播（unicast）：向标识的单独接口递送数据，TCP 仅支持此种</li>\n<li>任播（anycast）：向标识的一组接口中的一个递送数据</li>\n<li>组播（multicast）：向标识的一组中的所有接口递送数据</li>\n<li>广播（broadcast）：向全体递送数据</li>\n</ul>\n<p>广播和组播都需要使用UDP，都不能使用TCP。IPv4地址可以使用｛子网id，主机id｝来表示，-1表示所有位都为1的字段，广播可以分为几种： </p>\n<ul>\n<li><p>子网定向广播地址，｛子网id，-1｝，指定子网上所有接口的广播地址</p>\n<blockquote>\n<p>192.168.1.0/24 该子网上的广播地址192.168.1.255 </p>\n</blockquote>\n</li>\n<li><p>受限广播地址｛-1，-1｝即 <code>255.255.255.255</code>。</p>\n</li>\n</ul>\n<ol>\n<li><p>广播的流程<br>发送广播的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li>指定目标地址和端口</li>\n<li><p>设置套接字选项允许发送广播包</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;on, <span class=\"keyword\">sizeof</span>(on));</div></pre></td></tr></table></figure>\n</li>\n<li><p>发送广播包</p>\n</li>\n</ul>\n<p>接收广播包的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li>绑定目标地址和端口</li>\n<li>接收广播包</li>\n</ul>\n</li>\n<li><p>广播的缺点</p>\n<ul>\n<li><p>当使用单播时：<br>发送端UDP 套接字承载了目的 IP，比如 192.168.32.3，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成 相应的以太网地址，并标识相应的帧类型为 IPv4（0x0800）。<br>该数据在接口层传输，相应的主机接口首先判断该帧的以太网地址是否和本机一致：不一致忽略，一致读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，把数据置于相应的套接字接收队列。</p>\n</li>\n<li><p>当使用广播时：<br>发送端UDP 套接字承载了目的 IP，比如 192.168.32.255，和目的端口 比如 7433，在传输层，对他冠以一个 UDP 首部，在 IPv4 中标识为 17， 其次在网络层，标识为 IPv4, 确定了外出接口，接口层的以太网接口将相应的目的IP映射成所在以太网的子网的以太网地址，此时这个以太网地址为全1的地址，并标识相应的帧类型为 IPv4（0x0800）。<br>该数据在接口层传输，该子网内所有的主机接口都会判断该帧的以太网地址是和本机一致，读取整个帧，单播对非目的主机不造成任何额外开销。目的主机接口读取整个帧后，比较相应的帧类型 0x0800，传递给相应网络层协议 IPv4，网络层比较相应的 IP 是否和本机一致，一致后接收，随后查看相应的协议字段 17，数据被传送给传输层 UDP，UDP 查看相应的目的端口，如果有相应端口的应用进程，执行相应的接收程序，如果没有相应的进程，则 UDP 丢弃当前数据包。</p>\n</li>\n</ul>\n<p>所以广播存在的问题是：子网上所有使用 IP 协议的主机都必须沿相应的协议传输到 UDP 层判断自己是否参加了相应的广播。所有不使用 IP 协议的主机也都必须在接口层接收所用的数据，并在网络层读取判断。</p>\n</li>\n<li><p>组播地址<br>IPv4 地址可以分为五类：</p>\n<ul>\n<li>A 类：最高位0，主机号占 24 位，地址范围为：1.0.0.1 到 126.255.255.254</li>\n<li>B 类：最高两位10，主机号占 16 位，地址范围为：128.0.0.1 到 191.255.255.254</li>\n<li>C 类：最高三位110，主机号占 8 位，地址范围为：192.0.1.1 到 223.255.255.254</li>\n<li>D 类：最高四位1110，地址范围为：224.0.0.1 到 239.255.255.254</li>\n<li>E 类：保留<br>其中，D类地址为组播地址，每一个组播地址代表一个多播组。</li>\n</ul>\n</li>\n<li><p>组播的流程<br>发送组播的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li>指定目标地址和端口</li>\n<li>发送组播包</li>\n</ul>\n<p>接收组播的流程是：</p>\n<ul>\n<li>创建 UDP 套接字</li>\n<li><p>加入多播组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class=\"keyword\">sizeof</span>(mreq));</div></pre></td></tr></table></figure>\n</li>\n<li><p>绑定地址和端口</p>\n</li>\n<li>发送组播包</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、本地套接字\"><a href=\"#四、本地套接字\" class=\"headerlink\" title=\"四、本地套接字\"></a>四、本地套接字</h2><p>套接字的引用本来就只支持本地通信，目前很多前台后台进程依旧使用 UNIX 域套接字进行通信，本地套接字的特点是使用简单，效率高。本地套接字也分为流式套接字和用户数据报两种类型。具体的编程方法和相应 TCP / UDP 套接字基本一致，区别仅是使用的协议和地址不同，这里就不再详细描述。</p>"},{"title":"Linux学习总结（八）——线程","date":"2016-12-18T03:52:36.000Z","_content":"\n进程，它是资源分配的最小单位，进程中的事情需要按照一定的顺序逐个进行，那么：**如何让一个进程中的一些事情同时执行？**\n<!--more-->\n\n这时候就需要使用线程。**线程**，有时又称轻量级进程，它是 **程序执行的最小单位**，**系统独立调度和分派 cpu 的基本单位**，它是**进程中的一个实体**。一个进程中可以有多个线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。\n\n在了解线程之前需要清楚几个概念：\n1. **并发**\n并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。 **看起来同时发生**\n1. **并行**\n并行是指在同一时刻，有多条指令在多个处理器上同时执行。**真正的同时发生**\n1. **同步**\n彼此有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情。\n1. **异步**\n异步的概念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生。\n\n\n线程解决了进程的很多弊端：一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此，线程具有以下优势：\n> 1、在多处理器中开发程序的并行性\n    2、在等待慢速IO操作时，程序可以执行其他操作，提高并发性\n    3、模块化的编程，能更清晰的表达程序中独立事件的关系，结构清晰\n    4、占用较少的系统资源\n\n\n## 一、线程的创建：\n每个 Linux 都会运行在下面四种状态下：\n* 就绪\n 当线程刚被创建时就处于就绪状态，或者当线程被解除阻塞以后也会处于就绪状态。就绪的线程在等待一个可用的处理器，当一个运行的线程被抢占时，它立刻又回到就绪状态\n* 运行\n 当处理器选中一个就绪的线程执行时，它立刻变成运行状态\n* 阻塞\n 线程会在以下情况下发生阻塞：试图加锁一个已经被锁住的互斥量，等待某个条件变量，调用singwait等待尚未发生的信号，执行无法完成的I/O信号，由于内存页错误。\n* 终止\n 线程可以在启动函数中返回来终止自己，或者调用 `pthread_exit` 退出，或者取消线程。\n\n### 1. 线程ID\n我们首先来看下线程的创建，线程的创建使用的是 `pthread_create` 函数:\n````C++\n#include <pthread.h>\nint pthread_create (pthread_t *thread,\n                    pthread_attr_t *attr,\n                    void *(*start_routine)(void *),\n                    void *arg);````\n功能：创建一个线程。\n第一个参数 `thread`：新线程的id，如果成功则新线程的id回填充到tidp指向的内存\n第二个参数 `attr`：线程属性（调度策略，继承性，分离性...）\n第三个参数 `start_routine`：回调函数（新线程要执行的函数）\n第四个参数 `arg`：回调函数的参数\n返回值：成功返回0，失败则返回错误码\n\n当线程被创建时，`thread` 被写入一个标识符，我们使用这个标识符来引用被创建的线程。`attr` 可以用来详细设定线程的属性，一般为 `NULL`，我们会在本篇博客的最后详细介绍线程的属性，`start_routine` 指向了一个函数地址，我们可以定义任意一个具有一个任意类型的参数并返回任意一个返回值的函数作为线程的执行函数，最后一个 `arg` 传入了该函数的参数。需要注意的是：\n> 编译时需要连接库 `libpthread`。\n新线程可能在当前线程从函数 `pthread_create` 返回之前就已经运行了，甚至新线程可能在当前线程从函数 `pthread_create` 返回之前就已经运行完毕了。\n\n对于一个线程，可以使用 `pthread_self()` 函数来获取自己的线程号。\n````C++\n#include <pthread.h>\nint pthread_self (void);````\n功能：返回当前线程的线程 id。\n返回值：调用线程的线程ID。\n\n还有一个函数是 `pthread_equal()` 可以用来判断两个线程ID 是否一致。\n````C++\n#include <pthread.h>\nint pthread_equal (pthread_t tid1, pthread_t tid2);````\n功能：功能判断两个线程ID是否一致。\n参数：`tid1` `tid2` 需要判断的ID\n返回值：相等返回非0值，不相等返回0.\n\n这样，主线程可以将工作任务放在一个队列中，并将每个任务添加一个进程ID标识，这样相应的线程使用上面两个函数就可以取出和自己相关的任务。\n\n\n### 2. 初始线程/主线程\n当c程序运行时，首先运行 `main` 函数。在线程代码中，这个特殊的执行流被称作初始线程或者主线程。你可以在初始线程中做任何普通线程可以做的事情。主线程的特殊性在于:\n* 它在 `main` 函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用 `pthread_exit` 函数，这样进程就会等待所有线程结束时才终止。\n* 主线程接受参数的方式是通过 `argc` 和 `argv`，而普通的线程只有一个参数 `void*`。\n* 在绝大多数情况下，主线程在默认堆栈上运行，这个堆栈可以增长到足够的长度。而普通线程的堆栈是受限制的，一旦溢出就会产生错误。\n \n## 二、线程的运行\n### 1. 线程的退出\n退出线程使用的是 `pthread_exit`，需要注意的是：线程函数不能使用 `exit()` 退出，`exit`是危险的：如果进程中的任意一个线程调用了 `exit`，`_Exit`，`_exit`，那么整个进程就会终止，普通的单个线程以以下三种方式退出，不会终止进程：\n 1. 从启动函数中返回，返回值是线程的退出码。\n 2. 线程可以被同一进程中的其他线程取消。\n 3. 线程调用 `pthread_exit()` 函数。\n \n````C\n#include <pthread.h>\n void pthread_exit(void *rval);````\n 功能：退出一个线程。\n 参数：`rval` 是个无类型的指针，保存线程的退出码，其他线程可以通过 `pthread_join()` 函数来接收这个值。\n \n### 2. 线程的回收\n类似于进程的 `wait()` 函数，线程也有相应的机制，称为线程的回收，和这个机制紧密相关的一个概念是线程的**分离属性**。\n\n**线程的分离属性：** \n > 分离一个正在运行的线程并不影响它，仅仅是通知当前系统该线程结束时，其所属的资源可以回收。\n 一个没有被分离的线程在终止时会保留它的虚拟内存，包括他们的堆栈和其他系统资源，有时这种线程被称为**僵尸线程**。\n 创建线程时**默认是非分离的**。\n\n如果线程具有分离属性，线程终止时会被立刻回收，回收将释放掉所有在线程终止时未释放的系统资源和进程资源，包括保存线程返回值的内存空间、堆栈、保存寄存器的内存空间等。\n终止被分离的线程会释放所有的系统资源，但是你必须释放由该线程占有的程序资源。由 `malloc()` 或者 `mmap()` 分配的内存可以在任何时候由任何线程释放，条件变量、互斥量、信号灯可以由任何线程销毁，只要他们被解锁了或者没有线程等待。但是只有互斥量的主人才能解锁它，所以**在线程终止前，你需要解锁互斥量**。\n\n将已创建的线程设置为分离的有两种方式：\n* 调用 `pthread_detach()` 这个函数，那么当这个线程终止的时候，和它相关的系统资源将被自动释放。\n  ````C\n  #include <pthread.h>\n  int pthread_detach(pthread_t thread);````\n  功能：分离一个线程，线程可以自己分离自己。\n  参数：`thread` 指定线程的 id。\n  返回值：成功返回0，失败返回错误码\n \n* 调用 `pthread_join` 会使指定的线程处于分离状态()，如果指定线程已经处于分离状态，那么调用就会失败。\n  ````C\n  #include <pthread.h>\n  int pthread_join(pthead_t tid, void **rval);````\n  功能：调用该函数的线程会一直阻塞，直到指定的线程 `tid` 调用 `pthread_exit`、从启动函数返回或者被取消。\n  参数：参数 `tid` 就是指定线程的 `id`，参数 `rval` 是指定线程的返回码，如果线程被取消，那么 `rval` 被置为 `PTHREAD_CANCELED`\n  返回值：该函数调用成功会返回0，失败返回错误码\n\n\n### 3. 线程的取消\n线程的取消类似于一个线程向另一个线程发送了一个信号，要求它终止，相应的取消函数很简单：\n````C\n#include <pthread.h>\nint pthread_cancle(pthread_t tid);````\n功能：请求一个线程终止\n参数：`tid` 指定的线程\n返回值：成功返回0，失败返回错误码。\n\n取消只是发送一个请求，并不意味着等待线程终止，而且发送成功也不意味着 `tid` 一定会终止，它通常需要被取消线程的配合。线程在很多时候会查看自己取消状态，如果有就主动退出， 这些查看是否有取消的地方称为取消点\n \n这时候，我们又有了两个概念：**取消状态**，**取消点**。\n \n * 取消状态\n   取消状态，就是线程对取消信号的处理方式，忽略或者响应。线程创建时默认响应取消信号，相应的设置函数为：\n   ````C\n   #include <pthread.h> \n   int pthread_setcancelstate(int state, int *oldstate);````\n   功能：设置本线程对取消请求(CANCEL 信号)的反应\n   参数：`state` 有两种值：`PTHREAD_CANCEL_ENABLE`（缺省，接收取消请求）和 `PTHREAD_CANCEL_DISABLE`(忽略取消请求)；`old_state` 如果不为NULL则存入原来的Cancel状态以便恢复\n   返回值：成功返回0，失败返回错误码。\n\n   如果函数设置为接收取消请求，还可以设置他的**取消类型**:\n   取消类型，是线程对取消信号的响应方式，立即取消或者延时取消。线程创建时默认延时取消\n   ````C\n   #include <pthread.h> \n   int pthread_setcanceltype(int type, int *oldtype) ;````\n   功能：设置本线程取消动作的执行时机\n   参数：`type` 由两种取值：`PTHREAD_CANCEL_DEFFERED` 表示收到信号后继续运行至下一个取消点再退出， `PTHREAD_CANCEL_ASYCHRONOUS` 标识立即执行取消动作（退出）；两者仅当 Cancel 状态为 Enable 时有效；`oldtype` 如果不为NULL则存入运来的取消动作类型值。\n   返回值：成功返回0，失败则返回错误码\n \n * 取消点\n   取消点：取消一个线程，默认需要被取消线程的配合。线程在很多时候会查看自己是否有取消请求，如果有就主动退出， 这些查看是否有取消的地方称为取消点。很多地方都是包含取消点，包括 `pthread_join()`、 `pthread_testcancel()`、`pthread_cond_wait()`、 `pthread_cond_timedwait()`、`sem_wait()`、`sigwait()` 以及 `write`、`read` 等大多数会阻塞的系统调用。\n\n \n### 4. 线程的清除\n线程可以安排它退出时的清理操作，这与进程的可以用atexit函数安排进程退出时需要调用的函数类似。这样的函数称为线程清理处理程序。线程可以建立多个清理处理程序，处理程序记录在栈中，所以这些处理程序执行的顺序与他们注册的顺序相反\n````C\n#include <pthread.h> \nvoid pthread_cleanup_push（void （*rtn）（void*）， void *args）//注册处理程序\nvoid pthread_cleanup_pop（int excute）//清除处理程序````\n \n当执行以下操作时调用清理函数，清理函数的参数由 `args` 传入\n1. 调用 `pthread_exit`\n2. 响应取消请求\n3. 用非零参数调用 `pthread_cleanup_pop`\n\n**`return` 不调用清理操作**。\n\n\n## 五、线程的同步\n有几种方法可以很好的控制线程执行和访问临界区域，主要是互斥量和信号量。\n\n### 1. 互斥量\n * 为什么要使用互斥量？\n当多个线程共享相同的内存时，需要每一个线程看到相同的视图。当一个线程修改变量时，而其他线程也可以读取或者修改这个变量，就需要对这些线程同步，确保他们不会访问到无效的变量。\n为了让线程访问数据不产生冲突，这要就需要对变量加锁，使得同一时刻只有一个线程可以访问变量。互斥量本质就是锁，访问共享资源前对互斥量加锁，访问完成后解锁。\n当互斥量加锁以后，其他所有需要访问该互斥量的线程都将阻塞，当互斥量解锁以后，所有因为这个互斥量阻塞的线程都将变为就绪态，第一个获得cpu的线程会获得互斥量，变为运行态，而其他线程会继续变为阻塞，在这种方式下访问互斥量每次只有一个线程能向前执行. \n\n\n1. 互斥量的初始化和销毁\n\n   互斥量用 `pthread_mutex_t` 类型的数据表示，在使用之前需要对互斥量初始化\n   * 如果是动态分配的互斥量，可以调用 `pthread_mutex_init()`函数初始化\n   * 如果是静态分配的互斥量，还可以把它置为常量 `PTHREAD_MUTEX_INITIALIZER`\n   * 动态分配的互斥量在释放内存之前需要调用 `pthread_mutex_destroy()`\n\n  相应的处理函数为\n   ````C\n   #include <pthread.h>\n   int pthread_mutex_init(pthread_mutex_t *restrict mutex,\n          const pthread_mutexattr_t *restrict attr);  //动态初始化互斥量\n \n   int pthread_mutex_destroy(pthread_mutex_t *mutex); //动态互斥量销毁\n   pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //静态初始化互斥量\n   ````\n   `mutex` 为需要创建或销毁的互斥量；`attr` 为新建互斥量的属性，默认为 `PTHREAD_MUTEX_TIMED_NP`， 即普通锁。\n\n3. 加锁和解锁\n    ````C\n    int pthread_mutex_lock(pthread_mutex_t *mutex); ````\n    成功返回0，失败返回错误码。如果互斥量已经被锁住，那么会导致该线程阻塞。\n\n    ````C\n    int pthread_mutex_trylock(pthread_mutex_t *mutex);`````\n    成功返回0，失败返回错误码。如果互斥量已经被锁住，不会导致线程阻塞。\n\n   ````C\n   int pthread_mutex_unlock(pthread_mutex_t *mutex);````\n    成功返回0，失败返回错误码。如果一个互斥量没有被锁住，那么解锁就会出错。\n \n4. 死锁\n   死锁：线程一直在等待锁，而锁却无法解开。如果一个线程对已经占有的互斥量继续加锁，那么他就会陷入死锁状态。\n\n   **如何去避免死锁？**\n   你可以小心的控制互斥量加锁的顺序来避免死锁，例如所有的线程都在加锁B之前先加锁A，那么这两个互斥量就不会产生死锁了。有的时候程序写的多了互斥量就难以把控，你可以先释放已经占有的锁，然后再加锁其他互斥量。\n \n互斥量使用要注意：\n> \n1. 访问共享资源时需要加锁\n2. 互斥量使用完之后需要销毁\n3. 加锁之后一定要解锁\n4. 互斥量加锁的范围要小\n5. 互斥量的数量应该少\n\n### 2. 信号量\n这里说的信号量和前一篇说的信号量不同，这里的信号量来自 POSIX 的实时扩展，而之前的信号量来自于 System V。两者的函数接口相似，但是不用通用。这里的相关信号量函数都以 `sem_` 开头。相关的函数有四个：\n\n1. `sem_init` 函数\n   该函数用于创建信号量，其原型如下：\n   ````C\n   int sem_init(sem_t *sem, int pshared， unsigned int value);  ````\n   该函数初始化由 `sem` 指向的信号对象，设置它的共享选项，并给它一个初始的整数值。`pshared` 控制信号量的类型，如果其值为0，就表示这个信号量是当前进程的局部信号量，否则信号量就可以在多个进程之间共享，`value` 为 `sem` 的初始值。\n   调用成功时返回0，失败返回-1.\n\n2. `sem_wait` 函数\n   该函数用于以原子操作的方式将信号量的值减1。原子操作就是，如果两个线程企图同时给一个信号量加1或减1，它们之间不会互相干扰。它的原型如下：\n   ````C\n   int sem_wait(sem_t *sem);  ````\n   `sem` 指向的对象是由 `sem_init` 调用初始化的信号量。\n   调用成功时返回0，失败返回-1.\n\n3. `sem_post` 函数\n   该函数用于以原子操作的方式将信号量的值加1。它的原型如下：\n   ````C\n   int sem_post(sem_t *sem);  ````\n   与 `sem_wait` 一样，`sem` 指向的对象是由 `sem_init` 调用初始化的信号量。\n   调用成功时返回0，失败返回-1.\n\n4. `sem_destroy` 函数\n   该函数用于对用完的信号量的清理。它的原型如下：\n   ````C\n   int sem_destroy(sem_t *sem);  \n   成功时返回0，失败时返回-1.````\n\n### 3. 读写锁\n**什么是读写锁，它与互斥量的区别：**\n读写锁与互斥量类似，不过读写锁有更高的并行性。互斥量要么加锁要么不加锁，而且同一时刻只允许一个线程对其加锁。但是对于一个变量的读取，完全可以让多个线程同时进行操作。这时候读写锁更为实用。\n\n* 读写锁有三种状态，读模式下加锁，写模式下加锁，不加锁。相应的使用方法为：\n * 一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式的读写锁。 \n * 读写锁在写加锁状态时，在它被解锁之前，所有试图对这个锁加锁的线程都会阻塞。\n * 读写锁在读加锁状态时，所有试图以读模式对其加锁的线程都会获得访问权，但是如果线程希望以写模式对其加锁，它必须阻塞直到所有的线程释放锁。 \n * 读写锁在读加锁状态时，如果有线程试图以写模式对其加锁，那么读写锁会阻塞随后的读模式锁请求。这样可以避免读锁长期占用，而写锁达不到请求。\n\n读写锁非常适合对数据结构读次数大于写次数的程序，当它以读模式锁住时，是以共享的方式锁住的；当它以写模式锁住时，是以独占的模式锁住的。\n\n1. 读写锁的初始化和销毁\n   读写锁在使用之前必须初始化,使用完需要销毁。\n   ````C\n   int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,\n             const pthread_rwlockattr_t *restrict attr);\n   int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);````\n   成功返回0 ，失败返回错误码\n\n2. 加锁和解锁\n   读模式加锁    \n   ````C   \n   int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n   int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);````\n   写模式加锁\n   ````C\n   int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n   int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);````\n   解锁\n   ````C\n   int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);````\n   成功返回0\n \n### 3.  条件变量\n条件变量的引入：我们需要一种机制，当互斥量被锁住以后发现当前线程还是无法完成自己的操作，那么它应该释放互斥量，让其他线程工作。条件变量的作用就是可以采用轮询的方式，不停的让系统来帮你查询条件。\n\n1. 条件变量的初始化和销毁\n  条件变量使用之前需要初始化，条件变量使用完成之后需要销毁。\n  ````C\n  pthread_cond_t cond = PTHREAD_COND_INITIALIZER;    //静态初始化条件变量\n  int pthread_cond_init(pthread_cond_t *restrict cond,\n                        const pthread_condattr_t *restrict attr); //动态初始化条件变量\n  int pthread_cond_destroy(pthread_cond_t *cond);//销毁条件变量 ````\n  动态条件变量的初始化和销毁函数返回值都是成功返回0，失败返回错误代码。`attr` 的值一般为 `NULL`。详细的设置在下个章节。\n \n2. 条件变量的等待和唤醒\n  条件变量使用需要配合互斥量\n    1. 使用 `pthread_cond_wait` 等待条件变为真。传递给 `pthread_cond_wait` 的互斥量对条件进行保护，调用者把锁住的互斥量传递给函数。\n      这个函数将线程放到等待条件的线程列表上，然后对互斥量进行解锁，这是个原子操作。当条件满足时这个函数返回，返回以后继续对互斥量加锁。\n      ````C\n      int pthread_cond_wait(pthread_cond_t *restrict cond,\n                            pthread_mutex_t *restrict mutex);\n       int pthread_cond_timedwait(pthread_cond_t *restrict cond,\n                                  pthread_mutex_t *restrict mutex,\n                                  const struct timespec *restrict abstime);````\n       这个函数与 `pthread_cond_wait` 类似，只是多一个 `timeout`，如果到了指定的时间条件还不满足，那么就返回。\n       注意，这个时间是绝对时间。例如你要等待3分钟，就要把当前时间加上3分钟然后转换到 `timespec`，而不是直接将3分钟转换到 `timespec`。\n    4. 当条件满足的时候，需要唤醒等待条件的线程\n    ````C\n    int pthread_cond_broadcast(pthread_cond_t *cond); //唤醒等待条件的所有线程\n    int pthread_cond_signal(pthread_cond_t *cond);    //至少唤醒等待条件的某一个线程````\n    注意，**一定要在条件改变以后在唤醒线程。**\n\n3. 条件变量的使用\n   条件变量主要使用在那些需要条件触发的场景。譬如，一个经典的生产者消费者的问题。消费者等待生产者生产，如果单纯的使用互斥量，当然也可以解决问题，但是在生产者没有生产的时候，消费者就需要不停的轮询，大大浪费了CPU资源。我们更期待的是等生产者生产后\"通知\"我们的消费者，所以我们使用条件变量：\n   生产者线程的执行顺序是：加锁 -> 生产 -> `pthread_cond_signal` -> 释放锁\n   消费者线程的执行顺寻是：加锁 -> while(没有生产) `pthread_cond_wait`; 当没有商品存在的时候，进入条件变量，此时条件变量首先释放了锁，然后阻塞等待 `pthread_cond_signal` 信号的发送，接收到信号之后，申请锁，`pthread_cond_wait`结束， -> 执行相应的程序 -> 释放锁。\n    \n## 六、线程的控制\n### 1. 线程属性\n\n线程的属性用 `pthread_attr_t` 类型的结构表示，在创建线程的时候可以不用传入NULL，而是传入一个 `pthread_attr_t` 结构，由用户自己来配置线程的属性。`pthread_attr_t` 结构中定义的线程属性有很多：\n\n|名称|描述|\n|---|----|\n|detachstate|\t线程的分离状态|\n|guardsize|\t线程栈末尾的警戒区域大小（字节数）|\n|stacksize|\t线程栈的最低地址|\n|stacksize|\t线程栈的大小（字节数）|\n\n1. 线程属性的初始化和销毁\n   线程的初始化和销毁使用下面两个函数：\n   ````C\n   int pthread_attr_init(pthread_attr_t *attr);     //线程属性初始化\n   int pthread_attr_destroy(pthread_attr_t *attr);  //线程属性销毁````\n   如果在调用 `pthread_attr_init` 初始化属性的时候分配了内存空间，那么 `pthread_attr_destroy` 将释放内存空间。除此之外，`pthread_atty_destroy` 还会用无效的值初始化 `pthread_attr_t` 对象，因此如果该属性对象被误用，会导致创建线程失败。`pthread_attr_t` 类型对应用程序是不透明的，也就是说应用程序不需要了解有关属性对象内部结构的任何细节，因而可以增加程序的可移植性。\n\n\n2. 线程的分离属性\n   线程的分离属性已经在前面的章节介绍过了，如果在创建线程的时候就知道不需要了解线程的终止状态，那么可以修改 `pthread_attr_t` 结构体的 `detachstate` 属性，让线程以分离状态启动。线程的分离属性有两种合法值:\n   `PTHREAD_CREATE_DETACHED` 分离的；\n   `PTHREAD_CREATE_JOINABLE` 非分离的，可连接的；\n   设置线程分离属性的步骤\n    1. 定义线程属性变量 `pthread_attr_t attr`\n    2. 初始化 `attr` ，`pthread_attr_init(&attr)`\n    3. 设置线程为分离或非分离 `pthread_attr_setdetachstate(&attr, detachstate)`\n    4. 创建线程 `pthread_create（&tid， &attr， thread_fun,  NULL）`\n\n3. 线程的栈属性\n   对一个进程，他的虚拟空间的大小是固定的，如果程序启动了大量的线程，因为所有的线程共享进程的的虚拟地址空间，所以按照默认的栈大小，虚拟空间就会不足，需要调小栈空间。或者某个线程使用了大量的自动变量，这时候需要调大栈空间，具体的分配使用不再详说，介绍下相关的函数：\n   ````C\n   int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);   //修改栈属性\n   int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize); //获取栈属性\n   int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);                //单独设置栈属性\n   int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);               //单独获取栈属性\n   int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);                //单独设置栈属性\n   int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);               //单独获取栈属性\n   ````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n   对于遵循POSIX标准的系统来说，不一定要支持线程的栈属性，因此你需要检查\n     1. 在编译阶段使用       \n        `_POSIX_THREAD_ATTR_STACKADDR` 和 `_POSIX_THREAD_ATTR_STACKSIZE` 符号来检查系统是否支持线程栈属性。\n     2. 在运行阶段把\n        `_SC_THREAD_ATTR_STACKADD` 和 `_SC_THREAD_THREAD_ATTR_STACKSIZE` 传递给 `sysconf` 函数检查系统对线程栈属性的支持。\n\n4. 线程的其他属性：\n   线程还有一些属性没有在 `pthread_attr_t` 结构体中定义，如已经在上面介绍过的线程的取消状态和线程的取消类型，还有没有介绍的线程的并发度，这些就不再详细描述。\n   \n### 2. 同步属性\n\n1. **互斥量的属性**\n   就像线程有属性一样，线程的同步互斥量也有属性，比较重要的是进程共享属性和类型属性。互斥量的属性用 `pthread_mutexattr_t` 类型的数据表示，当然在使用之前必须进行初始化，使用完成之后需要进行销毁：\n   ````C\n   int pthread_mutexattr_init(pthread_mutexattr_t *attr);    //互斥量属性初始化\n   int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); //互斥量属性销毁\n   int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr, \n                                     int *restrict pshared); //获取互斥量属性\n   int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, \n                                    int pshared);            //设置互斥量属性````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n   互斥量属性的相关的值有：\n   * `PTHREAD_MUTEX_TIMED_NP`，缺省值，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。\n   * `PTHREAD_MUTEX_RECURSIVE_NP`，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。\n   * `PTHREAD_MUTEX_ERRORCHECK_NP`，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。\n   * `PTHREAD_MUTEX_ADAPTIVE_NP`，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。\n \n4. **读写锁的属性**\n   读写锁也有属性，它只有一个进程共享属性:\n   ````C\n   int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);\n   int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);\n   int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr, int *restrict pshared);\n   int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared); ````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n\n5. **条件变量的属性**\n   条件变量也有进程共享属性:\n   ````C\n   int pthread_condattr_destroy(pthread_condattr_t *attr);\n   int pthread_condattr_init(pthread_condattr_t *attr);\n   int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr, int *restrict pshared);\n   int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n\n### 3. 私有数据\n应用程序设计中有必要提供一种变量，使得多个函数多个线程都可以访问这个变量（看起来是个全局变量），但是线程对这个变量的访问都不会彼此产生影响（貌似不是全局变量哦），但是你需要这样的数据，比如 `errno`。那么这种数据就是线程的私有数据，尽管名字相同，但是每个线程访问的都是数据的副本。\n \n在使用私有数据之前，你首先要创建一个与私有数据相关的键，要来获取对私有数据的访问权限 。这个键的类型是 `pthread_key_t`:\n````C\nint pthread_key_create(pthread_key_t *key, void (*destructor)(voi8d*));````\n\n创建的键放在key指向的内存单元，`destructor` 是与键相关的析构函数。当线程调用 `pthread_exit` 或者使用 `return` 返回，析构函数就会被调用。当析构函数调用的时候，它只有一个参数，这个参数是与key关联的那个数据的地址，因此你可以在析构函数中将这个数据销毁。\n\n键使用完之后也可以删除，当键删除之后，与它关联的数据并没有销毁:\n````C\nint pthread_key_delete(pthread_key_t key);````\n \n有了键之后，你就可以将私有数据和键关联起来，这样就就可以通过键来找到数据。所有的线程都可以访问这个键，但他们可以为键关联不同的数据。\n````C\nint pthread_setspecific(pthread_key_t key, const void *value);````\n将私有数据与key关联\n\n````C\nvoid *pthread_getspecific(pthread_key_t key);````\n获取私有数据的地址，如果没有数据与key关联，那么返回空。\n\n有些事需要且只能执行一次（比如互斥量初始化）。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库函数时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始（`pthread_once_t`）会比较容易些。\n \n* 首先要定义一个 `pthread_once_t`变量，这个变量要用宏 `PTHREAD_ONCE_INIT` 初始化。然后创建一个与控制变量相关的初始化函数\n  ````C\n  pthread_once_t once_control = PTHREAD_ONCE_INIT;\n  void init_routine（）\n  {\n   //初始化互斥量\n   //初始化读写锁\n   ......\n  }````\n \n* 接下来就可以在任何时刻调用pthread_once函数\n  ````C\n  int pthread_once(pthread_once_t* once_control, void (*init_routine)(void));````\n  功能：本函数使用初值为 `PTHREAD_ONCE_INIT` 的 `once_control` 变量保证 `init_routine()` 函数在本进程执行序列中仅执行一次。在多线程编程环境下，尽管`pthread_once()` 调用会出现在多个线程中，`init_routine()` 函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。\"一次性函数\"的执行状态有三种：`NEVER（0）`. `IN_PROGRESS（1）`. `DONE （2）`，用 `once_control` 来表示 `pthread_once()` 的执行状态：\n  1. 如果 `once_control` 初值为0，那么 `pthread_once` 从未执行过，`init_routine()` 函数会执行。\n  2. 如果 `once_control` 初值设为1，则由于所有 `pthread_once()` 都必须等待其中一个激发\"已执行一次\"信号， 因此所有 `pthread_once ()` 都会陷入永久的等待中，`init_routine()` 就无法执行\n  3. 如果 `once_control` 设为2，则表示 `pthread_once()` 函数已执行过一次，从而所有 `pthread_once()`都会立即返回，`init_routine()`就没有机会执行。当pthread_once函数成功返回，once_control就会被设置为2\n\n###  4. 线程的信号\n在线程中使用信号，与在进程中使用信号机制有着根本的区别。在进程环境中，对信号的处理是异步的（我们完全不知到信号会在进程的那个执行点到来！）。但是在多线程中处理信号的原则完全不同，它的基本原则是：将对信号的异步处理，转换成同步处理，也就是说用一个线程专门的来“同步等待”信号的到来，而其它的线程可以完全不被该信号中断/打断(interrupt)。\n\n* 信号的发送\n  线程中信号的发送并不使用 `kill()` 函数，而是有专门的进程信号函数：\n  ````C\n  #include <pthread.h> \n  int pthread_kill(pthread_t thread, int sig);````\n  功能：向指定ID的线程发送信号。\n  参数：`thread` 进程标识符，`sig` 发送的信号。\n\n  如果线程代码内不做处理，则按照信号默认的行为影响整个进程，也就是说，如果你给一个线程发送了 `SIGQUIT` ，但线程却没有实现 `signal` 处理函数，则整个进程退出。如果要获得正确的行为，就需要在线程内实现 `signal(SIGKILL,sig_handler)` 了。所以，如果 `sig` 不是0，那一定要清楚到底要干什么，而且一定要实现线程的信号处理函数，否则，就会影响整个进程。如果 `sig` 是0，这是一个保留信号，其实并没有发送信号，作用是用来判断线程是不是还活着。\n\n* 信号的接收\n  在多线程代码中，总是使用 `sigwait` 或者 `sigwaitinfo` 或者 `sigtimedwait` 等函数来处理信号。而不是 `signal` 或者 `sigaction` 等函数。因为在一个线程中调用 `signal` 或者 `sigaction` 等函数会改变所以线程中的信号处理函数。而不是仅仅改变调用 `signal`/`sigaction` 的那个线程的信号处理函数。\n\n### 5. 线程与fork\n当线程调用 `fork()` 函数时，就为子进程创建了整个进程地址空间的副本，子进程通过继承整个地址空间的副本，也会将父进程的互斥量、读写锁、条件变量的状态继承过来。也就是说，如果父进程调用 `fork()` 的线程中占有锁，那么在子进程中也占有锁，这是非常不安全的，因为不是子进程自己锁住的，它无法解锁。\n \n子进程内部只有一个线程，由父进程中调用 `fork()` 函数的线程副本构成。如果调用 `fork()` 的线程将互斥量锁住，那么子进程会拷贝一个 `pthread_mutex_lock` 副本，这样子进程就有机会去解锁了。或者互斥量根本就没被加锁，这样也是可以的，但是你不能确保永远是这样的情况。\n \n`pthread_atfork` 函数给你创造了这样的条件，它会注册三个函数\n````C\nint pthread_atfork(void (*prepare)(void);\n                   void (*parent)(void); \n                   void (*child)(void));````\n`prepare` 是在 `fork()` 调用之前会被调用的，他的任务是获取所有父进程中定义的锁。\n`parent` 在 `fork()` 创建了子进程但返回之前在父进程中调用，他的任务是对所有 `prepare` 中获取的锁解锁。\n`child` 在 `fork()` 创建了子进程但返回之前在子进程中调用，他的任务是对所有 `prepare` 中获取的锁解锁。\n\n \n\n","source":"_posts/Linux学习总结08.md","raw":"---\ntitle: Linux学习总结（八）——线程\ndate: 2016-12-18 11:52:36\ncategories: Linux学习记录\ntags: [线程, 条件变量, 线程属性, 互斥锁]\n---\n\n进程，它是资源分配的最小单位，进程中的事情需要按照一定的顺序逐个进行，那么：**如何让一个进程中的一些事情同时执行？**\n<!--more-->\n\n这时候就需要使用线程。**线程**，有时又称轻量级进程，它是 **程序执行的最小单位**，**系统独立调度和分派 cpu 的基本单位**，它是**进程中的一个实体**。一个进程中可以有多个线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。\n\n在了解线程之前需要清楚几个概念：\n1. **并发**\n并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。 **看起来同时发生**\n1. **并行**\n并行是指在同一时刻，有多条指令在多个处理器上同时执行。**真正的同时发生**\n1. **同步**\n彼此有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情。\n1. **异步**\n异步的概念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生。\n\n\n线程解决了进程的很多弊端：一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此，线程具有以下优势：\n> 1、在多处理器中开发程序的并行性\n    2、在等待慢速IO操作时，程序可以执行其他操作，提高并发性\n    3、模块化的编程，能更清晰的表达程序中独立事件的关系，结构清晰\n    4、占用较少的系统资源\n\n\n## 一、线程的创建：\n每个 Linux 都会运行在下面四种状态下：\n* 就绪\n 当线程刚被创建时就处于就绪状态，或者当线程被解除阻塞以后也会处于就绪状态。就绪的线程在等待一个可用的处理器，当一个运行的线程被抢占时，它立刻又回到就绪状态\n* 运行\n 当处理器选中一个就绪的线程执行时，它立刻变成运行状态\n* 阻塞\n 线程会在以下情况下发生阻塞：试图加锁一个已经被锁住的互斥量，等待某个条件变量，调用singwait等待尚未发生的信号，执行无法完成的I/O信号，由于内存页错误。\n* 终止\n 线程可以在启动函数中返回来终止自己，或者调用 `pthread_exit` 退出，或者取消线程。\n\n### 1. 线程ID\n我们首先来看下线程的创建，线程的创建使用的是 `pthread_create` 函数:\n````C++\n#include <pthread.h>\nint pthread_create (pthread_t *thread,\n                    pthread_attr_t *attr,\n                    void *(*start_routine)(void *),\n                    void *arg);````\n功能：创建一个线程。\n第一个参数 `thread`：新线程的id，如果成功则新线程的id回填充到tidp指向的内存\n第二个参数 `attr`：线程属性（调度策略，继承性，分离性...）\n第三个参数 `start_routine`：回调函数（新线程要执行的函数）\n第四个参数 `arg`：回调函数的参数\n返回值：成功返回0，失败则返回错误码\n\n当线程被创建时，`thread` 被写入一个标识符，我们使用这个标识符来引用被创建的线程。`attr` 可以用来详细设定线程的属性，一般为 `NULL`，我们会在本篇博客的最后详细介绍线程的属性，`start_routine` 指向了一个函数地址，我们可以定义任意一个具有一个任意类型的参数并返回任意一个返回值的函数作为线程的执行函数，最后一个 `arg` 传入了该函数的参数。需要注意的是：\n> 编译时需要连接库 `libpthread`。\n新线程可能在当前线程从函数 `pthread_create` 返回之前就已经运行了，甚至新线程可能在当前线程从函数 `pthread_create` 返回之前就已经运行完毕了。\n\n对于一个线程，可以使用 `pthread_self()` 函数来获取自己的线程号。\n````C++\n#include <pthread.h>\nint pthread_self (void);````\n功能：返回当前线程的线程 id。\n返回值：调用线程的线程ID。\n\n还有一个函数是 `pthread_equal()` 可以用来判断两个线程ID 是否一致。\n````C++\n#include <pthread.h>\nint pthread_equal (pthread_t tid1, pthread_t tid2);````\n功能：功能判断两个线程ID是否一致。\n参数：`tid1` `tid2` 需要判断的ID\n返回值：相等返回非0值，不相等返回0.\n\n这样，主线程可以将工作任务放在一个队列中，并将每个任务添加一个进程ID标识，这样相应的线程使用上面两个函数就可以取出和自己相关的任务。\n\n\n### 2. 初始线程/主线程\n当c程序运行时，首先运行 `main` 函数。在线程代码中，这个特殊的执行流被称作初始线程或者主线程。你可以在初始线程中做任何普通线程可以做的事情。主线程的特殊性在于:\n* 它在 `main` 函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用 `pthread_exit` 函数，这样进程就会等待所有线程结束时才终止。\n* 主线程接受参数的方式是通过 `argc` 和 `argv`，而普通的线程只有一个参数 `void*`。\n* 在绝大多数情况下，主线程在默认堆栈上运行，这个堆栈可以增长到足够的长度。而普通线程的堆栈是受限制的，一旦溢出就会产生错误。\n \n## 二、线程的运行\n### 1. 线程的退出\n退出线程使用的是 `pthread_exit`，需要注意的是：线程函数不能使用 `exit()` 退出，`exit`是危险的：如果进程中的任意一个线程调用了 `exit`，`_Exit`，`_exit`，那么整个进程就会终止，普通的单个线程以以下三种方式退出，不会终止进程：\n 1. 从启动函数中返回，返回值是线程的退出码。\n 2. 线程可以被同一进程中的其他线程取消。\n 3. 线程调用 `pthread_exit()` 函数。\n \n````C\n#include <pthread.h>\n void pthread_exit(void *rval);````\n 功能：退出一个线程。\n 参数：`rval` 是个无类型的指针，保存线程的退出码，其他线程可以通过 `pthread_join()` 函数来接收这个值。\n \n### 2. 线程的回收\n类似于进程的 `wait()` 函数，线程也有相应的机制，称为线程的回收，和这个机制紧密相关的一个概念是线程的**分离属性**。\n\n**线程的分离属性：** \n > 分离一个正在运行的线程并不影响它，仅仅是通知当前系统该线程结束时，其所属的资源可以回收。\n 一个没有被分离的线程在终止时会保留它的虚拟内存，包括他们的堆栈和其他系统资源，有时这种线程被称为**僵尸线程**。\n 创建线程时**默认是非分离的**。\n\n如果线程具有分离属性，线程终止时会被立刻回收，回收将释放掉所有在线程终止时未释放的系统资源和进程资源，包括保存线程返回值的内存空间、堆栈、保存寄存器的内存空间等。\n终止被分离的线程会释放所有的系统资源，但是你必须释放由该线程占有的程序资源。由 `malloc()` 或者 `mmap()` 分配的内存可以在任何时候由任何线程释放，条件变量、互斥量、信号灯可以由任何线程销毁，只要他们被解锁了或者没有线程等待。但是只有互斥量的主人才能解锁它，所以**在线程终止前，你需要解锁互斥量**。\n\n将已创建的线程设置为分离的有两种方式：\n* 调用 `pthread_detach()` 这个函数，那么当这个线程终止的时候，和它相关的系统资源将被自动释放。\n  ````C\n  #include <pthread.h>\n  int pthread_detach(pthread_t thread);````\n  功能：分离一个线程，线程可以自己分离自己。\n  参数：`thread` 指定线程的 id。\n  返回值：成功返回0，失败返回错误码\n \n* 调用 `pthread_join` 会使指定的线程处于分离状态()，如果指定线程已经处于分离状态，那么调用就会失败。\n  ````C\n  #include <pthread.h>\n  int pthread_join(pthead_t tid, void **rval);````\n  功能：调用该函数的线程会一直阻塞，直到指定的线程 `tid` 调用 `pthread_exit`、从启动函数返回或者被取消。\n  参数：参数 `tid` 就是指定线程的 `id`，参数 `rval` 是指定线程的返回码，如果线程被取消，那么 `rval` 被置为 `PTHREAD_CANCELED`\n  返回值：该函数调用成功会返回0，失败返回错误码\n\n\n### 3. 线程的取消\n线程的取消类似于一个线程向另一个线程发送了一个信号，要求它终止，相应的取消函数很简单：\n````C\n#include <pthread.h>\nint pthread_cancle(pthread_t tid);````\n功能：请求一个线程终止\n参数：`tid` 指定的线程\n返回值：成功返回0，失败返回错误码。\n\n取消只是发送一个请求，并不意味着等待线程终止，而且发送成功也不意味着 `tid` 一定会终止，它通常需要被取消线程的配合。线程在很多时候会查看自己取消状态，如果有就主动退出， 这些查看是否有取消的地方称为取消点\n \n这时候，我们又有了两个概念：**取消状态**，**取消点**。\n \n * 取消状态\n   取消状态，就是线程对取消信号的处理方式，忽略或者响应。线程创建时默认响应取消信号，相应的设置函数为：\n   ````C\n   #include <pthread.h> \n   int pthread_setcancelstate(int state, int *oldstate);````\n   功能：设置本线程对取消请求(CANCEL 信号)的反应\n   参数：`state` 有两种值：`PTHREAD_CANCEL_ENABLE`（缺省，接收取消请求）和 `PTHREAD_CANCEL_DISABLE`(忽略取消请求)；`old_state` 如果不为NULL则存入原来的Cancel状态以便恢复\n   返回值：成功返回0，失败返回错误码。\n\n   如果函数设置为接收取消请求，还可以设置他的**取消类型**:\n   取消类型，是线程对取消信号的响应方式，立即取消或者延时取消。线程创建时默认延时取消\n   ````C\n   #include <pthread.h> \n   int pthread_setcanceltype(int type, int *oldtype) ;````\n   功能：设置本线程取消动作的执行时机\n   参数：`type` 由两种取值：`PTHREAD_CANCEL_DEFFERED` 表示收到信号后继续运行至下一个取消点再退出， `PTHREAD_CANCEL_ASYCHRONOUS` 标识立即执行取消动作（退出）；两者仅当 Cancel 状态为 Enable 时有效；`oldtype` 如果不为NULL则存入运来的取消动作类型值。\n   返回值：成功返回0，失败则返回错误码\n \n * 取消点\n   取消点：取消一个线程，默认需要被取消线程的配合。线程在很多时候会查看自己是否有取消请求，如果有就主动退出， 这些查看是否有取消的地方称为取消点。很多地方都是包含取消点，包括 `pthread_join()`、 `pthread_testcancel()`、`pthread_cond_wait()`、 `pthread_cond_timedwait()`、`sem_wait()`、`sigwait()` 以及 `write`、`read` 等大多数会阻塞的系统调用。\n\n \n### 4. 线程的清除\n线程可以安排它退出时的清理操作，这与进程的可以用atexit函数安排进程退出时需要调用的函数类似。这样的函数称为线程清理处理程序。线程可以建立多个清理处理程序，处理程序记录在栈中，所以这些处理程序执行的顺序与他们注册的顺序相反\n````C\n#include <pthread.h> \nvoid pthread_cleanup_push（void （*rtn）（void*）， void *args）//注册处理程序\nvoid pthread_cleanup_pop（int excute）//清除处理程序````\n \n当执行以下操作时调用清理函数，清理函数的参数由 `args` 传入\n1. 调用 `pthread_exit`\n2. 响应取消请求\n3. 用非零参数调用 `pthread_cleanup_pop`\n\n**`return` 不调用清理操作**。\n\n\n## 五、线程的同步\n有几种方法可以很好的控制线程执行和访问临界区域，主要是互斥量和信号量。\n\n### 1. 互斥量\n * 为什么要使用互斥量？\n当多个线程共享相同的内存时，需要每一个线程看到相同的视图。当一个线程修改变量时，而其他线程也可以读取或者修改这个变量，就需要对这些线程同步，确保他们不会访问到无效的变量。\n为了让线程访问数据不产生冲突，这要就需要对变量加锁，使得同一时刻只有一个线程可以访问变量。互斥量本质就是锁，访问共享资源前对互斥量加锁，访问完成后解锁。\n当互斥量加锁以后，其他所有需要访问该互斥量的线程都将阻塞，当互斥量解锁以后，所有因为这个互斥量阻塞的线程都将变为就绪态，第一个获得cpu的线程会获得互斥量，变为运行态，而其他线程会继续变为阻塞，在这种方式下访问互斥量每次只有一个线程能向前执行. \n\n\n1. 互斥量的初始化和销毁\n\n   互斥量用 `pthread_mutex_t` 类型的数据表示，在使用之前需要对互斥量初始化\n   * 如果是动态分配的互斥量，可以调用 `pthread_mutex_init()`函数初始化\n   * 如果是静态分配的互斥量，还可以把它置为常量 `PTHREAD_MUTEX_INITIALIZER`\n   * 动态分配的互斥量在释放内存之前需要调用 `pthread_mutex_destroy()`\n\n  相应的处理函数为\n   ````C\n   #include <pthread.h>\n   int pthread_mutex_init(pthread_mutex_t *restrict mutex,\n          const pthread_mutexattr_t *restrict attr);  //动态初始化互斥量\n \n   int pthread_mutex_destroy(pthread_mutex_t *mutex); //动态互斥量销毁\n   pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //静态初始化互斥量\n   ````\n   `mutex` 为需要创建或销毁的互斥量；`attr` 为新建互斥量的属性，默认为 `PTHREAD_MUTEX_TIMED_NP`， 即普通锁。\n\n3. 加锁和解锁\n    ````C\n    int pthread_mutex_lock(pthread_mutex_t *mutex); ````\n    成功返回0，失败返回错误码。如果互斥量已经被锁住，那么会导致该线程阻塞。\n\n    ````C\n    int pthread_mutex_trylock(pthread_mutex_t *mutex);`````\n    成功返回0，失败返回错误码。如果互斥量已经被锁住，不会导致线程阻塞。\n\n   ````C\n   int pthread_mutex_unlock(pthread_mutex_t *mutex);````\n    成功返回0，失败返回错误码。如果一个互斥量没有被锁住，那么解锁就会出错。\n \n4. 死锁\n   死锁：线程一直在等待锁，而锁却无法解开。如果一个线程对已经占有的互斥量继续加锁，那么他就会陷入死锁状态。\n\n   **如何去避免死锁？**\n   你可以小心的控制互斥量加锁的顺序来避免死锁，例如所有的线程都在加锁B之前先加锁A，那么这两个互斥量就不会产生死锁了。有的时候程序写的多了互斥量就难以把控，你可以先释放已经占有的锁，然后再加锁其他互斥量。\n \n互斥量使用要注意：\n> \n1. 访问共享资源时需要加锁\n2. 互斥量使用完之后需要销毁\n3. 加锁之后一定要解锁\n4. 互斥量加锁的范围要小\n5. 互斥量的数量应该少\n\n### 2. 信号量\n这里说的信号量和前一篇说的信号量不同，这里的信号量来自 POSIX 的实时扩展，而之前的信号量来自于 System V。两者的函数接口相似，但是不用通用。这里的相关信号量函数都以 `sem_` 开头。相关的函数有四个：\n\n1. `sem_init` 函数\n   该函数用于创建信号量，其原型如下：\n   ````C\n   int sem_init(sem_t *sem, int pshared， unsigned int value);  ````\n   该函数初始化由 `sem` 指向的信号对象，设置它的共享选项，并给它一个初始的整数值。`pshared` 控制信号量的类型，如果其值为0，就表示这个信号量是当前进程的局部信号量，否则信号量就可以在多个进程之间共享，`value` 为 `sem` 的初始值。\n   调用成功时返回0，失败返回-1.\n\n2. `sem_wait` 函数\n   该函数用于以原子操作的方式将信号量的值减1。原子操作就是，如果两个线程企图同时给一个信号量加1或减1，它们之间不会互相干扰。它的原型如下：\n   ````C\n   int sem_wait(sem_t *sem);  ````\n   `sem` 指向的对象是由 `sem_init` 调用初始化的信号量。\n   调用成功时返回0，失败返回-1.\n\n3. `sem_post` 函数\n   该函数用于以原子操作的方式将信号量的值加1。它的原型如下：\n   ````C\n   int sem_post(sem_t *sem);  ````\n   与 `sem_wait` 一样，`sem` 指向的对象是由 `sem_init` 调用初始化的信号量。\n   调用成功时返回0，失败返回-1.\n\n4. `sem_destroy` 函数\n   该函数用于对用完的信号量的清理。它的原型如下：\n   ````C\n   int sem_destroy(sem_t *sem);  \n   成功时返回0，失败时返回-1.````\n\n### 3. 读写锁\n**什么是读写锁，它与互斥量的区别：**\n读写锁与互斥量类似，不过读写锁有更高的并行性。互斥量要么加锁要么不加锁，而且同一时刻只允许一个线程对其加锁。但是对于一个变量的读取，完全可以让多个线程同时进行操作。这时候读写锁更为实用。\n\n* 读写锁有三种状态，读模式下加锁，写模式下加锁，不加锁。相应的使用方法为：\n * 一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式的读写锁。 \n * 读写锁在写加锁状态时，在它被解锁之前，所有试图对这个锁加锁的线程都会阻塞。\n * 读写锁在读加锁状态时，所有试图以读模式对其加锁的线程都会获得访问权，但是如果线程希望以写模式对其加锁，它必须阻塞直到所有的线程释放锁。 \n * 读写锁在读加锁状态时，如果有线程试图以写模式对其加锁，那么读写锁会阻塞随后的读模式锁请求。这样可以避免读锁长期占用，而写锁达不到请求。\n\n读写锁非常适合对数据结构读次数大于写次数的程序，当它以读模式锁住时，是以共享的方式锁住的；当它以写模式锁住时，是以独占的模式锁住的。\n\n1. 读写锁的初始化和销毁\n   读写锁在使用之前必须初始化,使用完需要销毁。\n   ````C\n   int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,\n             const pthread_rwlockattr_t *restrict attr);\n   int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);````\n   成功返回0 ，失败返回错误码\n\n2. 加锁和解锁\n   读模式加锁    \n   ````C   \n   int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n   int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);````\n   写模式加锁\n   ````C\n   int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n   int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);````\n   解锁\n   ````C\n   int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);````\n   成功返回0\n \n### 3.  条件变量\n条件变量的引入：我们需要一种机制，当互斥量被锁住以后发现当前线程还是无法完成自己的操作，那么它应该释放互斥量，让其他线程工作。条件变量的作用就是可以采用轮询的方式，不停的让系统来帮你查询条件。\n\n1. 条件变量的初始化和销毁\n  条件变量使用之前需要初始化，条件变量使用完成之后需要销毁。\n  ````C\n  pthread_cond_t cond = PTHREAD_COND_INITIALIZER;    //静态初始化条件变量\n  int pthread_cond_init(pthread_cond_t *restrict cond,\n                        const pthread_condattr_t *restrict attr); //动态初始化条件变量\n  int pthread_cond_destroy(pthread_cond_t *cond);//销毁条件变量 ````\n  动态条件变量的初始化和销毁函数返回值都是成功返回0，失败返回错误代码。`attr` 的值一般为 `NULL`。详细的设置在下个章节。\n \n2. 条件变量的等待和唤醒\n  条件变量使用需要配合互斥量\n    1. 使用 `pthread_cond_wait` 等待条件变为真。传递给 `pthread_cond_wait` 的互斥量对条件进行保护，调用者把锁住的互斥量传递给函数。\n      这个函数将线程放到等待条件的线程列表上，然后对互斥量进行解锁，这是个原子操作。当条件满足时这个函数返回，返回以后继续对互斥量加锁。\n      ````C\n      int pthread_cond_wait(pthread_cond_t *restrict cond,\n                            pthread_mutex_t *restrict mutex);\n       int pthread_cond_timedwait(pthread_cond_t *restrict cond,\n                                  pthread_mutex_t *restrict mutex,\n                                  const struct timespec *restrict abstime);````\n       这个函数与 `pthread_cond_wait` 类似，只是多一个 `timeout`，如果到了指定的时间条件还不满足，那么就返回。\n       注意，这个时间是绝对时间。例如你要等待3分钟，就要把当前时间加上3分钟然后转换到 `timespec`，而不是直接将3分钟转换到 `timespec`。\n    4. 当条件满足的时候，需要唤醒等待条件的线程\n    ````C\n    int pthread_cond_broadcast(pthread_cond_t *cond); //唤醒等待条件的所有线程\n    int pthread_cond_signal(pthread_cond_t *cond);    //至少唤醒等待条件的某一个线程````\n    注意，**一定要在条件改变以后在唤醒线程。**\n\n3. 条件变量的使用\n   条件变量主要使用在那些需要条件触发的场景。譬如，一个经典的生产者消费者的问题。消费者等待生产者生产，如果单纯的使用互斥量，当然也可以解决问题，但是在生产者没有生产的时候，消费者就需要不停的轮询，大大浪费了CPU资源。我们更期待的是等生产者生产后\"通知\"我们的消费者，所以我们使用条件变量：\n   生产者线程的执行顺序是：加锁 -> 生产 -> `pthread_cond_signal` -> 释放锁\n   消费者线程的执行顺寻是：加锁 -> while(没有生产) `pthread_cond_wait`; 当没有商品存在的时候，进入条件变量，此时条件变量首先释放了锁，然后阻塞等待 `pthread_cond_signal` 信号的发送，接收到信号之后，申请锁，`pthread_cond_wait`结束， -> 执行相应的程序 -> 释放锁。\n    \n## 六、线程的控制\n### 1. 线程属性\n\n线程的属性用 `pthread_attr_t` 类型的结构表示，在创建线程的时候可以不用传入NULL，而是传入一个 `pthread_attr_t` 结构，由用户自己来配置线程的属性。`pthread_attr_t` 结构中定义的线程属性有很多：\n\n|名称|描述|\n|---|----|\n|detachstate|\t线程的分离状态|\n|guardsize|\t线程栈末尾的警戒区域大小（字节数）|\n|stacksize|\t线程栈的最低地址|\n|stacksize|\t线程栈的大小（字节数）|\n\n1. 线程属性的初始化和销毁\n   线程的初始化和销毁使用下面两个函数：\n   ````C\n   int pthread_attr_init(pthread_attr_t *attr);     //线程属性初始化\n   int pthread_attr_destroy(pthread_attr_t *attr);  //线程属性销毁````\n   如果在调用 `pthread_attr_init` 初始化属性的时候分配了内存空间，那么 `pthread_attr_destroy` 将释放内存空间。除此之外，`pthread_atty_destroy` 还会用无效的值初始化 `pthread_attr_t` 对象，因此如果该属性对象被误用，会导致创建线程失败。`pthread_attr_t` 类型对应用程序是不透明的，也就是说应用程序不需要了解有关属性对象内部结构的任何细节，因而可以增加程序的可移植性。\n\n\n2. 线程的分离属性\n   线程的分离属性已经在前面的章节介绍过了，如果在创建线程的时候就知道不需要了解线程的终止状态，那么可以修改 `pthread_attr_t` 结构体的 `detachstate` 属性，让线程以分离状态启动。线程的分离属性有两种合法值:\n   `PTHREAD_CREATE_DETACHED` 分离的；\n   `PTHREAD_CREATE_JOINABLE` 非分离的，可连接的；\n   设置线程分离属性的步骤\n    1. 定义线程属性变量 `pthread_attr_t attr`\n    2. 初始化 `attr` ，`pthread_attr_init(&attr)`\n    3. 设置线程为分离或非分离 `pthread_attr_setdetachstate(&attr, detachstate)`\n    4. 创建线程 `pthread_create（&tid， &attr， thread_fun,  NULL）`\n\n3. 线程的栈属性\n   对一个进程，他的虚拟空间的大小是固定的，如果程序启动了大量的线程，因为所有的线程共享进程的的虚拟地址空间，所以按照默认的栈大小，虚拟空间就会不足，需要调小栈空间。或者某个线程使用了大量的自动变量，这时候需要调大栈空间，具体的分配使用不再详说，介绍下相关的函数：\n   ````C\n   int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);   //修改栈属性\n   int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize); //获取栈属性\n   int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);                //单独设置栈属性\n   int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);               //单独获取栈属性\n   int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);                //单独设置栈属性\n   int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);               //单独获取栈属性\n   ````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n   对于遵循POSIX标准的系统来说，不一定要支持线程的栈属性，因此你需要检查\n     1. 在编译阶段使用       \n        `_POSIX_THREAD_ATTR_STACKADDR` 和 `_POSIX_THREAD_ATTR_STACKSIZE` 符号来检查系统是否支持线程栈属性。\n     2. 在运行阶段把\n        `_SC_THREAD_ATTR_STACKADD` 和 `_SC_THREAD_THREAD_ATTR_STACKSIZE` 传递给 `sysconf` 函数检查系统对线程栈属性的支持。\n\n4. 线程的其他属性：\n   线程还有一些属性没有在 `pthread_attr_t` 结构体中定义，如已经在上面介绍过的线程的取消状态和线程的取消类型，还有没有介绍的线程的并发度，这些就不再详细描述。\n   \n### 2. 同步属性\n\n1. **互斥量的属性**\n   就像线程有属性一样，线程的同步互斥量也有属性，比较重要的是进程共享属性和类型属性。互斥量的属性用 `pthread_mutexattr_t` 类型的数据表示，当然在使用之前必须进行初始化，使用完成之后需要进行销毁：\n   ````C\n   int pthread_mutexattr_init(pthread_mutexattr_t *attr);    //互斥量属性初始化\n   int pthread_mutexattr_destroy(pthread_mutexattr_t *attr); //互斥量属性销毁\n   int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr, \n                                     int *restrict pshared); //获取互斥量属性\n   int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, \n                                    int pshared);            //设置互斥量属性````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n   互斥量属性的相关的值有：\n   * `PTHREAD_MUTEX_TIMED_NP`，缺省值，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。\n   * `PTHREAD_MUTEX_RECURSIVE_NP`，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。\n   * `PTHREAD_MUTEX_ERRORCHECK_NP`，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。\n   * `PTHREAD_MUTEX_ADAPTIVE_NP`，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。\n \n4. **读写锁的属性**\n   读写锁也有属性，它只有一个进程共享属性:\n   ````C\n   int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);\n   int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);\n   int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr, int *restrict pshared);\n   int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared); ````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n\n5. **条件变量的属性**\n   条件变量也有进程共享属性:\n   ````C\n   int pthread_condattr_destroy(pthread_condattr_t *attr);\n   int pthread_condattr_init(pthread_condattr_t *attr);\n   int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr, int *restrict pshared);\n   int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);````\n   上述函数的返回值都是成功返回0，失败返回相应的错误编码。\n\n### 3. 私有数据\n应用程序设计中有必要提供一种变量，使得多个函数多个线程都可以访问这个变量（看起来是个全局变量），但是线程对这个变量的访问都不会彼此产生影响（貌似不是全局变量哦），但是你需要这样的数据，比如 `errno`。那么这种数据就是线程的私有数据，尽管名字相同，但是每个线程访问的都是数据的副本。\n \n在使用私有数据之前，你首先要创建一个与私有数据相关的键，要来获取对私有数据的访问权限 。这个键的类型是 `pthread_key_t`:\n````C\nint pthread_key_create(pthread_key_t *key, void (*destructor)(voi8d*));````\n\n创建的键放在key指向的内存单元，`destructor` 是与键相关的析构函数。当线程调用 `pthread_exit` 或者使用 `return` 返回，析构函数就会被调用。当析构函数调用的时候，它只有一个参数，这个参数是与key关联的那个数据的地址，因此你可以在析构函数中将这个数据销毁。\n\n键使用完之后也可以删除，当键删除之后，与它关联的数据并没有销毁:\n````C\nint pthread_key_delete(pthread_key_t key);````\n \n有了键之后，你就可以将私有数据和键关联起来，这样就就可以通过键来找到数据。所有的线程都可以访问这个键，但他们可以为键关联不同的数据。\n````C\nint pthread_setspecific(pthread_key_t key, const void *value);````\n将私有数据与key关联\n\n````C\nvoid *pthread_getspecific(pthread_key_t key);````\n获取私有数据的地址，如果没有数据与key关联，那么返回空。\n\n有些事需要且只能执行一次（比如互斥量初始化）。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库函数时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始（`pthread_once_t`）会比较容易些。\n \n* 首先要定义一个 `pthread_once_t`变量，这个变量要用宏 `PTHREAD_ONCE_INIT` 初始化。然后创建一个与控制变量相关的初始化函数\n  ````C\n  pthread_once_t once_control = PTHREAD_ONCE_INIT;\n  void init_routine（）\n  {\n   //初始化互斥量\n   //初始化读写锁\n   ......\n  }````\n \n* 接下来就可以在任何时刻调用pthread_once函数\n  ````C\n  int pthread_once(pthread_once_t* once_control, void (*init_routine)(void));````\n  功能：本函数使用初值为 `PTHREAD_ONCE_INIT` 的 `once_control` 变量保证 `init_routine()` 函数在本进程执行序列中仅执行一次。在多线程编程环境下，尽管`pthread_once()` 调用会出现在多个线程中，`init_routine()` 函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。\"一次性函数\"的执行状态有三种：`NEVER（0）`. `IN_PROGRESS（1）`. `DONE （2）`，用 `once_control` 来表示 `pthread_once()` 的执行状态：\n  1. 如果 `once_control` 初值为0，那么 `pthread_once` 从未执行过，`init_routine()` 函数会执行。\n  2. 如果 `once_control` 初值设为1，则由于所有 `pthread_once()` 都必须等待其中一个激发\"已执行一次\"信号， 因此所有 `pthread_once ()` 都会陷入永久的等待中，`init_routine()` 就无法执行\n  3. 如果 `once_control` 设为2，则表示 `pthread_once()` 函数已执行过一次，从而所有 `pthread_once()`都会立即返回，`init_routine()`就没有机会执行。当pthread_once函数成功返回，once_control就会被设置为2\n\n###  4. 线程的信号\n在线程中使用信号，与在进程中使用信号机制有着根本的区别。在进程环境中，对信号的处理是异步的（我们完全不知到信号会在进程的那个执行点到来！）。但是在多线程中处理信号的原则完全不同，它的基本原则是：将对信号的异步处理，转换成同步处理，也就是说用一个线程专门的来“同步等待”信号的到来，而其它的线程可以完全不被该信号中断/打断(interrupt)。\n\n* 信号的发送\n  线程中信号的发送并不使用 `kill()` 函数，而是有专门的进程信号函数：\n  ````C\n  #include <pthread.h> \n  int pthread_kill(pthread_t thread, int sig);````\n  功能：向指定ID的线程发送信号。\n  参数：`thread` 进程标识符，`sig` 发送的信号。\n\n  如果线程代码内不做处理，则按照信号默认的行为影响整个进程，也就是说，如果你给一个线程发送了 `SIGQUIT` ，但线程却没有实现 `signal` 处理函数，则整个进程退出。如果要获得正确的行为，就需要在线程内实现 `signal(SIGKILL,sig_handler)` 了。所以，如果 `sig` 不是0，那一定要清楚到底要干什么，而且一定要实现线程的信号处理函数，否则，就会影响整个进程。如果 `sig` 是0，这是一个保留信号，其实并没有发送信号，作用是用来判断线程是不是还活着。\n\n* 信号的接收\n  在多线程代码中，总是使用 `sigwait` 或者 `sigwaitinfo` 或者 `sigtimedwait` 等函数来处理信号。而不是 `signal` 或者 `sigaction` 等函数。因为在一个线程中调用 `signal` 或者 `sigaction` 等函数会改变所以线程中的信号处理函数。而不是仅仅改变调用 `signal`/`sigaction` 的那个线程的信号处理函数。\n\n### 5. 线程与fork\n当线程调用 `fork()` 函数时，就为子进程创建了整个进程地址空间的副本，子进程通过继承整个地址空间的副本，也会将父进程的互斥量、读写锁、条件变量的状态继承过来。也就是说，如果父进程调用 `fork()` 的线程中占有锁，那么在子进程中也占有锁，这是非常不安全的，因为不是子进程自己锁住的，它无法解锁。\n \n子进程内部只有一个线程，由父进程中调用 `fork()` 函数的线程副本构成。如果调用 `fork()` 的线程将互斥量锁住，那么子进程会拷贝一个 `pthread_mutex_lock` 副本，这样子进程就有机会去解锁了。或者互斥量根本就没被加锁，这样也是可以的，但是你不能确保永远是这样的情况。\n \n`pthread_atfork` 函数给你创造了这样的条件，它会注册三个函数\n````C\nint pthread_atfork(void (*prepare)(void);\n                   void (*parent)(void); \n                   void (*child)(void));````\n`prepare` 是在 `fork()` 调用之前会被调用的，他的任务是获取所有父进程中定义的锁。\n`parent` 在 `fork()` 创建了子进程但返回之前在父进程中调用，他的任务是对所有 `prepare` 中获取的锁解锁。\n`child` 在 `fork()` 创建了子进程但返回之前在子进程中调用，他的任务是对所有 `prepare` 中获取的锁解锁。\n\n \n\n","slug":"Linux学习总结08","published":1,"updated":"2017-12-06T13:40:23.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001hbkw15g48hcvl","content":"<p>进程，它是资源分配的最小单位，进程中的事情需要按照一定的顺序逐个进行，那么：<strong>如何让一个进程中的一些事情同时执行？</strong><br><a id=\"more\"></a></p>\n<p>这时候就需要使用线程。<strong>线程</strong>，有时又称轻量级进程，它是 <strong>程序执行的最小单位</strong>，<strong>系统独立调度和分派 cpu 的基本单位</strong>，它是<strong>进程中的一个实体</strong>。一个进程中可以有多个线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。</p>\n<p>在了解线程之前需要清楚几个概念：</p>\n<ol>\n<li><strong>并发</strong><br>并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。 <strong>看起来同时发生</strong></li>\n<li><strong>并行</strong><br>并行是指在同一时刻，有多条指令在多个处理器上同时执行。<strong>真正的同时发生</strong></li>\n<li><strong>同步</strong><br>彼此有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情。</li>\n<li><strong>异步</strong><br>异步的概念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生。</li>\n</ol>\n<p>线程解决了进程的很多弊端：一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此，线程具有以下优势：</p>\n<blockquote>\n<p>1、在多处理器中开发程序的并行性<br>    2、在等待慢速IO操作时，程序可以执行其他操作，提高并发性<br>    3、模块化的编程，能更清晰的表达程序中独立事件的关系，结构清晰<br>    4、占用较少的系统资源</p>\n</blockquote>\n<h2 id=\"一、线程的创建：\"><a href=\"#一、线程的创建：\" class=\"headerlink\" title=\"一、线程的创建：\"></a>一、线程的创建：</h2><p>每个 Linux 都会运行在下面四种状态下：</p>\n<ul>\n<li>就绪<br>当线程刚被创建时就处于就绪状态，或者当线程被解除阻塞以后也会处于就绪状态。就绪的线程在等待一个可用的处理器，当一个运行的线程被抢占时，它立刻又回到就绪状态</li>\n<li>运行<br>当处理器选中一个就绪的线程执行时，它立刻变成运行状态</li>\n<li>阻塞<br>线程会在以下情况下发生阻塞：试图加锁一个已经被锁住的互斥量，等待某个条件变量，调用singwait等待尚未发生的信号，执行无法完成的I/O信号，由于内存页错误。</li>\n<li>终止<br>线程可以在启动函数中返回来终止自己，或者调用 <code>pthread_exit</code> 退出，或者取消线程。</li>\n</ul>\n<h3 id=\"1-线程ID\"><a href=\"#1-线程ID\" class=\"headerlink\" title=\"1. 线程ID\"></a>1. 线程ID</h3><p>我们首先来看下线程的创建，线程的创建使用的是 <code>pthread_create</code> 函数:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;pthread.h&gt;</div><div class=\"line\">int pthread_create (pthread_t *thread,</div><div class=\"line\">                    pthread_attr_t *attr,</div><div class=\"line\">                    void *(*start_routine)(void *),</div><div class=\"line\">                    void *arg);</div></pre></td></tr></table></figure></p>\n<p>功能：创建一个线程。<br>第一个参数 <code>thread</code>：新线程的id，如果成功则新线程的id回填充到tidp指向的内存<br>第二个参数 <code>attr</code>：线程属性（调度策略，继承性，分离性…）<br>第三个参数 <code>start_routine</code>：回调函数（新线程要执行的函数）<br>第四个参数 <code>arg</code>：回调函数的参数<br>返回值：成功返回0，失败则返回错误码</p>\n<p>当线程被创建时，<code>thread</code> 被写入一个标识符，我们使用这个标识符来引用被创建的线程。<code>attr</code> 可以用来详细设定线程的属性，一般为 <code>NULL</code>，我们会在本篇博客的最后详细介绍线程的属性，<code>start_routine</code> 指向了一个函数地址，我们可以定义任意一个具有一个任意类型的参数并返回任意一个返回值的函数作为线程的执行函数，最后一个 <code>arg</code> 传入了该函数的参数。需要注意的是：</p>\n<blockquote>\n<p>编译时需要连接库 <code>libpthread</code>。<br>新线程可能在当前线程从函数 <code>pthread_create</code> 返回之前就已经运行了，甚至新线程可能在当前线程从函数 <code>pthread_create</code> 返回之前就已经运行完毕了。</p>\n</blockquote>\n<p>对于一个线程，可以使用 <code>pthread_self()</code> 函数来获取自己的线程号。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_self</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：返回当前线程的线程 id。<br>返回值：调用线程的线程ID。</p>\n<p>还有一个函数是 <code>pthread_equal()</code> 可以用来判断两个线程ID 是否一致。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_equal</span> <span class=\"params\">(<span class=\"keyword\">pthread_t</span> tid1, <span class=\"keyword\">pthread_t</span> tid2)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：功能判断两个线程ID是否一致。<br>参数：<code>tid1</code> <code>tid2</code> 需要判断的ID<br>返回值：相等返回非0值，不相等返回0.</p>\n<p>这样，主线程可以将工作任务放在一个队列中，并将每个任务添加一个进程ID标识，这样相应的线程使用上面两个函数就可以取出和自己相关的任务。</p>\n<h3 id=\"2-初始线程-主线程\"><a href=\"#2-初始线程-主线程\" class=\"headerlink\" title=\"2. 初始线程/主线程\"></a>2. 初始线程/主线程</h3><p>当c程序运行时，首先运行 <code>main</code> 函数。在线程代码中，这个特殊的执行流被称作初始线程或者主线程。你可以在初始线程中做任何普通线程可以做的事情。主线程的特殊性在于:</p>\n<ul>\n<li>它在 <code>main</code> 函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用 <code>pthread_exit</code> 函数，这样进程就会等待所有线程结束时才终止。</li>\n<li>主线程接受参数的方式是通过 <code>argc</code> 和 <code>argv</code>，而普通的线程只有一个参数 <code>void*</code>。</li>\n<li>在绝大多数情况下，主线程在默认堆栈上运行，这个堆栈可以增长到足够的长度。而普通线程的堆栈是受限制的，一旦溢出就会产生错误。</li>\n</ul>\n<h2 id=\"二、线程的运行\"><a href=\"#二、线程的运行\" class=\"headerlink\" title=\"二、线程的运行\"></a>二、线程的运行</h2><h3 id=\"1-线程的退出\"><a href=\"#1-线程的退出\" class=\"headerlink\" title=\"1. 线程的退出\"></a>1. 线程的退出</h3><p>退出线程使用的是 <code>pthread_exit</code>，需要注意的是：线程函数不能使用 <code>exit()</code> 退出，<code>exit</code>是危险的：如果进程中的任意一个线程调用了 <code>exit</code>，<code>_Exit</code>，<code>_exit</code>，那么整个进程就会终止，普通的单个线程以以下三种方式退出，不会终止进程：</p>\n<ol>\n<li>从启动函数中返回，返回值是线程的退出码。</li>\n<li>线程可以被同一进程中的其他线程取消。</li>\n<li>线程调用 <code>pthread_exit()</code> 函数。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span> *rval)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：退出一个线程。<br> 参数：<code>rval</code> 是个无类型的指针，保存线程的退出码，其他线程可以通过 <code>pthread_join()</code> 函数来接收这个值。</p>\n<h3 id=\"2-线程的回收\"><a href=\"#2-线程的回收\" class=\"headerlink\" title=\"2. 线程的回收\"></a>2. 线程的回收</h3><p>类似于进程的 <code>wait()</code> 函数，线程也有相应的机制，称为线程的回收，和这个机制紧密相关的一个概念是线程的<strong>分离属性</strong>。</p>\n<p><strong>线程的分离属性：</strong> </p>\n<blockquote>\n<p>分离一个正在运行的线程并不影响它，仅仅是通知当前系统该线程结束时，其所属的资源可以回收。<br> 一个没有被分离的线程在终止时会保留它的虚拟内存，包括他们的堆栈和其他系统资源，有时这种线程被称为<strong>僵尸线程</strong>。<br> 创建线程时<strong>默认是非分离的</strong>。</p>\n</blockquote>\n<p>如果线程具有分离属性，线程终止时会被立刻回收，回收将释放掉所有在线程终止时未释放的系统资源和进程资源，包括保存线程返回值的内存空间、堆栈、保存寄存器的内存空间等。<br>终止被分离的线程会释放所有的系统资源，但是你必须释放由该线程占有的程序资源。由 <code>malloc()</code> 或者 <code>mmap()</code> 分配的内存可以在任何时候由任何线程释放，条件变量、互斥量、信号灯可以由任何线程销毁，只要他们被解锁了或者没有线程等待。但是只有互斥量的主人才能解锁它，所以<strong>在线程终止前，你需要解锁互斥量</strong>。</p>\n<p>将已创建的线程设置为分离的有两种方式：</p>\n<ul>\n<li><p>调用 <code>pthread_detach()</code> 这个函数，那么当这个线程终止的时候，和它相关的系统资源将被自动释放。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_detach</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：分离一个线程，线程可以自己分离自己。<br>参数：<code>thread</code> 指定线程的 id。<br>返回值：成功返回0，失败返回错误码</p>\n</li>\n<li><p>调用 <code>pthread_join</code> 会使指定的线程处于分离状态()，如果指定线程已经处于分离状态，那么调用就会失败。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthead_t</span> tid, <span class=\"keyword\">void</span> **rval)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：调用该函数的线程会一直阻塞，直到指定的线程 <code>tid</code> 调用 <code>pthread_exit</code>、从启动函数返回或者被取消。<br>参数：参数 <code>tid</code> 就是指定线程的 <code>id</code>，参数 <code>rval</code> 是指定线程的返回码，如果线程被取消，那么 <code>rval</code> 被置为 <code>PTHREAD_CANCELED</code><br>返回值：该函数调用成功会返回0，失败返回错误码</p>\n</li>\n</ul>\n<h3 id=\"3-线程的取消\"><a href=\"#3-线程的取消\" class=\"headerlink\" title=\"3. 线程的取消\"></a>3. 线程的取消</h3><p>线程的取消类似于一个线程向另一个线程发送了一个信号，要求它终止，相应的取消函数很简单：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cancle</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> tid)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：请求一个线程终止<br>参数：<code>tid</code> 指定的线程<br>返回值：成功返回0，失败返回错误码。</p>\n<p>取消只是发送一个请求，并不意味着等待线程终止，而且发送成功也不意味着 <code>tid</code> 一定会终止，它通常需要被取消线程的配合。线程在很多时候会查看自己取消状态，如果有就主动退出， 这些查看是否有取消的地方称为取消点</p>\n<p>这时候，我们又有了两个概念：<strong>取消状态</strong>，<strong>取消点</strong>。</p>\n<ul>\n<li><p>取消状态<br>取消状态，就是线程对取消信号的处理方式，忽略或者响应。线程创建时默认响应取消信号，相应的设置函数为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcancelstate</span><span class=\"params\">(<span class=\"keyword\">int</span> state, <span class=\"keyword\">int</span> *oldstate)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：设置本线程对取消请求(CANCEL 信号)的反应<br>参数：<code>state</code> 有两种值：<code>PTHREAD_CANCEL_ENABLE</code>（缺省，接收取消请求）和 <code>PTHREAD_CANCEL_DISABLE</code>(忽略取消请求)；<code>old_state</code> 如果不为NULL则存入原来的Cancel状态以便恢复<br>返回值：成功返回0，失败返回错误码。</p>\n<p>如果函数设置为接收取消请求，还可以设置他的<strong>取消类型</strong>:<br>取消类型，是线程对取消信号的响应方式，立即取消或者延时取消。线程创建时默认延时取消</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcanceltype</span><span class=\"params\">(<span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> *oldtype)</span> </span>;</div></pre></td></tr></table></figure>\n<p>功能：设置本线程取消动作的执行时机<br>参数：<code>type</code> 由两种取值：<code>PTHREAD_CANCEL_DEFFERED</code> 表示收到信号后继续运行至下一个取消点再退出， <code>PTHREAD_CANCEL_ASYCHRONOUS</code> 标识立即执行取消动作（退出）；两者仅当 Cancel 状态为 Enable 时有效；<code>oldtype</code> 如果不为NULL则存入运来的取消动作类型值。<br>返回值：成功返回0，失败则返回错误码</p>\n</li>\n<li><p>取消点<br>取消点：取消一个线程，默认需要被取消线程的配合。线程在很多时候会查看自己是否有取消请求，如果有就主动退出， 这些查看是否有取消的地方称为取消点。很多地方都是包含取消点，包括 <code>pthread_join()</code>、 <code>pthread_testcancel()</code>、<code>pthread_cond_wait()</code>、 <code>pthread_cond_timedwait()</code>、<code>sem_wait()</code>、<code>sigwait()</code> 以及 <code>write</code>、<code>read</code> 等大多数会阻塞的系统调用。</p>\n</li>\n</ul>\n<h3 id=\"4-线程的清除\"><a href=\"#4-线程的清除\" class=\"headerlink\" title=\"4. 线程的清除\"></a>4. 线程的清除</h3><p>线程可以安排它退出时的清理操作，这与进程的可以用atexit函数安排进程退出时需要调用的函数类似。这样的函数称为线程清理处理程序。线程可以建立多个清理处理程序，处理程序记录在栈中，所以这些处理程序执行的顺序与他们注册的顺序相反<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"keyword\">void</span> pthread_cleanup_push（<span class=\"keyword\">void</span> （*rtn）（<span class=\"keyword\">void</span>*）， <span class=\"keyword\">void</span> *args）<span class=\"comment\">//注册处理程序</span></div><div class=\"line\"><span class=\"keyword\">void</span> pthread_cleanup_pop（<span class=\"keyword\">int</span> excute）<span class=\"comment\">//清除处理程序</span></div></pre></td></tr></table></figure></p>\n<p>当执行以下操作时调用清理函数，清理函数的参数由 <code>args</code> 传入</p>\n<ol>\n<li>调用 <code>pthread_exit</code></li>\n<li>响应取消请求</li>\n<li>用非零参数调用 <code>pthread_cleanup_pop</code></li>\n</ol>\n<p><strong><code>return</code> 不调用清理操作</strong>。</p>\n<h2 id=\"五、线程的同步\"><a href=\"#五、线程的同步\" class=\"headerlink\" title=\"五、线程的同步\"></a>五、线程的同步</h2><p>有几种方法可以很好的控制线程执行和访问临界区域，主要是互斥量和信号量。</p>\n<h3 id=\"1-互斥量\"><a href=\"#1-互斥量\" class=\"headerlink\" title=\"1. 互斥量\"></a>1. 互斥量</h3><ul>\n<li>为什么要使用互斥量？<br>当多个线程共享相同的内存时，需要每一个线程看到相同的视图。当一个线程修改变量时，而其他线程也可以读取或者修改这个变量，就需要对这些线程同步，确保他们不会访问到无效的变量。<br>为了让线程访问数据不产生冲突，这要就需要对变量加锁，使得同一时刻只有一个线程可以访问变量。互斥量本质就是锁，访问共享资源前对互斥量加锁，访问完成后解锁。<br>当互斥量加锁以后，其他所有需要访问该互斥量的线程都将阻塞，当互斥量解锁以后，所有因为这个互斥量阻塞的线程都将变为就绪态，第一个获得cpu的线程会获得互斥量，变为运行态，而其他线程会继续变为阻塞，在这种方式下访问互斥量每次只有一个线程能向前执行. </li>\n</ul>\n<ol>\n<li><p>互斥量的初始化和销毁</p>\n<p>互斥量用 <code>pthread_mutex_t</code> 类型的数据表示，在使用之前需要对互斥量初始化</p>\n<ul>\n<li>如果是动态分配的互斥量，可以调用 <code>pthread_mutex_init()</code>函数初始化</li>\n<li>如果是静态分配的互斥量，还可以把它置为常量 <code>PTHREAD_MUTEX_INITIALIZER</code></li>\n<li>动态分配的互斥量在释放内存之前需要调用 <code>pthread_mutex_destroy()</code></li>\n</ul>\n<p>相应的处理函数为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex,</span></span></div><div class=\"line\">       <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *<span class=\"keyword\">restrict</span> attr);  <span class=\"comment\">//动态初始化互斥量</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>; <span class=\"comment\">//动态互斥量销毁</span></div><div class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class=\"comment\">//静态初始化互斥量</span></div></pre></td></tr></table></figure>\n<p><code>mutex</code> 为需要创建或销毁的互斥量；<code>attr</code> 为新建互斥量的属性，默认为 <code>PTHREAD_MUTEX_TIMED_NP</code>， 即普通锁。</p>\n</li>\n<li><p>加锁和解锁</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure>\n<p> 成功返回0，失败返回错误码。如果互斥量已经被锁住，那么会导致该线程阻塞。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;`</div></pre></td></tr></table></figure>\n<p> 成功返回0，失败返回错误码。如果互斥量已经被锁住，不会导致线程阻塞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure>\n<p> 成功返回0，失败返回错误码。如果一个互斥量没有被锁住，那么解锁就会出错。</p>\n</li>\n<li><p>死锁<br>死锁：线程一直在等待锁，而锁却无法解开。如果一个线程对已经占有的互斥量继续加锁，那么他就会陷入死锁状态。</p>\n<p><strong>如何去避免死锁？</strong><br>你可以小心的控制互斥量加锁的顺序来避免死锁，例如所有的线程都在加锁B之前先加锁A，那么这两个互斥量就不会产生死锁了。有的时候程序写的多了互斥量就难以把控，你可以先释放已经占有的锁，然后再加锁其他互斥量。</p>\n</li>\n</ol>\n<p>互斥量使用要注意：</p>\n<blockquote>\n<ol>\n<li>访问共享资源时需要加锁</li>\n<li>互斥量使用完之后需要销毁</li>\n<li>加锁之后一定要解锁</li>\n<li>互斥量加锁的范围要小</li>\n<li>互斥量的数量应该少</li>\n</ol>\n</blockquote>\n<h3 id=\"2-信号量\"><a href=\"#2-信号量\" class=\"headerlink\" title=\"2. 信号量\"></a>2. 信号量</h3><p>这里说的信号量和前一篇说的信号量不同，这里的信号量来自 POSIX 的实时扩展，而之前的信号量来自于 System V。两者的函数接口相似，但是不用通用。这里的相关信号量函数都以 <code>sem_</code> 开头。相关的函数有四个：</p>\n<ol>\n<li><p><code>sem_init</code> 函数<br>该函数用于创建信号量，其原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_init</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem, <span class=\"keyword\">int</span> pshared， <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> value)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数初始化由 <code>sem</code> 指向的信号对象，设置它的共享选项，并给它一个初始的整数值。<code>pshared</code> 控制信号量的类型，如果其值为0，就表示这个信号量是当前进程的局部信号量，否则信号量就可以在多个进程之间共享，<code>value</code> 为 <code>sem</code> 的初始值。<br>调用成功时返回0，失败返回-1.</p>\n</li>\n<li><p><code>sem_wait</code> 函数<br>该函数用于以原子操作的方式将信号量的值减1。原子操作就是，如果两个线程企图同时给一个信号量加1或减1，它们之间不会互相干扰。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_wait</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>sem</code> 指向的对象是由 <code>sem_init</code> 调用初始化的信号量。<br>调用成功时返回0，失败返回-1.</p>\n</li>\n<li><p><code>sem_post</code> 函数<br>该函数用于以原子操作的方式将信号量的值加1。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_post</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem)</span></span>;</div></pre></td></tr></table></figure>\n<p>与 <code>sem_wait</code> 一样，<code>sem</code> 指向的对象是由 <code>sem_init</code> 调用初始化的信号量。<br>调用成功时返回0，失败返回-1.</p>\n</li>\n<li><p><code>sem_destroy</code> 函数<br>该函数用于对用完的信号量的清理。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_destroy</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem)</span></span>;  </div><div class=\"line\">成功时返回<span class=\"number\">0</span>，失败时返回<span class=\"number\">-1.</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-读写锁\"><a href=\"#3-读写锁\" class=\"headerlink\" title=\"3. 读写锁\"></a>3. 读写锁</h3><p><strong>什么是读写锁，它与互斥量的区别：</strong><br>读写锁与互斥量类似，不过读写锁有更高的并行性。互斥量要么加锁要么不加锁，而且同一时刻只允许一个线程对其加锁。但是对于一个变量的读取，完全可以让多个线程同时进行操作。这时候读写锁更为实用。</p>\n<ul>\n<li>读写锁有三种状态，读模式下加锁，写模式下加锁，不加锁。相应的使用方法为：<ul>\n<li>一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式的读写锁。 </li>\n<li>读写锁在写加锁状态时，在它被解锁之前，所有试图对这个锁加锁的线程都会阻塞。</li>\n<li>读写锁在读加锁状态时，所有试图以读模式对其加锁的线程都会获得访问权，但是如果线程希望以写模式对其加锁，它必须阻塞直到所有的线程释放锁。 </li>\n<li>读写锁在读加锁状态时，如果有线程试图以写模式对其加锁，那么读写锁会阻塞随后的读模式锁请求。这样可以避免读锁长期占用，而写锁达不到请求。</li>\n</ul>\n</li>\n</ul>\n<p>读写锁非常适合对数据结构读次数大于写次数的程序，当它以读模式锁住时，是以共享的方式锁住的；当它以写模式锁住时，是以独占的模式锁住的。</p>\n<ol>\n<li><p>读写锁的初始化和销毁<br>读写锁在使用之前必须初始化,使用完需要销毁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_init</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *<span class=\"keyword\">restrict</span> rwlock,</span></span></div><div class=\"line\">          <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_rwlockattr_t</span> *<span class=\"keyword\">restrict</span> attr);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>成功返回0 ，失败返回错误码</p>\n</li>\n<li><p>加锁和解锁<br>读模式加锁    </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_rdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_tryrdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>写模式加锁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_wrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_trywrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>解锁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>成功返回0</p>\n</li>\n</ol>\n<h3 id=\"3-条件变量\"><a href=\"#3-条件变量\" class=\"headerlink\" title=\"3.  条件变量\"></a>3.  条件变量</h3><p>条件变量的引入：我们需要一种机制，当互斥量被锁住以后发现当前线程还是无法完成自己的操作，那么它应该释放互斥量，让其他线程工作。条件变量的作用就是可以采用轮询的方式，不停的让系统来帮你查询条件。</p>\n<ol>\n<li><p>条件变量的初始化和销毁<br>条件变量使用之前需要初始化，条件变量使用完成之后需要销毁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;    <span class=\"comment\">//静态初始化条件变量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_init</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,</span></span></div><div class=\"line\">                      <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_condattr_t</span> *<span class=\"keyword\">restrict</span> attr); <span class=\"comment\">//动态初始化条件变量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;<span class=\"comment\">//销毁条件变量</span></div></pre></td></tr></table></figure>\n<p>动态条件变量的初始化和销毁函数返回值都是成功返回0，失败返回错误代码。<code>attr</code> 的值一般为 <code>NULL</code>。详细的设置在下个章节。</p>\n</li>\n<li><p>条件变量的等待和唤醒<br>条件变量使用需要配合互斥量</p>\n<ol>\n<li><p>使用 <code>pthread_cond_wait</code> 等待条件变为真。传递给 <code>pthread_cond_wait</code> 的互斥量对条件进行保护，调用者把锁住的互斥量传递给函数。<br>这个函数将线程放到等待条件的线程列表上，然后对互斥量进行解锁，这是个原子操作。当条件满足时这个函数返回，返回以后继续对互斥量加锁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_wait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,</span></span></div><div class=\"line\">                      <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex);</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_timedwait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,</span></span></div><div class=\"line\">                            <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex,</div><div class=\"line\">                            <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> timespec *<span class=\"keyword\">restrict</span> abstime);</div></pre></td></tr></table></figure>\n<p>这个函数与 <code>pthread_cond_wait</code> 类似，只是多一个 <code>timeout</code>，如果到了指定的时间条件还不满足，那么就返回。<br>注意，这个时间是绝对时间。例如你要等待3分钟，就要把当前时间加上3分钟然后转换到 <code>timespec</code>，而不是直接将3分钟转换到 <code>timespec</code>。</p>\n</li>\n<li><p>当条件满足的时候，需要唤醒等待条件的线程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_broadcast</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>; <span class=\"comment\">//唤醒等待条件的所有线程</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_signal</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;    <span class=\"comment\">//至少唤醒等待条件的某一个线程</span></div></pre></td></tr></table></figure>\n<p>注意，<strong>一定要在条件改变以后在唤醒线程。</strong></p>\n</li>\n</ol>\n</li>\n<li><p>条件变量的使用<br>条件变量主要使用在那些需要条件触发的场景。譬如，一个经典的生产者消费者的问题。消费者等待生产者生产，如果单纯的使用互斥量，当然也可以解决问题，但是在生产者没有生产的时候，消费者就需要不停的轮询，大大浪费了CPU资源。我们更期待的是等生产者生产后”通知”我们的消费者，所以我们使用条件变量：<br>生产者线程的执行顺序是：加锁 -&gt; 生产 -&gt; <code>pthread_cond_signal</code> -&gt; 释放锁<br>消费者线程的执行顺寻是：加锁 -&gt; while(没有生产) <code>pthread_cond_wait</code>; 当没有商品存在的时候，进入条件变量，此时条件变量首先释放了锁，然后阻塞等待 <code>pthread_cond_signal</code> 信号的发送，接收到信号之后，申请锁，<code>pthread_cond_wait</code>结束， -&gt; 执行相应的程序 -&gt; 释放锁。</p>\n</li>\n</ol>\n<h2 id=\"六、线程的控制\"><a href=\"#六、线程的控制\" class=\"headerlink\" title=\"六、线程的控制\"></a>六、线程的控制</h2><h3 id=\"1-线程属性\"><a href=\"#1-线程属性\" class=\"headerlink\" title=\"1. 线程属性\"></a>1. 线程属性</h3><p>线程的属性用 <code>pthread_attr_t</code> 类型的结构表示，在创建线程的时候可以不用传入NULL，而是传入一个 <code>pthread_attr_t</code> 结构，由用户自己来配置线程的属性。<code>pthread_attr_t</code> 结构中定义的线程属性有很多：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>detachstate</td>\n<td>线程的分离状态</td>\n</tr>\n<tr>\n<td>guardsize</td>\n<td>线程栈末尾的警戒区域大小（字节数）</td>\n</tr>\n<tr>\n<td>stacksize</td>\n<td>线程栈的最低地址</td>\n</tr>\n<tr>\n<td>stacksize</td>\n<td>线程栈的大小（字节数）</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>线程属性的初始化和销毁<br>线程的初始化和销毁使用下面两个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span>;     <span class=\"comment\">//线程属性初始化</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span>;  <span class=\"comment\">//线程属性销毁</span></div></pre></td></tr></table></figure>\n<p>如果在调用 <code>pthread_attr_init</code> 初始化属性的时候分配了内存空间，那么 <code>pthread_attr_destroy</code> 将释放内存空间。除此之外，<code>pthread_atty_destroy</code> 还会用无效的值初始化 <code>pthread_attr_t</code> 对象，因此如果该属性对象被误用，会导致创建线程失败。<code>pthread_attr_t</code> 类型对应用程序是不透明的，也就是说应用程序不需要了解有关属性对象内部结构的任何细节，因而可以增加程序的可移植性。</p>\n</li>\n</ol>\n<ol>\n<li><p>线程的分离属性<br>线程的分离属性已经在前面的章节介绍过了，如果在创建线程的时候就知道不需要了解线程的终止状态，那么可以修改 <code>pthread_attr_t</code> 结构体的 <code>detachstate</code> 属性，让线程以分离状态启动。线程的分离属性有两种合法值:<br><code>PTHREAD_CREATE_DETACHED</code> 分离的；<br><code>PTHREAD_CREATE_JOINABLE</code> 非分离的，可连接的；<br>设置线程分离属性的步骤</p>\n<ol>\n<li>定义线程属性变量 <code>pthread_attr_t attr</code></li>\n<li>初始化 <code>attr</code> ，<code>pthread_attr_init(&amp;attr)</code></li>\n<li>设置线程为分离或非分离 <code>pthread_attr_setdetachstate(&amp;attr, detachstate)</code></li>\n<li>创建线程 <code>pthread_create（&amp;tid， &amp;attr， thread_fun,  NULL）</code></li>\n</ol>\n</li>\n<li><p>线程的栈属性<br>对一个进程，他的虚拟空间的大小是固定的，如果程序启动了大量的线程，因为所有的线程共享进程的的虚拟地址空间，所以按照默认的栈大小，虚拟空间就会不足，需要调小栈空间。或者某个线程使用了大量的自动变量，这时候需要调大栈空间，具体的分配使用不再详说，介绍下相关的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setstack</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">void</span> *stackaddr, <span class=\"keyword\">size_t</span> stacksize)</span></span>;   <span class=\"comment\">//修改栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getstack</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">void</span> **stackaddr, <span class=\"keyword\">size_t</span> *stacksize)</span></span>; <span class=\"comment\">//获取栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setstacksize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> stacksize)</span></span>;                <span class=\"comment\">//单独设置栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getstacksize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> *stacksize)</span></span>;               <span class=\"comment\">//单独获取栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setguardsize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> guardsize)</span></span>;                <span class=\"comment\">//单独设置栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getguardsize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> *guardsize)</span></span>;               <span class=\"comment\">//单独获取栈属性</span></div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。<br>对于遵循POSIX标准的系统来说，不一定要支持线程的栈属性，因此你需要检查</p>\n<ol>\n<li>在编译阶段使用<br><code>_POSIX_THREAD_ATTR_STACKADDR</code> 和 <code>_POSIX_THREAD_ATTR_STACKSIZE</code> 符号来检查系统是否支持线程栈属性。</li>\n<li>在运行阶段把<br><code>_SC_THREAD_ATTR_STACKADD</code> 和 <code>_SC_THREAD_THREAD_ATTR_STACKSIZE</code> 传递给 <code>sysconf</code> 函数检查系统对线程栈属性的支持。</li>\n</ol>\n</li>\n<li><p>线程的其他属性：<br>线程还有一些属性没有在 <code>pthread_attr_t</code> 结构体中定义，如已经在上面介绍过的线程的取消状态和线程的取消类型，还有没有介绍的线程的并发度，这些就不再详细描述。</p>\n</li>\n</ol>\n<h3 id=\"2-同步属性\"><a href=\"#2-同步属性\" class=\"headerlink\" title=\"2. 同步属性\"></a>2. 同步属性</h3><ol>\n<li><p><strong>互斥量的属性</strong><br>就像线程有属性一样，线程的同步互斥量也有属性，比较重要的是进程共享属性和类型属性。互斥量的属性用 <code>pthread_mutexattr_t</code> 类型的数据表示，当然在使用之前必须进行初始化，使用完成之后需要进行销毁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>;    <span class=\"comment\">//互斥量属性初始化</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>; <span class=\"comment\">//互斥量属性销毁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *<span class=\"keyword\">restrict</span> attr, </span></span></div><div class=\"line\">                                  <span class=\"keyword\">int</span> *<span class=\"keyword\">restrict</span> pshared); <span class=\"comment\">//获取互斥量属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr, </span></span></div><div class=\"line\">                                 <span class=\"keyword\">int</span> pshared);            <span class=\"comment\">//设置互斥量属性</span></div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。<br>互斥量属性的相关的值有：</p>\n<ul>\n<li><code>PTHREAD_MUTEX_TIMED_NP</code>，缺省值，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。</li>\n<li><code>PTHREAD_MUTEX_RECURSIVE_NP</code>，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</li>\n<li><code>PTHREAD_MUTEX_ERRORCHECK_NP</code>，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</li>\n<li><code>PTHREAD_MUTEX_ADAPTIVE_NP</code>，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。</li>\n</ul>\n</li>\n<li><p><strong>读写锁的属性</strong><br>读写锁也有属性，它只有一个进程共享属性:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_rwlockattr_t</span> *<span class=\"keyword\">restrict</span> attr, <span class=\"keyword\">int</span> *<span class=\"keyword\">restrict</span> pshared)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlockattr_t</span> *attr, <span class=\"keyword\">int</span> pshared)</span></span>;</div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。</p>\n</li>\n<li><p><strong>条件变量的属性</strong><br>条件变量也有进程共享属性:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_condattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_condattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_condattr_t</span> *<span class=\"keyword\">restrict</span> attr, <span class=\"keyword\">int</span> *<span class=\"keyword\">restrict</span> pshared)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">pthread_condattr_t</span> *attr, <span class=\"keyword\">int</span> pshared)</span></span>;</div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。</p>\n</li>\n</ol>\n<h3 id=\"3-私有数据\"><a href=\"#3-私有数据\" class=\"headerlink\" title=\"3. 私有数据\"></a>3. 私有数据</h3><p>应用程序设计中有必要提供一种变量，使得多个函数多个线程都可以访问这个变量（看起来是个全局变量），但是线程对这个变量的访问都不会彼此产生影响（貌似不是全局变量哦），但是你需要这样的数据，比如 <code>errno</code>。那么这种数据就是线程的私有数据，尽管名字相同，但是每个线程访问的都是数据的副本。</p>\n<p>在使用私有数据之前，你首先要创建一个与私有数据相关的键，要来获取对私有数据的访问权限 。这个键的类型是 <code>pthread_key_t</code>:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int pthread_key_create(pthread_key_t *key, void (*destructor)(voi8d*));</div></pre></td></tr></table></figure></p>\n<p>创建的键放在key指向的内存单元，<code>destructor</code> 是与键相关的析构函数。当线程调用 <code>pthread_exit</code> 或者使用 <code>return</code> 返回，析构函数就会被调用。当析构函数调用的时候，它只有一个参数，这个参数是与key关联的那个数据的地址，因此你可以在析构函数中将这个数据销毁。</p>\n<p>键使用完之后也可以删除，当键删除之后，与它关联的数据并没有销毁:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_key_delete</span><span class=\"params\">(<span class=\"keyword\">pthread_key_t</span> key)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>有了键之后，你就可以将私有数据和键关联起来，这样就就可以通过键来找到数据。所有的线程都可以访问这个键，但他们可以为键关联不同的数据。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setspecific</span><span class=\"params\">(<span class=\"keyword\">pthread_key_t</span> key, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>将私有数据与key关联</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">pthread_getspecific</span><span class=\"params\">(<span class=\"keyword\">pthread_key_t</span> key)</span></span>;</div></pre></td></tr></table></figure>\n<p>获取私有数据的地址，如果没有数据与key关联，那么返回空。</p>\n<p>有些事需要且只能执行一次（比如互斥量初始化）。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库函数时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始（<code>pthread_once_t</code>）会比较容易些。</p>\n<ul>\n<li>首先要定义一个 <code>pthread_once_t</code>变量，这个变量要用宏 <code>PTHREAD_ONCE_INIT</code> 初始化。然后创建一个与控制变量相关的初始化函数<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</div><div class=\"line\"><span class=\"keyword\">void</span> init_routine（）</div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"comment\">//初始化互斥量</span></div><div class=\"line\"> <span class=\"comment\">//初始化读写锁</span></div><div class=\"line\"> ......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>接下来就可以在任何时刻调用pthread_once函数</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int pthread_once(pthread_once_t* once_control, void (*init_routine)(void));</div></pre></td></tr></table></figure>\n<p>功能：本函数使用初值为 <code>PTHREAD_ONCE_INIT</code> 的 <code>once_control</code> 变量保证 <code>init_routine()</code> 函数在本进程执行序列中仅执行一次。在多线程编程环境下，尽管<code>pthread_once()</code> 调用会出现在多个线程中，<code>init_routine()</code> 函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。”一次性函数”的执行状态有三种：<code>NEVER（0）</code>. <code>IN_PROGRESS（1）</code>. <code>DONE （2）</code>，用 <code>once_control</code> 来表示 <code>pthread_once()</code> 的执行状态：</p>\n<ol>\n<li>如果 <code>once_control</code> 初值为0，那么 <code>pthread_once</code> 从未执行过，<code>init_routine()</code> 函数会执行。</li>\n<li>如果 <code>once_control</code> 初值设为1，则由于所有 <code>pthread_once()</code> 都必须等待其中一个激发”已执行一次”信号， 因此所有 <code>pthread_once ()</code> 都会陷入永久的等待中，<code>init_routine()</code> 就无法执行</li>\n<li>如果 <code>once_control</code> 设为2，则表示 <code>pthread_once()</code> 函数已执行过一次，从而所有 <code>pthread_once()</code>都会立即返回，<code>init_routine()</code>就没有机会执行。当pthread_once函数成功返回，once_control就会被设置为2</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"4-线程的信号\"><a href=\"#4-线程的信号\" class=\"headerlink\" title=\"4. 线程的信号\"></a>4. 线程的信号</h3><p>在线程中使用信号，与在进程中使用信号机制有着根本的区别。在进程环境中，对信号的处理是异步的（我们完全不知到信号会在进程的那个执行点到来！）。但是在多线程中处理信号的原则完全不同，它的基本原则是：将对信号的异步处理，转换成同步处理，也就是说用一个线程专门的来“同步等待”信号的到来，而其它的线程可以完全不被该信号中断/打断(interrupt)。</p>\n<ul>\n<li><p>信号的发送<br>线程中信号的发送并不使用 <code>kill()</code> 函数，而是有专门的进程信号函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_kill</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">int</span> sig)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：向指定ID的线程发送信号。<br>参数：<code>thread</code> 进程标识符，<code>sig</code> 发送的信号。</p>\n<p>如果线程代码内不做处理，则按照信号默认的行为影响整个进程，也就是说，如果你给一个线程发送了 <code>SIGQUIT</code> ，但线程却没有实现 <code>signal</code> 处理函数，则整个进程退出。如果要获得正确的行为，就需要在线程内实现 <code>signal(SIGKILL,sig_handler)</code> 了。所以，如果 <code>sig</code> 不是0，那一定要清楚到底要干什么，而且一定要实现线程的信号处理函数，否则，就会影响整个进程。如果 <code>sig</code> 是0，这是一个保留信号，其实并没有发送信号，作用是用来判断线程是不是还活着。</p>\n</li>\n<li><p>信号的接收<br>在多线程代码中，总是使用 <code>sigwait</code> 或者 <code>sigwaitinfo</code> 或者 <code>sigtimedwait</code> 等函数来处理信号。而不是 <code>signal</code> 或者 <code>sigaction</code> 等函数。因为在一个线程中调用 <code>signal</code> 或者 <code>sigaction</code> 等函数会改变所以线程中的信号处理函数。而不是仅仅改变调用 <code>signal</code>/<code>sigaction</code> 的那个线程的信号处理函数。</p>\n</li>\n</ul>\n<h3 id=\"5-线程与fork\"><a href=\"#5-线程与fork\" class=\"headerlink\" title=\"5. 线程与fork\"></a>5. 线程与fork</h3><p>当线程调用 <code>fork()</code> 函数时，就为子进程创建了整个进程地址空间的副本，子进程通过继承整个地址空间的副本，也会将父进程的互斥量、读写锁、条件变量的状态继承过来。也就是说，如果父进程调用 <code>fork()</code> 的线程中占有锁，那么在子进程中也占有锁，这是非常不安全的，因为不是子进程自己锁住的，它无法解锁。</p>\n<p>子进程内部只有一个线程，由父进程中调用 <code>fork()</code> 函数的线程副本构成。如果调用 <code>fork()</code> 的线程将互斥量锁住，那么子进程会拷贝一个 <code>pthread_mutex_lock</code> 副本，这样子进程就有机会去解锁了。或者互斥量根本就没被加锁，这样也是可以的，但是你不能确保永远是这样的情况。</p>\n<p><code>pthread_atfork</code> 函数给你创造了这样的条件，它会注册三个函数<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_atfork</span><span class=\"params\">(<span class=\"keyword\">void</span> (*prepare)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\">                   <span class=\"keyword\">void</span> (*parent)(<span class=\"keyword\">void</span>); </div><div class=\"line\">                   <span class=\"keyword\">void</span> (*child)(<span class=\"keyword\">void</span>));</div></pre></td></tr></table></figure></p>\n<p><code>prepare</code> 是在 <code>fork()</code> 调用之前会被调用的，他的任务是获取所有父进程中定义的锁。<br><code>parent</code> 在 <code>fork()</code> 创建了子进程但返回之前在父进程中调用，他的任务是对所有 <code>prepare</code> 中获取的锁解锁。<br><code>child</code> 在 <code>fork()</code> 创建了子进程但返回之前在子进程中调用，他的任务是对所有 <code>prepare</code> 中获取的锁解锁。</p>\n","excerpt":"<p>进程，它是资源分配的最小单位，进程中的事情需要按照一定的顺序逐个进行，那么：<strong>如何让一个进程中的一些事情同时执行？</strong><br>","more":"</p>\n<p>这时候就需要使用线程。<strong>线程</strong>，有时又称轻量级进程，它是 <strong>程序执行的最小单位</strong>，<strong>系统独立调度和分派 cpu 的基本单位</strong>，它是<strong>进程中的一个实体</strong>。一个进程中可以有多个线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。</p>\n<p>在了解线程之前需要清楚几个概念：</p>\n<ol>\n<li><strong>并发</strong><br>并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。 <strong>看起来同时发生</strong></li>\n<li><strong>并行</strong><br>并行是指在同一时刻，有多条指令在多个处理器上同时执行。<strong>真正的同时发生</strong></li>\n<li><strong>同步</strong><br>彼此有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情。</li>\n<li><strong>异步</strong><br>异步的概念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生。</li>\n</ol>\n<p>线程解决了进程的很多弊端：一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此，线程具有以下优势：</p>\n<blockquote>\n<p>1、在多处理器中开发程序的并行性<br>    2、在等待慢速IO操作时，程序可以执行其他操作，提高并发性<br>    3、模块化的编程，能更清晰的表达程序中独立事件的关系，结构清晰<br>    4、占用较少的系统资源</p>\n</blockquote>\n<h2 id=\"一、线程的创建：\"><a href=\"#一、线程的创建：\" class=\"headerlink\" title=\"一、线程的创建：\"></a>一、线程的创建：</h2><p>每个 Linux 都会运行在下面四种状态下：</p>\n<ul>\n<li>就绪<br>当线程刚被创建时就处于就绪状态，或者当线程被解除阻塞以后也会处于就绪状态。就绪的线程在等待一个可用的处理器，当一个运行的线程被抢占时，它立刻又回到就绪状态</li>\n<li>运行<br>当处理器选中一个就绪的线程执行时，它立刻变成运行状态</li>\n<li>阻塞<br>线程会在以下情况下发生阻塞：试图加锁一个已经被锁住的互斥量，等待某个条件变量，调用singwait等待尚未发生的信号，执行无法完成的I/O信号，由于内存页错误。</li>\n<li>终止<br>线程可以在启动函数中返回来终止自己，或者调用 <code>pthread_exit</code> 退出，或者取消线程。</li>\n</ul>\n<h3 id=\"1-线程ID\"><a href=\"#1-线程ID\" class=\"headerlink\" title=\"1. 线程ID\"></a>1. 线程ID</h3><p>我们首先来看下线程的创建，线程的创建使用的是 <code>pthread_create</code> 函数:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;pthread.h&gt;</div><div class=\"line\">int pthread_create (pthread_t *thread,</div><div class=\"line\">                    pthread_attr_t *attr,</div><div class=\"line\">                    void *(*start_routine)(void *),</div><div class=\"line\">                    void *arg);</div></pre></td></tr></table></figure></p>\n<p>功能：创建一个线程。<br>第一个参数 <code>thread</code>：新线程的id，如果成功则新线程的id回填充到tidp指向的内存<br>第二个参数 <code>attr</code>：线程属性（调度策略，继承性，分离性…）<br>第三个参数 <code>start_routine</code>：回调函数（新线程要执行的函数）<br>第四个参数 <code>arg</code>：回调函数的参数<br>返回值：成功返回0，失败则返回错误码</p>\n<p>当线程被创建时，<code>thread</code> 被写入一个标识符，我们使用这个标识符来引用被创建的线程。<code>attr</code> 可以用来详细设定线程的属性，一般为 <code>NULL</code>，我们会在本篇博客的最后详细介绍线程的属性，<code>start_routine</code> 指向了一个函数地址，我们可以定义任意一个具有一个任意类型的参数并返回任意一个返回值的函数作为线程的执行函数，最后一个 <code>arg</code> 传入了该函数的参数。需要注意的是：</p>\n<blockquote>\n<p>编译时需要连接库 <code>libpthread</code>。<br>新线程可能在当前线程从函数 <code>pthread_create</code> 返回之前就已经运行了，甚至新线程可能在当前线程从函数 <code>pthread_create</code> 返回之前就已经运行完毕了。</p>\n</blockquote>\n<p>对于一个线程，可以使用 <code>pthread_self()</code> 函数来获取自己的线程号。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_self</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：返回当前线程的线程 id。<br>返回值：调用线程的线程ID。</p>\n<p>还有一个函数是 <code>pthread_equal()</code> 可以用来判断两个线程ID 是否一致。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_equal</span> <span class=\"params\">(<span class=\"keyword\">pthread_t</span> tid1, <span class=\"keyword\">pthread_t</span> tid2)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：功能判断两个线程ID是否一致。<br>参数：<code>tid1</code> <code>tid2</code> 需要判断的ID<br>返回值：相等返回非0值，不相等返回0.</p>\n<p>这样，主线程可以将工作任务放在一个队列中，并将每个任务添加一个进程ID标识，这样相应的线程使用上面两个函数就可以取出和自己相关的任务。</p>\n<h3 id=\"2-初始线程-主线程\"><a href=\"#2-初始线程-主线程\" class=\"headerlink\" title=\"2. 初始线程/主线程\"></a>2. 初始线程/主线程</h3><p>当c程序运行时，首先运行 <code>main</code> 函数。在线程代码中，这个特殊的执行流被称作初始线程或者主线程。你可以在初始线程中做任何普通线程可以做的事情。主线程的特殊性在于:</p>\n<ul>\n<li>它在 <code>main</code> 函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用 <code>pthread_exit</code> 函数，这样进程就会等待所有线程结束时才终止。</li>\n<li>主线程接受参数的方式是通过 <code>argc</code> 和 <code>argv</code>，而普通的线程只有一个参数 <code>void*</code>。</li>\n<li>在绝大多数情况下，主线程在默认堆栈上运行，这个堆栈可以增长到足够的长度。而普通线程的堆栈是受限制的，一旦溢出就会产生错误。</li>\n</ul>\n<h2 id=\"二、线程的运行\"><a href=\"#二、线程的运行\" class=\"headerlink\" title=\"二、线程的运行\"></a>二、线程的运行</h2><h3 id=\"1-线程的退出\"><a href=\"#1-线程的退出\" class=\"headerlink\" title=\"1. 线程的退出\"></a>1. 线程的退出</h3><p>退出线程使用的是 <code>pthread_exit</code>，需要注意的是：线程函数不能使用 <code>exit()</code> 退出，<code>exit</code>是危险的：如果进程中的任意一个线程调用了 <code>exit</code>，<code>_Exit</code>，<code>_exit</code>，那么整个进程就会终止，普通的单个线程以以下三种方式退出，不会终止进程：</p>\n<ol>\n<li>从启动函数中返回，返回值是线程的退出码。</li>\n<li>线程可以被同一进程中的其他线程取消。</li>\n<li>线程调用 <code>pthread_exit()</code> 函数。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span> *rval)</span></span>;</div></pre></td></tr></table></figure>\n<p> 功能：退出一个线程。<br> 参数：<code>rval</code> 是个无类型的指针，保存线程的退出码，其他线程可以通过 <code>pthread_join()</code> 函数来接收这个值。</p>\n<h3 id=\"2-线程的回收\"><a href=\"#2-线程的回收\" class=\"headerlink\" title=\"2. 线程的回收\"></a>2. 线程的回收</h3><p>类似于进程的 <code>wait()</code> 函数，线程也有相应的机制，称为线程的回收，和这个机制紧密相关的一个概念是线程的<strong>分离属性</strong>。</p>\n<p><strong>线程的分离属性：</strong> </p>\n<blockquote>\n<p>分离一个正在运行的线程并不影响它，仅仅是通知当前系统该线程结束时，其所属的资源可以回收。<br> 一个没有被分离的线程在终止时会保留它的虚拟内存，包括他们的堆栈和其他系统资源，有时这种线程被称为<strong>僵尸线程</strong>。<br> 创建线程时<strong>默认是非分离的</strong>。</p>\n</blockquote>\n<p>如果线程具有分离属性，线程终止时会被立刻回收，回收将释放掉所有在线程终止时未释放的系统资源和进程资源，包括保存线程返回值的内存空间、堆栈、保存寄存器的内存空间等。<br>终止被分离的线程会释放所有的系统资源，但是你必须释放由该线程占有的程序资源。由 <code>malloc()</code> 或者 <code>mmap()</code> 分配的内存可以在任何时候由任何线程释放，条件变量、互斥量、信号灯可以由任何线程销毁，只要他们被解锁了或者没有线程等待。但是只有互斥量的主人才能解锁它，所以<strong>在线程终止前，你需要解锁互斥量</strong>。</p>\n<p>将已创建的线程设置为分离的有两种方式：</p>\n<ul>\n<li><p>调用 <code>pthread_detach()</code> 这个函数，那么当这个线程终止的时候，和它相关的系统资源将被自动释放。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_detach</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：分离一个线程，线程可以自己分离自己。<br>参数：<code>thread</code> 指定线程的 id。<br>返回值：成功返回0，失败返回错误码</p>\n</li>\n<li><p>调用 <code>pthread_join</code> 会使指定的线程处于分离状态()，如果指定线程已经处于分离状态，那么调用就会失败。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthead_t</span> tid, <span class=\"keyword\">void</span> **rval)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：调用该函数的线程会一直阻塞，直到指定的线程 <code>tid</code> 调用 <code>pthread_exit</code>、从启动函数返回或者被取消。<br>参数：参数 <code>tid</code> 就是指定线程的 <code>id</code>，参数 <code>rval</code> 是指定线程的返回码，如果线程被取消，那么 <code>rval</code> 被置为 <code>PTHREAD_CANCELED</code><br>返回值：该函数调用成功会返回0，失败返回错误码</p>\n</li>\n</ul>\n<h3 id=\"3-线程的取消\"><a href=\"#3-线程的取消\" class=\"headerlink\" title=\"3. 线程的取消\"></a>3. 线程的取消</h3><p>线程的取消类似于一个线程向另一个线程发送了一个信号，要求它终止，相应的取消函数很简单：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cancle</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> tid)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：请求一个线程终止<br>参数：<code>tid</code> 指定的线程<br>返回值：成功返回0，失败返回错误码。</p>\n<p>取消只是发送一个请求，并不意味着等待线程终止，而且发送成功也不意味着 <code>tid</code> 一定会终止，它通常需要被取消线程的配合。线程在很多时候会查看自己取消状态，如果有就主动退出， 这些查看是否有取消的地方称为取消点</p>\n<p>这时候，我们又有了两个概念：<strong>取消状态</strong>，<strong>取消点</strong>。</p>\n<ul>\n<li><p>取消状态<br>取消状态，就是线程对取消信号的处理方式，忽略或者响应。线程创建时默认响应取消信号，相应的设置函数为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcancelstate</span><span class=\"params\">(<span class=\"keyword\">int</span> state, <span class=\"keyword\">int</span> *oldstate)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：设置本线程对取消请求(CANCEL 信号)的反应<br>参数：<code>state</code> 有两种值：<code>PTHREAD_CANCEL_ENABLE</code>（缺省，接收取消请求）和 <code>PTHREAD_CANCEL_DISABLE</code>(忽略取消请求)；<code>old_state</code> 如果不为NULL则存入原来的Cancel状态以便恢复<br>返回值：成功返回0，失败返回错误码。</p>\n<p>如果函数设置为接收取消请求，还可以设置他的<strong>取消类型</strong>:<br>取消类型，是线程对取消信号的响应方式，立即取消或者延时取消。线程创建时默认延时取消</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcanceltype</span><span class=\"params\">(<span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> *oldtype)</span> </span>;</div></pre></td></tr></table></figure>\n<p>功能：设置本线程取消动作的执行时机<br>参数：<code>type</code> 由两种取值：<code>PTHREAD_CANCEL_DEFFERED</code> 表示收到信号后继续运行至下一个取消点再退出， <code>PTHREAD_CANCEL_ASYCHRONOUS</code> 标识立即执行取消动作（退出）；两者仅当 Cancel 状态为 Enable 时有效；<code>oldtype</code> 如果不为NULL则存入运来的取消动作类型值。<br>返回值：成功返回0，失败则返回错误码</p>\n</li>\n<li><p>取消点<br>取消点：取消一个线程，默认需要被取消线程的配合。线程在很多时候会查看自己是否有取消请求，如果有就主动退出， 这些查看是否有取消的地方称为取消点。很多地方都是包含取消点，包括 <code>pthread_join()</code>、 <code>pthread_testcancel()</code>、<code>pthread_cond_wait()</code>、 <code>pthread_cond_timedwait()</code>、<code>sem_wait()</code>、<code>sigwait()</code> 以及 <code>write</code>、<code>read</code> 等大多数会阻塞的系统调用。</p>\n</li>\n</ul>\n<h3 id=\"4-线程的清除\"><a href=\"#4-线程的清除\" class=\"headerlink\" title=\"4. 线程的清除\"></a>4. 线程的清除</h3><p>线程可以安排它退出时的清理操作，这与进程的可以用atexit函数安排进程退出时需要调用的函数类似。这样的函数称为线程清理处理程序。线程可以建立多个清理处理程序，处理程序记录在栈中，所以这些处理程序执行的顺序与他们注册的顺序相反<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"keyword\">void</span> pthread_cleanup_push（<span class=\"keyword\">void</span> （*rtn）（<span class=\"keyword\">void</span>*）， <span class=\"keyword\">void</span> *args）<span class=\"comment\">//注册处理程序</span></div><div class=\"line\"><span class=\"keyword\">void</span> pthread_cleanup_pop（<span class=\"keyword\">int</span> excute）<span class=\"comment\">//清除处理程序</span></div></pre></td></tr></table></figure></p>\n<p>当执行以下操作时调用清理函数，清理函数的参数由 <code>args</code> 传入</p>\n<ol>\n<li>调用 <code>pthread_exit</code></li>\n<li>响应取消请求</li>\n<li>用非零参数调用 <code>pthread_cleanup_pop</code></li>\n</ol>\n<p><strong><code>return</code> 不调用清理操作</strong>。</p>\n<h2 id=\"五、线程的同步\"><a href=\"#五、线程的同步\" class=\"headerlink\" title=\"五、线程的同步\"></a>五、线程的同步</h2><p>有几种方法可以很好的控制线程执行和访问临界区域，主要是互斥量和信号量。</p>\n<h3 id=\"1-互斥量\"><a href=\"#1-互斥量\" class=\"headerlink\" title=\"1. 互斥量\"></a>1. 互斥量</h3><ul>\n<li>为什么要使用互斥量？<br>当多个线程共享相同的内存时，需要每一个线程看到相同的视图。当一个线程修改变量时，而其他线程也可以读取或者修改这个变量，就需要对这些线程同步，确保他们不会访问到无效的变量。<br>为了让线程访问数据不产生冲突，这要就需要对变量加锁，使得同一时刻只有一个线程可以访问变量。互斥量本质就是锁，访问共享资源前对互斥量加锁，访问完成后解锁。<br>当互斥量加锁以后，其他所有需要访问该互斥量的线程都将阻塞，当互斥量解锁以后，所有因为这个互斥量阻塞的线程都将变为就绪态，第一个获得cpu的线程会获得互斥量，变为运行态，而其他线程会继续变为阻塞，在这种方式下访问互斥量每次只有一个线程能向前执行. </li>\n</ul>\n<ol>\n<li><p>互斥量的初始化和销毁</p>\n<p>互斥量用 <code>pthread_mutex_t</code> 类型的数据表示，在使用之前需要对互斥量初始化</p>\n<ul>\n<li>如果是动态分配的互斥量，可以调用 <code>pthread_mutex_init()</code>函数初始化</li>\n<li>如果是静态分配的互斥量，还可以把它置为常量 <code>PTHREAD_MUTEX_INITIALIZER</code></li>\n<li>动态分配的互斥量在释放内存之前需要调用 <code>pthread_mutex_destroy()</code></li>\n</ul>\n<p>相应的处理函数为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex,</div><div class=\"line\">       <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;  <span class=\"comment\">//动态初始化互斥量</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>; <span class=\"comment\">//动态互斥量销毁</span></div><div class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class=\"comment\">//静态初始化互斥量</span></div></pre></td></tr></table></figure>\n<p><code>mutex</code> 为需要创建或销毁的互斥量；<code>attr</code> 为新建互斥量的属性，默认为 <code>PTHREAD_MUTEX_TIMED_NP</code>， 即普通锁。</p>\n</li>\n<li><p>加锁和解锁</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure>\n<p> 成功返回0，失败返回错误码。如果互斥量已经被锁住，那么会导致该线程阻塞。</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;`</div></pre></td></tr></table></figure>\n<p> 成功返回0，失败返回错误码。如果互斥量已经被锁住，不会导致线程阻塞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure>\n<p> 成功返回0，失败返回错误码。如果一个互斥量没有被锁住，那么解锁就会出错。</p>\n</li>\n<li><p>死锁<br>死锁：线程一直在等待锁，而锁却无法解开。如果一个线程对已经占有的互斥量继续加锁，那么他就会陷入死锁状态。</p>\n<p><strong>如何去避免死锁？</strong><br>你可以小心的控制互斥量加锁的顺序来避免死锁，例如所有的线程都在加锁B之前先加锁A，那么这两个互斥量就不会产生死锁了。有的时候程序写的多了互斥量就难以把控，你可以先释放已经占有的锁，然后再加锁其他互斥量。</p>\n</li>\n</ol>\n<p>互斥量使用要注意：</p>\n<blockquote>\n<ol>\n<li>访问共享资源时需要加锁</li>\n<li>互斥量使用完之后需要销毁</li>\n<li>加锁之后一定要解锁</li>\n<li>互斥量加锁的范围要小</li>\n<li>互斥量的数量应该少</li>\n</ol>\n</blockquote>\n<h3 id=\"2-信号量\"><a href=\"#2-信号量\" class=\"headerlink\" title=\"2. 信号量\"></a>2. 信号量</h3><p>这里说的信号量和前一篇说的信号量不同，这里的信号量来自 POSIX 的实时扩展，而之前的信号量来自于 System V。两者的函数接口相似，但是不用通用。这里的相关信号量函数都以 <code>sem_</code> 开头。相关的函数有四个：</p>\n<ol>\n<li><p><code>sem_init</code> 函数<br>该函数用于创建信号量，其原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_init</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem, <span class=\"keyword\">int</span> pshared， <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> value)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数初始化由 <code>sem</code> 指向的信号对象，设置它的共享选项，并给它一个初始的整数值。<code>pshared</code> 控制信号量的类型，如果其值为0，就表示这个信号量是当前进程的局部信号量，否则信号量就可以在多个进程之间共享，<code>value</code> 为 <code>sem</code> 的初始值。<br>调用成功时返回0，失败返回-1.</p>\n</li>\n<li><p><code>sem_wait</code> 函数<br>该函数用于以原子操作的方式将信号量的值减1。原子操作就是，如果两个线程企图同时给一个信号量加1或减1，它们之间不会互相干扰。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_wait</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>sem</code> 指向的对象是由 <code>sem_init</code> 调用初始化的信号量。<br>调用成功时返回0，失败返回-1.</p>\n</li>\n<li><p><code>sem_post</code> 函数<br>该函数用于以原子操作的方式将信号量的值加1。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_post</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem)</span></span>;</div></pre></td></tr></table></figure>\n<p>与 <code>sem_wait</code> 一样，<code>sem</code> 指向的对象是由 <code>sem_init</code> 调用初始化的信号量。<br>调用成功时返回0，失败返回-1.</p>\n</li>\n<li><p><code>sem_destroy</code> 函数<br>该函数用于对用完的信号量的清理。它的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_destroy</span><span class=\"params\">(<span class=\"keyword\">sem_t</span> *sem)</span></span>;  </div><div class=\"line\">成功时返回<span class=\"number\">0</span>，失败时返回<span class=\"number\">-1.</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-读写锁\"><a href=\"#3-读写锁\" class=\"headerlink\" title=\"3. 读写锁\"></a>3. 读写锁</h3><p><strong>什么是读写锁，它与互斥量的区别：</strong><br>读写锁与互斥量类似，不过读写锁有更高的并行性。互斥量要么加锁要么不加锁，而且同一时刻只允许一个线程对其加锁。但是对于一个变量的读取，完全可以让多个线程同时进行操作。这时候读写锁更为实用。</p>\n<ul>\n<li>读写锁有三种状态，读模式下加锁，写模式下加锁，不加锁。相应的使用方法为：<ul>\n<li>一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式的读写锁。 </li>\n<li>读写锁在写加锁状态时，在它被解锁之前，所有试图对这个锁加锁的线程都会阻塞。</li>\n<li>读写锁在读加锁状态时，所有试图以读模式对其加锁的线程都会获得访问权，但是如果线程希望以写模式对其加锁，它必须阻塞直到所有的线程释放锁。 </li>\n<li>读写锁在读加锁状态时，如果有线程试图以写模式对其加锁，那么读写锁会阻塞随后的读模式锁请求。这样可以避免读锁长期占用，而写锁达不到请求。</li>\n</ul>\n</li>\n</ul>\n<p>读写锁非常适合对数据结构读次数大于写次数的程序，当它以读模式锁住时，是以共享的方式锁住的；当它以写模式锁住时，是以独占的模式锁住的。</p>\n<ol>\n<li><p>读写锁的初始化和销毁<br>读写锁在使用之前必须初始化,使用完需要销毁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_init</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *<span class=\"keyword\">restrict</span> rwlock,</div><div class=\"line\">          <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_rwlockattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>成功返回0 ，失败返回错误码</p>\n</li>\n<li><p>加锁和解锁<br>读模式加锁    </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_rdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_tryrdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>写模式加锁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_wrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_trywrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>解锁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</div></pre></td></tr></table></figure>\n<p>成功返回0</p>\n</li>\n</ol>\n<h3 id=\"3-条件变量\"><a href=\"#3-条件变量\" class=\"headerlink\" title=\"3.  条件变量\"></a>3.  条件变量</h3><p>条件变量的引入：我们需要一种机制，当互斥量被锁住以后发现当前线程还是无法完成自己的操作，那么它应该释放互斥量，让其他线程工作。条件变量的作用就是可以采用轮询的方式，不停的让系统来帮你查询条件。</p>\n<ol>\n<li><p>条件变量的初始化和销毁<br>条件变量使用之前需要初始化，条件变量使用完成之后需要销毁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;    <span class=\"comment\">//静态初始化条件变量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_init</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,</div><div class=\"line\">                      <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_condattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>; <span class=\"comment\">//动态初始化条件变量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;<span class=\"comment\">//销毁条件变量</span></div></pre></td></tr></table></figure>\n<p>动态条件变量的初始化和销毁函数返回值都是成功返回0，失败返回错误代码。<code>attr</code> 的值一般为 <code>NULL</code>。详细的设置在下个章节。</p>\n</li>\n<li><p>条件变量的等待和唤醒<br>条件变量使用需要配合互斥量</p>\n<ol>\n<li><p>使用 <code>pthread_cond_wait</code> 等待条件变为真。传递给 <code>pthread_cond_wait</code> 的互斥量对条件进行保护，调用者把锁住的互斥量传递给函数。<br>这个函数将线程放到等待条件的线程列表上，然后对互斥量进行解锁，这是个原子操作。当条件满足时这个函数返回，返回以后继续对互斥量加锁。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_wait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,</div><div class=\"line\">                      <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex)</span></span>;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_timedwait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,</div><div class=\"line\">                            <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex,</div><div class=\"line\">                            <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> timespec *<span class=\"keyword\">restrict</span> abstime)</span></span>;</div></pre></td></tr></table></figure>\n<p>这个函数与 <code>pthread_cond_wait</code> 类似，只是多一个 <code>timeout</code>，如果到了指定的时间条件还不满足，那么就返回。<br>注意，这个时间是绝对时间。例如你要等待3分钟，就要把当前时间加上3分钟然后转换到 <code>timespec</code>，而不是直接将3分钟转换到 <code>timespec</code>。</p>\n</li>\n<li><p>当条件满足的时候，需要唤醒等待条件的线程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_broadcast</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>; <span class=\"comment\">//唤醒等待条件的所有线程</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_signal</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;    <span class=\"comment\">//至少唤醒等待条件的某一个线程</span></div></pre></td></tr></table></figure>\n<p>注意，<strong>一定要在条件改变以后在唤醒线程。</strong></p>\n</li>\n</ol>\n</li>\n<li><p>条件变量的使用<br>条件变量主要使用在那些需要条件触发的场景。譬如，一个经典的生产者消费者的问题。消费者等待生产者生产，如果单纯的使用互斥量，当然也可以解决问题，但是在生产者没有生产的时候，消费者就需要不停的轮询，大大浪费了CPU资源。我们更期待的是等生产者生产后”通知”我们的消费者，所以我们使用条件变量：<br>生产者线程的执行顺序是：加锁 -&gt; 生产 -&gt; <code>pthread_cond_signal</code> -&gt; 释放锁<br>消费者线程的执行顺寻是：加锁 -&gt; while(没有生产) <code>pthread_cond_wait</code>; 当没有商品存在的时候，进入条件变量，此时条件变量首先释放了锁，然后阻塞等待 <code>pthread_cond_signal</code> 信号的发送，接收到信号之后，申请锁，<code>pthread_cond_wait</code>结束， -&gt; 执行相应的程序 -&gt; 释放锁。</p>\n</li>\n</ol>\n<h2 id=\"六、线程的控制\"><a href=\"#六、线程的控制\" class=\"headerlink\" title=\"六、线程的控制\"></a>六、线程的控制</h2><h3 id=\"1-线程属性\"><a href=\"#1-线程属性\" class=\"headerlink\" title=\"1. 线程属性\"></a>1. 线程属性</h3><p>线程的属性用 <code>pthread_attr_t</code> 类型的结构表示，在创建线程的时候可以不用传入NULL，而是传入一个 <code>pthread_attr_t</code> 结构，由用户自己来配置线程的属性。<code>pthread_attr_t</code> 结构中定义的线程属性有很多：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>detachstate</td>\n<td>线程的分离状态</td>\n</tr>\n<tr>\n<td>guardsize</td>\n<td>线程栈末尾的警戒区域大小（字节数）</td>\n</tr>\n<tr>\n<td>stacksize</td>\n<td>线程栈的最低地址</td>\n</tr>\n<tr>\n<td>stacksize</td>\n<td>线程栈的大小（字节数）</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>线程属性的初始化和销毁<br>线程的初始化和销毁使用下面两个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span>;     <span class=\"comment\">//线程属性初始化</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span>;  <span class=\"comment\">//线程属性销毁</span></div></pre></td></tr></table></figure>\n<p>如果在调用 <code>pthread_attr_init</code> 初始化属性的时候分配了内存空间，那么 <code>pthread_attr_destroy</code> 将释放内存空间。除此之外，<code>pthread_atty_destroy</code> 还会用无效的值初始化 <code>pthread_attr_t</code> 对象，因此如果该属性对象被误用，会导致创建线程失败。<code>pthread_attr_t</code> 类型对应用程序是不透明的，也就是说应用程序不需要了解有关属性对象内部结构的任何细节，因而可以增加程序的可移植性。</p>\n</li>\n</ol>\n<ol>\n<li><p>线程的分离属性<br>线程的分离属性已经在前面的章节介绍过了，如果在创建线程的时候就知道不需要了解线程的终止状态，那么可以修改 <code>pthread_attr_t</code> 结构体的 <code>detachstate</code> 属性，让线程以分离状态启动。线程的分离属性有两种合法值:<br><code>PTHREAD_CREATE_DETACHED</code> 分离的；<br><code>PTHREAD_CREATE_JOINABLE</code> 非分离的，可连接的；<br>设置线程分离属性的步骤</p>\n<ol>\n<li>定义线程属性变量 <code>pthread_attr_t attr</code></li>\n<li>初始化 <code>attr</code> ，<code>pthread_attr_init(&amp;attr)</code></li>\n<li>设置线程为分离或非分离 <code>pthread_attr_setdetachstate(&amp;attr, detachstate)</code></li>\n<li>创建线程 <code>pthread_create（&amp;tid， &amp;attr， thread_fun,  NULL）</code></li>\n</ol>\n</li>\n<li><p>线程的栈属性<br>对一个进程，他的虚拟空间的大小是固定的，如果程序启动了大量的线程，因为所有的线程共享进程的的虚拟地址空间，所以按照默认的栈大小，虚拟空间就会不足，需要调小栈空间。或者某个线程使用了大量的自动变量，这时候需要调大栈空间，具体的分配使用不再详说，介绍下相关的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setstack</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">void</span> *stackaddr, <span class=\"keyword\">size_t</span> stacksize)</span></span>;   <span class=\"comment\">//修改栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getstack</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">void</span> **stackaddr, <span class=\"keyword\">size_t</span> *stacksize)</span></span>; <span class=\"comment\">//获取栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setstacksize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> stacksize)</span></span>;                <span class=\"comment\">//单独设置栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getstacksize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> *stacksize)</span></span>;               <span class=\"comment\">//单独获取栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setguardsize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> guardsize)</span></span>;                <span class=\"comment\">//单独设置栈属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getguardsize</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">size_t</span> *guardsize)</span></span>;               <span class=\"comment\">//单独获取栈属性</span></div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。<br>对于遵循POSIX标准的系统来说，不一定要支持线程的栈属性，因此你需要检查</p>\n<ol>\n<li>在编译阶段使用<br><code>_POSIX_THREAD_ATTR_STACKADDR</code> 和 <code>_POSIX_THREAD_ATTR_STACKSIZE</code> 符号来检查系统是否支持线程栈属性。</li>\n<li>在运行阶段把<br><code>_SC_THREAD_ATTR_STACKADD</code> 和 <code>_SC_THREAD_THREAD_ATTR_STACKSIZE</code> 传递给 <code>sysconf</code> 函数检查系统对线程栈属性的支持。</li>\n</ol>\n</li>\n<li><p>线程的其他属性：<br>线程还有一些属性没有在 <code>pthread_attr_t</code> 结构体中定义，如已经在上面介绍过的线程的取消状态和线程的取消类型，还有没有介绍的线程的并发度，这些就不再详细描述。</p>\n</li>\n</ol>\n<h3 id=\"2-同步属性\"><a href=\"#2-同步属性\" class=\"headerlink\" title=\"2. 同步属性\"></a>2. 同步属性</h3><ol>\n<li><p><strong>互斥量的属性</strong><br>就像线程有属性一样，线程的同步互斥量也有属性，比较重要的是进程共享属性和类型属性。互斥量的属性用 <code>pthread_mutexattr_t</code> 类型的数据表示，当然在使用之前必须进行初始化，使用完成之后需要进行销毁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>;    <span class=\"comment\">//互斥量属性初始化</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>; <span class=\"comment\">//互斥量属性销毁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *<span class=\"keyword\">restrict</span> attr, </div><div class=\"line\">                                  <span class=\"keyword\">int</span> *<span class=\"keyword\">restrict</span> pshared)</span></span>; <span class=\"comment\">//获取互斥量属性</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr, </div><div class=\"line\">                                 <span class=\"keyword\">int</span> pshared)</span></span>;            <span class=\"comment\">//设置互斥量属性</span></div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。<br>互斥量属性的相关的值有：</p>\n<ul>\n<li><code>PTHREAD_MUTEX_TIMED_NP</code>，缺省值，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。</li>\n<li><code>PTHREAD_MUTEX_RECURSIVE_NP</code>，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</li>\n<li><code>PTHREAD_MUTEX_ERRORCHECK_NP</code>，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</li>\n<li><code>PTHREAD_MUTEX_ADAPTIVE_NP</code>，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。</li>\n</ul>\n</li>\n<li><p><strong>读写锁的属性</strong><br>读写锁也有属性，它只有一个进程共享属性:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_rwlockattr_t</span> *<span class=\"keyword\">restrict</span> attr, <span class=\"keyword\">int</span> *<span class=\"keyword\">restrict</span> pshared)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlockattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlockattr_t</span> *attr, <span class=\"keyword\">int</span> pshared)</span></span>;</div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。</p>\n</li>\n<li><p><strong>条件变量的属性</strong><br>条件变量也有进程共享属性:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_condattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_condattr_t</span> *attr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_condattr_t</span> *<span class=\"keyword\">restrict</span> attr, <span class=\"keyword\">int</span> *<span class=\"keyword\">restrict</span> pshared)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_condattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">pthread_condattr_t</span> *attr, <span class=\"keyword\">int</span> pshared)</span></span>;</div></pre></td></tr></table></figure>\n<p>上述函数的返回值都是成功返回0，失败返回相应的错误编码。</p>\n</li>\n</ol>\n<h3 id=\"3-私有数据\"><a href=\"#3-私有数据\" class=\"headerlink\" title=\"3. 私有数据\"></a>3. 私有数据</h3><p>应用程序设计中有必要提供一种变量，使得多个函数多个线程都可以访问这个变量（看起来是个全局变量），但是线程对这个变量的访问都不会彼此产生影响（貌似不是全局变量哦），但是你需要这样的数据，比如 <code>errno</code>。那么这种数据就是线程的私有数据，尽管名字相同，但是每个线程访问的都是数据的副本。</p>\n<p>在使用私有数据之前，你首先要创建一个与私有数据相关的键，要来获取对私有数据的访问权限 。这个键的类型是 <code>pthread_key_t</code>:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int pthread_key_create(pthread_key_t *key, void (*destructor)(voi8d*));</div></pre></td></tr></table></figure></p>\n<p>创建的键放在key指向的内存单元，<code>destructor</code> 是与键相关的析构函数。当线程调用 <code>pthread_exit</code> 或者使用 <code>return</code> 返回，析构函数就会被调用。当析构函数调用的时候，它只有一个参数，这个参数是与key关联的那个数据的地址，因此你可以在析构函数中将这个数据销毁。</p>\n<p>键使用完之后也可以删除，当键删除之后，与它关联的数据并没有销毁:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_key_delete</span><span class=\"params\">(<span class=\"keyword\">pthread_key_t</span> key)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>有了键之后，你就可以将私有数据和键关联起来，这样就就可以通过键来找到数据。所有的线程都可以访问这个键，但他们可以为键关联不同的数据。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setspecific</span><span class=\"params\">(<span class=\"keyword\">pthread_key_t</span> key, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *value)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>将私有数据与key关联</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">pthread_getspecific</span><span class=\"params\">(<span class=\"keyword\">pthread_key_t</span> key)</span></span>;</div></pre></td></tr></table></figure>\n<p>获取私有数据的地址，如果没有数据与key关联，那么返回空。</p>\n<p>有些事需要且只能执行一次（比如互斥量初始化）。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库函数时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始（<code>pthread_once_t</code>）会比较容易些。</p>\n<ul>\n<li>首先要定义一个 <code>pthread_once_t</code>变量，这个变量要用宏 <code>PTHREAD_ONCE_INIT</code> 初始化。然后创建一个与控制变量相关的初始化函数<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</div><div class=\"line\"><span class=\"keyword\">void</span> init_routine（）</div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"comment\">//初始化互斥量</span></div><div class=\"line\"> <span class=\"comment\">//初始化读写锁</span></div><div class=\"line\"> ......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>接下来就可以在任何时刻调用pthread_once函数</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int pthread_once(pthread_once_t* once_control, void (*init_routine)(void));</div></pre></td></tr></table></figure>\n<p>功能：本函数使用初值为 <code>PTHREAD_ONCE_INIT</code> 的 <code>once_control</code> 变量保证 <code>init_routine()</code> 函数在本进程执行序列中仅执行一次。在多线程编程环境下，尽管<code>pthread_once()</code> 调用会出现在多个线程中，<code>init_routine()</code> 函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。”一次性函数”的执行状态有三种：<code>NEVER（0）</code>. <code>IN_PROGRESS（1）</code>. <code>DONE （2）</code>，用 <code>once_control</code> 来表示 <code>pthread_once()</code> 的执行状态：</p>\n<ol>\n<li>如果 <code>once_control</code> 初值为0，那么 <code>pthread_once</code> 从未执行过，<code>init_routine()</code> 函数会执行。</li>\n<li>如果 <code>once_control</code> 初值设为1，则由于所有 <code>pthread_once()</code> 都必须等待其中一个激发”已执行一次”信号， 因此所有 <code>pthread_once ()</code> 都会陷入永久的等待中，<code>init_routine()</code> 就无法执行</li>\n<li>如果 <code>once_control</code> 设为2，则表示 <code>pthread_once()</code> 函数已执行过一次，从而所有 <code>pthread_once()</code>都会立即返回，<code>init_routine()</code>就没有机会执行。当pthread_once函数成功返回，once_control就会被设置为2</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"4-线程的信号\"><a href=\"#4-线程的信号\" class=\"headerlink\" title=\"4. 线程的信号\"></a>4. 线程的信号</h3><p>在线程中使用信号，与在进程中使用信号机制有着根本的区别。在进程环境中，对信号的处理是异步的（我们完全不知到信号会在进程的那个执行点到来！）。但是在多线程中处理信号的原则完全不同，它的基本原则是：将对信号的异步处理，转换成同步处理，也就是说用一个线程专门的来“同步等待”信号的到来，而其它的线程可以完全不被该信号中断/打断(interrupt)。</p>\n<ul>\n<li><p>信号的发送<br>线程中信号的发送并不使用 <code>kill()</code> 函数，而是有专门的进程信号函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span> </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_kill</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">int</span> sig)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：向指定ID的线程发送信号。<br>参数：<code>thread</code> 进程标识符，<code>sig</code> 发送的信号。</p>\n<p>如果线程代码内不做处理，则按照信号默认的行为影响整个进程，也就是说，如果你给一个线程发送了 <code>SIGQUIT</code> ，但线程却没有实现 <code>signal</code> 处理函数，则整个进程退出。如果要获得正确的行为，就需要在线程内实现 <code>signal(SIGKILL,sig_handler)</code> 了。所以，如果 <code>sig</code> 不是0，那一定要清楚到底要干什么，而且一定要实现线程的信号处理函数，否则，就会影响整个进程。如果 <code>sig</code> 是0，这是一个保留信号，其实并没有发送信号，作用是用来判断线程是不是还活着。</p>\n</li>\n<li><p>信号的接收<br>在多线程代码中，总是使用 <code>sigwait</code> 或者 <code>sigwaitinfo</code> 或者 <code>sigtimedwait</code> 等函数来处理信号。而不是 <code>signal</code> 或者 <code>sigaction</code> 等函数。因为在一个线程中调用 <code>signal</code> 或者 <code>sigaction</code> 等函数会改变所以线程中的信号处理函数。而不是仅仅改变调用 <code>signal</code>/<code>sigaction</code> 的那个线程的信号处理函数。</p>\n</li>\n</ul>\n<h3 id=\"5-线程与fork\"><a href=\"#5-线程与fork\" class=\"headerlink\" title=\"5. 线程与fork\"></a>5. 线程与fork</h3><p>当线程调用 <code>fork()</code> 函数时，就为子进程创建了整个进程地址空间的副本，子进程通过继承整个地址空间的副本，也会将父进程的互斥量、读写锁、条件变量的状态继承过来。也就是说，如果父进程调用 <code>fork()</code> 的线程中占有锁，那么在子进程中也占有锁，这是非常不安全的，因为不是子进程自己锁住的，它无法解锁。</p>\n<p>子进程内部只有一个线程，由父进程中调用 <code>fork()</code> 函数的线程副本构成。如果调用 <code>fork()</code> 的线程将互斥量锁住，那么子进程会拷贝一个 <code>pthread_mutex_lock</code> 副本，这样子进程就有机会去解锁了。或者互斥量根本就没被加锁，这样也是可以的，但是你不能确保永远是这样的情况。</p>\n<p><code>pthread_atfork</code> 函数给你创造了这样的条件，它会注册三个函数<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_atfork</span><span class=\"params\">(<span class=\"keyword\">void</span> (*prepare)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\">                   <span class=\"keyword\">void</span> (*parent)(<span class=\"keyword\">void</span>); </div><div class=\"line\">                   <span class=\"keyword\">void</span> (*child)(<span class=\"keyword\">void</span>));</div></pre></td></tr></table></figure></p>\n<p><code>prepare</code> 是在 <code>fork()</code> 调用之前会被调用的，他的任务是获取所有父进程中定义的锁。<br><code>parent</code> 在 <code>fork()</code> 创建了子进程但返回之前在父进程中调用，他的任务是对所有 <code>prepare</code> 中获取的锁解锁。<br><code>child</code> 在 <code>fork()</code> 创建了子进程但返回之前在子进程中调用，他的任务是对所有 <code>prepare</code> 中获取的锁解锁。</p>"},{"title":"Linux驱动开发（三）——并发控制","date":"2016-12-19T19:08:01.000Z","_content":"**并发**的定义是：多个执行单元同时、并行的执行。并发会导致**竞态**：并发的执行单元对共享资源的访问。\n<!--more-->\n以下几种情况会发生竞态：\n\n1. 对称多处理器(SMP)的多个 CPU。\n2. 单个 CPU 内部的多个进程。\n3. 中断与进程之间。\n\n解决竞态的途径是保证对共享资源的**互斥访问**：一个执行单元访问共享资源的时候，其他的执行单元被禁止访问。我们常用的互斥机制有：\n `中断屏蔽`、`原子操作`、`自旋锁`、`信号量`。\n## 一、中断屏蔽\n因为 Linux 的异步 IO、进程调度等很多操作都是通过中断来进行的。所以，最简单的避免竞态的方法就是在进入临界区之前屏蔽系统的中断。但是同样，因为中断有这样重要的作用，长时间的屏蔽中断是很危险的。另外，中断屏蔽只能解决上述三种竞态情况中的后两种，对于第一种竞态是无法解决的。所以中断屏蔽通常和自旋锁搭配使用。\n中断屏蔽的使用方法是：\n````C \nlocal_irq_disable() //屏蔽中断\n...\ncritical section /*临界区*/\n...\nlocal_irq_enable()````\n中断屏蔽通常是和自旋锁联合使用的。\n\n## 二、原子操作\n有时候，共享的资源可能正好是一个整数值或者是位操作。内核提供了一种原子的整数类型（位类型）。相应的操作如下：\n\n* 整形原子操作\n  ````C\n  void atomic_set(atomic_t *v, int i);             //设置原子变量 v 的值为 i\n  atomic_t v = ATOMIC_INIT(0);                     //初始化原子变量 v 的值为 0\n  atomic_read(atomic_t *v);                        //读取原子变量 v 的值\n  void atomic_add(int i, atomic_t *v);             //原子变量 v 的值加 i\n  void atomic_sub(int i, atomic_t *v);             //原子变量 v 的值减 i\n  void atomic_inc(atomic_t *v);                    //原子变量 v 的值自加1\n  void atomic_dec(atomic_t *v);                    //原子变量 v 的值自减1\n  int atomic_inc_and_test(atomic_t *v);            //原子变量 v 的值自加1，并测试是否等于0\n  int atomic_dec_and_test(atomic_t *v);            //原子变量 v 的值自减1，并测试是否等于0\n  int atomic_sub_and_test(int i, atomic_t *v);     //原子变量 v 的值减 i，并测试是否等于0\n  int atomic_add_and_return(int i, atomic_t *v);   //原子变量 v 的值加 i，并返回值\n  int atomic_sub_and_return(int i, atomic_t *v);   //原子变量 v 的值减 i，并返回值\n  int atomic_inc_and_return(atomic_t *v);          //原子变量 v 的值自加1，并返回值\n  int atomic_dec_and_return(atomic_t *v);          //原子变量 v 的值自减1，并返回值\n  ````\n  `atomic_t` 的数据只能通过上述的函数进行访问。\n\n* 位原子操作\n  ````C\n  void set_bit(nr, void *addr);           //设置addr地址的第nr位为1\n  void clear_bit(nr, void *addr);         //设置addr地址的第nr位为0\n  void change_bit(nr, void *addr);        //反置addr地址的第nr位\n  test_bit(nr, void *addr);               //返回addr地址的第nr位\n  int test_and_set_bit(nr, void *addr);   //返回addr地址的第nr位并置该位为1\n  int test_and_clear_bit(nr, void *addr); //返回addr地址的第nr位并置该位为0\n  int test_and_change_bit(nr, void *addr);//返回addr地址的第nr位并反置该位\n  ````\n\n## 三、自旋锁\n自旋锁是一个互斥设备，他只能有两个值：锁定和解锁。为了获取一个自旋锁，程序先执行一个原子操作，测试相关的位，如果锁可用，则锁定，代码进入临界区；如果锁不可用，代码则进入循环测试直到该锁可用。\n\n1. 自旋锁的初始化：\n   可以使用两种方法进行自旋锁的初始化：\n   编译时使用：`spinlock_t my_lock = SPIN_LOCK_UNLOCKED; `\n   运行时使用：`void spin_lock_init(spinlock_t *lock);`  \n\n2. 获取锁\n   获取锁使用下面的函数：\n   ````C\n   void spin_lock(spinlock_t *lock);````\n   需要注意的是，自旋锁的等待是不可中断的，一旦调用了该函数，在获取锁之前将一直处于自旋状态。\n\n   如果不想阻塞等待可以使用非阻塞版本的获取锁：\n   ````C\n   void spin_trylock(spinlock_t *lock);````\n   该函数在成功获取锁的情况下返回非零值，在未获取锁的情况下返回0\n\n3. 释放锁\n   释放锁的函数如下：\n   ````C\n   void spin_unlock(spinlock_t *lock);````\n   这个函数一般与 `spin_lock` 和 `spin_trylock` 搭配使用。\n\n4. 自旋锁和中断\n   自旋锁可以保证临界区不受当前CPU和其他CPU的抢占进程打扰，即能解决前面提到的竞态中的前两种，但是依旧可能受到中断的影响，所以自旋锁有下列衍生：\n   ````C\n   void spin_lock_irq(spinlock_t *lock);   //在获取自旋锁之前禁止中断\n   void spin_lock_irqsave(spinlock_t *lock, unsigned long flags); //在获取锁之前屏蔽中断，并将相应的中断状态保存在 flags 中\n   void spin_lock_bh(spinlock_t *lock);   //在获取锁之前屏蔽软件中断，但保持硬件中断\n   ````\n   当然还有与上面几个函数一一对应的 unlock 函数，不再详细描述。\n\n5. 读写自旋锁\n   读写自旋锁是对自旋锁的扩展，它允许多个读操作并发执行，但是只能有一个写单元。相应的函数如下：\n   ````C\n   rwlock_t my_rwlock = RW_LOCK_UNLOCKED;  //静态初始化读写自旋锁\n   rwlock_init(rwlock_t *my_rwlock);       //动态初始化读写自旋锁\n   void read_lock(rwlock_t *my_rwlock);    //获取读锁\n   void read_unlock(rwlock_t *my_rwlock);  //释放读锁\n   void write_lock(rwlock_t *my_rwlock);   //获取写锁\n   void write_unlock(rwlock_t *my_rwlock); //释放写锁\n   ````\n   读写自旋锁也有相应的中断衍生版本。\n\n6. 顺序锁\n   对于资源较小，频繁被读取但是很少写入的资源，可以使用顺序锁。顺序锁的读执行单元不会被写执行单元阻塞。\n   顺序锁的初始化类似于自旋锁：\n   ````C\n   seqlock_t my_seqlock = SEQLOCK_UNLOCKED;  //静态初始化读写自旋锁\n   seqlock_t_init(seqlock_t *my_seqlock);       //动态初始化读写自旋锁\n   ````\n   对于写单元来说，相应的获取锁和释放锁的机制和自旋锁一致，不再详说，详细说下读单元的执行。\n   ````C\n   unsigned int seq;\n   do {\n     seq = read_seqbegin(&my_seqlock);\n     /*相应的操作*/\n   } while (read_seqretry(&the_lock, seq))````\n   `read_seqbegin`会返回当前顺序锁的顺序号，`read_seqretry` 会检查当前的顺序号是否改变。\n   通常不能使用顺序锁来保护数据结构中含有指针的数据。\n\n7. 读-拷贝-更新\n   `RCU`（read-copy-update，读-拷贝-更新）是基于原理命名的，在这里不再详细介绍\n   \n## 四、信号量\n信号量和自旋锁类似，只有得到信号量的进程才能执行临界区代码。但是与自旋锁不同的是，当获取不到信号量的时候，进程不会原地打转而是会进入休眠等待状态。\n\n1. 信号量的定义和初始化\n   有三种方法可以初始化一个信号量：\n   ````C\n   void sema_init(struct semaphore *sem, int val); //初始化信号量 sem，并将 sem 的值设为 val\n   void init_MUTEX(struct semaphore *sem);         //初始化信号量 sem 为0\n   void init_MUTEX_LOCKED(struct semaphore *sem);  //初始化信号量 sem 为1\n   DECLARE_MUTEX(name);                            //声明并初始化一个名为 name 的信号量为0\n   DECLARE_MUTEX_LOCKED(name);                     //声明并初始化一个名为 name 的信号量为1\n   ````\n   对于含有 `LOCKED` 的初始化方法，信号量的初始状态就是锁定的。\n\n2. 信号量的获取\n   信号量的获取使用下列方式：\n   ````C\n   void down(struct semaphore *sem);               //会导致睡眠，不能被信号打断\n   int down_interruptible(struct semaphore *sem);  //会导致睡眠，并能被信号打断\n   int down_trylock(struct semaphore *sem);        //不导致睡眠\n   ````\n   使用 `down_interruptible` 函数被信号打断和使用 `down_trylock` 函数未获取信号量，函数会返回非零值。否则返回0。\n\n3. 信号量的释放\n   ````C\n   void up(struct semaphore *sem);\n   ````\n   该函数会释放信号量，唤醒等待者。\n\n4. 完成量\n   completion (完成量) 用于一个执行单元等待另一个执行单元执行完成某事。相应的使用方法如下：\n   ````C\n   struct completion my_completion; \n   init_completion(&my_completion); //定义并初始化 completion\n   /*\n   DECLARE_COMPLETION(my_completion); //另一种创建 completion 的方法\n   */\n   void wait_for_completion(struct completion *c); //等待 completion 被唤醒\n   ...\n   void complete(struct completion *c); //唤醒一个等待 c 的执行单元\n   void complete_all(struct completion *c); //唤醒所有等待 c 的执行单元\n   INIT_COMPLETION(struct completion my_completion); //用于重新初始化一个信号量\n   void completion_and_exit(struct completion *c, long retval); //\n   ````\n   对于 `completion_and_exit` 的用法还有不清楚的地方，等验证完成后再来补充。\n\n5. 读写信号量\n   读写信号量类似与读写自旋锁，使用方法如下：\n   ````C\n   struct rw_semaphore my_rws; //定义读写信号量\n   void init_rwsem(struct rw_semaphore *sem); //初始化读写信号量\n   void down_read(struct rw_semaphore *sem); \n   void down_read_trylock(struct rw_semaphore *sem); //读信号量获取\n   void up_read(struct rw_semaphore *sem); //读信号量释放\n   void down_write(struct rw_semaphore *sem);\n   void down_write_trylock(struct rw_semaphore *sem); //写信号量获取\n   void up_write(struct rw_semaphore *sem); //写信号量释放\n   ````\n\n## 五、互斥体\n   互斥体简单实现了互斥的功能：\n   ````C\n   struct mutex my_mutex;\n   mutex_init(&my_mutex);  //初始化互斥体\n   void inline __sched mutex_lock(struct mutex *lock);\n   int __sched mutex_lock_interruptible(struct mutex *lock);\n   int __sched mutex_trylock(struct mutext *lock);   //获取互斥体\n   void __sched mutex_unlock(struct mutext *lock);   //释放互斥体\n   ````","source":"_posts/Linux驱动开发03.md","raw":"---\ntitle: Linux驱动开发（三）——并发控制\ndate: 2016-12-20 03:08:01\ncategories: 驱动开发\ntags: [驱动, 并发, 自旋锁, 信号量]\n---\n**并发**的定义是：多个执行单元同时、并行的执行。并发会导致**竞态**：并发的执行单元对共享资源的访问。\n<!--more-->\n以下几种情况会发生竞态：\n\n1. 对称多处理器(SMP)的多个 CPU。\n2. 单个 CPU 内部的多个进程。\n3. 中断与进程之间。\n\n解决竞态的途径是保证对共享资源的**互斥访问**：一个执行单元访问共享资源的时候，其他的执行单元被禁止访问。我们常用的互斥机制有：\n `中断屏蔽`、`原子操作`、`自旋锁`、`信号量`。\n## 一、中断屏蔽\n因为 Linux 的异步 IO、进程调度等很多操作都是通过中断来进行的。所以，最简单的避免竞态的方法就是在进入临界区之前屏蔽系统的中断。但是同样，因为中断有这样重要的作用，长时间的屏蔽中断是很危险的。另外，中断屏蔽只能解决上述三种竞态情况中的后两种，对于第一种竞态是无法解决的。所以中断屏蔽通常和自旋锁搭配使用。\n中断屏蔽的使用方法是：\n````C \nlocal_irq_disable() //屏蔽中断\n...\ncritical section /*临界区*/\n...\nlocal_irq_enable()````\n中断屏蔽通常是和自旋锁联合使用的。\n\n## 二、原子操作\n有时候，共享的资源可能正好是一个整数值或者是位操作。内核提供了一种原子的整数类型（位类型）。相应的操作如下：\n\n* 整形原子操作\n  ````C\n  void atomic_set(atomic_t *v, int i);             //设置原子变量 v 的值为 i\n  atomic_t v = ATOMIC_INIT(0);                     //初始化原子变量 v 的值为 0\n  atomic_read(atomic_t *v);                        //读取原子变量 v 的值\n  void atomic_add(int i, atomic_t *v);             //原子变量 v 的值加 i\n  void atomic_sub(int i, atomic_t *v);             //原子变量 v 的值减 i\n  void atomic_inc(atomic_t *v);                    //原子变量 v 的值自加1\n  void atomic_dec(atomic_t *v);                    //原子变量 v 的值自减1\n  int atomic_inc_and_test(atomic_t *v);            //原子变量 v 的值自加1，并测试是否等于0\n  int atomic_dec_and_test(atomic_t *v);            //原子变量 v 的值自减1，并测试是否等于0\n  int atomic_sub_and_test(int i, atomic_t *v);     //原子变量 v 的值减 i，并测试是否等于0\n  int atomic_add_and_return(int i, atomic_t *v);   //原子变量 v 的值加 i，并返回值\n  int atomic_sub_and_return(int i, atomic_t *v);   //原子变量 v 的值减 i，并返回值\n  int atomic_inc_and_return(atomic_t *v);          //原子变量 v 的值自加1，并返回值\n  int atomic_dec_and_return(atomic_t *v);          //原子变量 v 的值自减1，并返回值\n  ````\n  `atomic_t` 的数据只能通过上述的函数进行访问。\n\n* 位原子操作\n  ````C\n  void set_bit(nr, void *addr);           //设置addr地址的第nr位为1\n  void clear_bit(nr, void *addr);         //设置addr地址的第nr位为0\n  void change_bit(nr, void *addr);        //反置addr地址的第nr位\n  test_bit(nr, void *addr);               //返回addr地址的第nr位\n  int test_and_set_bit(nr, void *addr);   //返回addr地址的第nr位并置该位为1\n  int test_and_clear_bit(nr, void *addr); //返回addr地址的第nr位并置该位为0\n  int test_and_change_bit(nr, void *addr);//返回addr地址的第nr位并反置该位\n  ````\n\n## 三、自旋锁\n自旋锁是一个互斥设备，他只能有两个值：锁定和解锁。为了获取一个自旋锁，程序先执行一个原子操作，测试相关的位，如果锁可用，则锁定，代码进入临界区；如果锁不可用，代码则进入循环测试直到该锁可用。\n\n1. 自旋锁的初始化：\n   可以使用两种方法进行自旋锁的初始化：\n   编译时使用：`spinlock_t my_lock = SPIN_LOCK_UNLOCKED; `\n   运行时使用：`void spin_lock_init(spinlock_t *lock);`  \n\n2. 获取锁\n   获取锁使用下面的函数：\n   ````C\n   void spin_lock(spinlock_t *lock);````\n   需要注意的是，自旋锁的等待是不可中断的，一旦调用了该函数，在获取锁之前将一直处于自旋状态。\n\n   如果不想阻塞等待可以使用非阻塞版本的获取锁：\n   ````C\n   void spin_trylock(spinlock_t *lock);````\n   该函数在成功获取锁的情况下返回非零值，在未获取锁的情况下返回0\n\n3. 释放锁\n   释放锁的函数如下：\n   ````C\n   void spin_unlock(spinlock_t *lock);````\n   这个函数一般与 `spin_lock` 和 `spin_trylock` 搭配使用。\n\n4. 自旋锁和中断\n   自旋锁可以保证临界区不受当前CPU和其他CPU的抢占进程打扰，即能解决前面提到的竞态中的前两种，但是依旧可能受到中断的影响，所以自旋锁有下列衍生：\n   ````C\n   void spin_lock_irq(spinlock_t *lock);   //在获取自旋锁之前禁止中断\n   void spin_lock_irqsave(spinlock_t *lock, unsigned long flags); //在获取锁之前屏蔽中断，并将相应的中断状态保存在 flags 中\n   void spin_lock_bh(spinlock_t *lock);   //在获取锁之前屏蔽软件中断，但保持硬件中断\n   ````\n   当然还有与上面几个函数一一对应的 unlock 函数，不再详细描述。\n\n5. 读写自旋锁\n   读写自旋锁是对自旋锁的扩展，它允许多个读操作并发执行，但是只能有一个写单元。相应的函数如下：\n   ````C\n   rwlock_t my_rwlock = RW_LOCK_UNLOCKED;  //静态初始化读写自旋锁\n   rwlock_init(rwlock_t *my_rwlock);       //动态初始化读写自旋锁\n   void read_lock(rwlock_t *my_rwlock);    //获取读锁\n   void read_unlock(rwlock_t *my_rwlock);  //释放读锁\n   void write_lock(rwlock_t *my_rwlock);   //获取写锁\n   void write_unlock(rwlock_t *my_rwlock); //释放写锁\n   ````\n   读写自旋锁也有相应的中断衍生版本。\n\n6. 顺序锁\n   对于资源较小，频繁被读取但是很少写入的资源，可以使用顺序锁。顺序锁的读执行单元不会被写执行单元阻塞。\n   顺序锁的初始化类似于自旋锁：\n   ````C\n   seqlock_t my_seqlock = SEQLOCK_UNLOCKED;  //静态初始化读写自旋锁\n   seqlock_t_init(seqlock_t *my_seqlock);       //动态初始化读写自旋锁\n   ````\n   对于写单元来说，相应的获取锁和释放锁的机制和自旋锁一致，不再详说，详细说下读单元的执行。\n   ````C\n   unsigned int seq;\n   do {\n     seq = read_seqbegin(&my_seqlock);\n     /*相应的操作*/\n   } while (read_seqretry(&the_lock, seq))````\n   `read_seqbegin`会返回当前顺序锁的顺序号，`read_seqretry` 会检查当前的顺序号是否改变。\n   通常不能使用顺序锁来保护数据结构中含有指针的数据。\n\n7. 读-拷贝-更新\n   `RCU`（read-copy-update，读-拷贝-更新）是基于原理命名的，在这里不再详细介绍\n   \n## 四、信号量\n信号量和自旋锁类似，只有得到信号量的进程才能执行临界区代码。但是与自旋锁不同的是，当获取不到信号量的时候，进程不会原地打转而是会进入休眠等待状态。\n\n1. 信号量的定义和初始化\n   有三种方法可以初始化一个信号量：\n   ````C\n   void sema_init(struct semaphore *sem, int val); //初始化信号量 sem，并将 sem 的值设为 val\n   void init_MUTEX(struct semaphore *sem);         //初始化信号量 sem 为0\n   void init_MUTEX_LOCKED(struct semaphore *sem);  //初始化信号量 sem 为1\n   DECLARE_MUTEX(name);                            //声明并初始化一个名为 name 的信号量为0\n   DECLARE_MUTEX_LOCKED(name);                     //声明并初始化一个名为 name 的信号量为1\n   ````\n   对于含有 `LOCKED` 的初始化方法，信号量的初始状态就是锁定的。\n\n2. 信号量的获取\n   信号量的获取使用下列方式：\n   ````C\n   void down(struct semaphore *sem);               //会导致睡眠，不能被信号打断\n   int down_interruptible(struct semaphore *sem);  //会导致睡眠，并能被信号打断\n   int down_trylock(struct semaphore *sem);        //不导致睡眠\n   ````\n   使用 `down_interruptible` 函数被信号打断和使用 `down_trylock` 函数未获取信号量，函数会返回非零值。否则返回0。\n\n3. 信号量的释放\n   ````C\n   void up(struct semaphore *sem);\n   ````\n   该函数会释放信号量，唤醒等待者。\n\n4. 完成量\n   completion (完成量) 用于一个执行单元等待另一个执行单元执行完成某事。相应的使用方法如下：\n   ````C\n   struct completion my_completion; \n   init_completion(&my_completion); //定义并初始化 completion\n   /*\n   DECLARE_COMPLETION(my_completion); //另一种创建 completion 的方法\n   */\n   void wait_for_completion(struct completion *c); //等待 completion 被唤醒\n   ...\n   void complete(struct completion *c); //唤醒一个等待 c 的执行单元\n   void complete_all(struct completion *c); //唤醒所有等待 c 的执行单元\n   INIT_COMPLETION(struct completion my_completion); //用于重新初始化一个信号量\n   void completion_and_exit(struct completion *c, long retval); //\n   ````\n   对于 `completion_and_exit` 的用法还有不清楚的地方，等验证完成后再来补充。\n\n5. 读写信号量\n   读写信号量类似与读写自旋锁，使用方法如下：\n   ````C\n   struct rw_semaphore my_rws; //定义读写信号量\n   void init_rwsem(struct rw_semaphore *sem); //初始化读写信号量\n   void down_read(struct rw_semaphore *sem); \n   void down_read_trylock(struct rw_semaphore *sem); //读信号量获取\n   void up_read(struct rw_semaphore *sem); //读信号量释放\n   void down_write(struct rw_semaphore *sem);\n   void down_write_trylock(struct rw_semaphore *sem); //写信号量获取\n   void up_write(struct rw_semaphore *sem); //写信号量释放\n   ````\n\n## 五、互斥体\n   互斥体简单实现了互斥的功能：\n   ````C\n   struct mutex my_mutex;\n   mutex_init(&my_mutex);  //初始化互斥体\n   void inline __sched mutex_lock(struct mutex *lock);\n   int __sched mutex_lock_interruptible(struct mutex *lock);\n   int __sched mutex_trylock(struct mutext *lock);   //获取互斥体\n   void __sched mutex_unlock(struct mutext *lock);   //释放互斥体\n   ````","slug":"Linux驱动开发03","published":1,"updated":"2017-12-06T13:43:30.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001lbkw10fktdean","content":"<p><strong>并发</strong>的定义是：多个执行单元同时、并行的执行。并发会导致<strong>竞态</strong>：并发的执行单元对共享资源的访问。<br><a id=\"more\"></a><br>以下几种情况会发生竞态：</p>\n<ol>\n<li>对称多处理器(SMP)的多个 CPU。</li>\n<li>单个 CPU 内部的多个进程。</li>\n<li>中断与进程之间。</li>\n</ol>\n<p>解决竞态的途径是保证对共享资源的<strong>互斥访问</strong>：一个执行单元访问共享资源的时候，其他的执行单元被禁止访问。我们常用的互斥机制有：<br> <code>中断屏蔽</code>、<code>原子操作</code>、<code>自旋锁</code>、<code>信号量</code>。</p>\n<h2 id=\"一、中断屏蔽\"><a href=\"#一、中断屏蔽\" class=\"headerlink\" title=\"一、中断屏蔽\"></a>一、中断屏蔽</h2><p>因为 Linux 的异步 IO、进程调度等很多操作都是通过中断来进行的。所以，最简单的避免竞态的方法就是在进入临界区之前屏蔽系统的中断。但是同样，因为中断有这样重要的作用，长时间的屏蔽中断是很危险的。另外，中断屏蔽只能解决上述三种竞态情况中的后两种，对于第一种竞态是无法解决的。所以中断屏蔽通常和自旋锁搭配使用。<br>中断屏蔽的使用方法是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">local_irq_disable() <span class=\"comment\">//屏蔽中断</span></div><div class=\"line\">...</div><div class=\"line\">critical section <span class=\"comment\">/*临界区*/</span></div><div class=\"line\">...</div><div class=\"line\">local_irq_enable()</div></pre></td></tr></table></figure></p>\n<p>中断屏蔽通常是和自旋锁联合使用的。</p>\n<h2 id=\"二、原子操作\"><a href=\"#二、原子操作\" class=\"headerlink\" title=\"二、原子操作\"></a>二、原子操作</h2><p>有时候，共享的资源可能正好是一个整数值或者是位操作。内核提供了一种原子的整数类型（位类型）。相应的操作如下：</p>\n<ul>\n<li><p>整形原子操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_set</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v, <span class=\"keyword\">int</span> i)</span></span>;             <span class=\"comment\">//设置原子变量 v 的值为 i</span></div><div class=\"line\"><span class=\"keyword\">atomic_t</span> v = ATOMIC_INIT(<span class=\"number\">0</span>);                     <span class=\"comment\">//初始化原子变量 v 的值为 0</span></div><div class=\"line\">atomic_read(<span class=\"keyword\">atomic_t</span> *v);                        <span class=\"comment\">//读取原子变量 v 的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;             <span class=\"comment\">//原子变量 v 的值加 i</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_sub</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;             <span class=\"comment\">//原子变量 v 的值减 i</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_inc</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;                    <span class=\"comment\">//原子变量 v 的值自加1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_dec</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;                    <span class=\"comment\">//原子变量 v 的值自减1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_inc_and_test</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;            <span class=\"comment\">//原子变量 v 的值自加1，并测试是否等于0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_dec_and_test</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;            <span class=\"comment\">//原子变量 v 的值自减1，并测试是否等于0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_sub_and_test</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;     <span class=\"comment\">//原子变量 v 的值减 i，并测试是否等于0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_add_and_return</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;   <span class=\"comment\">//原子变量 v 的值加 i，并返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_sub_and_return</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;   <span class=\"comment\">//原子变量 v 的值减 i，并返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_inc_and_return</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;          <span class=\"comment\">//原子变量 v 的值自加1，并返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_dec_and_return</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;          <span class=\"comment\">//原子变量 v 的值自减1，并返回值</span></div></pre></td></tr></table></figure>\n<p><code>atomic_t</code> 的数据只能通过上述的函数进行访问。</p>\n</li>\n<li><p>位原子操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;           <span class=\"comment\">//设置addr地址的第nr位为1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;         <span class=\"comment\">//设置addr地址的第nr位为0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;        <span class=\"comment\">//反置addr地址的第nr位</span></div><div class=\"line\">test_bit(nr, <span class=\"keyword\">void</span> *addr);               <span class=\"comment\">//返回addr地址的第nr位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_and_set_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;   <span class=\"comment\">//返回addr地址的第nr位并置该位为1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_and_clear_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>; <span class=\"comment\">//返回addr地址的第nr位并置该位为0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_and_change_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;<span class=\"comment\">//返回addr地址的第nr位并反置该位</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"三、自旋锁\"><a href=\"#三、自旋锁\" class=\"headerlink\" title=\"三、自旋锁\"></a>三、自旋锁</h2><p>自旋锁是一个互斥设备，他只能有两个值：锁定和解锁。为了获取一个自旋锁，程序先执行一个原子操作，测试相关的位，如果锁可用，则锁定，代码进入临界区；如果锁不可用，代码则进入循环测试直到该锁可用。</p>\n<ol>\n<li><p>自旋锁的初始化：<br>可以使用两种方法进行自旋锁的初始化：<br>编译时使用：<code>spinlock_t my_lock = SPIN_LOCK_UNLOCKED;</code><br>运行时使用：<code>void spin_lock_init(spinlock_t *lock);</code>  </p>\n</li>\n<li><p>获取锁<br>获取锁使用下面的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;</div></pre></td></tr></table></figure>\n<p>需要注意的是，自旋锁的等待是不可中断的，一旦调用了该函数，在获取锁之前将一直处于自旋状态。</p>\n<p>如果不想阻塞等待可以使用非阻塞版本的获取锁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_trylock</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数在成功获取锁的情况下返回非零值，在未获取锁的情况下返回0</p>\n</li>\n<li><p>释放锁<br>释放锁的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_unlock</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;</div></pre></td></tr></table></figure>\n<p>这个函数一般与 <code>spin_lock</code> 和 <code>spin_trylock</code> 搭配使用。</p>\n</li>\n<li><p>自旋锁和中断<br>自旋锁可以保证临界区不受当前CPU和其他CPU的抢占进程打扰，即能解决前面提到的竞态中的前两种，但是依旧可能受到中断的影响，所以自旋锁有下列衍生：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock_irq</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;   <span class=\"comment\">//在获取自旋锁之前禁止中断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock_irqsave</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>; <span class=\"comment\">//在获取锁之前屏蔽中断，并将相应的中断状态保存在 flags 中</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock_bh</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;   <span class=\"comment\">//在获取锁之前屏蔽软件中断，但保持硬件中断</span></div></pre></td></tr></table></figure>\n<p>当然还有与上面几个函数一一对应的 unlock 函数，不再详细描述。</p>\n</li>\n<li><p>读写自旋锁<br>读写自旋锁是对自旋锁的扩展，它允许多个读操作并发执行，但是只能有一个写单元。相应的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">rwlock_t</span> my_rwlock = RW_LOCK_UNLOCKED;  <span class=\"comment\">//静态初始化读写自旋锁</span></div><div class=\"line\">rwlock_init(<span class=\"keyword\">rwlock_t</span> *my_rwlock);       <span class=\"comment\">//动态初始化读写自旋锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_lock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>;    <span class=\"comment\">//获取读锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_unlock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>;  <span class=\"comment\">//释放读锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_lock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>;   <span class=\"comment\">//获取写锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_unlock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>; <span class=\"comment\">//释放写锁</span></div></pre></td></tr></table></figure>\n<p>读写自旋锁也有相应的中断衍生版本。</p>\n</li>\n<li><p>顺序锁<br>对于资源较小，频繁被读取但是很少写入的资源，可以使用顺序锁。顺序锁的读执行单元不会被写执行单元阻塞。<br>顺序锁的初始化类似于自旋锁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">seqlock_t</span> my_seqlock = SEQLOCK_UNLOCKED;  <span class=\"comment\">//静态初始化读写自旋锁</span></div><div class=\"line\">seqlock_t_init(<span class=\"keyword\">seqlock_t</span> *my_seqlock);       <span class=\"comment\">//动态初始化读写自旋锁</span></div></pre></td></tr></table></figure>\n<p>对于写单元来说，相应的获取锁和释放锁的机制和自旋锁一致，不再详说，详细说下读单元的执行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seq;</div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">  seq = read_seqbegin(&amp;my_seqlock);</div><div class=\"line\">  <span class=\"comment\">/*相应的操作*/</span></div><div class=\"line\">&#125; <span class=\"keyword\">while</span> (read_seqretry(&amp;the_lock, seq))</div></pre></td></tr></table></figure>\n<p><code>read_seqbegin</code>会返回当前顺序锁的顺序号，<code>read_seqretry</code> 会检查当前的顺序号是否改变。<br>通常不能使用顺序锁来保护数据结构中含有指针的数据。</p>\n</li>\n<li><p>读-拷贝-更新<br><code>RCU</code>（read-copy-update，读-拷贝-更新）是基于原理命名的，在这里不再详细介绍</p>\n</li>\n</ol>\n<h2 id=\"四、信号量\"><a href=\"#四、信号量\" class=\"headerlink\" title=\"四、信号量\"></a>四、信号量</h2><p>信号量和自旋锁类似，只有得到信号量的进程才能执行临界区代码。但是与自旋锁不同的是，当获取不到信号量的时候，进程不会原地打转而是会进入休眠等待状态。</p>\n<ol>\n<li><p>信号量的定义和初始化<br>有三种方法可以初始化一个信号量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sema_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem, <span class=\"keyword\">int</span> val)</span></span>; <span class=\"comment\">//初始化信号量 sem，并将 sem 的值设为 val</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_MUTEX</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;         <span class=\"comment\">//初始化信号量 sem 为0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_MUTEX_LOCKED</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;  <span class=\"comment\">//初始化信号量 sem 为1</span></div><div class=\"line\">DECLARE_MUTEX(name);                            <span class=\"comment\">//声明并初始化一个名为 name 的信号量为0</span></div><div class=\"line\">DECLARE_MUTEX_LOCKED(name);                     <span class=\"comment\">//声明并初始化一个名为 name 的信号量为1</span></div></pre></td></tr></table></figure>\n<p>对于含有 <code>LOCKED</code> 的初始化方法，信号量的初始状态就是锁定的。</p>\n</li>\n<li><p>信号量的获取<br>信号量的获取使用下列方式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;               <span class=\"comment\">//会导致睡眠，不能被信号打断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">down_interruptible</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;  <span class=\"comment\">//会导致睡眠，并能被信号打断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">down_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;        <span class=\"comment\">//不导致睡眠</span></div></pre></td></tr></table></figure>\n<p>使用 <code>down_interruptible</code> 函数被信号打断和使用 <code>down_trylock</code> 函数未获取信号量，函数会返回非零值。否则返回0。</p>\n</li>\n<li><p>信号量的释放</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数会释放信号量，唤醒等待者。</p>\n</li>\n<li><p>完成量<br>completion (完成量) 用于一个执行单元等待另一个执行单元执行完成某事。相应的使用方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> completion my_completion; </div><div class=\"line\">init_completion(&amp;my_completion); <span class=\"comment\">//定义并初始化 completion</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">DECLARE_COMPLETION(my_completion); //另一种创建 completion 的方法</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wait_for_completion</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c)</span></span>; <span class=\"comment\">//等待 completion 被唤醒</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c)</span></span>; <span class=\"comment\">//唤醒一个等待 c 的执行单元</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">complete_all</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c)</span></span>; <span class=\"comment\">//唤醒所有等待 c 的执行单元</span></div><div class=\"line\">INIT_COMPLETION(<span class=\"keyword\">struct</span> completion my_completion); <span class=\"comment\">//用于重新初始化一个信号量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">completion_and_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c, <span class=\"keyword\">long</span> retval)</span></span>; <span class=\"comment\">//</span></div></pre></td></tr></table></figure>\n<p>对于 <code>completion_and_exit</code> 的用法还有不清楚的地方，等验证完成后再来补充。</p>\n</li>\n<li><p>读写信号量<br>读写信号量类似与读写自旋锁，使用方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> rw_semaphore my_rws; <span class=\"comment\">//定义读写信号量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_rwsem</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//初始化读写信号量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_read</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_read_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//读信号量获取</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up_read</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//读信号量释放</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_write_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//写信号量获取</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//写信号量释放</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"五、互斥体\"><a href=\"#五、互斥体\" class=\"headerlink\" title=\"五、互斥体\"></a>五、互斥体</h2><p>   互斥体简单实现了互斥的功能：<br>   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> mutex my_mutex;</div><div class=\"line\">mutex_init(&amp;my_mutex);  <span class=\"comment\">//初始化互斥体</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"keyword\">inline</span> __<span class=\"function\">sched <span class=\"title\">mutex_lock</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutex *lock)</span></span>;</div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">sched <span class=\"title\">mutex_lock_interruptible</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutex *lock)</span></span>;</div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">sched <span class=\"title\">mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutext *lock)</span></span>;   <span class=\"comment\">//获取互斥体</span></div><div class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">sched <span class=\"title\">mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutext *lock)</span></span>;   <span class=\"comment\">//释放互斥体</span></div></pre></td></tr></table></figure></p>\n","excerpt":"<p><strong>并发</strong>的定义是：多个执行单元同时、并行的执行。并发会导致<strong>竞态</strong>：并发的执行单元对共享资源的访问。<br>","more":"<br>以下几种情况会发生竞态：</p>\n<ol>\n<li>对称多处理器(SMP)的多个 CPU。</li>\n<li>单个 CPU 内部的多个进程。</li>\n<li>中断与进程之间。</li>\n</ol>\n<p>解决竞态的途径是保证对共享资源的<strong>互斥访问</strong>：一个执行单元访问共享资源的时候，其他的执行单元被禁止访问。我们常用的互斥机制有：<br> <code>中断屏蔽</code>、<code>原子操作</code>、<code>自旋锁</code>、<code>信号量</code>。</p>\n<h2 id=\"一、中断屏蔽\"><a href=\"#一、中断屏蔽\" class=\"headerlink\" title=\"一、中断屏蔽\"></a>一、中断屏蔽</h2><p>因为 Linux 的异步 IO、进程调度等很多操作都是通过中断来进行的。所以，最简单的避免竞态的方法就是在进入临界区之前屏蔽系统的中断。但是同样，因为中断有这样重要的作用，长时间的屏蔽中断是很危险的。另外，中断屏蔽只能解决上述三种竞态情况中的后两种，对于第一种竞态是无法解决的。所以中断屏蔽通常和自旋锁搭配使用。<br>中断屏蔽的使用方法是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">local_irq_disable() <span class=\"comment\">//屏蔽中断</span></div><div class=\"line\">...</div><div class=\"line\">critical section <span class=\"comment\">/*临界区*/</span></div><div class=\"line\">...</div><div class=\"line\">local_irq_enable()</div></pre></td></tr></table></figure></p>\n<p>中断屏蔽通常是和自旋锁联合使用的。</p>\n<h2 id=\"二、原子操作\"><a href=\"#二、原子操作\" class=\"headerlink\" title=\"二、原子操作\"></a>二、原子操作</h2><p>有时候，共享的资源可能正好是一个整数值或者是位操作。内核提供了一种原子的整数类型（位类型）。相应的操作如下：</p>\n<ul>\n<li><p>整形原子操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_set</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v, <span class=\"keyword\">int</span> i)</span></span>;             <span class=\"comment\">//设置原子变量 v 的值为 i</span></div><div class=\"line\"><span class=\"keyword\">atomic_t</span> v = ATOMIC_INIT(<span class=\"number\">0</span>);                     <span class=\"comment\">//初始化原子变量 v 的值为 0</span></div><div class=\"line\">atomic_read(<span class=\"keyword\">atomic_t</span> *v);                        <span class=\"comment\">//读取原子变量 v 的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;             <span class=\"comment\">//原子变量 v 的值加 i</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_sub</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;             <span class=\"comment\">//原子变量 v 的值减 i</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_inc</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;                    <span class=\"comment\">//原子变量 v 的值自加1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">atomic_dec</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;                    <span class=\"comment\">//原子变量 v 的值自减1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_inc_and_test</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;            <span class=\"comment\">//原子变量 v 的值自加1，并测试是否等于0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_dec_and_test</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;            <span class=\"comment\">//原子变量 v 的值自减1，并测试是否等于0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_sub_and_test</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;     <span class=\"comment\">//原子变量 v 的值减 i，并测试是否等于0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_add_and_return</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;   <span class=\"comment\">//原子变量 v 的值加 i，并返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_sub_and_return</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">atomic_t</span> *v)</span></span>;   <span class=\"comment\">//原子变量 v 的值减 i，并返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_inc_and_return</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;          <span class=\"comment\">//原子变量 v 的值自加1，并返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atomic_dec_and_return</span><span class=\"params\">(<span class=\"keyword\">atomic_t</span> *v)</span></span>;          <span class=\"comment\">//原子变量 v 的值自减1，并返回值</span></div></pre></td></tr></table></figure>\n<p><code>atomic_t</code> 的数据只能通过上述的函数进行访问。</p>\n</li>\n<li><p>位原子操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;           <span class=\"comment\">//设置addr地址的第nr位为1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;         <span class=\"comment\">//设置addr地址的第nr位为0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;        <span class=\"comment\">//反置addr地址的第nr位</span></div><div class=\"line\">test_bit(nr, <span class=\"keyword\">void</span> *addr);               <span class=\"comment\">//返回addr地址的第nr位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_and_set_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;   <span class=\"comment\">//返回addr地址的第nr位并置该位为1</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_and_clear_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>; <span class=\"comment\">//返回addr地址的第nr位并置该位为0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test_and_change_bit</span><span class=\"params\">(nr, <span class=\"keyword\">void</span> *addr)</span></span>;<span class=\"comment\">//返回addr地址的第nr位并反置该位</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"三、自旋锁\"><a href=\"#三、自旋锁\" class=\"headerlink\" title=\"三、自旋锁\"></a>三、自旋锁</h2><p>自旋锁是一个互斥设备，他只能有两个值：锁定和解锁。为了获取一个自旋锁，程序先执行一个原子操作，测试相关的位，如果锁可用，则锁定，代码进入临界区；如果锁不可用，代码则进入循环测试直到该锁可用。</p>\n<ol>\n<li><p>自旋锁的初始化：<br>可以使用两种方法进行自旋锁的初始化：<br>编译时使用：<code>spinlock_t my_lock = SPIN_LOCK_UNLOCKED;</code><br>运行时使用：<code>void spin_lock_init(spinlock_t *lock);</code>  </p>\n</li>\n<li><p>获取锁<br>获取锁使用下面的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;</div></pre></td></tr></table></figure>\n<p>需要注意的是，自旋锁的等待是不可中断的，一旦调用了该函数，在获取锁之前将一直处于自旋状态。</p>\n<p>如果不想阻塞等待可以使用非阻塞版本的获取锁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_trylock</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数在成功获取锁的情况下返回非零值，在未获取锁的情况下返回0</p>\n</li>\n<li><p>释放锁<br>释放锁的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_unlock</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;</div></pre></td></tr></table></figure>\n<p>这个函数一般与 <code>spin_lock</code> 和 <code>spin_trylock</code> 搭配使用。</p>\n</li>\n<li><p>自旋锁和中断<br>自旋锁可以保证临界区不受当前CPU和其他CPU的抢占进程打扰，即能解决前面提到的竞态中的前两种，但是依旧可能受到中断的影响，所以自旋锁有下列衍生：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock_irq</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;   <span class=\"comment\">//在获取自旋锁之前禁止中断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock_irqsave</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>; <span class=\"comment\">//在获取锁之前屏蔽中断，并将相应的中断状态保存在 flags 中</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spin_lock_bh</span><span class=\"params\">(<span class=\"keyword\">spinlock_t</span> *lock)</span></span>;   <span class=\"comment\">//在获取锁之前屏蔽软件中断，但保持硬件中断</span></div></pre></td></tr></table></figure>\n<p>当然还有与上面几个函数一一对应的 unlock 函数，不再详细描述。</p>\n</li>\n<li><p>读写自旋锁<br>读写自旋锁是对自旋锁的扩展，它允许多个读操作并发执行，但是只能有一个写单元。相应的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">rwlock_t</span> my_rwlock = RW_LOCK_UNLOCKED;  <span class=\"comment\">//静态初始化读写自旋锁</span></div><div class=\"line\">rwlock_init(<span class=\"keyword\">rwlock_t</span> *my_rwlock);       <span class=\"comment\">//动态初始化读写自旋锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_lock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>;    <span class=\"comment\">//获取读锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_unlock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>;  <span class=\"comment\">//释放读锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_lock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>;   <span class=\"comment\">//获取写锁</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_unlock</span><span class=\"params\">(<span class=\"keyword\">rwlock_t</span> *my_rwlock)</span></span>; <span class=\"comment\">//释放写锁</span></div></pre></td></tr></table></figure>\n<p>读写自旋锁也有相应的中断衍生版本。</p>\n</li>\n<li><p>顺序锁<br>对于资源较小，频繁被读取但是很少写入的资源，可以使用顺序锁。顺序锁的读执行单元不会被写执行单元阻塞。<br>顺序锁的初始化类似于自旋锁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">seqlock_t</span> my_seqlock = SEQLOCK_UNLOCKED;  <span class=\"comment\">//静态初始化读写自旋锁</span></div><div class=\"line\">seqlock_t_init(<span class=\"keyword\">seqlock_t</span> *my_seqlock);       <span class=\"comment\">//动态初始化读写自旋锁</span></div></pre></td></tr></table></figure>\n<p>对于写单元来说，相应的获取锁和释放锁的机制和自旋锁一致，不再详说，详细说下读单元的执行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seq;</div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">  seq = read_seqbegin(&amp;my_seqlock);</div><div class=\"line\">  <span class=\"comment\">/*相应的操作*/</span></div><div class=\"line\">&#125; <span class=\"keyword\">while</span> (read_seqretry(&amp;the_lock, seq))</div></pre></td></tr></table></figure>\n<p><code>read_seqbegin</code>会返回当前顺序锁的顺序号，<code>read_seqretry</code> 会检查当前的顺序号是否改变。<br>通常不能使用顺序锁来保护数据结构中含有指针的数据。</p>\n</li>\n<li><p>读-拷贝-更新<br><code>RCU</code>（read-copy-update，读-拷贝-更新）是基于原理命名的，在这里不再详细介绍</p>\n</li>\n</ol>\n<h2 id=\"四、信号量\"><a href=\"#四、信号量\" class=\"headerlink\" title=\"四、信号量\"></a>四、信号量</h2><p>信号量和自旋锁类似，只有得到信号量的进程才能执行临界区代码。但是与自旋锁不同的是，当获取不到信号量的时候，进程不会原地打转而是会进入休眠等待状态。</p>\n<ol>\n<li><p>信号量的定义和初始化<br>有三种方法可以初始化一个信号量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sema_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem, <span class=\"keyword\">int</span> val)</span></span>; <span class=\"comment\">//初始化信号量 sem，并将 sem 的值设为 val</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_MUTEX</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;         <span class=\"comment\">//初始化信号量 sem 为0</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_MUTEX_LOCKED</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;  <span class=\"comment\">//初始化信号量 sem 为1</span></div><div class=\"line\">DECLARE_MUTEX(name);                            <span class=\"comment\">//声明并初始化一个名为 name 的信号量为0</span></div><div class=\"line\">DECLARE_MUTEX_LOCKED(name);                     <span class=\"comment\">//声明并初始化一个名为 name 的信号量为1</span></div></pre></td></tr></table></figure>\n<p>对于含有 <code>LOCKED</code> 的初始化方法，信号量的初始状态就是锁定的。</p>\n</li>\n<li><p>信号量的获取<br>信号量的获取使用下列方式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;               <span class=\"comment\">//会导致睡眠，不能被信号打断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">down_interruptible</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;  <span class=\"comment\">//会导致睡眠，并能被信号打断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">down_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;        <span class=\"comment\">//不导致睡眠</span></div></pre></td></tr></table></figure>\n<p>使用 <code>down_interruptible</code> 函数被信号打断和使用 <code>down_trylock</code> 函数未获取信号量，函数会返回非零值。否则返回0。</p>\n</li>\n<li><p>信号量的释放</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up</span><span class=\"params\">(<span class=\"keyword\">struct</span> semaphore *sem)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数会释放信号量，唤醒等待者。</p>\n</li>\n<li><p>完成量<br>completion (完成量) 用于一个执行单元等待另一个执行单元执行完成某事。相应的使用方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> completion my_completion; </div><div class=\"line\">init_completion(&amp;my_completion); <span class=\"comment\">//定义并初始化 completion</span></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">DECLARE_COMPLETION(my_completion); //另一种创建 completion 的方法</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wait_for_completion</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c)</span></span>; <span class=\"comment\">//等待 completion 被唤醒</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c)</span></span>; <span class=\"comment\">//唤醒一个等待 c 的执行单元</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">complete_all</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c)</span></span>; <span class=\"comment\">//唤醒所有等待 c 的执行单元</span></div><div class=\"line\">INIT_COMPLETION(<span class=\"keyword\">struct</span> completion my_completion); <span class=\"comment\">//用于重新初始化一个信号量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">completion_and_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> completion *c, <span class=\"keyword\">long</span> retval)</span></span>; <span class=\"comment\">//</span></div></pre></td></tr></table></figure>\n<p>对于 <code>completion_and_exit</code> 的用法还有不清楚的地方，等验证完成后再来补充。</p>\n</li>\n<li><p>读写信号量<br>读写信号量类似与读写自旋锁，使用方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> rw_semaphore my_rws; <span class=\"comment\">//定义读写信号量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_rwsem</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//初始化读写信号量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_read</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_read_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//读信号量获取</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up_read</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//读信号量释放</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">down_write_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//写信号量获取</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> rw_semaphore *sem)</span></span>; <span class=\"comment\">//写信号量释放</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"五、互斥体\"><a href=\"#五、互斥体\" class=\"headerlink\" title=\"五、互斥体\"></a>五、互斥体</h2><p>   互斥体简单实现了互斥的功能：<br>   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> mutex my_mutex;</div><div class=\"line\">mutex_init(&amp;my_mutex);  <span class=\"comment\">//初始化互斥体</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"keyword\">inline</span> __<span class=\"function\">sched <span class=\"title\">mutex_lock</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutex *lock)</span></span>;</div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">sched <span class=\"title\">mutex_lock_interruptible</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutex *lock)</span></span>;</div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">sched <span class=\"title\">mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutext *lock)</span></span>;   <span class=\"comment\">//获取互斥体</span></div><div class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">sched <span class=\"title\">mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">struct</span> mutext *lock)</span></span>;   <span class=\"comment\">//释放互斥体</span></div></pre></td></tr></table></figure></p>"},{"title":"Linux驱动开发（四）——I/O操作","date":"2016-12-19T22:08:01.000Z","_content":"对于 Linux 设备来说，设备是当作文件来处理的。所以，很多设备的 I/O 操作都是很重要的一个部分。这篇博客总结了 Linux 驱动开发中 I/O 相关的一些内容。包含阻塞和非阻塞 I/O 、I/O 轮询、异步 I/O 等。\n<!--more-->\n\n## 一、阻塞和非阻塞 I/O\n阻塞是指设备操作时，如果不能获取资源，则挂起相应的操作单元直到满足可操作的条件后进行操作。而非阻塞是指在不能满足操作需求的时候，相应的操作单元并不挂起，而是选择放弃或者不停的查询直到满足条件。\n我们可以显式的设置一个设备文件为非阻塞 I/O。我们可以在打开一个文件的时候通过设置 `filp->f_flags` 为 `O_NONBLOCK` 来实现。如果设置为阻塞模式，当使用 `open()` 函数打开一个文件的时候，I/O 操作会在操作条件不满足的时候返回 `EAGAIN`，此时必须严格检查相应的 `errno`。\n`\n而对于我们的驱动程序来讲，我们更多的应该（默认）阻塞进程，将其置入**休眠状态**。\n**休眠状态**：当一个进程被置入休眠状态之后，他会被标记为一种特殊的状态并从 CPU 的运行队列中移走，直到某些情况修改了这个状态。对于休眠状态，有两个重要的规则：\n * 永远不要在原子操作中进入休眠。\n * 我们对唤醒之后的状态不能做任何假定，必须检查以确保我们等待的条件为真。\n\n另外一个需要考虑的问题是，进入休眠的进程必须确保有其他进程会在其他地方唤醒休眠的进程，且休眠的进程能够被找到。\n\n### 1.1 等待队列\n如上文所说，我们需要能够找到进入休眠的进程。我们使用一种叫做等待队列的数据结构来实现这个功能。\n**等待队列**是以队列为基础数据结构，与进程调度机制相结合，用于实现内核中的异步事件通知的机制。它实际上是一个进程链表，其中包含了等待某个特定事件的所有进程。\n\n1. 初始化等待队列\n   等待队列使用一个**等待队列头**来管理，他可以通过下面两种方式来定义并初始化：\n    ````C\n    /*使用动态方法定义并初始化*/\n    wait_queue_head_t my_queue;\n    init_waitqueue_head(&my_queue);\n    /*使用静态定义并初始化*/\n    DECLARE_WAIT_QUEUE_HEAD(name);\n    ````\n    我们使用这个等待队列头来指代我们的等待队列。\n\n2. 进入休眠\n   * 当我们 I/O 遇到了阻塞条件，我们需要将其休眠的时候，我们可以使用 `wait_event` 宏来设置相应的进程进入休眠。\n     ````C\n    wait_event(queue, condition); \n    wait_event_interruptible(queue, condition); \n    wait_event_timeout(queue, condition, timeout); \n    wait_event_interruptible_timeout(queue, condition, timeout);\n    ````\n    上面相应的宏中，需要注意的是**`queue` 是相应的等待队列头，它是值传递的**。`condition` 是一个布尔表达式，在表达式为真之前，进程会持续休眠。该表达式有可能被多次求值。\n    `wait_event` 将相应的进程置于非中断休眠，我们更多使用的是 `wait_event_interruptible`，他可以被信号中断，当被信号中断的时候，返回一个非零值；后两个函数会设置相应的等待时间，超过等待时间之后，进程返回，返回值为0。\n\n   * 我们也可以手动设置一个进程进入休眠：\n     1. 建立一个并初始化一个**等待队列入口**。\n        我们可以使用宏 `DEFINE_WAIT(my_wait)` 来静态定义并初始化一个名为 `my_wait` 的等待队列入口，也可以使用下面的动态方法：\n        ````C\n        wait_queue_t my_wait;\n        init_wait(&my_wait);\n        ````\n        我们更多使用的是静态方法。\n     2. 将相应的等待队列入口加入到队列中：\n        ````C\n        void prepare_to_wait(wait_queue_head_t *queue,\n                             wait_queue_t *wait,\n                             int state);````\n        其中 `queue` 指我们的等待队列头，`wait` 指我们的进程等待队列入口，`state` 是进程的新状态，有两种值 `TASK_INTERRUPTIBLE`（可中断休眠，常用值）`TASK_UNINTERRUPTIBLE`（不可中断休眠）。\n     3. 再次检查条件，让出 CPU：\n        ````C\n        if (condition)\n            schedule();\n        ````\n     4. 进程被唤醒后执行相应的清理工作：\n        ````C\n        void finish_wait(wait_queue_head_t *q, wait_queue_t *wait);\n        ````\n        该函数将进程状态更改为 `TASK_RUNNING`，并从等待队列中删除该进程。\n     5. 最后，我们需要测试我们是否是被信号唤醒的。\n\n3. 对于阻塞的进程，我们需要能够唤醒它，唤醒函数如下：\n````C\nvoid wake_up(wait_queue_head_t *q);\nvoid wake_up_interruptible(wait_queue_head_t *q);````\n第一个函数会唤醒等待队列 `q` 上面的所有进程，而第二个只能唤醒等待队列上执行可中断休眠的进程。通常我们是将对应版本的 `wait` 和 `wake` 搭配使用。\n\n\n### 1.2 轮询操作\n在应用层有轮询的概念（I/O 多路复用），指的是在读取多个文件的时候，阻塞进程直到给定的文件描述符集合中任何一个可以进行相应的读写操作。相应的应用层函数有 `select`、`poll`、`epoll`等，他们在底层调用的是 `poll` 函数。它的原型是：\n````C\nunsigned int (*poll)(struct file *filp, poll_table *wait);\n````\n\n这个函数要完成两个工作：\n1. 对可能引起设备文件状态变化的等待队列调用 `poll_wait()` 函数，将对应的等待队列添加到 `poll_table`。\n2. 返回表示是否能对设备进行无阻塞的读写访问的掩码。\n\n`poll_wait()` 函数的原型如下：\n ````C\n void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table *wait);\n ````\n 功能：将当前进程加入到函数指定的等待列表 `wait`。\n 参数：`filp` 打开的文件指针，`queue` 需要加入的 `wait` 的等待队列。\n\n 一个相应的 `poll` 函数实现代码如下：\n ````C\n static unsigned int xxx_poll(struct file *filp, poll_table *wait) {\n     struct xxx_dev *dev = filp->private_data;\n     unsigned int mask = 0;\n     poll_wait(filp, &dev->r_wait, wait);\n     poll_wait(filp, &dev->w_wait, wait);\n     if (readable)\n        mask |= POLLIN|POLLRDNORM;\n     if (writable)\n        mask |= POLLOUT|POLLWRNORM;\n    return mask;\n }````\n\n## 二、异步通知\n异步通知的意思是：一旦设备就绪，就主动通知应用程序，这样应用程序就不用查询设备的状态，类似于硬件上的中断的概念。在 Linux 中，异步通知使用信号来实现。为了使设备支持异步通知机制，驱动程序中涉及三项工作：\n1. 支持 `F_SETOWN` 命令，能在这个命令处理中设置 `filp->f_owner` 为对应的进程 ID，这部分工作由内核完成。\n2. 支持 `F_SETFL` 命令，每当 `FASYNC` 标志改变的时候，驱动程序中的 `fasync()` 函数将得以执行。因此，应在设备驱动中实现 `fasync()` 函数。\n3. 在设备资源可以获得的时候，调用 `kill_fasync()` 函数激发相应的信号。\n\n设备驱动的异步通知机制编程涉及到两个函数和一个结构体：\n\n* `fasync_struct` 结构体\n* `FASYNC` 标志变更函数\n  ````C\n  int fasync_helper(int fd, struct file *filp, int mode, struct fasync_struct **fa);````\n* 释放信号的函数\n  ````C\n  void kill_fasync(struct fasync_struct **fa, int sig, int band);````\n\n`fasync_struct` 同样一般定义在相应的设备结构体 `xxx_dev` 中。\n设备驱动的 `fasync()` 函数，一般参照下面的模板编写：\n````C\nstatic int xxx_fasync(int fd, struct file *filp, int mode) {\n    struct xxx_dev *dev = filp->private_data;\n    return fasync_helper(fd, filp, mode, &dev->fasync_queue);\n}````\n\n\n在设备删除的时候，还需要将文件从异步通知列表中删除，调用`xxx_fasync(-1, filp, 0);`。\n","source":"_posts/Linux驱动开发04.md","raw":"---\ntitle: Linux驱动开发（四）——I/O操作\ndate: 2016-12-20 06:08:01\ncategories: 驱动开发\ntags: [驱动, I/O, poll, 等待队列, 异步通知]\n---\n对于 Linux 设备来说，设备是当作文件来处理的。所以，很多设备的 I/O 操作都是很重要的一个部分。这篇博客总结了 Linux 驱动开发中 I/O 相关的一些内容。包含阻塞和非阻塞 I/O 、I/O 轮询、异步 I/O 等。\n<!--more-->\n\n## 一、阻塞和非阻塞 I/O\n阻塞是指设备操作时，如果不能获取资源，则挂起相应的操作单元直到满足可操作的条件后进行操作。而非阻塞是指在不能满足操作需求的时候，相应的操作单元并不挂起，而是选择放弃或者不停的查询直到满足条件。\n我们可以显式的设置一个设备文件为非阻塞 I/O。我们可以在打开一个文件的时候通过设置 `filp->f_flags` 为 `O_NONBLOCK` 来实现。如果设置为阻塞模式，当使用 `open()` 函数打开一个文件的时候，I/O 操作会在操作条件不满足的时候返回 `EAGAIN`，此时必须严格检查相应的 `errno`。\n`\n而对于我们的驱动程序来讲，我们更多的应该（默认）阻塞进程，将其置入**休眠状态**。\n**休眠状态**：当一个进程被置入休眠状态之后，他会被标记为一种特殊的状态并从 CPU 的运行队列中移走，直到某些情况修改了这个状态。对于休眠状态，有两个重要的规则：\n * 永远不要在原子操作中进入休眠。\n * 我们对唤醒之后的状态不能做任何假定，必须检查以确保我们等待的条件为真。\n\n另外一个需要考虑的问题是，进入休眠的进程必须确保有其他进程会在其他地方唤醒休眠的进程，且休眠的进程能够被找到。\n\n### 1.1 等待队列\n如上文所说，我们需要能够找到进入休眠的进程。我们使用一种叫做等待队列的数据结构来实现这个功能。\n**等待队列**是以队列为基础数据结构，与进程调度机制相结合，用于实现内核中的异步事件通知的机制。它实际上是一个进程链表，其中包含了等待某个特定事件的所有进程。\n\n1. 初始化等待队列\n   等待队列使用一个**等待队列头**来管理，他可以通过下面两种方式来定义并初始化：\n    ````C\n    /*使用动态方法定义并初始化*/\n    wait_queue_head_t my_queue;\n    init_waitqueue_head(&my_queue);\n    /*使用静态定义并初始化*/\n    DECLARE_WAIT_QUEUE_HEAD(name);\n    ````\n    我们使用这个等待队列头来指代我们的等待队列。\n\n2. 进入休眠\n   * 当我们 I/O 遇到了阻塞条件，我们需要将其休眠的时候，我们可以使用 `wait_event` 宏来设置相应的进程进入休眠。\n     ````C\n    wait_event(queue, condition); \n    wait_event_interruptible(queue, condition); \n    wait_event_timeout(queue, condition, timeout); \n    wait_event_interruptible_timeout(queue, condition, timeout);\n    ````\n    上面相应的宏中，需要注意的是**`queue` 是相应的等待队列头，它是值传递的**。`condition` 是一个布尔表达式，在表达式为真之前，进程会持续休眠。该表达式有可能被多次求值。\n    `wait_event` 将相应的进程置于非中断休眠，我们更多使用的是 `wait_event_interruptible`，他可以被信号中断，当被信号中断的时候，返回一个非零值；后两个函数会设置相应的等待时间，超过等待时间之后，进程返回，返回值为0。\n\n   * 我们也可以手动设置一个进程进入休眠：\n     1. 建立一个并初始化一个**等待队列入口**。\n        我们可以使用宏 `DEFINE_WAIT(my_wait)` 来静态定义并初始化一个名为 `my_wait` 的等待队列入口，也可以使用下面的动态方法：\n        ````C\n        wait_queue_t my_wait;\n        init_wait(&my_wait);\n        ````\n        我们更多使用的是静态方法。\n     2. 将相应的等待队列入口加入到队列中：\n        ````C\n        void prepare_to_wait(wait_queue_head_t *queue,\n                             wait_queue_t *wait,\n                             int state);````\n        其中 `queue` 指我们的等待队列头，`wait` 指我们的进程等待队列入口，`state` 是进程的新状态，有两种值 `TASK_INTERRUPTIBLE`（可中断休眠，常用值）`TASK_UNINTERRUPTIBLE`（不可中断休眠）。\n     3. 再次检查条件，让出 CPU：\n        ````C\n        if (condition)\n            schedule();\n        ````\n     4. 进程被唤醒后执行相应的清理工作：\n        ````C\n        void finish_wait(wait_queue_head_t *q, wait_queue_t *wait);\n        ````\n        该函数将进程状态更改为 `TASK_RUNNING`，并从等待队列中删除该进程。\n     5. 最后，我们需要测试我们是否是被信号唤醒的。\n\n3. 对于阻塞的进程，我们需要能够唤醒它，唤醒函数如下：\n````C\nvoid wake_up(wait_queue_head_t *q);\nvoid wake_up_interruptible(wait_queue_head_t *q);````\n第一个函数会唤醒等待队列 `q` 上面的所有进程，而第二个只能唤醒等待队列上执行可中断休眠的进程。通常我们是将对应版本的 `wait` 和 `wake` 搭配使用。\n\n\n### 1.2 轮询操作\n在应用层有轮询的概念（I/O 多路复用），指的是在读取多个文件的时候，阻塞进程直到给定的文件描述符集合中任何一个可以进行相应的读写操作。相应的应用层函数有 `select`、`poll`、`epoll`等，他们在底层调用的是 `poll` 函数。它的原型是：\n````C\nunsigned int (*poll)(struct file *filp, poll_table *wait);\n````\n\n这个函数要完成两个工作：\n1. 对可能引起设备文件状态变化的等待队列调用 `poll_wait()` 函数，将对应的等待队列添加到 `poll_table`。\n2. 返回表示是否能对设备进行无阻塞的读写访问的掩码。\n\n`poll_wait()` 函数的原型如下：\n ````C\n void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table *wait);\n ````\n 功能：将当前进程加入到函数指定的等待列表 `wait`。\n 参数：`filp` 打开的文件指针，`queue` 需要加入的 `wait` 的等待队列。\n\n 一个相应的 `poll` 函数实现代码如下：\n ````C\n static unsigned int xxx_poll(struct file *filp, poll_table *wait) {\n     struct xxx_dev *dev = filp->private_data;\n     unsigned int mask = 0;\n     poll_wait(filp, &dev->r_wait, wait);\n     poll_wait(filp, &dev->w_wait, wait);\n     if (readable)\n        mask |= POLLIN|POLLRDNORM;\n     if (writable)\n        mask |= POLLOUT|POLLWRNORM;\n    return mask;\n }````\n\n## 二、异步通知\n异步通知的意思是：一旦设备就绪，就主动通知应用程序，这样应用程序就不用查询设备的状态，类似于硬件上的中断的概念。在 Linux 中，异步通知使用信号来实现。为了使设备支持异步通知机制，驱动程序中涉及三项工作：\n1. 支持 `F_SETOWN` 命令，能在这个命令处理中设置 `filp->f_owner` 为对应的进程 ID，这部分工作由内核完成。\n2. 支持 `F_SETFL` 命令，每当 `FASYNC` 标志改变的时候，驱动程序中的 `fasync()` 函数将得以执行。因此，应在设备驱动中实现 `fasync()` 函数。\n3. 在设备资源可以获得的时候，调用 `kill_fasync()` 函数激发相应的信号。\n\n设备驱动的异步通知机制编程涉及到两个函数和一个结构体：\n\n* `fasync_struct` 结构体\n* `FASYNC` 标志变更函数\n  ````C\n  int fasync_helper(int fd, struct file *filp, int mode, struct fasync_struct **fa);````\n* 释放信号的函数\n  ````C\n  void kill_fasync(struct fasync_struct **fa, int sig, int band);````\n\n`fasync_struct` 同样一般定义在相应的设备结构体 `xxx_dev` 中。\n设备驱动的 `fasync()` 函数，一般参照下面的模板编写：\n````C\nstatic int xxx_fasync(int fd, struct file *filp, int mode) {\n    struct xxx_dev *dev = filp->private_data;\n    return fasync_helper(fd, filp, mode, &dev->fasync_queue);\n}````\n\n\n在设备删除的时候，还需要将文件从异步通知列表中删除，调用`xxx_fasync(-1, filp, 0);`。\n","slug":"Linux驱动开发04","published":1,"updated":"2016-12-25T08:09:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001obkw1n1cqios3","content":"<p>对于 Linux 设备来说，设备是当作文件来处理的。所以，很多设备的 I/O 操作都是很重要的一个部分。这篇博客总结了 Linux 驱动开发中 I/O 相关的一些内容。包含阻塞和非阻塞 I/O 、I/O 轮询、异步 I/O 等。<br><a id=\"more\"></a></p>\n<h2 id=\"一、阻塞和非阻塞-I-O\"><a href=\"#一、阻塞和非阻塞-I-O\" class=\"headerlink\" title=\"一、阻塞和非阻塞 I/O\"></a>一、阻塞和非阻塞 I/O</h2><p>阻塞是指设备操作时，如果不能获取资源，则挂起相应的操作单元直到满足可操作的条件后进行操作。而非阻塞是指在不能满足操作需求的时候，相应的操作单元并不挂起，而是选择放弃或者不停的查询直到满足条件。<br>我们可以显式的设置一个设备文件为非阻塞 I/O。我们可以在打开一个文件的时候通过设置 <code>filp-&gt;f_flags</code> 为 <code>O_NONBLOCK</code> 来实现。如果设置为阻塞模式，当使用 <code>open()</code> 函数打开一个文件的时候，I/O 操作会在操作条件不满足的时候返回 <code>EAGAIN</code>，此时必须严格检查相应的 <code>errno</code>。<br>`<br>而对于我们的驱动程序来讲，我们更多的应该（默认）阻塞进程，将其置入<strong>休眠状态</strong>。<br><strong>休眠状态</strong>：当一个进程被置入休眠状态之后，他会被标记为一种特殊的状态并从 CPU 的运行队列中移走，直到某些情况修改了这个状态。对于休眠状态，有两个重要的规则：</p>\n<ul>\n<li>永远不要在原子操作中进入休眠。</li>\n<li>我们对唤醒之后的状态不能做任何假定，必须检查以确保我们等待的条件为真。</li>\n</ul>\n<p>另外一个需要考虑的问题是，进入休眠的进程必须确保有其他进程会在其他地方唤醒休眠的进程，且休眠的进程能够被找到。</p>\n<h3 id=\"1-1-等待队列\"><a href=\"#1-1-等待队列\" class=\"headerlink\" title=\"1.1 等待队列\"></a>1.1 等待队列</h3><p>如上文所说，我们需要能够找到进入休眠的进程。我们使用一种叫做等待队列的数据结构来实现这个功能。<br><strong>等待队列</strong>是以队列为基础数据结构，与进程调度机制相结合，用于实现内核中的异步事件通知的机制。它实际上是一个进程链表，其中包含了等待某个特定事件的所有进程。</p>\n<ol>\n<li><p>初始化等待队列<br>等待队列使用一个<strong>等待队列头</strong>来管理，他可以通过下面两种方式来定义并初始化：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*使用动态方法定义并初始化*/</span></div><div class=\"line\"><span class=\"keyword\">wait_queue_head_t</span> my_queue;</div><div class=\"line\">init_waitqueue_head(&amp;my_queue);</div><div class=\"line\"><span class=\"comment\">/*使用静态定义并初始化*/</span></div><div class=\"line\">DECLARE_WAIT_QUEUE_HEAD(name);</div></pre></td></tr></table></figure>\n<p> 我们使用这个等待队列头来指代我们的等待队列。</p>\n</li>\n<li><p>进入休眠</p>\n<ul>\n<li><p>当我们 I/O 遇到了阻塞条件，我们需要将其休眠的时候，我们可以使用 <code>wait_event</code> 宏来设置相应的进程进入休眠。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">wait_event(<span class=\"built_in\">queue</span>, condition); </div><div class=\"line\">wait_event_interruptible(<span class=\"built_in\">queue</span>, condition); </div><div class=\"line\">wait_event_timeout(<span class=\"built_in\">queue</span>, condition, timeout); </div><div class=\"line\">wait_event_interruptible_timeout(<span class=\"built_in\">queue</span>, condition, timeout);</div></pre></td></tr></table></figure>\n<p>上面相应的宏中，需要注意的是<strong><code>queue</code> 是相应的等待队列头，它是值传递的</strong>。<code>condition</code> 是一个布尔表达式，在表达式为真之前，进程会持续休眠。该表达式有可能被多次求值。<br><code>wait_event</code> 将相应的进程置于非中断休眠，我们更多使用的是 <code>wait_event_interruptible</code>，他可以被信号中断，当被信号中断的时候，返回一个非零值；后两个函数会设置相应的等待时间，超过等待时间之后，进程返回，返回值为0。</p>\n</li>\n<li><p>我们也可以手动设置一个进程进入休眠：</p>\n<ol>\n<li><p>建立一个并初始化一个<strong>等待队列入口</strong>。<br>我们可以使用宏 <code>DEFINE_WAIT(my_wait)</code> 来静态定义并初始化一个名为 <code>my_wait</code> 的等待队列入口，也可以使用下面的动态方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">wait_queue_t</span> my_wait;</div><div class=\"line\">init_wait(&amp;my_wait);</div></pre></td></tr></table></figure>\n<p>我们更多使用的是静态方法。</p>\n</li>\n<li><p>将相应的等待队列入口加入到队列中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prepare_to_wait</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *<span class=\"built_in\">queue</span>,</span></span></div><div class=\"line\">                     <span class=\"keyword\">wait_queue_t</span> *wait,</div><div class=\"line\">                     <span class=\"keyword\">int</span> state);</div></pre></td></tr></table></figure>\n<p>其中 <code>queue</code> 指我们的等待队列头，<code>wait</code> 指我们的进程等待队列入口，<code>state</code> 是进程的新状态，有两种值 <code>TASK_INTERRUPTIBLE</code>（可中断休眠，常用值）<code>TASK_UNINTERRUPTIBLE</code>（不可中断休眠）。</p>\n</li>\n<li><p>再次检查条件，让出 CPU：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (condition)</div><div class=\"line\">    schedule();</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程被唤醒后执行相应的清理工作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish_wait</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q, <span class=\"keyword\">wait_queue_t</span> *wait)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数将进程状态更改为 <code>TASK_RUNNING</code>，并从等待队列中删除该进程。</p>\n</li>\n<li>最后，我们需要测试我们是否是被信号唤醒的。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>对于阻塞的进程，我们需要能够唤醒它，唤醒函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wake_up</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wake_up_interruptible</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>第一个函数会唤醒等待队列 <code>q</code> 上面的所有进程，而第二个只能唤醒等待队列上执行可中断休眠的进程。通常我们是将对应版本的 <code>wait</code> 和 <code>wake</code> 搭配使用。</p>\n<h3 id=\"1-2-轮询操作\"><a href=\"#1-2-轮询操作\" class=\"headerlink\" title=\"1.2 轮询操作\"></a>1.2 轮询操作</h3><p>在应用层有轮询的概念（I/O 多路复用），指的是在读取多个文件的时候，阻塞进程直到给定的文件描述符集合中任何一个可以进行相应的读写操作。相应的应用层函数有 <code>select</code>、<code>poll</code>、<code>epoll</code>等，他们在底层调用的是 <code>poll</code> 函数。它的原型是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*poll)</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, poll_table *wait)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>这个函数要完成两个工作：</p>\n<ol>\n<li>对可能引起设备文件状态变化的等待队列调用 <code>poll_wait()</code> 函数，将对应的等待队列添加到 <code>poll_table</code>。</li>\n<li>返回表示是否能对设备进行无阻塞的读写访问的掩码。</li>\n</ol>\n<p><code>poll_wait()</code> 函数的原型如下：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">poll_wait</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">wait_queue_head_t</span> *<span class=\"built_in\">queue</span>, poll_table *wait)</span></span>;</div></pre></td></tr></table></figure></p>\n<p> 功能：将当前进程加入到函数指定的等待列表 <code>wait</code>。<br> 参数：<code>filp</code> 打开的文件指针，<code>queue</code> 需要加入的 <code>wait</code> 的等待队列。</p>\n<p> 一个相应的 <code>poll</code> 函数实现代码如下：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">xxx_poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, poll_table *wait)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> xxx_dev *dev = filp-&gt;private_data;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>;</div><div class=\"line\">    poll_wait(filp, &amp;dev-&gt;r_wait, wait);</div><div class=\"line\">    poll_wait(filp, &amp;dev-&gt;w_wait, wait);</div><div class=\"line\">    <span class=\"keyword\">if</span> (readable)</div><div class=\"line\">       mask |= POLLIN|POLLRDNORM;</div><div class=\"line\">    <span class=\"keyword\">if</span> (writable)</div><div class=\"line\">       mask |= POLLOUT|POLLWRNORM;</div><div class=\"line\">   <span class=\"keyword\">return</span> mask;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二、异步通知\"><a href=\"#二、异步通知\" class=\"headerlink\" title=\"二、异步通知\"></a>二、异步通知</h2><p>异步通知的意思是：一旦设备就绪，就主动通知应用程序，这样应用程序就不用查询设备的状态，类似于硬件上的中断的概念。在 Linux 中，异步通知使用信号来实现。为了使设备支持异步通知机制，驱动程序中涉及三项工作：</p>\n<ol>\n<li>支持 <code>F_SETOWN</code> 命令，能在这个命令处理中设置 <code>filp-&gt;f_owner</code> 为对应的进程 ID，这部分工作由内核完成。</li>\n<li>支持 <code>F_SETFL</code> 命令，每当 <code>FASYNC</code> 标志改变的时候，驱动程序中的 <code>fasync()</code> 函数将得以执行。因此，应在设备驱动中实现 <code>fasync()</code> 函数。</li>\n<li>在设备资源可以获得的时候，调用 <code>kill_fasync()</code> 函数激发相应的信号。</li>\n</ol>\n<p>设备驱动的异步通知机制编程涉及到两个函数和一个结构体：</p>\n<ul>\n<li><code>fasync_struct</code> 结构体</li>\n<li><p><code>FASYNC</code> 标志变更函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fasync_helper</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">int</span> mode, <span class=\"keyword\">struct</span> fasync_struct **fa)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>释放信号的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kill_fasync</span><span class=\"params\">(<span class=\"keyword\">struct</span> fasync_struct **fa, <span class=\"keyword\">int</span> sig, <span class=\"keyword\">int</span> band)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>fasync_struct</code> 同样一般定义在相应的设备结构体 <code>xxx_dev</code> 中。<br>设备驱动的 <code>fasync()</code> 函数，一般参照下面的模板编写：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">xxx_fasync</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">int</span> mode)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> xxx_dev *dev = filp-&gt;private_data;</div><div class=\"line\">    <span class=\"keyword\">return</span> fasync_helper(fd, filp, mode, &amp;dev-&gt;fasync_queue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在设备删除的时候，还需要将文件从异步通知列表中删除，调用<code>xxx_fasync(-1, filp, 0);</code>。</p>\n","excerpt":"<p>对于 Linux 设备来说，设备是当作文件来处理的。所以，很多设备的 I/O 操作都是很重要的一个部分。这篇博客总结了 Linux 驱动开发中 I/O 相关的一些内容。包含阻塞和非阻塞 I/O 、I/O 轮询、异步 I/O 等。<br>","more":"</p>\n<h2 id=\"一、阻塞和非阻塞-I-O\"><a href=\"#一、阻塞和非阻塞-I-O\" class=\"headerlink\" title=\"一、阻塞和非阻塞 I/O\"></a>一、阻塞和非阻塞 I/O</h2><p>阻塞是指设备操作时，如果不能获取资源，则挂起相应的操作单元直到满足可操作的条件后进行操作。而非阻塞是指在不能满足操作需求的时候，相应的操作单元并不挂起，而是选择放弃或者不停的查询直到满足条件。<br>我们可以显式的设置一个设备文件为非阻塞 I/O。我们可以在打开一个文件的时候通过设置 <code>filp-&gt;f_flags</code> 为 <code>O_NONBLOCK</code> 来实现。如果设置为阻塞模式，当使用 <code>open()</code> 函数打开一个文件的时候，I/O 操作会在操作条件不满足的时候返回 <code>EAGAIN</code>，此时必须严格检查相应的 <code>errno</code>。<br>`<br>而对于我们的驱动程序来讲，我们更多的应该（默认）阻塞进程，将其置入<strong>休眠状态</strong>。<br><strong>休眠状态</strong>：当一个进程被置入休眠状态之后，他会被标记为一种特殊的状态并从 CPU 的运行队列中移走，直到某些情况修改了这个状态。对于休眠状态，有两个重要的规则：</p>\n<ul>\n<li>永远不要在原子操作中进入休眠。</li>\n<li>我们对唤醒之后的状态不能做任何假定，必须检查以确保我们等待的条件为真。</li>\n</ul>\n<p>另外一个需要考虑的问题是，进入休眠的进程必须确保有其他进程会在其他地方唤醒休眠的进程，且休眠的进程能够被找到。</p>\n<h3 id=\"1-1-等待队列\"><a href=\"#1-1-等待队列\" class=\"headerlink\" title=\"1.1 等待队列\"></a>1.1 等待队列</h3><p>如上文所说，我们需要能够找到进入休眠的进程。我们使用一种叫做等待队列的数据结构来实现这个功能。<br><strong>等待队列</strong>是以队列为基础数据结构，与进程调度机制相结合，用于实现内核中的异步事件通知的机制。它实际上是一个进程链表，其中包含了等待某个特定事件的所有进程。</p>\n<ol>\n<li><p>初始化等待队列<br>等待队列使用一个<strong>等待队列头</strong>来管理，他可以通过下面两种方式来定义并初始化：</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*使用动态方法定义并初始化*/</span></div><div class=\"line\"><span class=\"keyword\">wait_queue_head_t</span> my_queue;</div><div class=\"line\">init_waitqueue_head(&amp;my_queue);</div><div class=\"line\"><span class=\"comment\">/*使用静态定义并初始化*/</span></div><div class=\"line\">DECLARE_WAIT_QUEUE_HEAD(name);</div></pre></td></tr></table></figure>\n<p> 我们使用这个等待队列头来指代我们的等待队列。</p>\n</li>\n<li><p>进入休眠</p>\n<ul>\n<li><p>当我们 I/O 遇到了阻塞条件，我们需要将其休眠的时候，我们可以使用 <code>wait_event</code> 宏来设置相应的进程进入休眠。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">wait_event(<span class=\"built_in\">queue</span>, condition); </div><div class=\"line\">wait_event_interruptible(<span class=\"built_in\">queue</span>, condition); </div><div class=\"line\">wait_event_timeout(<span class=\"built_in\">queue</span>, condition, timeout); </div><div class=\"line\">wait_event_interruptible_timeout(<span class=\"built_in\">queue</span>, condition, timeout);</div></pre></td></tr></table></figure>\n<p>上面相应的宏中，需要注意的是<strong><code>queue</code> 是相应的等待队列头，它是值传递的</strong>。<code>condition</code> 是一个布尔表达式，在表达式为真之前，进程会持续休眠。该表达式有可能被多次求值。<br><code>wait_event</code> 将相应的进程置于非中断休眠，我们更多使用的是 <code>wait_event_interruptible</code>，他可以被信号中断，当被信号中断的时候，返回一个非零值；后两个函数会设置相应的等待时间，超过等待时间之后，进程返回，返回值为0。</p>\n</li>\n<li><p>我们也可以手动设置一个进程进入休眠：</p>\n<ol>\n<li><p>建立一个并初始化一个<strong>等待队列入口</strong>。<br>我们可以使用宏 <code>DEFINE_WAIT(my_wait)</code> 来静态定义并初始化一个名为 <code>my_wait</code> 的等待队列入口，也可以使用下面的动态方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">wait_queue_t</span> my_wait;</div><div class=\"line\">init_wait(&amp;my_wait);</div></pre></td></tr></table></figure>\n<p>我们更多使用的是静态方法。</p>\n</li>\n<li><p>将相应的等待队列入口加入到队列中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prepare_to_wait</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *<span class=\"built_in\">queue</span>,</div><div class=\"line\">                     <span class=\"keyword\">wait_queue_t</span> *wait,</div><div class=\"line\">                     <span class=\"keyword\">int</span> state)</span></span>;</div></pre></td></tr></table></figure>\n<p>其中 <code>queue</code> 指我们的等待队列头，<code>wait</code> 指我们的进程等待队列入口，<code>state</code> 是进程的新状态，有两种值 <code>TASK_INTERRUPTIBLE</code>（可中断休眠，常用值）<code>TASK_UNINTERRUPTIBLE</code>（不可中断休眠）。</p>\n</li>\n<li><p>再次检查条件，让出 CPU：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (condition)</div><div class=\"line\">    schedule();</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程被唤醒后执行相应的清理工作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish_wait</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q, <span class=\"keyword\">wait_queue_t</span> *wait)</span></span>;</div></pre></td></tr></table></figure>\n<p>该函数将进程状态更改为 <code>TASK_RUNNING</code>，并从等待队列中删除该进程。</p>\n</li>\n<li>最后，我们需要测试我们是否是被信号唤醒的。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>对于阻塞的进程，我们需要能够唤醒它，唤醒函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wake_up</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wake_up_interruptible</span><span class=\"params\">(<span class=\"keyword\">wait_queue_head_t</span> *q)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>第一个函数会唤醒等待队列 <code>q</code> 上面的所有进程，而第二个只能唤醒等待队列上执行可中断休眠的进程。通常我们是将对应版本的 <code>wait</code> 和 <code>wake</code> 搭配使用。</p>\n<h3 id=\"1-2-轮询操作\"><a href=\"#1-2-轮询操作\" class=\"headerlink\" title=\"1.2 轮询操作\"></a>1.2 轮询操作</h3><p>在应用层有轮询的概念（I/O 多路复用），指的是在读取多个文件的时候，阻塞进程直到给定的文件描述符集合中任何一个可以进行相应的读写操作。相应的应用层函数有 <code>select</code>、<code>poll</code>、<code>epoll</code>等，他们在底层调用的是 <code>poll</code> 函数。它的原型是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*poll)</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, poll_table *wait)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>这个函数要完成两个工作：</p>\n<ol>\n<li>对可能引起设备文件状态变化的等待队列调用 <code>poll_wait()</code> 函数，将对应的等待队列添加到 <code>poll_table</code>。</li>\n<li>返回表示是否能对设备进行无阻塞的读写访问的掩码。</li>\n</ol>\n<p><code>poll_wait()</code> 函数的原型如下：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">poll_wait</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">wait_queue_head_t</span> *<span class=\"built_in\">queue</span>, poll_table *wait)</span></span>;</div></pre></td></tr></table></figure></p>\n<p> 功能：将当前进程加入到函数指定的等待列表 <code>wait</code>。<br> 参数：<code>filp</code> 打开的文件指针，<code>queue</code> 需要加入的 <code>wait</code> 的等待队列。</p>\n<p> 一个相应的 <code>poll</code> 函数实现代码如下：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">xxx_poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, poll_table *wait)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> xxx_dev *dev = filp-&gt;private_data;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>;</div><div class=\"line\">    poll_wait(filp, &amp;dev-&gt;r_wait, wait);</div><div class=\"line\">    poll_wait(filp, &amp;dev-&gt;w_wait, wait);</div><div class=\"line\">    <span class=\"keyword\">if</span> (readable)</div><div class=\"line\">       mask |= POLLIN|POLLRDNORM;</div><div class=\"line\">    <span class=\"keyword\">if</span> (writable)</div><div class=\"line\">       mask |= POLLOUT|POLLWRNORM;</div><div class=\"line\">   <span class=\"keyword\">return</span> mask;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二、异步通知\"><a href=\"#二、异步通知\" class=\"headerlink\" title=\"二、异步通知\"></a>二、异步通知</h2><p>异步通知的意思是：一旦设备就绪，就主动通知应用程序，这样应用程序就不用查询设备的状态，类似于硬件上的中断的概念。在 Linux 中，异步通知使用信号来实现。为了使设备支持异步通知机制，驱动程序中涉及三项工作：</p>\n<ol>\n<li>支持 <code>F_SETOWN</code> 命令，能在这个命令处理中设置 <code>filp-&gt;f_owner</code> 为对应的进程 ID，这部分工作由内核完成。</li>\n<li>支持 <code>F_SETFL</code> 命令，每当 <code>FASYNC</code> 标志改变的时候，驱动程序中的 <code>fasync()</code> 函数将得以执行。因此，应在设备驱动中实现 <code>fasync()</code> 函数。</li>\n<li>在设备资源可以获得的时候，调用 <code>kill_fasync()</code> 函数激发相应的信号。</li>\n</ol>\n<p>设备驱动的异步通知机制编程涉及到两个函数和一个结构体：</p>\n<ul>\n<li><code>fasync_struct</code> 结构体</li>\n<li><p><code>FASYNC</code> 标志变更函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fasync_helper</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">int</span> mode, <span class=\"keyword\">struct</span> fasync_struct **fa)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>释放信号的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kill_fasync</span><span class=\"params\">(<span class=\"keyword\">struct</span> fasync_struct **fa, <span class=\"keyword\">int</span> sig, <span class=\"keyword\">int</span> band)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>fasync_struct</code> 同样一般定义在相应的设备结构体 <code>xxx_dev</code> 中。<br>设备驱动的 <code>fasync()</code> 函数，一般参照下面的模板编写：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">xxx_fasync</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">int</span> mode)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> xxx_dev *dev = filp-&gt;private_data;</div><div class=\"line\">    <span class=\"keyword\">return</span> fasync_helper(fd, filp, mode, &amp;dev-&gt;fasync_queue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在设备删除的时候，还需要将文件从异步通知列表中删除，调用<code>xxx_fasync(-1, filp, 0);</code>。</p>"},{"title":"Linux驱动开发（二）——字符设备驱动模型","date":"2016-12-19T17:08:01.000Z","_content":"本篇对字符设备驱动模型进行总结。\n<!--more-->\n## 一、驱动结构\n如上篇博客所说驱动开发关注的是两个重要的结构体：`file_operations`、`inode`，而对字符驱动设备来讲，我们关注的是 `inode` 中的 `cdev` 结构体和 `file_operations` 中的相关的操作函数。\n`cdev` 结构体的定义如下：\n````struct cdev {\n    struct kobject kobj;         //内嵌的kobj对象\n    struct module *owner;        //所属模块\n    struct file_operations *ops; //文件操作结构体\n    struct list_head list;\n    dev_t dev;                   //设备号\n    unsigned int count;\n}````\n\n其中的 `dev_t` 成员定义了设备号，我们可以使用相应的宏从中获取主次设备号，或者使用相应的设备号生成 `dev_t`：\n````c \nMAJOR(dev_t dev);  //获取主设备号\nMINOR(dev_t dev);  //获取次设备号\nMKDEV(int major, int minor) //生成 dev_t\n````\n\n操作 `cdev` 结构体的函数如下所示：\n````c\nvoid cdev_init(struct cdev *, struct file_operations *);  //初始化 cdev \nstruct cdev *cdev_alloc(void);                            //动态申请 cdev 内存\nvoid cdev_put(struct cdev *p);                            //释放 cdev 内存\nint cdev_add(struct cdev *, dev_t, unsigned);             //添加一个 cdev 字符:设备注册\nint cdev_del(struct cdev *)；                             //删除一个 cdev 字符:设备注销\n````\n\n在设备注册和注销前，还需要向系统申请注册和释放设备号：\n````c\nint register_chrdev_region(dev_t from, unsigned count, const char *name); //已知起始设备号注册设备\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, \n                        const char *name);                                 //动态申请设备号\nint unregister_chrdev_region(dev_t form, unsigned count);                  //注销设备号\n````\n\n## 二、加载和卸载\n\n字符设备驱动模块加载函数中应实现设备号的申请和 cdev 的注册，在卸载函数中应实现设备号的释放和 cdev 注销。相应的代码如下：\n````C\n//设备结构体，通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进去。\nstruct xxx_dev_t {\n    struct cdev cdev;\n    ...\n} xxx_dev;  \n//设备驱动模块加载函数\nstatic int __init xxx_init(void) {\n    ...\n    cdev_init(&xxx_dev.cdev, &xxx_fops); //初始化cdev\n    xxx_dev.cdev.owner = THIS_MODULE;\n    if (xxx_major) {\n        register_chrdev_region(xxx_dev_no, 1, DEV_NAME);\n    } else {\n        alloc_chrdev_region(&xxx_dev_no, 0, 1, DEV_NAME);\n    }  //获取字符设备号\n    ret = cdev_add(&xxx_dev.cdev, xxx_dev_no, 1); //注册设备\n} \n//设备驱动模块卸载函数\nstatic void __exit xxx_exit(void) {\n    unregister_chrdev_region(xxx_dev_no, 1); //释放占用的设备号\n    cdev_del(&xxx_dev.cdev); //注销设备\n}````\n\n## 三、`file_operations` 结构体函数\n字符设备驱动通常要实现字符设备 `file_operations` 结构体中的读写函数，相应的结构体模板是：\n````c\nstruct file_operations xxx_fops = {\n    .owner = THIS_MODULE;\n    .read = xxx_read;\n    .write = xxx_write;\n    .ioctl = xxx_ioctl;\n    ...\n};````\n\n我们需要将我们实现的操作函数在 `file_operations` 结构体中指定其实现函数。相应的实现函数模板是：\n````c\n//打开设备\nint xxx_open(struct inode *inode, struct file *filp) {\n    return 0;\n}\n//释放设备文件\nint xxx_release(struct inode *inode, struct file *filp) {\n    return 0;\n}\n//读设备\nssize_t xxx_read(struct file *filp, char __user *buf，size_t count, loff_t *f_pos) {\n    ...\n    copy_to_user(buf, ..., ...);\n}\n//写设备\nssize_t xxx_write(struct file *filp, char __user *buf，size_t count, loff_t *f_pos) {\n    ...\n    copy_from_user(buf, ..., ...);\n}\n//文件定位\nstatic loff_t xxx_llseek(struct file *filp, loff_t offset, int orig) {\n    ...\n}\n//设备控制\nssize_t xxx_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg) {\n    ...\n    switch (cmd) {\n    case xxx_CMD1:\n        ...\n        break;\n    case xxx_CMD1:\n        ...\n        break;\n    default:\n        return -ENOTTY;\n    }\n    return 0;\n}````\n\n分别介绍写通常要使用的实现函数：\n### 3.1 打开函数 \n`int xxx_open(struct inode *inode, struct file *filp)`\n  打开函数中给驱动初始化，通常我们应实现以下工作：\n   * 检查设备的错误\n   * 如果设备初次打开，对其初始化\n   * 如果必要，更新操作函数指针\n   * 分配私有数据指针\n  `inode` 参数指的是我们打开设备的文件结构体，其中包含了我们的字符设备cdev结构体指针。如上文所说，我们通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进设备结构体中。这里有个技巧可以从 `inode` 指针中获取我们的设备结构体，使用宏 `container_of`，使用该宏可以从结构体成员指针找到对应的结构体指针:\n  `container_of(pointer, container_type, container_field)`\n  其中，\n  `pointer` 是我们已知的指针，这里我们可以知道设备结构体中的 `cdev` 成员的指针为 `inode->i_cdev`；\n  `container_type` 是我们想要获取的结构体类型，我们这里想要获取的结构体是自定义的设备结构体 `xxx_dev_t`\n  `container_field` 是 `pointer` 的类型，这里 `cdev` 的类型是 `cdev`。\n  这样，该宏就返回了我们想要的自定义的设备结构体指针，使用该指针可以很方便的找到我们的私有数据指针等和设备相关的信息。\n\n### 3.2 关闭函数 \n`int xxx_release(struct inode *inode, struct file *filp)`\n   关闭函数和打开函数相反，完成了以下的工作：\n   * 释放由 `open` 分配的，保存在 `filp->private_data` 中的所有数据。\n   * 在最后一次关闭操作的时候关闭设备。\n\n### 3.3 读写函数\n  在设备读写函数中，`filp` 是文件结构体指针，`buf` 是用户空间内存地址，`count` 是要读写的字节数，`f_ops` 是读写的位置偏移量。\n  因为内核空间和用户空间不能直接互相访问，所以需要在读写函数中实现用户空间到内核空间的复制。使用下述两个函数：\n  ````c\n  unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);\n  unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);\n  ````\n  上述函数返回不能复制的字节数，如果完全复制成功，返回0。 `__user` 是一个宏，表明后面的指针指向用户空间。\n\n### 3.4 ioctl函数\n  ioctl 是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。在 `xxx_ioctl` 函数中的 `cmd` 参数我们可以自己来直接指定，它可能仅仅是一个整数集，但 Linux 中的 ioctl 命令号都是有特定含义的，因此通常我们不么做。Linux 建议以 `设备类型/幻数（8bit）+序列号（8bit）+方向（2bit）+数据尺寸（13/14bit）` 的方式来定义 `cmd`。\n  Linux 内核提供了相应的宏来自动生成 ioctl 命令号： \n  ````C\n  _IO(type,nr) //没有参数的命令\n  _IOR(type,nr,size) //该命令是从驱动读取数据\n  _IOW(type,nr,size) //该命令是从驱动写入数据\n  _IOWR(type,nr,size) //双向数据传输````\n  上面的命令已经定义了方向，我们要传的是幻数(type)、序号(nr)和大小(size)。在这里szie的参数只需要填参数的类型，如int，上面的命令就会帮你检测类型的正确然后赋值 sizeof(int)。 \n  有生成cmd的命令就必有拆分cmd的命令：\n  ````C\n  _IOC_DIR(cmd) //从命令中提取方向\n  _IOC_TYPE(cmd) //从命令中提取幻数\n  _IOC_NR(cmd) //从命令中提取序数\n  _IOC_SIZE(cmd) //从命令中提取数据大小````\n\n### 3.5 定位函数\n`static loff_t xxx_llseek(struct file *filp, loff_t offset, int orig)`\n通过对 `orig` 的判断可以将起始地址设为文件开头（SEEK_SET， 0）、当前位置（SEELK_CUL，1）和文件尾（SEEK_END，2）。\n","source":"_posts/Linux驱动开发02.md","raw":"---\ntitle: Linux驱动开发（二）——字符设备驱动模型\ndate: 2016-12-20 01:08:01\ncategories: 驱动开发\ntags: [驱动, file_operations, 驱动加载]\n---\n本篇对字符设备驱动模型进行总结。\n<!--more-->\n## 一、驱动结构\n如上篇博客所说驱动开发关注的是两个重要的结构体：`file_operations`、`inode`，而对字符驱动设备来讲，我们关注的是 `inode` 中的 `cdev` 结构体和 `file_operations` 中的相关的操作函数。\n`cdev` 结构体的定义如下：\n````struct cdev {\n    struct kobject kobj;         //内嵌的kobj对象\n    struct module *owner;        //所属模块\n    struct file_operations *ops; //文件操作结构体\n    struct list_head list;\n    dev_t dev;                   //设备号\n    unsigned int count;\n}````\n\n其中的 `dev_t` 成员定义了设备号，我们可以使用相应的宏从中获取主次设备号，或者使用相应的设备号生成 `dev_t`：\n````c \nMAJOR(dev_t dev);  //获取主设备号\nMINOR(dev_t dev);  //获取次设备号\nMKDEV(int major, int minor) //生成 dev_t\n````\n\n操作 `cdev` 结构体的函数如下所示：\n````c\nvoid cdev_init(struct cdev *, struct file_operations *);  //初始化 cdev \nstruct cdev *cdev_alloc(void);                            //动态申请 cdev 内存\nvoid cdev_put(struct cdev *p);                            //释放 cdev 内存\nint cdev_add(struct cdev *, dev_t, unsigned);             //添加一个 cdev 字符:设备注册\nint cdev_del(struct cdev *)；                             //删除一个 cdev 字符:设备注销\n````\n\n在设备注册和注销前，还需要向系统申请注册和释放设备号：\n````c\nint register_chrdev_region(dev_t from, unsigned count, const char *name); //已知起始设备号注册设备\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, \n                        const char *name);                                 //动态申请设备号\nint unregister_chrdev_region(dev_t form, unsigned count);                  //注销设备号\n````\n\n## 二、加载和卸载\n\n字符设备驱动模块加载函数中应实现设备号的申请和 cdev 的注册，在卸载函数中应实现设备号的释放和 cdev 注销。相应的代码如下：\n````C\n//设备结构体，通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进去。\nstruct xxx_dev_t {\n    struct cdev cdev;\n    ...\n} xxx_dev;  \n//设备驱动模块加载函数\nstatic int __init xxx_init(void) {\n    ...\n    cdev_init(&xxx_dev.cdev, &xxx_fops); //初始化cdev\n    xxx_dev.cdev.owner = THIS_MODULE;\n    if (xxx_major) {\n        register_chrdev_region(xxx_dev_no, 1, DEV_NAME);\n    } else {\n        alloc_chrdev_region(&xxx_dev_no, 0, 1, DEV_NAME);\n    }  //获取字符设备号\n    ret = cdev_add(&xxx_dev.cdev, xxx_dev_no, 1); //注册设备\n} \n//设备驱动模块卸载函数\nstatic void __exit xxx_exit(void) {\n    unregister_chrdev_region(xxx_dev_no, 1); //释放占用的设备号\n    cdev_del(&xxx_dev.cdev); //注销设备\n}````\n\n## 三、`file_operations` 结构体函数\n字符设备驱动通常要实现字符设备 `file_operations` 结构体中的读写函数，相应的结构体模板是：\n````c\nstruct file_operations xxx_fops = {\n    .owner = THIS_MODULE;\n    .read = xxx_read;\n    .write = xxx_write;\n    .ioctl = xxx_ioctl;\n    ...\n};````\n\n我们需要将我们实现的操作函数在 `file_operations` 结构体中指定其实现函数。相应的实现函数模板是：\n````c\n//打开设备\nint xxx_open(struct inode *inode, struct file *filp) {\n    return 0;\n}\n//释放设备文件\nint xxx_release(struct inode *inode, struct file *filp) {\n    return 0;\n}\n//读设备\nssize_t xxx_read(struct file *filp, char __user *buf，size_t count, loff_t *f_pos) {\n    ...\n    copy_to_user(buf, ..., ...);\n}\n//写设备\nssize_t xxx_write(struct file *filp, char __user *buf，size_t count, loff_t *f_pos) {\n    ...\n    copy_from_user(buf, ..., ...);\n}\n//文件定位\nstatic loff_t xxx_llseek(struct file *filp, loff_t offset, int orig) {\n    ...\n}\n//设备控制\nssize_t xxx_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg) {\n    ...\n    switch (cmd) {\n    case xxx_CMD1:\n        ...\n        break;\n    case xxx_CMD1:\n        ...\n        break;\n    default:\n        return -ENOTTY;\n    }\n    return 0;\n}````\n\n分别介绍写通常要使用的实现函数：\n### 3.1 打开函数 \n`int xxx_open(struct inode *inode, struct file *filp)`\n  打开函数中给驱动初始化，通常我们应实现以下工作：\n   * 检查设备的错误\n   * 如果设备初次打开，对其初始化\n   * 如果必要，更新操作函数指针\n   * 分配私有数据指针\n  `inode` 参数指的是我们打开设备的文件结构体，其中包含了我们的字符设备cdev结构体指针。如上文所说，我们通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进设备结构体中。这里有个技巧可以从 `inode` 指针中获取我们的设备结构体，使用宏 `container_of`，使用该宏可以从结构体成员指针找到对应的结构体指针:\n  `container_of(pointer, container_type, container_field)`\n  其中，\n  `pointer` 是我们已知的指针，这里我们可以知道设备结构体中的 `cdev` 成员的指针为 `inode->i_cdev`；\n  `container_type` 是我们想要获取的结构体类型，我们这里想要获取的结构体是自定义的设备结构体 `xxx_dev_t`\n  `container_field` 是 `pointer` 的类型，这里 `cdev` 的类型是 `cdev`。\n  这样，该宏就返回了我们想要的自定义的设备结构体指针，使用该指针可以很方便的找到我们的私有数据指针等和设备相关的信息。\n\n### 3.2 关闭函数 \n`int xxx_release(struct inode *inode, struct file *filp)`\n   关闭函数和打开函数相反，完成了以下的工作：\n   * 释放由 `open` 分配的，保存在 `filp->private_data` 中的所有数据。\n   * 在最后一次关闭操作的时候关闭设备。\n\n### 3.3 读写函数\n  在设备读写函数中，`filp` 是文件结构体指针，`buf` 是用户空间内存地址，`count` 是要读写的字节数，`f_ops` 是读写的位置偏移量。\n  因为内核空间和用户空间不能直接互相访问，所以需要在读写函数中实现用户空间到内核空间的复制。使用下述两个函数：\n  ````c\n  unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);\n  unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);\n  ````\n  上述函数返回不能复制的字节数，如果完全复制成功，返回0。 `__user` 是一个宏，表明后面的指针指向用户空间。\n\n### 3.4 ioctl函数\n  ioctl 是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。在 `xxx_ioctl` 函数中的 `cmd` 参数我们可以自己来直接指定，它可能仅仅是一个整数集，但 Linux 中的 ioctl 命令号都是有特定含义的，因此通常我们不么做。Linux 建议以 `设备类型/幻数（8bit）+序列号（8bit）+方向（2bit）+数据尺寸（13/14bit）` 的方式来定义 `cmd`。\n  Linux 内核提供了相应的宏来自动生成 ioctl 命令号： \n  ````C\n  _IO(type,nr) //没有参数的命令\n  _IOR(type,nr,size) //该命令是从驱动读取数据\n  _IOW(type,nr,size) //该命令是从驱动写入数据\n  _IOWR(type,nr,size) //双向数据传输````\n  上面的命令已经定义了方向，我们要传的是幻数(type)、序号(nr)和大小(size)。在这里szie的参数只需要填参数的类型，如int，上面的命令就会帮你检测类型的正确然后赋值 sizeof(int)。 \n  有生成cmd的命令就必有拆分cmd的命令：\n  ````C\n  _IOC_DIR(cmd) //从命令中提取方向\n  _IOC_TYPE(cmd) //从命令中提取幻数\n  _IOC_NR(cmd) //从命令中提取序数\n  _IOC_SIZE(cmd) //从命令中提取数据大小````\n\n### 3.5 定位函数\n`static loff_t xxx_llseek(struct file *filp, loff_t offset, int orig)`\n通过对 `orig` 的判断可以将起始地址设为文件开头（SEEK_SET， 0）、当前位置（SEELK_CUL，1）和文件尾（SEEK_END，2）。\n","slug":"Linux驱动开发02","published":1,"updated":"2017-12-06T13:48:33.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001rbkw1r55vqzts","content":"<p>本篇对字符设备驱动模型进行总结。<br><a id=\"more\"></a></p>\n<h2 id=\"一、驱动结构\"><a href=\"#一、驱动结构\" class=\"headerlink\" title=\"一、驱动结构\"></a>一、驱动结构</h2><p>如上篇博客所说驱动开发关注的是两个重要的结构体：<code>file_operations</code>、<code>inode</code>，而对字符驱动设备来讲，我们关注的是 <code>inode</code> 中的 <code>cdev</code> 结构体和 <code>file_operations</code> 中的相关的操作函数。<br><code>cdev</code> 结构体的定义如下：<br><figure class=\"highlight plain\"><figcaption><span>cdev &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    struct kobject kobj;         //内嵌的kobj对象</div><div class=\"line\">    struct module *owner;        //所属模块</div><div class=\"line\">    struct file_operations *ops; //文件操作结构体</div><div class=\"line\">    struct list_head list;</div><div class=\"line\">    dev_t dev;                   //设备号</div><div class=\"line\">    unsigned int count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的 <code>dev_t</code> 成员定义了设备号，我们可以使用相应的宏从中获取主次设备号，或者使用相应的设备号生成 <code>dev_t</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MAJOR(<span class=\"keyword\">dev_t</span> dev);  <span class=\"comment\">//获取主设备号</span></div><div class=\"line\">MINOR(<span class=\"keyword\">dev_t</span> dev);  <span class=\"comment\">//获取次设备号</span></div><div class=\"line\">MKDEV(<span class=\"keyword\">int</span> major, <span class=\"keyword\">int</span> minor) <span class=\"comment\">//生成 dev_t</span></div></pre></td></tr></table></figure></p>\n<p>操作 <code>cdev</code> 结构体的函数如下所示：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void cdev_init(struct cdev *, struct file_operations *);  //初始化 cdev </div><div class=\"line\">struct cdev *cdev_alloc(void);                            //动态申请 cdev 内存</div><div class=\"line\">void cdev_put(struct cdev *p);                            //释放 cdev 内存</div><div class=\"line\">int cdev_add(struct cdev *, dev_t, unsigned);             //添加一个 cdev 字符:设备注册</div><div class=\"line\">int cdev_del(struct cdev *)；                             //删除一个 cdev 字符:设备注销</div></pre></td></tr></table></figure></p>\n<p>在设备注册和注销前，还需要向系统申请注册和释放设备号：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_chrdev_region</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> from, <span class=\"keyword\">unsigned</span> count, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>; <span class=\"comment\">//已知起始设备号注册设备</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">alloc_chrdev_region</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> *dev, <span class=\"keyword\">unsigned</span> baseminor, <span class=\"keyword\">unsigned</span> count, </span></span></div><div class=\"line\">                        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name);                                 <span class=\"comment\">//动态申请设备号</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">unregister_chrdev_region</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> form, <span class=\"keyword\">unsigned</span> count)</span></span>;                  <span class=\"comment\">//注销设备号</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"二、加载和卸载\"><a href=\"#二、加载和卸载\" class=\"headerlink\" title=\"二、加载和卸载\"></a>二、加载和卸载</h2><p>字符设备驱动模块加载函数中应实现设备号的申请和 cdev 的注册，在卸载函数中应实现设备号的释放和 cdev 注销。相应的代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设备结构体，通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进去。</span></div><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"keyword\">xxx_dev_t</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> cdev cdev;</div><div class=\"line\">    ...</div><div class=\"line\">&#125; xxx_dev;  </div><div class=\"line\"><span class=\"comment\">//设备驱动模块加载函数</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">xxx_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); <span class=\"comment\">//初始化cdev</span></div><div class=\"line\">    xxx_dev.cdev.owner = THIS_MODULE;</div><div class=\"line\">    <span class=\"keyword\">if</span> (xxx_major) &#123;</div><div class=\"line\">        register_chrdev_region(xxx_dev_no, <span class=\"number\">1</span>, DEV_NAME);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        alloc_chrdev_region(&amp;xxx_dev_no, <span class=\"number\">0</span>, <span class=\"number\">1</span>, DEV_NAME);</div><div class=\"line\">    &#125;  <span class=\"comment\">//获取字符设备号</span></div><div class=\"line\">    ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, <span class=\"number\">1</span>); <span class=\"comment\">//注册设备</span></div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">//设备驱动模块卸载函数</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">xxx_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">    unregister_chrdev_region(xxx_dev_no, <span class=\"number\">1</span>); <span class=\"comment\">//释放占用的设备号</span></div><div class=\"line\">    cdev_del(&amp;xxx_dev.cdev); <span class=\"comment\">//注销设备</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、file-operations-结构体函数\"><a href=\"#三、file-operations-结构体函数\" class=\"headerlink\" title=\"三、file_operations 结构体函数\"></a>三、<code>file_operations</code> 结构体函数</h2><p>字符设备驱动通常要实现字符设备 <code>file_operations</code> 结构体中的读写函数，相应的结构体模板是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> file_operations xxx_fops = &#123;</div><div class=\"line\">    .owner = THIS_MODULE;</div><div class=\"line\">    .read = xxx_read;</div><div class=\"line\">    .write = xxx_write;</div><div class=\"line\">    .ioctl = xxx_ioctl;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们需要将我们实现的操作函数在 <code>file_operations</code> 结构体中指定其实现函数。相应的实现函数模板是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//打开设备</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xxx_open</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//释放设备文件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xxx_release</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//读设备</span></div><div class=\"line\"><span class=\"keyword\">ssize_t</span> xxx_read(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">char</span> __user *buf，<span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *f_pos) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    copy_to_user(buf, ..., ...);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//写设备</span></div><div class=\"line\"><span class=\"keyword\">ssize_t</span> xxx_write(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">char</span> __user *buf，<span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *f_pos) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    copy_from_user(buf, ..., ...);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//文件定位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> loff_t <span class=\"title\">xxx_llseek</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">loff_t</span> offset, <span class=\"keyword\">int</span> orig)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备控制</span></div><div class=\"line\"><span class=\"keyword\">ssize_t</span> xxx_ioctl(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> xxx_CMD1:</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> xxx_CMD1:</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> -ENOTTY;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>分别介绍写通常要使用的实现函数：</p>\n<h3 id=\"3-1-打开函数\"><a href=\"#3-1-打开函数\" class=\"headerlink\" title=\"3.1 打开函数\"></a>3.1 打开函数</h3><p><code>int xxx_open(struct inode *inode, struct file *filp)</code><br>  打开函数中给驱动初始化，通常我们应实现以下工作：</p>\n<ul>\n<li>检查设备的错误</li>\n<li>如果设备初次打开，对其初始化</li>\n<li>如果必要，更新操作函数指针</li>\n<li>分配私有数据指针<br><code>inode</code> 参数指的是我们打开设备的文件结构体，其中包含了我们的字符设备cdev结构体指针。如上文所说，我们通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进设备结构体中。这里有个技巧可以从 <code>inode</code> 指针中获取我们的设备结构体，使用宏 <code>container_of</code>，使用该宏可以从结构体成员指针找到对应的结构体指针:<br><code>container_of(pointer, container_type, container_field)</code><br>其中，<br><code>pointer</code> 是我们已知的指针，这里我们可以知道设备结构体中的 <code>cdev</code> 成员的指针为 <code>inode-&gt;i_cdev</code>；<br><code>container_type</code> 是我们想要获取的结构体类型，我们这里想要获取的结构体是自定义的设备结构体 <code>xxx_dev_t</code><br><code>container_field</code> 是 <code>pointer</code> 的类型，这里 <code>cdev</code> 的类型是 <code>cdev</code>。<br>这样，该宏就返回了我们想要的自定义的设备结构体指针，使用该指针可以很方便的找到我们的私有数据指针等和设备相关的信息。</li>\n</ul>\n<h3 id=\"3-2-关闭函数\"><a href=\"#3-2-关闭函数\" class=\"headerlink\" title=\"3.2 关闭函数\"></a>3.2 关闭函数</h3><p><code>int xxx_release(struct inode *inode, struct file *filp)</code><br>   关闭函数和打开函数相反，完成了以下的工作：</p>\n<ul>\n<li>释放由 <code>open</code> 分配的，保存在 <code>filp-&gt;private_data</code> 中的所有数据。</li>\n<li>在最后一次关闭操作的时候关闭设备。</li>\n</ul>\n<h3 id=\"3-3-读写函数\"><a href=\"#3-3-读写函数\" class=\"headerlink\" title=\"3.3 读写函数\"></a>3.3 读写函数</h3><p>  在设备读写函数中，<code>filp</code> 是文件结构体指针，<code>buf</code> 是用户空间内存地址，<code>count</code> 是要读写的字节数，<code>f_ops</code> 是读写的位置偏移量。<br>  因为内核空间和用户空间不能直接互相访问，所以需要在读写函数中实现用户空间到内核空间的复制。使用下述两个函数：<br>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">copy_from_user</span><span class=\"params\">(<span class=\"keyword\">void</span> *to, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> __user *from, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">copy_to_user</span><span class=\"params\">(<span class=\"keyword\">void</span> __user *to, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *from, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>  上述函数返回不能复制的字节数，如果完全复制成功，返回0。 <code>__user</code> 是一个宏，表明后面的指针指向用户空间。</p>\n<h3 id=\"3-4-ioctl函数\"><a href=\"#3-4-ioctl函数\" class=\"headerlink\" title=\"3.4 ioctl函数\"></a>3.4 ioctl函数</h3><p>  ioctl 是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。在 <code>xxx_ioctl</code> 函数中的 <code>cmd</code> 参数我们可以自己来直接指定，它可能仅仅是一个整数集，但 Linux 中的 ioctl 命令号都是有特定含义的，因此通常我们不么做。Linux 建议以 <code>设备类型/幻数（8bit）+序列号（8bit）+方向（2bit）+数据尺寸（13/14bit）</code> 的方式来定义 <code>cmd</code>。<br>  Linux 内核提供了相应的宏来自动生成 ioctl 命令号：<br>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_IO(type,nr) <span class=\"comment\">//没有参数的命令</span></div><div class=\"line\">_IOR(type,nr,size) <span class=\"comment\">//该命令是从驱动读取数据</span></div><div class=\"line\">_IOW(type,nr,size) <span class=\"comment\">//该命令是从驱动写入数据</span></div><div class=\"line\">_IOWR(type,nr,size) <span class=\"comment\">//双向数据传输</span></div></pre></td></tr></table></figure></p>\n<p>  上面的命令已经定义了方向，我们要传的是幻数(type)、序号(nr)和大小(size)。在这里szie的参数只需要填参数的类型，如int，上面的命令就会帮你检测类型的正确然后赋值 sizeof(int)。<br>  有生成cmd的命令就必有拆分cmd的命令：<br>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_IOC_DIR(cmd) <span class=\"comment\">//从命令中提取方向</span></div><div class=\"line\">_IOC_TYPE(cmd) <span class=\"comment\">//从命令中提取幻数</span></div><div class=\"line\">_IOC_NR(cmd) <span class=\"comment\">//从命令中提取序数</span></div><div class=\"line\">_IOC_SIZE(cmd) <span class=\"comment\">//从命令中提取数据大小</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5-定位函数\"><a href=\"#3-5-定位函数\" class=\"headerlink\" title=\"3.5 定位函数\"></a>3.5 定位函数</h3><p><code>static loff_t xxx_llseek(struct file *filp, loff_t offset, int orig)</code><br>通过对 <code>orig</code> 的判断可以将起始地址设为文件开头（SEEK_SET， 0）、当前位置（SEELK_CUL，1）和文件尾（SEEK_END，2）。</p>\n","excerpt":"<p>本篇对字符设备驱动模型进行总结。<br>","more":"</p>\n<h2 id=\"一、驱动结构\"><a href=\"#一、驱动结构\" class=\"headerlink\" title=\"一、驱动结构\"></a>一、驱动结构</h2><p>如上篇博客所说驱动开发关注的是两个重要的结构体：<code>file_operations</code>、<code>inode</code>，而对字符驱动设备来讲，我们关注的是 <code>inode</code> 中的 <code>cdev</code> 结构体和 <code>file_operations</code> 中的相关的操作函数。<br><code>cdev</code> 结构体的定义如下：<br><figure class=\"highlight plain\"><figcaption><span>cdev &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    struct kobject kobj;         //内嵌的kobj对象</div><div class=\"line\">    struct module *owner;        //所属模块</div><div class=\"line\">    struct file_operations *ops; //文件操作结构体</div><div class=\"line\">    struct list_head list;</div><div class=\"line\">    dev_t dev;                   //设备号</div><div class=\"line\">    unsigned int count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的 <code>dev_t</code> 成员定义了设备号，我们可以使用相应的宏从中获取主次设备号，或者使用相应的设备号生成 <code>dev_t</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MAJOR(<span class=\"keyword\">dev_t</span> dev);  <span class=\"comment\">//获取主设备号</span></div><div class=\"line\">MINOR(<span class=\"keyword\">dev_t</span> dev);  <span class=\"comment\">//获取次设备号</span></div><div class=\"line\">MKDEV(<span class=\"keyword\">int</span> major, <span class=\"keyword\">int</span> minor) <span class=\"comment\">//生成 dev_t</span></div></pre></td></tr></table></figure></p>\n<p>操作 <code>cdev</code> 结构体的函数如下所示：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void cdev_init(struct cdev *, struct file_operations *);  //初始化 cdev </div><div class=\"line\">struct cdev *cdev_alloc(void);                            //动态申请 cdev 内存</div><div class=\"line\">void cdev_put(struct cdev *p);                            //释放 cdev 内存</div><div class=\"line\">int cdev_add(struct cdev *, dev_t, unsigned);             //添加一个 cdev 字符:设备注册</div><div class=\"line\">int cdev_del(struct cdev *)；                             //删除一个 cdev 字符:设备注销</div></pre></td></tr></table></figure></p>\n<p>在设备注册和注销前，还需要向系统申请注册和释放设备号：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_chrdev_region</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> from, <span class=\"keyword\">unsigned</span> count, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>; <span class=\"comment\">//已知起始设备号注册设备</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">alloc_chrdev_region</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> *dev, <span class=\"keyword\">unsigned</span> baseminor, <span class=\"keyword\">unsigned</span> count, </div><div class=\"line\">                        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;                                 <span class=\"comment\">//动态申请设备号</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">unregister_chrdev_region</span><span class=\"params\">(<span class=\"keyword\">dev_t</span> form, <span class=\"keyword\">unsigned</span> count)</span></span>;                  <span class=\"comment\">//注销设备号</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"二、加载和卸载\"><a href=\"#二、加载和卸载\" class=\"headerlink\" title=\"二、加载和卸载\"></a>二、加载和卸载</h2><p>字符设备驱动模块加载函数中应实现设备号的申请和 cdev 的注册，在卸载函数中应实现设备号的释放和 cdev 注销。相应的代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设备结构体，通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进去。</span></div><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"keyword\">xxx_dev_t</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> cdev cdev;</div><div class=\"line\">    ...</div><div class=\"line\">&#125; xxx_dev;  </div><div class=\"line\"><span class=\"comment\">//设备驱动模块加载函数</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">xxx_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); <span class=\"comment\">//初始化cdev</span></div><div class=\"line\">    xxx_dev.cdev.owner = THIS_MODULE;</div><div class=\"line\">    <span class=\"keyword\">if</span> (xxx_major) &#123;</div><div class=\"line\">        register_chrdev_region(xxx_dev_no, <span class=\"number\">1</span>, DEV_NAME);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        alloc_chrdev_region(&amp;xxx_dev_no, <span class=\"number\">0</span>, <span class=\"number\">1</span>, DEV_NAME);</div><div class=\"line\">    &#125;  <span class=\"comment\">//获取字符设备号</span></div><div class=\"line\">    ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, <span class=\"number\">1</span>); <span class=\"comment\">//注册设备</span></div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"comment\">//设备驱动模块卸载函数</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">xxx_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">    unregister_chrdev_region(xxx_dev_no, <span class=\"number\">1</span>); <span class=\"comment\">//释放占用的设备号</span></div><div class=\"line\">    cdev_del(&amp;xxx_dev.cdev); <span class=\"comment\">//注销设备</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、file-operations-结构体函数\"><a href=\"#三、file-operations-结构体函数\" class=\"headerlink\" title=\"三、file_operations 结构体函数\"></a>三、<code>file_operations</code> 结构体函数</h2><p>字符设备驱动通常要实现字符设备 <code>file_operations</code> 结构体中的读写函数，相应的结构体模板是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> file_operations xxx_fops = &#123;</div><div class=\"line\">    .owner = THIS_MODULE;</div><div class=\"line\">    .read = xxx_read;</div><div class=\"line\">    .write = xxx_write;</div><div class=\"line\">    .ioctl = xxx_ioctl;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们需要将我们实现的操作函数在 <code>file_operations</code> 结构体中指定其实现函数。相应的实现函数模板是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//打开设备</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xxx_open</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//释放设备文件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">xxx_release</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//读设备</span></div><div class=\"line\"><span class=\"keyword\">ssize_t</span> xxx_read(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">char</span> __user *buf，<span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *f_pos) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    copy_to_user(buf, ..., ...);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//写设备</span></div><div class=\"line\"><span class=\"keyword\">ssize_t</span> xxx_write(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">char</span> __user *buf，<span class=\"keyword\">size_t</span> count, <span class=\"keyword\">loff_t</span> *f_pos) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    copy_from_user(buf, ..., ...);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//文件定位</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> loff_t <span class=\"title\">xxx_llseek</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">loff_t</span> offset, <span class=\"keyword\">int</span> orig)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备控制</span></div><div class=\"line\"><span class=\"keyword\">ssize_t</span> xxx_ioctl(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cmd, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">switch</span> (cmd) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> xxx_CMD1:</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> xxx_CMD1:</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> -ENOTTY;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>分别介绍写通常要使用的实现函数：</p>\n<h3 id=\"3-1-打开函数\"><a href=\"#3-1-打开函数\" class=\"headerlink\" title=\"3.1 打开函数\"></a>3.1 打开函数</h3><p><code>int xxx_open(struct inode *inode, struct file *filp)</code><br>  打开函数中给驱动初始化，通常我们应实现以下工作：</p>\n<ul>\n<li>检查设备的错误</li>\n<li>如果设备初次打开，对其初始化</li>\n<li>如果必要，更新操作函数指针</li>\n<li>分配私有数据指针<br><code>inode</code> 参数指的是我们打开设备的文件结构体，其中包含了我们的字符设备cdev结构体指针。如上文所说，我们通常把该设备涉及到的cdev、私有数据及信号量等信息全包含进设备结构体中。这里有个技巧可以从 <code>inode</code> 指针中获取我们的设备结构体，使用宏 <code>container_of</code>，使用该宏可以从结构体成员指针找到对应的结构体指针:<br><code>container_of(pointer, container_type, container_field)</code><br>其中，<br><code>pointer</code> 是我们已知的指针，这里我们可以知道设备结构体中的 <code>cdev</code> 成员的指针为 <code>inode-&gt;i_cdev</code>；<br><code>container_type</code> 是我们想要获取的结构体类型，我们这里想要获取的结构体是自定义的设备结构体 <code>xxx_dev_t</code><br><code>container_field</code> 是 <code>pointer</code> 的类型，这里 <code>cdev</code> 的类型是 <code>cdev</code>。<br>这样，该宏就返回了我们想要的自定义的设备结构体指针，使用该指针可以很方便的找到我们的私有数据指针等和设备相关的信息。</li>\n</ul>\n<h3 id=\"3-2-关闭函数\"><a href=\"#3-2-关闭函数\" class=\"headerlink\" title=\"3.2 关闭函数\"></a>3.2 关闭函数</h3><p><code>int xxx_release(struct inode *inode, struct file *filp)</code><br>   关闭函数和打开函数相反，完成了以下的工作：</p>\n<ul>\n<li>释放由 <code>open</code> 分配的，保存在 <code>filp-&gt;private_data</code> 中的所有数据。</li>\n<li>在最后一次关闭操作的时候关闭设备。</li>\n</ul>\n<h3 id=\"3-3-读写函数\"><a href=\"#3-3-读写函数\" class=\"headerlink\" title=\"3.3 读写函数\"></a>3.3 读写函数</h3><p>  在设备读写函数中，<code>filp</code> 是文件结构体指针，<code>buf</code> 是用户空间内存地址，<code>count</code> 是要读写的字节数，<code>f_ops</code> 是读写的位置偏移量。<br>  因为内核空间和用户空间不能直接互相访问，所以需要在读写函数中实现用户空间到内核空间的复制。使用下述两个函数：<br>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">copy_from_user</span><span class=\"params\">(<span class=\"keyword\">void</span> *to, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> __user *from, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">copy_to_user</span><span class=\"params\">(<span class=\"keyword\">void</span> __user *to, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *from, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>  上述函数返回不能复制的字节数，如果完全复制成功，返回0。 <code>__user</code> 是一个宏，表明后面的指针指向用户空间。</p>\n<h3 id=\"3-4-ioctl函数\"><a href=\"#3-4-ioctl函数\" class=\"headerlink\" title=\"3.4 ioctl函数\"></a>3.4 ioctl函数</h3><p>  ioctl 是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。在 <code>xxx_ioctl</code> 函数中的 <code>cmd</code> 参数我们可以自己来直接指定，它可能仅仅是一个整数集，但 Linux 中的 ioctl 命令号都是有特定含义的，因此通常我们不么做。Linux 建议以 <code>设备类型/幻数（8bit）+序列号（8bit）+方向（2bit）+数据尺寸（13/14bit）</code> 的方式来定义 <code>cmd</code>。<br>  Linux 内核提供了相应的宏来自动生成 ioctl 命令号：<br>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_IO(type,nr) <span class=\"comment\">//没有参数的命令</span></div><div class=\"line\">_IOR(type,nr,size) <span class=\"comment\">//该命令是从驱动读取数据</span></div><div class=\"line\">_IOW(type,nr,size) <span class=\"comment\">//该命令是从驱动写入数据</span></div><div class=\"line\">_IOWR(type,nr,size) <span class=\"comment\">//双向数据传输</span></div></pre></td></tr></table></figure></p>\n<p>  上面的命令已经定义了方向，我们要传的是幻数(type)、序号(nr)和大小(size)。在这里szie的参数只需要填参数的类型，如int，上面的命令就会帮你检测类型的正确然后赋值 sizeof(int)。<br>  有生成cmd的命令就必有拆分cmd的命令：<br>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_IOC_DIR(cmd) <span class=\"comment\">//从命令中提取方向</span></div><div class=\"line\">_IOC_TYPE(cmd) <span class=\"comment\">//从命令中提取幻数</span></div><div class=\"line\">_IOC_NR(cmd) <span class=\"comment\">//从命令中提取序数</span></div><div class=\"line\">_IOC_SIZE(cmd) <span class=\"comment\">//从命令中提取数据大小</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5-定位函数\"><a href=\"#3-5-定位函数\" class=\"headerlink\" title=\"3.5 定位函数\"></a>3.5 定位函数</h3><p><code>static loff_t xxx_llseek(struct file *filp, loff_t offset, int orig)</code><br>通过对 <code>orig</code> 的判断可以将起始地址设为文件开头（SEEK_SET， 0）、当前位置（SEELK_CUL，1）和文件尾（SEEK_END，2）。</p>"},{"title":"Ubutu安装VSCode步骤","date":"2017-12-14T05:17:55.000Z","_content":"四条命令，记录备忘：\n<!-- more -->\n````\nsudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make\nsudo apt-get update\nsudo apt-get install ubuntu-make\numake web visual-studio-code````","source":"_posts/Ubutu安装VSCode步骤.md","raw":"---\ntitle: Ubutu安装VSCode步骤\ndate: 2017-12-14 13:17:55\ncategories: 工具使用\ntags: [VS Code,IDE]\n---\n四条命令，记录备忘：\n<!-- more -->\n````\nsudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make\nsudo apt-get update\nsudo apt-get install ubuntu-make\numake web visual-studio-code````","slug":"Ubutu安装VSCode步骤","published":1,"updated":"2017-12-14T05:19:34.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001sbkw1qil0eefc","content":"<p>四条命令，记录备忘：<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install ubuntu-make</div><div class=\"line\">umake web visual-studio-code</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>四条命令，记录备忘：<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install ubuntu-make</div><div class=\"line\">umake web visual-studio-code</div></pre></td></tr></table></figure></p>"},{"title":"Linux驱动开发（五）——中断和时钟","date":"2016-12-19T22:08:01.000Z","_content":"除了部分仅使用 I/O 寄存器的设备之外，大部分的设备都需要与外部打交道。这些外部的工作通常都是在与处理器完全不同的时间周期内完成的，且通常比处理器的处理速度要慢，所以一直让 CPU 等待设备的处理是不能令人满意的。这时候我们就需要使用中断。\n<!--more-->\n\n\n\n## 一、中断编程\n中断指的是 CPU 在执行的过程中，出现了某些突发事件基带处理，CPU 必须暂停执行当前的程序，转去处理相应的突发事件，处理完毕后返回程序被中断的位置并继续执行。\n\n设备的中断会打断内核内部正常的进程调度和运行，因此要求中断处理程序必须尽可能的短小。但是，往往现实中需要中断到来的时候完成大量的工作。为了解决这个冲突，Linux 将中断处理程序分为了两个部分：中断的顶半部和底半部。\n中断的顶半部完成尽可能少的工作，往往是简单的读取寄存器中的中断状态，并清除中断标志后就进行登记中断的工作。登记中断是将底半部的处理程序挂到设备的底半部执行队列中。因此，底半部是中断处理工作的重心，且可以被新的中断打断。\n\n### 1. 申请和释放中断\n申请中断使用下面的函数：\n````C\nint request_irq(unsigned int irq, irq_handlert handler, \n                unsigned long irqflags, const char *devname,\n                void *dev_id);````\n功能：申请中断。\n参数：`irq` 申请的硬件中断号；`handler` 顶半部中断处理函数；`irqflags` 中断处理的属性；`devname` 用来显示中断拥有者；`dev_id` 传递给`handler` 用于中断共享的中断信号线。`irqflags` 可能的值有：\n* `SA_INTERRUPT`\n  表示快速中断处理，快速中断处理程序被调用时将屏蔽中断。\n* `SA_SHIRQ`\n  表示中断共享\n\n返回值：成功返回0，返回`-EINVAL` 表示中断号无效，或者处理函数指针为 NULL，返回`-EBUSY` 表示中断已经被占用。\n\n相应的 `handler` 定义如下：\n````C\ntypedef irqreturn_t (*irq_handlert_t)(int, void *);\ntypedef int irq_handlert_t;````\n\n释放中断使用下面的函数：\n````C\nvoid free_irq(unsigned int irq, void *dev_id);````\n相应的参数定义和 `request_irq` 类似。\n\n### 2. 使能和屏蔽中断\n使用下面的函数屏蔽单个中断\n````C\nvoid disable_irq(int irq);\nvoid disable_irq_nosync(int irq);\nvoid enable_irq(int irq);\n````\n第一个函数会禁止相应的中断，并等待正在进行的中断处理例程完成。\n第二个函数会立即返回。\n\n使用下面的两个函数可以屏蔽当前 CPU 的所有的中断：\n````C\nvoid local_irq_save(unsigned long flags);\nvoid local_irq_disable(void);````\n第一个函数会把当前的中断状态保存在 `flags` 中，然后禁用当前处理器上的中断发送。第二个函数直接禁用所有的中断。相应的恢复函数是：\n````C\nvoid local_irq_restore(unsigned long flags);\nvoid local_irq_enable(void);````\n\n### 3. 底半部机制\n\n\n1. `tasklet`\n   `tasklet` 是一个基于软中断的特殊函数，它的使用很简单，就是定义一个 `tasklet` 和它的处理函数，并将他们两个关联起来。相应的模板代码如下：\n   ````C\n   //定义 tasklet 和底半部函数并关联\n   void xxx_do_tasklet(unsigned long arg);   //定义一个 tasklet 处理函数\n   DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0); //关联 tasklet 处理函数\n   //中断处理底半部\n   void xxx_do_tasklet(unsigned long arg) {\n     ...\n   }\n   //中断处理顶半部\n   irqreturn_t xxx_interrupt(int irq, void *dev_id) {\n     ...\n     tasklet_schedule(&xxx_tasklet);  //调用 tasklet 处理函数\n     return IRQ_HANDLED;\n   }\n   //设备驱动加载函数\n   int __init xxx_init(void) {\n     ...\n     //申请中断\n     result = request_irq(xxx_irq, xxx_interrupt,\n                          SA_INTERRUPT, \"xxx\", NULL);\n     ...\n   }\n   //设备驱动卸载函数\n   void __exit xxx_exit(void) {\n     ...\n     free_irq(xxx_irq, xxx_interrupt);\n     ...\n   }````\n\n   `tasklet` 是运行于软中断上下文的，属于原子上下文的一种，所以，是不能在 `tasklet` 处理函数中睡眠的。\n\n2. 工作队列\n   工作队列的使用方法和 `tasklet` 类似，模板代码如下：\n   ````C\n   //定义 tasklet 和底半部函数并关联\n   struct work_struct xxx_wq;   //定义一个工作队列\n   void xxx_do_work(unsigned long); //定义一个处理函数\n   //中断处理底半部\n   void xxx_do_tasklet(unsigned long arg) {\n     ...\n   }\n   //中断处理顶半部\n   irqreturn_t xxx_interrupt(int irq, void *dev_id) {\n     ...\n     schedule_work(&xxx_wq); //调用工作队列处理函数\n     return IRQ_HANDLED;\n   }\n   //设备驱动加载函数\n   int __init xxx_init(void) {\n     ...\n     //申请中断\n     result = request_irq(xxx_irq, xxx_interrupt,\n                          SA_INTERRUPT, \"xxx\", NULL);\n     ...\n     INIT_WORK(&xxx_wq, (void (*)(void *)) xxx_do_work, NULL);//绑定工作队列和处理函数\n   }\n   //设备驱动卸载函数\n   void __exit xxx_exit(void) {\n     ...\n     free_irq(xxx_irq, xxx_interrupt);\n     ...\n   }````\n   工作队列运行于进程上下文，所以可以在工作队列处理函数中睡眠。\n\n\n### 4. 中断共享\n因为设备上的中断线总是不够用的，所以 Linux 支持所有的总线的中断共享。使用中断共享的方法和之前介绍的类似，有几点不同：\n1. 请求中断，调用 `request_irq()` 时，应设置相应的 `irqflags` 为 `SA_SHIRQ`。\n2. `dev_id` 参数必须是唯一的。且不能为 NULL。\n\n当中断到来时，会遍历执行所有共享该中断的所有中断处理函数，应该在相应的中断处理函数顶半部中根据传入的 `dev_id` 值判断是否为当前设备的中断，是应返回 `IRQ_HANDLED` ，如果不是则返回 `IRQ_NONE`。\n\n## 二、时间操作\n中断一个十分重要的应用是定时器中断，内核使用其来跟踪时间流。定时器中断是有系统定时硬件以周期性的间隔产生，这个间隔是内核根据 `HZ` 的值来决定的。每次当内核定时器发生中断时，内核内部计数器就加1，这个计数器的值在系统引导的时候设置为0，因此它的值就是系统启动以来的时钟滴答数。这个值保存在一个 64 位的变量 `jiffies_64` 中，但我们更多使用的是一个 `jiffies` 变量。\n\n一个内核定时器是一个数据结构，他告诉内核在用户定义的时间点使用用户定义的参数来执行一个用户定义的函数。它的结构如下：\n````C\nstruct timer_list {\n  struct list_head entry;          //定时器列表\n  unsigned long expires;           //定时器到时时间\n  void (*function)(unsigned long); //定时器处理函数\n  unsigned long data;              //处理函数参数\n  struct timer_base_s *base;\n  ...\n}````\n\n### 2.1 定时器的使用\n1. 初始化定时器\n  ````C\n  //定义一个定时器\n  struct timer_list my_timer;\n  //初始化定时器   \n  void init_timer(struct timer_list *timer);\n  TIMER_INITIALIZER(_function, _expires, _data);\n  //定义并初始化定时器\n  DEFINE_TIMER(_name, _function, _expires, _data);\n  //初始化定时器并赋值\n  static inline void setup_timer(struct timer_list *timer,\n                                void (*function)(unsigned long),\n                                unsigned long data);````\n  其中，`init_timer` 函数初始化 `timer` 并将 `timer_list` 结构体中的 `entry` 的 `next` 设置为 NULL，将 `base` 赋值。\n\n2. 增加定时器\n  ````C\n  void add_timer(struct timer_list *timer);````\n  用来将定时器加入到内核定时器列表中。\n\n3. 删除定时器\n  ````C\n  int del_timer(struct timer_list *timer);````\n  用于删除定时器。\n\n4. 修改定时器\n  ````C\n  int mod_timer(struct timer_list *timer, unsigned long expires);````\n  用于修改定时器的到期时间。\n\n### 2.2 内核延时\n\n1. 短延时\n  使用下面三个函数实现纳秒、微秒、毫秒延时：\n  ````C\n  void ndelay(unsigned long nsecs);\n  void udelay(unsigned long usecs);\n  void mdelay(unsigned long msecs);````\n  这三个函数的实现是通过一个类似 `while(timer--)` 的循环完成的，因此是需要耗费 CPU 资源的。\n\n  对于微秒级以上延时有下列函数：\n  ````C\n  void msleep(unsigned int millisecs);\n  unsigned long msleep_interruptible(unsigned int millisecs);\n  void ssleep(unsigned int seconds);\n  ````\n  `msleep` 和 `ssleep` 分别用于毫秒和秒延时，这三个函数都会将相应的调用进程睡眠，`msleep_interruptible` 允许进程睡眠被打断。\n\n2. 长延时（忙等待）\n   长延时的实现通常是比对当前和目标的 `jiffies` 的值，相应的实现代码是：\n   ````C\n   while (time_before(jiffies, j1))\n    cpu_relax();\n   ````\n   上面的代码是忙等待模式的：循环会占用整个延时期间的处理器，严重降低系统性能，而且如果在进入延时前禁用了中断，系统将一直处于延时状态。\n\n3. 睡着延时\n   睡着延时是在等待时间到来之前让进程处于睡眠状态的一种延时方式，使用方法如下：\n   ````C\n   //1. 设置进程的状态。\n   set_current_state(TASK_INTERRUPTIBLE);\n   //2. 等待延时时间。\n   schedule_timeout(delay);\n   ````\n\n  \n\n\n\n\n","source":"_posts/Linux驱动开发05.md","raw":"---\ntitle: Linux驱动开发（五）——中断和时钟\ndate: 2016-12-20 06:08:01\ncategories: 驱动开发\ntags: [驱动, 中断, 定时器, 延时]\n---\n除了部分仅使用 I/O 寄存器的设备之外，大部分的设备都需要与外部打交道。这些外部的工作通常都是在与处理器完全不同的时间周期内完成的，且通常比处理器的处理速度要慢，所以一直让 CPU 等待设备的处理是不能令人满意的。这时候我们就需要使用中断。\n<!--more-->\n\n\n\n## 一、中断编程\n中断指的是 CPU 在执行的过程中，出现了某些突发事件基带处理，CPU 必须暂停执行当前的程序，转去处理相应的突发事件，处理完毕后返回程序被中断的位置并继续执行。\n\n设备的中断会打断内核内部正常的进程调度和运行，因此要求中断处理程序必须尽可能的短小。但是，往往现实中需要中断到来的时候完成大量的工作。为了解决这个冲突，Linux 将中断处理程序分为了两个部分：中断的顶半部和底半部。\n中断的顶半部完成尽可能少的工作，往往是简单的读取寄存器中的中断状态，并清除中断标志后就进行登记中断的工作。登记中断是将底半部的处理程序挂到设备的底半部执行队列中。因此，底半部是中断处理工作的重心，且可以被新的中断打断。\n\n### 1. 申请和释放中断\n申请中断使用下面的函数：\n````C\nint request_irq(unsigned int irq, irq_handlert handler, \n                unsigned long irqflags, const char *devname,\n                void *dev_id);````\n功能：申请中断。\n参数：`irq` 申请的硬件中断号；`handler` 顶半部中断处理函数；`irqflags` 中断处理的属性；`devname` 用来显示中断拥有者；`dev_id` 传递给`handler` 用于中断共享的中断信号线。`irqflags` 可能的值有：\n* `SA_INTERRUPT`\n  表示快速中断处理，快速中断处理程序被调用时将屏蔽中断。\n* `SA_SHIRQ`\n  表示中断共享\n\n返回值：成功返回0，返回`-EINVAL` 表示中断号无效，或者处理函数指针为 NULL，返回`-EBUSY` 表示中断已经被占用。\n\n相应的 `handler` 定义如下：\n````C\ntypedef irqreturn_t (*irq_handlert_t)(int, void *);\ntypedef int irq_handlert_t;````\n\n释放中断使用下面的函数：\n````C\nvoid free_irq(unsigned int irq, void *dev_id);````\n相应的参数定义和 `request_irq` 类似。\n\n### 2. 使能和屏蔽中断\n使用下面的函数屏蔽单个中断\n````C\nvoid disable_irq(int irq);\nvoid disable_irq_nosync(int irq);\nvoid enable_irq(int irq);\n````\n第一个函数会禁止相应的中断，并等待正在进行的中断处理例程完成。\n第二个函数会立即返回。\n\n使用下面的两个函数可以屏蔽当前 CPU 的所有的中断：\n````C\nvoid local_irq_save(unsigned long flags);\nvoid local_irq_disable(void);````\n第一个函数会把当前的中断状态保存在 `flags` 中，然后禁用当前处理器上的中断发送。第二个函数直接禁用所有的中断。相应的恢复函数是：\n````C\nvoid local_irq_restore(unsigned long flags);\nvoid local_irq_enable(void);````\n\n### 3. 底半部机制\n\n\n1. `tasklet`\n   `tasklet` 是一个基于软中断的特殊函数，它的使用很简单，就是定义一个 `tasklet` 和它的处理函数，并将他们两个关联起来。相应的模板代码如下：\n   ````C\n   //定义 tasklet 和底半部函数并关联\n   void xxx_do_tasklet(unsigned long arg);   //定义一个 tasklet 处理函数\n   DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0); //关联 tasklet 处理函数\n   //中断处理底半部\n   void xxx_do_tasklet(unsigned long arg) {\n     ...\n   }\n   //中断处理顶半部\n   irqreturn_t xxx_interrupt(int irq, void *dev_id) {\n     ...\n     tasklet_schedule(&xxx_tasklet);  //调用 tasklet 处理函数\n     return IRQ_HANDLED;\n   }\n   //设备驱动加载函数\n   int __init xxx_init(void) {\n     ...\n     //申请中断\n     result = request_irq(xxx_irq, xxx_interrupt,\n                          SA_INTERRUPT, \"xxx\", NULL);\n     ...\n   }\n   //设备驱动卸载函数\n   void __exit xxx_exit(void) {\n     ...\n     free_irq(xxx_irq, xxx_interrupt);\n     ...\n   }````\n\n   `tasklet` 是运行于软中断上下文的，属于原子上下文的一种，所以，是不能在 `tasklet` 处理函数中睡眠的。\n\n2. 工作队列\n   工作队列的使用方法和 `tasklet` 类似，模板代码如下：\n   ````C\n   //定义 tasklet 和底半部函数并关联\n   struct work_struct xxx_wq;   //定义一个工作队列\n   void xxx_do_work(unsigned long); //定义一个处理函数\n   //中断处理底半部\n   void xxx_do_tasklet(unsigned long arg) {\n     ...\n   }\n   //中断处理顶半部\n   irqreturn_t xxx_interrupt(int irq, void *dev_id) {\n     ...\n     schedule_work(&xxx_wq); //调用工作队列处理函数\n     return IRQ_HANDLED;\n   }\n   //设备驱动加载函数\n   int __init xxx_init(void) {\n     ...\n     //申请中断\n     result = request_irq(xxx_irq, xxx_interrupt,\n                          SA_INTERRUPT, \"xxx\", NULL);\n     ...\n     INIT_WORK(&xxx_wq, (void (*)(void *)) xxx_do_work, NULL);//绑定工作队列和处理函数\n   }\n   //设备驱动卸载函数\n   void __exit xxx_exit(void) {\n     ...\n     free_irq(xxx_irq, xxx_interrupt);\n     ...\n   }````\n   工作队列运行于进程上下文，所以可以在工作队列处理函数中睡眠。\n\n\n### 4. 中断共享\n因为设备上的中断线总是不够用的，所以 Linux 支持所有的总线的中断共享。使用中断共享的方法和之前介绍的类似，有几点不同：\n1. 请求中断，调用 `request_irq()` 时，应设置相应的 `irqflags` 为 `SA_SHIRQ`。\n2. `dev_id` 参数必须是唯一的。且不能为 NULL。\n\n当中断到来时，会遍历执行所有共享该中断的所有中断处理函数，应该在相应的中断处理函数顶半部中根据传入的 `dev_id` 值判断是否为当前设备的中断，是应返回 `IRQ_HANDLED` ，如果不是则返回 `IRQ_NONE`。\n\n## 二、时间操作\n中断一个十分重要的应用是定时器中断，内核使用其来跟踪时间流。定时器中断是有系统定时硬件以周期性的间隔产生，这个间隔是内核根据 `HZ` 的值来决定的。每次当内核定时器发生中断时，内核内部计数器就加1，这个计数器的值在系统引导的时候设置为0，因此它的值就是系统启动以来的时钟滴答数。这个值保存在一个 64 位的变量 `jiffies_64` 中，但我们更多使用的是一个 `jiffies` 变量。\n\n一个内核定时器是一个数据结构，他告诉内核在用户定义的时间点使用用户定义的参数来执行一个用户定义的函数。它的结构如下：\n````C\nstruct timer_list {\n  struct list_head entry;          //定时器列表\n  unsigned long expires;           //定时器到时时间\n  void (*function)(unsigned long); //定时器处理函数\n  unsigned long data;              //处理函数参数\n  struct timer_base_s *base;\n  ...\n}````\n\n### 2.1 定时器的使用\n1. 初始化定时器\n  ````C\n  //定义一个定时器\n  struct timer_list my_timer;\n  //初始化定时器   \n  void init_timer(struct timer_list *timer);\n  TIMER_INITIALIZER(_function, _expires, _data);\n  //定义并初始化定时器\n  DEFINE_TIMER(_name, _function, _expires, _data);\n  //初始化定时器并赋值\n  static inline void setup_timer(struct timer_list *timer,\n                                void (*function)(unsigned long),\n                                unsigned long data);````\n  其中，`init_timer` 函数初始化 `timer` 并将 `timer_list` 结构体中的 `entry` 的 `next` 设置为 NULL，将 `base` 赋值。\n\n2. 增加定时器\n  ````C\n  void add_timer(struct timer_list *timer);````\n  用来将定时器加入到内核定时器列表中。\n\n3. 删除定时器\n  ````C\n  int del_timer(struct timer_list *timer);````\n  用于删除定时器。\n\n4. 修改定时器\n  ````C\n  int mod_timer(struct timer_list *timer, unsigned long expires);````\n  用于修改定时器的到期时间。\n\n### 2.2 内核延时\n\n1. 短延时\n  使用下面三个函数实现纳秒、微秒、毫秒延时：\n  ````C\n  void ndelay(unsigned long nsecs);\n  void udelay(unsigned long usecs);\n  void mdelay(unsigned long msecs);````\n  这三个函数的实现是通过一个类似 `while(timer--)` 的循环完成的，因此是需要耗费 CPU 资源的。\n\n  对于微秒级以上延时有下列函数：\n  ````C\n  void msleep(unsigned int millisecs);\n  unsigned long msleep_interruptible(unsigned int millisecs);\n  void ssleep(unsigned int seconds);\n  ````\n  `msleep` 和 `ssleep` 分别用于毫秒和秒延时，这三个函数都会将相应的调用进程睡眠，`msleep_interruptible` 允许进程睡眠被打断。\n\n2. 长延时（忙等待）\n   长延时的实现通常是比对当前和目标的 `jiffies` 的值，相应的实现代码是：\n   ````C\n   while (time_before(jiffies, j1))\n    cpu_relax();\n   ````\n   上面的代码是忙等待模式的：循环会占用整个延时期间的处理器，严重降低系统性能，而且如果在进入延时前禁用了中断，系统将一直处于延时状态。\n\n3. 睡着延时\n   睡着延时是在等待时间到来之前让进程处于睡眠状态的一种延时方式，使用方法如下：\n   ````C\n   //1. 设置进程的状态。\n   set_current_state(TASK_INTERRUPTIBLE);\n   //2. 等待延时时间。\n   schedule_timeout(delay);\n   ````\n\n  \n\n\n\n\n","slug":"Linux驱动开发05","published":1,"updated":"2016-12-26T10:49:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001vbkw10ccve32d","content":"<p>除了部分仅使用 I/O 寄存器的设备之外，大部分的设备都需要与外部打交道。这些外部的工作通常都是在与处理器完全不同的时间周期内完成的，且通常比处理器的处理速度要慢，所以一直让 CPU 等待设备的处理是不能令人满意的。这时候我们就需要使用中断。<br><a id=\"more\"></a></p>\n<h2 id=\"一、中断编程\"><a href=\"#一、中断编程\" class=\"headerlink\" title=\"一、中断编程\"></a>一、中断编程</h2><p>中断指的是 CPU 在执行的过程中，出现了某些突发事件基带处理，CPU 必须暂停执行当前的程序，转去处理相应的突发事件，处理完毕后返回程序被中断的位置并继续执行。</p>\n<p>设备的中断会打断内核内部正常的进程调度和运行，因此要求中断处理程序必须尽可能的短小。但是，往往现实中需要中断到来的时候完成大量的工作。为了解决这个冲突，Linux 将中断处理程序分为了两个部分：中断的顶半部和底半部。<br>中断的顶半部完成尽可能少的工作，往往是简单的读取寄存器中的中断状态，并清除中断标志后就进行登记中断的工作。登记中断是将底半部的处理程序挂到设备的底半部执行队列中。因此，底半部是中断处理工作的重心，且可以被新的中断打断。</p>\n<h3 id=\"1-申请和释放中断\"><a href=\"#1-申请和释放中断\" class=\"headerlink\" title=\"1. 申请和释放中断\"></a>1. 申请和释放中断</h3><p>申请中断使用下面的函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">request_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, irq_handlert handler, </span></span></div><div class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> irqflags, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *devname,</div><div class=\"line\">                <span class=\"keyword\">void</span> *dev_id);</div></pre></td></tr></table></figure></p>\n<p>功能：申请中断。<br>参数：<code>irq</code> 申请的硬件中断号；<code>handler</code> 顶半部中断处理函数；<code>irqflags</code> 中断处理的属性；<code>devname</code> 用来显示中断拥有者；<code>dev_id</code> 传递给<code>handler</code> 用于中断共享的中断信号线。<code>irqflags</code> 可能的值有：</p>\n<ul>\n<li><code>SA_INTERRUPT</code><br>表示快速中断处理，快速中断处理程序被调用时将屏蔽中断。</li>\n<li><code>SA_SHIRQ</code><br>表示中断共享</li>\n</ul>\n<p>返回值：成功返回0，返回<code>-EINVAL</code> 表示中断号无效，或者处理函数指针为 NULL，返回<code>-EBUSY</code> 表示中断已经被占用。</p>\n<p>相应的 <code>handler</code> 定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">irqreturn_t</span> <span class=\"params\">(*<span class=\"keyword\">irq_handlert_t</span>)</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">void</span> *)</span></span>;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> <span class=\"keyword\">irq_handlert_t</span>;</div></pre></td></tr></table></figure></p>\n<p>释放中断使用下面的函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>相应的参数定义和 <code>request_irq</code> 类似。</p>\n<h3 id=\"2-使能和屏蔽中断\"><a href=\"#2-使能和屏蔽中断\" class=\"headerlink\" title=\"2. 使能和屏蔽中断\"></a>2. 使能和屏蔽中断</h3><p>使用下面的函数屏蔽单个中断<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">disable_irq</span><span class=\"params\">(<span class=\"keyword\">int</span> irq)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">disable_irq_nosync</span><span class=\"params\">(<span class=\"keyword\">int</span> irq)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enable_irq</span><span class=\"params\">(<span class=\"keyword\">int</span> irq)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>第一个函数会禁止相应的中断，并等待正在进行的中断处理例程完成。<br>第二个函数会立即返回。</p>\n<p>使用下面的两个函数可以屏蔽当前 CPU 的所有的中断：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_save</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_disable</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>第一个函数会把当前的中断状态保存在 <code>flags</code> 中，然后禁用当前处理器上的中断发送。第二个函数直接禁用所有的中断。相应的恢复函数是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_restore</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_enable</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-底半部机制\"><a href=\"#3-底半部机制\" class=\"headerlink\" title=\"3. 底半部机制\"></a>3. 底半部机制</h3><ol>\n<li><p><code>tasklet</code><br><code>tasklet</code> 是一个基于软中断的特殊函数，它的使用很简单，就是定义一个 <code>tasklet</code> 和它的处理函数，并将他们两个关联起来。相应的模板代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义 tasklet 和底半部函数并关联</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span>;   <span class=\"comment\">//定义一个 tasklet 处理函数</span></div><div class=\"line\">DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, <span class=\"number\">0</span>); <span class=\"comment\">//关联 tasklet 处理函数</span></div><div class=\"line\"><span class=\"comment\">//中断处理底半部</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//中断处理顶半部</span></div><div class=\"line\"><span class=\"keyword\">irqreturn_t</span> xxx_interrupt(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  tasklet_schedule(&amp;xxx_tasklet);  <span class=\"comment\">//调用 tasklet 处理函数</span></div><div class=\"line\">  <span class=\"keyword\">return</span> IRQ_HANDLED;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动加载函数</span></div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">xxx_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"comment\">//申请中断</span></div><div class=\"line\">  result = request_irq(xxx_irq, xxx_interrupt,</div><div class=\"line\">                       SA_INTERRUPT, <span class=\"string\">\"xxx\"</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动卸载函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">xxx_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  free_irq(xxx_irq, xxx_interrupt);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>tasklet</code> 是运行于软中断上下文的，属于原子上下文的一种，所以，是不能在 <code>tasklet</code> 处理函数中睡眠的。</p>\n</li>\n<li><p>工作队列<br>工作队列的使用方法和 <code>tasklet</code> 类似，模板代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义 tasklet 和底半部函数并关联</span></div><div class=\"line\"><span class=\"keyword\">struct</span> work_struct xxx_wq;   <span class=\"comment\">//定义一个工作队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_work</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)</span></span>; <span class=\"comment\">//定义一个处理函数</span></div><div class=\"line\"><span class=\"comment\">//中断处理底半部</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//中断处理顶半部</span></div><div class=\"line\"><span class=\"keyword\">irqreturn_t</span> xxx_interrupt(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  schedule_work(&amp;xxx_wq); <span class=\"comment\">//调用工作队列处理函数</span></div><div class=\"line\">  <span class=\"keyword\">return</span> IRQ_HANDLED;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动加载函数</span></div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">xxx_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"comment\">//申请中断</span></div><div class=\"line\">  result = request_irq(xxx_irq, xxx_interrupt,</div><div class=\"line\">                       SA_INTERRUPT, <span class=\"string\">\"xxx\"</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\">  ...</div><div class=\"line\">  INIT_WORK(&amp;xxx_wq, (<span class=\"keyword\">void</span> (*)(<span class=\"keyword\">void</span> *)) xxx_do_work, <span class=\"literal\">NULL</span>);<span class=\"comment\">//绑定工作队列和处理函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动卸载函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">xxx_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  free_irq(xxx_irq, xxx_interrupt);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>工作队列运行于进程上下文，所以可以在工作队列处理函数中睡眠。</p>\n</li>\n</ol>\n<h3 id=\"4-中断共享\"><a href=\"#4-中断共享\" class=\"headerlink\" title=\"4. 中断共享\"></a>4. 中断共享</h3><p>因为设备上的中断线总是不够用的，所以 Linux 支持所有的总线的中断共享。使用中断共享的方法和之前介绍的类似，有几点不同：</p>\n<ol>\n<li>请求中断，调用 <code>request_irq()</code> 时，应设置相应的 <code>irqflags</code> 为 <code>SA_SHIRQ</code>。</li>\n<li><code>dev_id</code> 参数必须是唯一的。且不能为 NULL。</li>\n</ol>\n<p>当中断到来时，会遍历执行所有共享该中断的所有中断处理函数，应该在相应的中断处理函数顶半部中根据传入的 <code>dev_id</code> 值判断是否为当前设备的中断，是应返回 <code>IRQ_HANDLED</code> ，如果不是则返回 <code>IRQ_NONE</code>。</p>\n<h2 id=\"二、时间操作\"><a href=\"#二、时间操作\" class=\"headerlink\" title=\"二、时间操作\"></a>二、时间操作</h2><p>中断一个十分重要的应用是定时器中断，内核使用其来跟踪时间流。定时器中断是有系统定时硬件以周期性的间隔产生，这个间隔是内核根据 <code>HZ</code> 的值来决定的。每次当内核定时器发生中断时，内核内部计数器就加1，这个计数器的值在系统引导的时候设置为0，因此它的值就是系统启动以来的时钟滴答数。这个值保存在一个 64 位的变量 <code>jiffies_64</code> 中，但我们更多使用的是一个 <code>jiffies</code> 变量。</p>\n<p>一个内核定时器是一个数据结构，他告诉内核在用户定义的时间点使用用户定义的参数来执行一个用户定义的函数。它的结构如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> timer_list &#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> list_head entry;          <span class=\"comment\">//定时器列表</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> expires;           <span class=\"comment\">//定时器到时时间</span></div><div class=\"line\">  <span class=\"keyword\">void</span> (*function)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>); <span class=\"comment\">//定时器处理函数</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data;              <span class=\"comment\">//处理函数参数</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> timer_base_s *base;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-定时器的使用\"><a href=\"#2-1-定时器的使用\" class=\"headerlink\" title=\"2.1 定时器的使用\"></a>2.1 定时器的使用</h3><ol>\n<li><p>初始化定时器</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义一个定时器</div><div class=\"line\">struct timer_list my_timer;</div><div class=\"line\">//初始化定时器   </div><div class=\"line\">void init_timer(struct timer_list *timer);</div><div class=\"line\">TIMER_INITIALIZER(_function, _expires, _data);</div><div class=\"line\">//定义并初始化定时器</div><div class=\"line\">DEFINE_TIMER(_name, _function, _expires, _data);</div><div class=\"line\">//初始化定时器并赋值</div><div class=\"line\">static inline void setup_timer(struct timer_list *timer,</div><div class=\"line\">                              void (*function)(unsigned long),</div><div class=\"line\">                              unsigned long data);</div></pre></td></tr></table></figure>\n<p>其中，<code>init_timer</code> 函数初始化 <code>timer</code> 并将 <code>timer_list</code> 结构体中的 <code>entry</code> 的 <code>next</code> 设置为 NULL，将 <code>base</code> 赋值。</p>\n</li>\n<li><p>增加定时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_timer</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list *timer)</span></span>;</div></pre></td></tr></table></figure>\n<p>用来将定时器加入到内核定时器列表中。</p>\n</li>\n<li><p>删除定时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">del_timer</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list *timer)</span></span>;</div></pre></td></tr></table></figure>\n<p>用于删除定时器。</p>\n</li>\n<li><p>修改定时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mod_timer</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list *timer, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> expires)</span></span>;</div></pre></td></tr></table></figure>\n<p>用于修改定时器的到期时间。</p>\n</li>\n</ol>\n<h3 id=\"2-2-内核延时\"><a href=\"#2-2-内核延时\" class=\"headerlink\" title=\"2.2 内核延时\"></a>2.2 内核延时</h3><ol>\n<li><p>短延时<br>使用下面三个函数实现纳秒、微秒、毫秒延时：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ndelay</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nsecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">udelay</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> usecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mdelay</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> msecs)</span></span>;</div></pre></td></tr></table></figure>\n<p>这三个函数的实现是通过一个类似 <code>while(timer--)</code> 的循环完成的，因此是需要耗费 CPU 资源的。</p>\n<p>对于微秒级以上延时有下列函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">msleep</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> millisecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">msleep_interruptible</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> millisecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ssleep</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seconds)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>msleep</code> 和 <code>ssleep</code> 分别用于毫秒和秒延时，这三个函数都会将相应的调用进程睡眠，<code>msleep_interruptible</code> 允许进程睡眠被打断。</p>\n</li>\n<li><p>长延时（忙等待）<br>长延时的实现通常是比对当前和目标的 <code>jiffies</code> 的值，相应的实现代码是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (time_before(jiffies, j1))</div><div class=\"line\"> cpu_relax();</div></pre></td></tr></table></figure>\n<p>上面的代码是忙等待模式的：循环会占用整个延时期间的处理器，严重降低系统性能，而且如果在进入延时前禁用了中断，系统将一直处于延时状态。</p>\n</li>\n<li><p>睡着延时<br>睡着延时是在等待时间到来之前让进程处于睡眠状态的一种延时方式，使用方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1. 设置进程的状态。</span></div><div class=\"line\">set_current_state(TASK_INTERRUPTIBLE);</div><div class=\"line\"><span class=\"comment\">//2. 等待延时时间。</span></div><div class=\"line\">schedule_timeout(delay);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","excerpt":"<p>除了部分仅使用 I/O 寄存器的设备之外，大部分的设备都需要与外部打交道。这些外部的工作通常都是在与处理器完全不同的时间周期内完成的，且通常比处理器的处理速度要慢，所以一直让 CPU 等待设备的处理是不能令人满意的。这时候我们就需要使用中断。<br>","more":"</p>\n<h2 id=\"一、中断编程\"><a href=\"#一、中断编程\" class=\"headerlink\" title=\"一、中断编程\"></a>一、中断编程</h2><p>中断指的是 CPU 在执行的过程中，出现了某些突发事件基带处理，CPU 必须暂停执行当前的程序，转去处理相应的突发事件，处理完毕后返回程序被中断的位置并继续执行。</p>\n<p>设备的中断会打断内核内部正常的进程调度和运行，因此要求中断处理程序必须尽可能的短小。但是，往往现实中需要中断到来的时候完成大量的工作。为了解决这个冲突，Linux 将中断处理程序分为了两个部分：中断的顶半部和底半部。<br>中断的顶半部完成尽可能少的工作，往往是简单的读取寄存器中的中断状态，并清除中断标志后就进行登记中断的工作。登记中断是将底半部的处理程序挂到设备的底半部执行队列中。因此，底半部是中断处理工作的重心，且可以被新的中断打断。</p>\n<h3 id=\"1-申请和释放中断\"><a href=\"#1-申请和释放中断\" class=\"headerlink\" title=\"1. 申请和释放中断\"></a>1. 申请和释放中断</h3><p>申请中断使用下面的函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">request_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, irq_handlert handler, </div><div class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> irqflags, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *devname,</div><div class=\"line\">                <span class=\"keyword\">void</span> *dev_id)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>功能：申请中断。<br>参数：<code>irq</code> 申请的硬件中断号；<code>handler</code> 顶半部中断处理函数；<code>irqflags</code> 中断处理的属性；<code>devname</code> 用来显示中断拥有者；<code>dev_id</code> 传递给<code>handler</code> 用于中断共享的中断信号线。<code>irqflags</code> 可能的值有：</p>\n<ul>\n<li><code>SA_INTERRUPT</code><br>表示快速中断处理，快速中断处理程序被调用时将屏蔽中断。</li>\n<li><code>SA_SHIRQ</code><br>表示中断共享</li>\n</ul>\n<p>返回值：成功返回0，返回<code>-EINVAL</code> 表示中断号无效，或者处理函数指针为 NULL，返回<code>-EBUSY</code> 表示中断已经被占用。</p>\n<p>相应的 <code>handler</code> 定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">irqreturn_t</span> <span class=\"params\">(*<span class=\"keyword\">irq_handlert_t</span>)</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">void</span> *)</span></span>;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> <span class=\"keyword\">irq_handlert_t</span>;</div></pre></td></tr></table></figure></p>\n<p>释放中断使用下面的函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_irq</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>相应的参数定义和 <code>request_irq</code> 类似。</p>\n<h3 id=\"2-使能和屏蔽中断\"><a href=\"#2-使能和屏蔽中断\" class=\"headerlink\" title=\"2. 使能和屏蔽中断\"></a>2. 使能和屏蔽中断</h3><p>使用下面的函数屏蔽单个中断<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">disable_irq</span><span class=\"params\">(<span class=\"keyword\">int</span> irq)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">disable_irq_nosync</span><span class=\"params\">(<span class=\"keyword\">int</span> irq)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enable_irq</span><span class=\"params\">(<span class=\"keyword\">int</span> irq)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>第一个函数会禁止相应的中断，并等待正在进行的中断处理例程完成。<br>第二个函数会立即返回。</p>\n<p>使用下面的两个函数可以屏蔽当前 CPU 的所有的中断：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_save</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_disable</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>第一个函数会把当前的中断状态保存在 <code>flags</code> 中，然后禁用当前处理器上的中断发送。第二个函数直接禁用所有的中断。相应的恢复函数是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_restore</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">local_irq_enable</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-底半部机制\"><a href=\"#3-底半部机制\" class=\"headerlink\" title=\"3. 底半部机制\"></a>3. 底半部机制</h3><ol>\n<li><p><code>tasklet</code><br><code>tasklet</code> 是一个基于软中断的特殊函数，它的使用很简单，就是定义一个 <code>tasklet</code> 和它的处理函数，并将他们两个关联起来。相应的模板代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义 tasklet 和底半部函数并关联</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span></span>;   <span class=\"comment\">//定义一个 tasklet 处理函数</span></div><div class=\"line\">DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, <span class=\"number\">0</span>); <span class=\"comment\">//关联 tasklet 处理函数</span></div><div class=\"line\"><span class=\"comment\">//中断处理底半部</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//中断处理顶半部</span></div><div class=\"line\"><span class=\"keyword\">irqreturn_t</span> xxx_interrupt(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  tasklet_schedule(&amp;xxx_tasklet);  <span class=\"comment\">//调用 tasklet 处理函数</span></div><div class=\"line\">  <span class=\"keyword\">return</span> IRQ_HANDLED;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动加载函数</span></div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">xxx_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"comment\">//申请中断</span></div><div class=\"line\">  result = request_irq(xxx_irq, xxx_interrupt,</div><div class=\"line\">                       SA_INTERRUPT, <span class=\"string\">\"xxx\"</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动卸载函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">xxx_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  free_irq(xxx_irq, xxx_interrupt);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>tasklet</code> 是运行于软中断上下文的，属于原子上下文的一种，所以，是不能在 <code>tasklet</code> 处理函数中睡眠的。</p>\n</li>\n<li><p>工作队列<br>工作队列的使用方法和 <code>tasklet</code> 类似，模板代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义 tasklet 和底半部函数并关联</span></div><div class=\"line\"><span class=\"keyword\">struct</span> work_struct xxx_wq;   <span class=\"comment\">//定义一个工作队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_work</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)</span></span>; <span class=\"comment\">//定义一个处理函数</span></div><div class=\"line\"><span class=\"comment\">//中断处理底半部</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">xxx_do_tasklet</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> arg)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//中断处理顶半部</span></div><div class=\"line\"><span class=\"keyword\">irqreturn_t</span> xxx_interrupt(<span class=\"keyword\">int</span> irq, <span class=\"keyword\">void</span> *dev_id) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  schedule_work(&amp;xxx_wq); <span class=\"comment\">//调用工作队列处理函数</span></div><div class=\"line\">  <span class=\"keyword\">return</span> IRQ_HANDLED;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动加载函数</span></div><div class=\"line\"><span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">xxx_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"comment\">//申请中断</span></div><div class=\"line\">  result = request_irq(xxx_irq, xxx_interrupt,</div><div class=\"line\">                       SA_INTERRUPT, <span class=\"string\">\"xxx\"</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\">  ...</div><div class=\"line\">  INIT_WORK(&amp;xxx_wq, (<span class=\"keyword\">void</span> (*)(<span class=\"keyword\">void</span> *)) xxx_do_work, <span class=\"literal\">NULL</span>);<span class=\"comment\">//绑定工作队列和处理函数</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设备驱动卸载函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\"><span class=\"built_in\">exit</span> <span class=\"title\">xxx_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  free_irq(xxx_irq, xxx_interrupt);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>工作队列运行于进程上下文，所以可以在工作队列处理函数中睡眠。</p>\n</li>\n</ol>\n<h3 id=\"4-中断共享\"><a href=\"#4-中断共享\" class=\"headerlink\" title=\"4. 中断共享\"></a>4. 中断共享</h3><p>因为设备上的中断线总是不够用的，所以 Linux 支持所有的总线的中断共享。使用中断共享的方法和之前介绍的类似，有几点不同：</p>\n<ol>\n<li>请求中断，调用 <code>request_irq()</code> 时，应设置相应的 <code>irqflags</code> 为 <code>SA_SHIRQ</code>。</li>\n<li><code>dev_id</code> 参数必须是唯一的。且不能为 NULL。</li>\n</ol>\n<p>当中断到来时，会遍历执行所有共享该中断的所有中断处理函数，应该在相应的中断处理函数顶半部中根据传入的 <code>dev_id</code> 值判断是否为当前设备的中断，是应返回 <code>IRQ_HANDLED</code> ，如果不是则返回 <code>IRQ_NONE</code>。</p>\n<h2 id=\"二、时间操作\"><a href=\"#二、时间操作\" class=\"headerlink\" title=\"二、时间操作\"></a>二、时间操作</h2><p>中断一个十分重要的应用是定时器中断，内核使用其来跟踪时间流。定时器中断是有系统定时硬件以周期性的间隔产生，这个间隔是内核根据 <code>HZ</code> 的值来决定的。每次当内核定时器发生中断时，内核内部计数器就加1，这个计数器的值在系统引导的时候设置为0，因此它的值就是系统启动以来的时钟滴答数。这个值保存在一个 64 位的变量 <code>jiffies_64</code> 中，但我们更多使用的是一个 <code>jiffies</code> 变量。</p>\n<p>一个内核定时器是一个数据结构，他告诉内核在用户定义的时间点使用用户定义的参数来执行一个用户定义的函数。它的结构如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> timer_list &#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> list_head entry;          <span class=\"comment\">//定时器列表</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> expires;           <span class=\"comment\">//定时器到时时间</span></div><div class=\"line\">  <span class=\"keyword\">void</span> (*function)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>); <span class=\"comment\">//定时器处理函数</span></div><div class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data;              <span class=\"comment\">//处理函数参数</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> timer_base_s *base;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-定时器的使用\"><a href=\"#2-1-定时器的使用\" class=\"headerlink\" title=\"2.1 定时器的使用\"></a>2.1 定时器的使用</h3><ol>\n<li><p>初始化定时器</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义一个定时器</div><div class=\"line\">struct timer_list my_timer;</div><div class=\"line\">//初始化定时器   </div><div class=\"line\">void init_timer(struct timer_list *timer);</div><div class=\"line\">TIMER_INITIALIZER(_function, _expires, _data);</div><div class=\"line\">//定义并初始化定时器</div><div class=\"line\">DEFINE_TIMER(_name, _function, _expires, _data);</div><div class=\"line\">//初始化定时器并赋值</div><div class=\"line\">static inline void setup_timer(struct timer_list *timer,</div><div class=\"line\">                              void (*function)(unsigned long),</div><div class=\"line\">                              unsigned long data);</div></pre></td></tr></table></figure>\n<p>其中，<code>init_timer</code> 函数初始化 <code>timer</code> 并将 <code>timer_list</code> 结构体中的 <code>entry</code> 的 <code>next</code> 设置为 NULL，将 <code>base</code> 赋值。</p>\n</li>\n<li><p>增加定时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_timer</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list *timer)</span></span>;</div></pre></td></tr></table></figure>\n<p>用来将定时器加入到内核定时器列表中。</p>\n</li>\n<li><p>删除定时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">del_timer</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list *timer)</span></span>;</div></pre></td></tr></table></figure>\n<p>用于删除定时器。</p>\n</li>\n<li><p>修改定时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mod_timer</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list *timer, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> expires)</span></span>;</div></pre></td></tr></table></figure>\n<p>用于修改定时器的到期时间。</p>\n</li>\n</ol>\n<h3 id=\"2-2-内核延时\"><a href=\"#2-2-内核延时\" class=\"headerlink\" title=\"2.2 内核延时\"></a>2.2 内核延时</h3><ol>\n<li><p>短延时<br>使用下面三个函数实现纳秒、微秒、毫秒延时：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ndelay</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nsecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">udelay</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> usecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mdelay</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> msecs)</span></span>;</div></pre></td></tr></table></figure>\n<p>这三个函数的实现是通过一个类似 <code>while(timer--)</code> 的循环完成的，因此是需要耗费 CPU 资源的。</p>\n<p>对于微秒级以上延时有下列函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">msleep</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> millisecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"title\">msleep_interruptible</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> millisecs)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ssleep</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seconds)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>msleep</code> 和 <code>ssleep</code> 分别用于毫秒和秒延时，这三个函数都会将相应的调用进程睡眠，<code>msleep_interruptible</code> 允许进程睡眠被打断。</p>\n</li>\n<li><p>长延时（忙等待）<br>长延时的实现通常是比对当前和目标的 <code>jiffies</code> 的值，相应的实现代码是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (time_before(jiffies, j1))</div><div class=\"line\"> cpu_relax();</div></pre></td></tr></table></figure>\n<p>上面的代码是忙等待模式的：循环会占用整个延时期间的处理器，严重降低系统性能，而且如果在进入延时前禁用了中断，系统将一直处于延时状态。</p>\n</li>\n<li><p>睡着延时<br>睡着延时是在等待时间到来之前让进程处于睡眠状态的一种延时方式，使用方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1. 设置进程的状态。</span></div><div class=\"line\">set_current_state(TASK_INTERRUPTIBLE);</div><div class=\"line\"><span class=\"comment\">//2. 等待延时时间。</span></div><div class=\"line\">schedule_timeout(delay);</div></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"Linux驱动开发（六）——内存使用","date":"2016-12-19T22:08:08.000Z","_content":"Linux 使用的是一个虚拟内存系统，意味着用户程序所使用的地址和硬件使用的物理地址是不等同的。本篇博客首先会简单描述相应的概念，然后介绍下内存存取的相应接口，最后讨论下和硬件IO相关的知识。\n<!--more-->\n\n## 一、Linux 内存管理\n### 1. 地址类型\n我们会听到很多种的地址类型，而每种类型都有自己的语义，相应的地址类型的解释如下：\n* **用户虚拟地址** \n  在用户空间看到的常规地址，每个进程都有自己的虚拟地址空间。\n* **物理地址**\n  在处理器和系统内存之间使用。\n* **总线地址**\n  在外围总线和内存之间使用，通常和处理器使用的物理地址相同。\n* **内核逻辑地址**\n  内核的常规地址空间，映射了部分内存。逻辑地址与物理地址的不同仅仅是之间存在一个固定的偏移量。使用 `kmalloc` 获取的地址就是内核逻辑地址。\n* **内核虚拟地址**\n  内核虚拟地址类似于逻辑地址，但是虚拟地址不一定是一对一的映射关系。\n### 2. 内存的使用\n系统对内存的使用是基于页的，页是物理地址分成的离散单元。页的大小一般位 4096 个字节。内存的地址都被分为了页号和一个偏移量。\n处理器一般会提供一个内存管理单元（MMU），MMU 提供了虚拟地址和物理地址的映射、内存访问权限保护、Cache 缓存控制等硬件支持。详细的 MMU 的工作模式不在这里详细描述。\n对于一个Linux 进程来讲，4GB 的内存空间被分为了两个部分：用户空间（0~3GB/PAGE_OFFSET）和内核空间（3~4GB）。内核空间又被分为了物理地址映射区（896MB）、专用页面映射区（FIXADDR_START~FIXADDR_TOP）、系统保留映射区(FIXADDR_TOP~4GB)。\n一般来讲，系统内存映射区最大位896MB，低于这个值的内存拥有逻辑地址，当大于这个值的时候，内核必须映射到高端页面映射区。一般来讲，内核数据都被放置在低端内存中，高端内存更趋向于为用户空间映射保留。\n\n## 二、内存存取\n在用户空间使用 `malloc()` 和 `free()` 函数进行内存的申请和释放，而内核空间往往使用下面的几个函数来进行内存的动态申请：\n\n1. `kmalloc`\n   ````C\n   void *kmalloc(size_t size, init flags);````\n   功能：从物理内存映射区域申请一块内存。\n   参数：`size` 申请的块的大小；`flags` 分配标志，常用的标志有：\n        `GFP_KERNEL` 在内核空间的进程中申请内存。\n        `GFP_ATOMIC` 如果不存在空闲页，直接返回。\n   使用 `kmalloc` 申请的内存应搭配使用 `kfree` 来释放。\n\n2. `__get_free_pages()`\n   ````C\n   //申请\n   get_zeroed_page(unsigned int flags);\n   __get_free_page(unsigned int flags);\n   __get_free_pages(unsigned int flags, unsigned int order);\n   //释放\n   void free_page(unsigned long addr);\n   void free_pages(unsigned long addr, unsigned int order);````\n\n   使用 GFP 等函数，申请的空间是以页为单位的，第一个函数返回一个指向新页的指针并将该页清零，第二个函数返回一个指向新页的指针但不清零，第三个函数返回一个指向多个页的首地址，分配的页数为2的 `order` 次幂。\n\n3. `vmalloc()`\n   ````C\n   void *vmalloc(unsigned long size);\n   void vfree(void *addr);````\n\n   `vmalloc` 在虚拟内存空间给出一块连续的内存区，这个函数不能用于原子上下文中。\n\n   和 `vmalloc` 类似，还有一对 `ioremap` `iounmap` 函数，用于映射I/O内存到虚拟空间，下面会使用到这个函数。 \n\n\n4. `slab`\n   针对返回使用的同一大小的内存块，内核提供了后备高速缓存。slab 算法就是针对上述特点设计的。\n   ````C\n   //创建 slab 缓存\n   struct kmem_cache *kmen_cache_create(const char *name, size_t size,\n            size_t align, unsigned long flags,\n            void (*ctor)(void *, struct kmem_cache *, unsigned long),\n            void (*dtor)(void *, struct kmem_cache *, unsigned long));\n   //分配 slab 缓存\n   void kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);\n   //释放 slab 缓存\n   void kmem_cache_free(struct kmem_cache *cachep, void *objp);\n   //收回 slab 缓存\n   int kmem_cache_destroy(struct kmem_cache *cachep);````\n\n\n## 二、硬件通信\n设备通常会有相应的寄存器来控制相应的功能，这些寄存器可能存在在IO空间，也可能存在在内存空间。需要注意的是不管是IO端口还是IO内存都存在边界效应。\n  \n### 1. I/O端口的使用\n1. I/O端口的分配\n   ````C\n   struct resource *request_region(unsigned long first, unsigned long n,\n                                   const char *name);//申请操作的端口\n   void release_region(unsigned long start, unsigned long n);//释放使用的端口\n   int check_region(unsigned long first, unsigned long n);//检查端口是否可用\n   ````\n   申请端口成功返回非NULL值，失败返回NULL。\n2. I/O端口的操作\n   ````C\n   //读写8位端口\n   unsigned inb(unsigned port);\n   void outb(unsigned char byte, unsigned port);\n   //读写16位端口\n   unsigned inw(unsigned port);\n   void outw(unsigned short word, unsigned port);\n   //读写32位端口\n   unsigned inl(unsigned port);\n   void outl(unsigned long byte, unsigned port);\n   //读写一串字节\n   void insb(unsigned port, void *addr, unsigned long count);\n   void outsb(unsigned port, void *addr, unsigned long count);\n   //读写一串字\n   void insw(unsigned port, void *addr, unsigned long count);\n   void outsw(unsigned port, void *addr, unsigned long count);\n   //读写一串长字\n   void insl(unsigned port, void *addr, unsigned long count);\n   void outsl(unsigned port, void *addr, unsigned long count);````\n   上述函数的 `port` 类型依赖于硬件平台。\n\n### 2. I/O内存的使用\n1. I/O内存的分配映射\n   ````C\n   struct resource *request_mem_region(unsigned long start, unsigned long len, \n                                       char *name);//分配I/O内存区域\n   void release_mem_region(unsigned long start, unsigned long len);//释放I/O内存\n   int check_mem_region(unsigned long start, unsigned long len);//检查是否可用\n   ````\n   进行IO内存的申请和释放后，并不是意味着得到的指针可以使用，应使用上面提到的 `ioremap` 函数来将相应的IO内存映射到虚拟空间内。\n\n2. I/O内存的访问\n   I/O内存访问使用下述函数，不再详细描述。\n   ````C\n   unsigned int ioread8(void *addr);\n   unsigned int ioread16(void *addr);\n   unsigned int ioread32(void *addr);\n   void iowrite8(u8 value, void *addr);\n   void iowrite16(u16 value, void *addr);\n   void iowrite32(u32 value, void *addr);````\n\n\n### 3. 映射I/O端口\n有一对函数可以把I/O端口映射为I/O内存。\n````C\nvoid *ioport_map(unsigned long port, unsigned int count);\nvoid ioport_unmap(void *addr);````\n\n","source":"_posts/Linux驱动开发06.md","raw":"---\ntitle: Linux驱动开发（六）——内存使用\ndate: 2016-12-20 06:08:08\ncategories: 驱动开发\ntags: [驱动, 内存, IO, 硬件通信]\n---\nLinux 使用的是一个虚拟内存系统，意味着用户程序所使用的地址和硬件使用的物理地址是不等同的。本篇博客首先会简单描述相应的概念，然后介绍下内存存取的相应接口，最后讨论下和硬件IO相关的知识。\n<!--more-->\n\n## 一、Linux 内存管理\n### 1. 地址类型\n我们会听到很多种的地址类型，而每种类型都有自己的语义，相应的地址类型的解释如下：\n* **用户虚拟地址** \n  在用户空间看到的常规地址，每个进程都有自己的虚拟地址空间。\n* **物理地址**\n  在处理器和系统内存之间使用。\n* **总线地址**\n  在外围总线和内存之间使用，通常和处理器使用的物理地址相同。\n* **内核逻辑地址**\n  内核的常规地址空间，映射了部分内存。逻辑地址与物理地址的不同仅仅是之间存在一个固定的偏移量。使用 `kmalloc` 获取的地址就是内核逻辑地址。\n* **内核虚拟地址**\n  内核虚拟地址类似于逻辑地址，但是虚拟地址不一定是一对一的映射关系。\n### 2. 内存的使用\n系统对内存的使用是基于页的，页是物理地址分成的离散单元。页的大小一般位 4096 个字节。内存的地址都被分为了页号和一个偏移量。\n处理器一般会提供一个内存管理单元（MMU），MMU 提供了虚拟地址和物理地址的映射、内存访问权限保护、Cache 缓存控制等硬件支持。详细的 MMU 的工作模式不在这里详细描述。\n对于一个Linux 进程来讲，4GB 的内存空间被分为了两个部分：用户空间（0~3GB/PAGE_OFFSET）和内核空间（3~4GB）。内核空间又被分为了物理地址映射区（896MB）、专用页面映射区（FIXADDR_START~FIXADDR_TOP）、系统保留映射区(FIXADDR_TOP~4GB)。\n一般来讲，系统内存映射区最大位896MB，低于这个值的内存拥有逻辑地址，当大于这个值的时候，内核必须映射到高端页面映射区。一般来讲，内核数据都被放置在低端内存中，高端内存更趋向于为用户空间映射保留。\n\n## 二、内存存取\n在用户空间使用 `malloc()` 和 `free()` 函数进行内存的申请和释放，而内核空间往往使用下面的几个函数来进行内存的动态申请：\n\n1. `kmalloc`\n   ````C\n   void *kmalloc(size_t size, init flags);````\n   功能：从物理内存映射区域申请一块内存。\n   参数：`size` 申请的块的大小；`flags` 分配标志，常用的标志有：\n        `GFP_KERNEL` 在内核空间的进程中申请内存。\n        `GFP_ATOMIC` 如果不存在空闲页，直接返回。\n   使用 `kmalloc` 申请的内存应搭配使用 `kfree` 来释放。\n\n2. `__get_free_pages()`\n   ````C\n   //申请\n   get_zeroed_page(unsigned int flags);\n   __get_free_page(unsigned int flags);\n   __get_free_pages(unsigned int flags, unsigned int order);\n   //释放\n   void free_page(unsigned long addr);\n   void free_pages(unsigned long addr, unsigned int order);````\n\n   使用 GFP 等函数，申请的空间是以页为单位的，第一个函数返回一个指向新页的指针并将该页清零，第二个函数返回一个指向新页的指针但不清零，第三个函数返回一个指向多个页的首地址，分配的页数为2的 `order` 次幂。\n\n3. `vmalloc()`\n   ````C\n   void *vmalloc(unsigned long size);\n   void vfree(void *addr);````\n\n   `vmalloc` 在虚拟内存空间给出一块连续的内存区，这个函数不能用于原子上下文中。\n\n   和 `vmalloc` 类似，还有一对 `ioremap` `iounmap` 函数，用于映射I/O内存到虚拟空间，下面会使用到这个函数。 \n\n\n4. `slab`\n   针对返回使用的同一大小的内存块，内核提供了后备高速缓存。slab 算法就是针对上述特点设计的。\n   ````C\n   //创建 slab 缓存\n   struct kmem_cache *kmen_cache_create(const char *name, size_t size,\n            size_t align, unsigned long flags,\n            void (*ctor)(void *, struct kmem_cache *, unsigned long),\n            void (*dtor)(void *, struct kmem_cache *, unsigned long));\n   //分配 slab 缓存\n   void kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);\n   //释放 slab 缓存\n   void kmem_cache_free(struct kmem_cache *cachep, void *objp);\n   //收回 slab 缓存\n   int kmem_cache_destroy(struct kmem_cache *cachep);````\n\n\n## 二、硬件通信\n设备通常会有相应的寄存器来控制相应的功能，这些寄存器可能存在在IO空间，也可能存在在内存空间。需要注意的是不管是IO端口还是IO内存都存在边界效应。\n  \n### 1. I/O端口的使用\n1. I/O端口的分配\n   ````C\n   struct resource *request_region(unsigned long first, unsigned long n,\n                                   const char *name);//申请操作的端口\n   void release_region(unsigned long start, unsigned long n);//释放使用的端口\n   int check_region(unsigned long first, unsigned long n);//检查端口是否可用\n   ````\n   申请端口成功返回非NULL值，失败返回NULL。\n2. I/O端口的操作\n   ````C\n   //读写8位端口\n   unsigned inb(unsigned port);\n   void outb(unsigned char byte, unsigned port);\n   //读写16位端口\n   unsigned inw(unsigned port);\n   void outw(unsigned short word, unsigned port);\n   //读写32位端口\n   unsigned inl(unsigned port);\n   void outl(unsigned long byte, unsigned port);\n   //读写一串字节\n   void insb(unsigned port, void *addr, unsigned long count);\n   void outsb(unsigned port, void *addr, unsigned long count);\n   //读写一串字\n   void insw(unsigned port, void *addr, unsigned long count);\n   void outsw(unsigned port, void *addr, unsigned long count);\n   //读写一串长字\n   void insl(unsigned port, void *addr, unsigned long count);\n   void outsl(unsigned port, void *addr, unsigned long count);````\n   上述函数的 `port` 类型依赖于硬件平台。\n\n### 2. I/O内存的使用\n1. I/O内存的分配映射\n   ````C\n   struct resource *request_mem_region(unsigned long start, unsigned long len, \n                                       char *name);//分配I/O内存区域\n   void release_mem_region(unsigned long start, unsigned long len);//释放I/O内存\n   int check_mem_region(unsigned long start, unsigned long len);//检查是否可用\n   ````\n   进行IO内存的申请和释放后，并不是意味着得到的指针可以使用，应使用上面提到的 `ioremap` 函数来将相应的IO内存映射到虚拟空间内。\n\n2. I/O内存的访问\n   I/O内存访问使用下述函数，不再详细描述。\n   ````C\n   unsigned int ioread8(void *addr);\n   unsigned int ioread16(void *addr);\n   unsigned int ioread32(void *addr);\n   void iowrite8(u8 value, void *addr);\n   void iowrite16(u16 value, void *addr);\n   void iowrite32(u32 value, void *addr);````\n\n\n### 3. 映射I/O端口\n有一对函数可以把I/O端口映射为I/O内存。\n````C\nvoid *ioport_map(unsigned long port, unsigned int count);\nvoid ioport_unmap(void *addr);````\n\n","slug":"Linux驱动开发06","published":1,"updated":"2016-12-26T10:58:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n17001xbkw1oy1x59md","content":"<p>Linux 使用的是一个虚拟内存系统，意味着用户程序所使用的地址和硬件使用的物理地址是不等同的。本篇博客首先会简单描述相应的概念，然后介绍下内存存取的相应接口，最后讨论下和硬件IO相关的知识。<br><a id=\"more\"></a></p>\n<h2 id=\"一、Linux-内存管理\"><a href=\"#一、Linux-内存管理\" class=\"headerlink\" title=\"一、Linux 内存管理\"></a>一、Linux 内存管理</h2><h3 id=\"1-地址类型\"><a href=\"#1-地址类型\" class=\"headerlink\" title=\"1. 地址类型\"></a>1. 地址类型</h3><p>我们会听到很多种的地址类型，而每种类型都有自己的语义，相应的地址类型的解释如下：</p>\n<ul>\n<li><strong>用户虚拟地址</strong><br>在用户空间看到的常规地址，每个进程都有自己的虚拟地址空间。</li>\n<li><strong>物理地址</strong><br>在处理器和系统内存之间使用。</li>\n<li><strong>总线地址</strong><br>在外围总线和内存之间使用，通常和处理器使用的物理地址相同。</li>\n<li><strong>内核逻辑地址</strong><br>内核的常规地址空间，映射了部分内存。逻辑地址与物理地址的不同仅仅是之间存在一个固定的偏移量。使用 <code>kmalloc</code> 获取的地址就是内核逻辑地址。</li>\n<li><strong>内核虚拟地址</strong><br>内核虚拟地址类似于逻辑地址，但是虚拟地址不一定是一对一的映射关系。<h3 id=\"2-内存的使用\"><a href=\"#2-内存的使用\" class=\"headerlink\" title=\"2. 内存的使用\"></a>2. 内存的使用</h3>系统对内存的使用是基于页的，页是物理地址分成的离散单元。页的大小一般位 4096 个字节。内存的地址都被分为了页号和一个偏移量。<br>处理器一般会提供一个内存管理单元（MMU），MMU 提供了虚拟地址和物理地址的映射、内存访问权限保护、Cache 缓存控制等硬件支持。详细的 MMU 的工作模式不在这里详细描述。<br>对于一个Linux 进程来讲，4GB 的内存空间被分为了两个部分：用户空间（0~3GB/PAGE_OFFSET）和内核空间（3~4GB）。内核空间又被分为了物理地址映射区（896MB）、专用页面映射区（FIXADDR_START~FIXADDR_TOP）、系统保留映射区(FIXADDR_TOP~4GB)。<br>一般来讲，系统内存映射区最大位896MB，低于这个值的内存拥有逻辑地址，当大于这个值的时候，内核必须映射到高端页面映射区。一般来讲，内核数据都被放置在低端内存中，高端内存更趋向于为用户空间映射保留。</li>\n</ul>\n<h2 id=\"二、内存存取\"><a href=\"#二、内存存取\" class=\"headerlink\" title=\"二、内存存取\"></a>二、内存存取</h2><p>在用户空间使用 <code>malloc()</code> 和 <code>free()</code> 函数进行内存的申请和释放，而内核空间往往使用下面的几个函数来进行内存的动态申请：</p>\n<ol>\n<li><p><code>kmalloc</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, init flags)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：从物理内存映射区域申请一块内存。<br>参数：<code>size</code> 申请的块的大小；<code>flags</code> 分配标志，常用的标志有：</p>\n<pre><code>`GFP_KERNEL` 在内核空间的进程中申请内存。\n`GFP_ATOMIC` 如果不存在空闲页，直接返回。\n</code></pre><p>使用 <code>kmalloc</code> 申请的内存应搭配使用 <code>kfree</code> 来释放。</p>\n</li>\n<li><p><code>__get_free_pages()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//申请</span></div><div class=\"line\">get_zeroed_page(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</div><div class=\"line\">__get_free_page(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</div><div class=\"line\">__get_free_pages(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order);</div><div class=\"line\"><span class=\"comment\">//释放</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_page</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_pages</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order)</span></span>;</div></pre></td></tr></table></figure>\n<p>使用 GFP 等函数，申请的空间是以页为单位的，第一个函数返回一个指向新页的指针并将该页清零，第二个函数返回一个指向新页的指针但不清零，第三个函数返回一个指向多个页的首地址，分配的页数为2的 <code>order</code> 次幂。</p>\n</li>\n<li><p><code>vmalloc()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">vmalloc</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vfree</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>vmalloc</code> 在虚拟内存空间给出一块连续的内存区，这个函数不能用于原子上下文中。</p>\n<p>和 <code>vmalloc</code> 类似，还有一对 <code>ioremap</code> <code>iounmap</code> 函数，用于映射I/O内存到虚拟空间，下面会使用到这个函数。 </p>\n</li>\n</ol>\n<ol>\n<li><code>slab</code><br>针对返回使用的同一大小的内存块，内核提供了后备高速缓存。slab 算法就是针对上述特点设计的。<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建 slab 缓存</div><div class=\"line\">struct kmem_cache *kmen_cache_create(const char *name, size_t size,</div><div class=\"line\">         size_t align, unsigned long flags,</div><div class=\"line\">         void (*ctor)(void *, struct kmem_cache *, unsigned long),</div><div class=\"line\">         void (*dtor)(void *, struct kmem_cache *, unsigned long));</div><div class=\"line\">//分配 slab 缓存</div><div class=\"line\">void kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);</div><div class=\"line\">//释放 slab 缓存</div><div class=\"line\">void kmem_cache_free(struct kmem_cache *cachep, void *objp);</div><div class=\"line\">//收回 slab 缓存</div><div class=\"line\">int kmem_cache_destroy(struct kmem_cache *cachep);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"二、硬件通信\"><a href=\"#二、硬件通信\" class=\"headerlink\" title=\"二、硬件通信\"></a>二、硬件通信</h2><p>设备通常会有相应的寄存器来控制相应的功能，这些寄存器可能存在在IO空间，也可能存在在内存空间。需要注意的是不管是IO端口还是IO内存都存在边界效应。</p>\n<h3 id=\"1-I-O端口的使用\"><a href=\"#1-I-O端口的使用\" class=\"headerlink\" title=\"1. I/O端口的使用\"></a>1. I/O端口的使用</h3><ol>\n<li><p>I/O端口的分配</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> resource *<span class=\"title\">request_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> first, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n,</span></span></div><div class=\"line\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name);<span class=\"comment\">//申请操作的端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span>;<span class=\"comment\">//释放使用的端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> first, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span>;<span class=\"comment\">//检查端口是否可用</span></div></pre></td></tr></table></figure>\n<p>申请端口成功返回非NULL值，失败返回NULL。</p>\n</li>\n<li><p>I/O端口的操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//读写8位端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">inb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> byte, <span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写16位端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">inw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> word, <span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写32位端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">inl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> byte, <span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写一串字节</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outsb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写一串字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outsw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写一串长字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outsl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div></pre></td></tr></table></figure>\n<p>上述函数的 <code>port</code> 类型依赖于硬件平台。</p>\n</li>\n</ol>\n<h3 id=\"2-I-O内存的使用\"><a href=\"#2-I-O内存的使用\" class=\"headerlink\" title=\"2. I/O内存的使用\"></a>2. I/O内存的使用</h3><ol>\n<li><p>I/O内存的分配映射</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> resource *<span class=\"title\">request_mem_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len, </span></span></div><div class=\"line\">                                    <span class=\"keyword\">char</span> *name);<span class=\"comment\">//分配I/O内存区域</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_mem_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len)</span></span>;<span class=\"comment\">//释放I/O内存</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_mem_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len)</span></span>;<span class=\"comment\">//检查是否可用</span></div></pre></td></tr></table></figure>\n<p>进行IO内存的申请和释放后，并不是意味着得到的指针可以使用，应使用上面提到的 <code>ioremap</code> 函数来将相应的IO内存映射到虚拟空间内。</p>\n</li>\n<li><p>I/O内存的访问<br>I/O内存访问使用下述函数，不再详细描述。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">ioread8</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">ioread16</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">ioread32</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iowrite8</span><span class=\"params\">(u8 value, <span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iowrite16</span><span class=\"params\">(u16 value, <span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iowrite32</span><span class=\"params\">(u32 value, <span class=\"keyword\">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-映射I-O端口\"><a href=\"#3-映射I-O端口\" class=\"headerlink\" title=\"3. 映射I/O端口\"></a>3. 映射I/O端口</h3><p>有一对函数可以把I/O端口映射为I/O内存。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">ioport_map</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> port, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ioport_unmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>Linux 使用的是一个虚拟内存系统，意味着用户程序所使用的地址和硬件使用的物理地址是不等同的。本篇博客首先会简单描述相应的概念，然后介绍下内存存取的相应接口，最后讨论下和硬件IO相关的知识。<br>","more":"</p>\n<h2 id=\"一、Linux-内存管理\"><a href=\"#一、Linux-内存管理\" class=\"headerlink\" title=\"一、Linux 内存管理\"></a>一、Linux 内存管理</h2><h3 id=\"1-地址类型\"><a href=\"#1-地址类型\" class=\"headerlink\" title=\"1. 地址类型\"></a>1. 地址类型</h3><p>我们会听到很多种的地址类型，而每种类型都有自己的语义，相应的地址类型的解释如下：</p>\n<ul>\n<li><strong>用户虚拟地址</strong><br>在用户空间看到的常规地址，每个进程都有自己的虚拟地址空间。</li>\n<li><strong>物理地址</strong><br>在处理器和系统内存之间使用。</li>\n<li><strong>总线地址</strong><br>在外围总线和内存之间使用，通常和处理器使用的物理地址相同。</li>\n<li><strong>内核逻辑地址</strong><br>内核的常规地址空间，映射了部分内存。逻辑地址与物理地址的不同仅仅是之间存在一个固定的偏移量。使用 <code>kmalloc</code> 获取的地址就是内核逻辑地址。</li>\n<li><strong>内核虚拟地址</strong><br>内核虚拟地址类似于逻辑地址，但是虚拟地址不一定是一对一的映射关系。<h3 id=\"2-内存的使用\"><a href=\"#2-内存的使用\" class=\"headerlink\" title=\"2. 内存的使用\"></a>2. 内存的使用</h3>系统对内存的使用是基于页的，页是物理地址分成的离散单元。页的大小一般位 4096 个字节。内存的地址都被分为了页号和一个偏移量。<br>处理器一般会提供一个内存管理单元（MMU），MMU 提供了虚拟地址和物理地址的映射、内存访问权限保护、Cache 缓存控制等硬件支持。详细的 MMU 的工作模式不在这里详细描述。<br>对于一个Linux 进程来讲，4GB 的内存空间被分为了两个部分：用户空间（0~3GB/PAGE_OFFSET）和内核空间（3~4GB）。内核空间又被分为了物理地址映射区（896MB）、专用页面映射区（FIXADDR_START~FIXADDR_TOP）、系统保留映射区(FIXADDR_TOP~4GB)。<br>一般来讲，系统内存映射区最大位896MB，低于这个值的内存拥有逻辑地址，当大于这个值的时候，内核必须映射到高端页面映射区。一般来讲，内核数据都被放置在低端内存中，高端内存更趋向于为用户空间映射保留。</li>\n</ul>\n<h2 id=\"二、内存存取\"><a href=\"#二、内存存取\" class=\"headerlink\" title=\"二、内存存取\"></a>二、内存存取</h2><p>在用户空间使用 <code>malloc()</code> 和 <code>free()</code> 函数进行内存的申请和释放，而内核空间往往使用下面的几个函数来进行内存的动态申请：</p>\n<ol>\n<li><p><code>kmalloc</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">kmalloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, init flags)</span></span>;</div></pre></td></tr></table></figure>\n<p>功能：从物理内存映射区域申请一块内存。<br>参数：<code>size</code> 申请的块的大小；<code>flags</code> 分配标志，常用的标志有：</p>\n<pre><code>`GFP_KERNEL` 在内核空间的进程中申请内存。\n`GFP_ATOMIC` 如果不存在空闲页，直接返回。\n</code></pre><p>使用 <code>kmalloc</code> 申请的内存应搭配使用 <code>kfree</code> 来释放。</p>\n</li>\n<li><p><code>__get_free_pages()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//申请</span></div><div class=\"line\">get_zeroed_page(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</div><div class=\"line\">__get_free_page(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags);</div><div class=\"line\">__get_free_pages(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order);</div><div class=\"line\"><span class=\"comment\">//释放</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_page</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_pages</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> order)</span></span>;</div></pre></td></tr></table></figure>\n<p>使用 GFP 等函数，申请的空间是以页为单位的，第一个函数返回一个指向新页的指针并将该页清零，第二个函数返回一个指向新页的指针但不清零，第三个函数返回一个指向多个页的首地址，分配的页数为2的 <code>order</code> 次幂。</p>\n</li>\n<li><p><code>vmalloc()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">vmalloc</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vfree</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure>\n<p><code>vmalloc</code> 在虚拟内存空间给出一块连续的内存区，这个函数不能用于原子上下文中。</p>\n<p>和 <code>vmalloc</code> 类似，还有一对 <code>ioremap</code> <code>iounmap</code> 函数，用于映射I/O内存到虚拟空间，下面会使用到这个函数。 </p>\n</li>\n</ol>\n<ol>\n<li><code>slab</code><br>针对返回使用的同一大小的内存块，内核提供了后备高速缓存。slab 算法就是针对上述特点设计的。<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建 slab 缓存</div><div class=\"line\">struct kmem_cache *kmen_cache_create(const char *name, size_t size,</div><div class=\"line\">         size_t align, unsigned long flags,</div><div class=\"line\">         void (*ctor)(void *, struct kmem_cache *, unsigned long),</div><div class=\"line\">         void (*dtor)(void *, struct kmem_cache *, unsigned long));</div><div class=\"line\">//分配 slab 缓存</div><div class=\"line\">void kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);</div><div class=\"line\">//释放 slab 缓存</div><div class=\"line\">void kmem_cache_free(struct kmem_cache *cachep, void *objp);</div><div class=\"line\">//收回 slab 缓存</div><div class=\"line\">int kmem_cache_destroy(struct kmem_cache *cachep);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"二、硬件通信\"><a href=\"#二、硬件通信\" class=\"headerlink\" title=\"二、硬件通信\"></a>二、硬件通信</h2><p>设备通常会有相应的寄存器来控制相应的功能，这些寄存器可能存在在IO空间，也可能存在在内存空间。需要注意的是不管是IO端口还是IO内存都存在边界效应。</p>\n<h3 id=\"1-I-O端口的使用\"><a href=\"#1-I-O端口的使用\" class=\"headerlink\" title=\"1. I/O端口的使用\"></a>1. I/O端口的使用</h3><ol>\n<li><p>I/O端口的分配</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> resource *<span class=\"title\">request_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> first, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n,</div><div class=\"line\">                                <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;<span class=\"comment\">//申请操作的端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span>;<span class=\"comment\">//释放使用的端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> first, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span>;<span class=\"comment\">//检查端口是否可用</span></div></pre></td></tr></table></figure>\n<p>申请端口成功返回非NULL值，失败返回NULL。</p>\n</li>\n<li><p>I/O端口的操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//读写8位端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">inb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> byte, <span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写16位端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">inw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> word, <span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写32位端口</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">inl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> byte, <span class=\"keyword\">unsigned</span> port)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写一串字节</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outsb</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写一串字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outsw</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"comment\">//读写一串长字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outsl</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> port, <span class=\"keyword\">void</span> *addr, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count)</span></span>;</div></pre></td></tr></table></figure>\n<p>上述函数的 <code>port</code> 类型依赖于硬件平台。</p>\n</li>\n</ol>\n<h3 id=\"2-I-O内存的使用\"><a href=\"#2-I-O内存的使用\" class=\"headerlink\" title=\"2. I/O内存的使用\"></a>2. I/O内存的使用</h3><ol>\n<li><p>I/O内存的分配映射</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> resource *<span class=\"title\">request_mem_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len, </div><div class=\"line\">                                    <span class=\"keyword\">char</span> *name)</span></span>;<span class=\"comment\">//分配I/O内存区域</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release_mem_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len)</span></span>;<span class=\"comment\">//释放I/O内存</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">check_mem_region</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> start, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len)</span></span>;<span class=\"comment\">//检查是否可用</span></div></pre></td></tr></table></figure>\n<p>进行IO内存的申请和释放后，并不是意味着得到的指针可以使用，应使用上面提到的 <code>ioremap</code> 函数来将相应的IO内存映射到虚拟空间内。</p>\n</li>\n<li><p>I/O内存的访问<br>I/O内存访问使用下述函数，不再详细描述。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">ioread8</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">ioread16</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">ioread32</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iowrite8</span><span class=\"params\">(u8 value, <span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iowrite16</span><span class=\"params\">(u16 value, <span class=\"keyword\">void</span> *addr)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iowrite32</span><span class=\"params\">(u32 value, <span class=\"keyword\">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-映射I-O端口\"><a href=\"#3-映射I-O端口\" class=\"headerlink\" title=\"3. 映射I/O端口\"></a>3. 映射I/O端口</h3><p>有一对函数可以把I/O端口映射为I/O内存。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">ioport_map</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> port, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ioport_unmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure></p>"},{"title":"Linux驱动开发（七）——设备驱动模型","date":"2016-12-19T22:08:09.000Z","_content":"\n设备驱动模型提供了硬件的抽象，内核使用这样的抽象可以完成很多硬件重复的工作，\n<!--more-->\n这些抽象工作包括几个部分：\n\n1. **电源管理**\n   设备驱动模型使电源管理子系统可以以正确的顺序遍历系统上的设备。\n2. **热插拔设备**\n   设备驱动模型自动捕捉插拔信号，加载驱动程序，使内核容易和设备通信。\n3. **与用户空间通信**\n   用户空间程序通过 sysfs 虚拟文件系统访问设备的相关信息。通过对 sysfs 文件系统的操作，就能够控制设备，或者从设备中读取相应的信息。\n\n## 一、sysfs 文件系统\nsysfs 文件系统是 Linux 文件系统中的一个。它的设计目的是：\n 1. 显示设备驱动模型中相关数据结构之间的关系；\n 2. 显示相应数据结构的信息。\n\nsysfs 文件系统与驱动模型结构的对应关系如下表所示：\n\n|类型\t|所包含的内容\t|对应内核数据结构|\t对应/sys目录|\n|-----|------------|--------------|-------------|\n|设备(Devices)\t|设备是此模型中最基本的类型，以设备本身的连接按层次组织|\tstruct device|\t/sys/devices/*/*/.../|\n|设备驱动(Device Drivers)|在一个系统中安装多个相同设备，只需要一份驱动程序的支持|struct device_driver|\t/sys/bus/pci/drivers/*/|\n|总线类型(Bus Types)|在整个总线级别对此总线上连接的所有设备进行管理|\tstruct bus_type|\t/sys/bus/*/|\n|设备类别(Device Classes)|\t这是按照功能进行分类组织的设备层次树|struct class|\t/sys/class/*/|\n\n其中的 sysfs 中的目录主要有\n├── block      //系统中的块设备目录\n├── bus        //系统中的总线目录\n├── class      //按照设备功能分类的设备模型\n├── dev        //系统中的发现的设备\n├── devices    //系统中所有设备的分层次表达\n├── firmware   //系统加载固件机制接口\n├── fs         //系统中的文件系统\n├── kernel     //内核可调整模块\n├── module     //系统中所有的模块信息\n└── power      //系统的电源选项\n\n### 1.1 kobject 结构体\nsysfs 文件系统树形结构的每一个目录都与一个 `kobject` 对象相对应，其中包含了该目录的组织结构和名字等信息。它的功能是：提供引用计数、维持父子和平级目录结构。\n````C\nstruct kobject {\n        const char              *name;       //kobject的名称\n        struct list_head        entry;       //连接下一个 kobject 结构\n        struct kobject          *parent;     //指向父级 kobject\n        struct kset             *kset;       //指向 kset 集合\n        struct kobj_type        *ktype;      //指向 kobject 的类型描述符\n        struct sysfs_dirent     *sd;         //对应 sysfs 的文件目录\n        struct kref             kref;        //kobject 的引用计数\n        unsigned int state_initialized:1;    //是否初始化\n\t    unsigned int state_in_sysfs:1;       //是否加入sysfs\n        unsigned int state_add_uevent_sent:1;\n        unsigned int state_remove_uevent_sent:1;\n};````\n`device`, `device_driver` 等各对象都是以 `kobject` 基础功能之上实现的。相应的 kobject 操作方法有：\n````C\nvoid kobject_init(struct kobject *kobj, struct kobj_type *ktype);  //初始化\nstatic void kobject_init_internal(struct kobj_type *ktype); //初始化内部成员\nstruct kobject *kobject_get(struct kobject *kobj);  //引用计数增加\nvoid kobject_put(struct kobject*kobj); //引用计数减少\nint kobject_set_name(struct kobject *kobj, const char *fmt, ...); //设置名字\nint kobject_rename(struct kobject *kobj, const char *new_name); //修改名字\n````\n\n其中的 `kobj_type` 是 kobject 的属性结构体，里面包含了 kobject 的属性（attribute）和属性操作方法（sysfs_ops）。相应的操作函数是：\n\n### 1.2 kset 结构体\n它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 kboject 实现，因而它同时也是一个 kobject (面向对象 OOP 概念中的继承关系) ，具有 kobject 的全部功能；\n````C\nstruct kset {\n        struct list_head list;\n        spinlock_t list_lock;\n        struct kobject kobj;\n        struct kset_uevent_ops *uevent_ops;\n};````\n\n在 /sys 根目录之下的都是 kset，它们组织了 /sys 的顶层目录视图；在部分 kset 下有二级或更深层次的 kset；\n每个 kset 目录下再包含着一个或多个 kobject，这表示一个集合所包含的 kobject 结构体；\n在 kobject 下有属性(attrs)文件和属性组(attr_group)，属性组就是组织属性的一个目录，它们一起向用户层提供了表示和操作这个 kobject 的属性特征的接口；\n在 kobject 下还有一些符号链接文件，指向其它的 kobject，这些符号链接文件用于组织上面所说的 device, driver, bus_type, class, module 之间的关系；\n不同类型如设备类型的、设备驱动类型的 kobject 都有不同的属性，不同驱动程序支持的 sysfs 接口也有不同的属性文件；而相同类型的设备上有很多相同的属性文件。\n\n## 二、设备驱动模型的三大组件\n设备驱动模型有三个重要的组件：总线、设备、驱动。它们三者是紧密联系的。总线将设备和驱动绑定，在系统每注册一个设备的时候，都会寻找相应的驱动，相反的，当系统每注册一个驱动的时候都会寻找与之匹配的设备。\n### 2.1 总线\n总线的定义如下：\n````C\nstruct bus_type {\n    const char *name; /* 总线类型名 */\n    struct bus_attribute *bus_attrs; /* 总线的属性 */\n    struct device_attribute *dev_attrs; /* 设备属性,为每个加入总线的设备建立属性链表 */\n    struct driver_attribute *drv_attrs; /* 驱动属性,为每个加入总线的驱动建立属性链表 */\n    int (*match)(struct device *dev, struct device_driver *drv); /* 驱动与设备匹配函数 */\n    int (*hotplug)(struct sevice *device, char **envp, int num_envp, \n                   char*buffer, int buffer_size)/*热插拔函数*/\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev); /* */\n    int (*remove)(struct device *dev); /* 设备移除调用操作 */\n    void (*shutdown)(struct device *dev);\n    int (*suspend)(struct device *dev, pm_message_t state);\n    int (*resume)(struct device *dev);\n    const struct dev_pm_ops *pm;\n    struct subsys_private *p; /* 一个很重要的域，包含了device链表和drivers链表 */\n};````\n总线中间最重要的是两个方法：`match` 一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次，若指定的驱动程序能够处理指定的设备，则返回非零值。必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序。`hotplug`在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）。\n\n### 2.2 设备\n设备在内核的定义如下：\n````C\nstruct device {\n    struct device *parent; /* 父设备，总线设备指定为NULL */\n    struct kobject kobj;\n    char bus_id[BUS_ID_SIZE];\n    const char *init_name; /* 初始默认的设备名,但@device_add调用之后又重新设为NULL */\n    struct device_type *type;\n    struct mutex mutex; /* mutex to synchronize calls to its driver */\n    struct bus_type *bus; /* type of bus device is on */\n    struct device_driver *driver; /* which driver has allocated this device */\n    void *platform_data; /* Platform specific data, device core doesn't touch it */\n    void (*release)(struct device *dev); \n    ...\n};````\n\n### 2.3 设备驱动\n设备驱动在内核中的表示如下：\n````C\nstruct device_driver {\n    const char *name; /* 驱动名称,在sysfs中以文件夹名出现 */\n    struct bus_type *bus; /* 驱动关联的总线类型 */\n    struct module *owner;\n    const char *mod_name; /* used for built-in modules */\n    bool suppress_bind_attrs; /* disables bind/unbind via sysfs */\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n    void (*shutdown) (struct device *dev);\n    int (*suspend) (struct device *dev, pm_message_t state);\n    int (*resume) (struct device *dev);\n    struct driver_private *p;\n    ...\n};\nstruct driver_private { /* 定义device_driver中的私有数据类型 */\n   struct kobject kobj; /* 内建kobject */\n   struct klist klist_devices; /* 驱动关联的设备链表，一个驱动可以关联多个设备 */\n   struct klist_node knode_bus;\n   struct module_kobject *mkobj;\n   struct device_driver *driver; /* 连接到的驱动链表 */\n};````\n\n","source":"_posts/Linux驱动开发07.md","raw":"---\ntitle: Linux驱动开发（七）——设备驱动模型\ndate: 2016-12-20 06:08:09\ncategories: 驱动开发\ntags: [驱动, 内存, IO, 硬件通信]\n---\n\n设备驱动模型提供了硬件的抽象，内核使用这样的抽象可以完成很多硬件重复的工作，\n<!--more-->\n这些抽象工作包括几个部分：\n\n1. **电源管理**\n   设备驱动模型使电源管理子系统可以以正确的顺序遍历系统上的设备。\n2. **热插拔设备**\n   设备驱动模型自动捕捉插拔信号，加载驱动程序，使内核容易和设备通信。\n3. **与用户空间通信**\n   用户空间程序通过 sysfs 虚拟文件系统访问设备的相关信息。通过对 sysfs 文件系统的操作，就能够控制设备，或者从设备中读取相应的信息。\n\n## 一、sysfs 文件系统\nsysfs 文件系统是 Linux 文件系统中的一个。它的设计目的是：\n 1. 显示设备驱动模型中相关数据结构之间的关系；\n 2. 显示相应数据结构的信息。\n\nsysfs 文件系统与驱动模型结构的对应关系如下表所示：\n\n|类型\t|所包含的内容\t|对应内核数据结构|\t对应/sys目录|\n|-----|------------|--------------|-------------|\n|设备(Devices)\t|设备是此模型中最基本的类型，以设备本身的连接按层次组织|\tstruct device|\t/sys/devices/*/*/.../|\n|设备驱动(Device Drivers)|在一个系统中安装多个相同设备，只需要一份驱动程序的支持|struct device_driver|\t/sys/bus/pci/drivers/*/|\n|总线类型(Bus Types)|在整个总线级别对此总线上连接的所有设备进行管理|\tstruct bus_type|\t/sys/bus/*/|\n|设备类别(Device Classes)|\t这是按照功能进行分类组织的设备层次树|struct class|\t/sys/class/*/|\n\n其中的 sysfs 中的目录主要有\n├── block      //系统中的块设备目录\n├── bus        //系统中的总线目录\n├── class      //按照设备功能分类的设备模型\n├── dev        //系统中的发现的设备\n├── devices    //系统中所有设备的分层次表达\n├── firmware   //系统加载固件机制接口\n├── fs         //系统中的文件系统\n├── kernel     //内核可调整模块\n├── module     //系统中所有的模块信息\n└── power      //系统的电源选项\n\n### 1.1 kobject 结构体\nsysfs 文件系统树形结构的每一个目录都与一个 `kobject` 对象相对应，其中包含了该目录的组织结构和名字等信息。它的功能是：提供引用计数、维持父子和平级目录结构。\n````C\nstruct kobject {\n        const char              *name;       //kobject的名称\n        struct list_head        entry;       //连接下一个 kobject 结构\n        struct kobject          *parent;     //指向父级 kobject\n        struct kset             *kset;       //指向 kset 集合\n        struct kobj_type        *ktype;      //指向 kobject 的类型描述符\n        struct sysfs_dirent     *sd;         //对应 sysfs 的文件目录\n        struct kref             kref;        //kobject 的引用计数\n        unsigned int state_initialized:1;    //是否初始化\n\t    unsigned int state_in_sysfs:1;       //是否加入sysfs\n        unsigned int state_add_uevent_sent:1;\n        unsigned int state_remove_uevent_sent:1;\n};````\n`device`, `device_driver` 等各对象都是以 `kobject` 基础功能之上实现的。相应的 kobject 操作方法有：\n````C\nvoid kobject_init(struct kobject *kobj, struct kobj_type *ktype);  //初始化\nstatic void kobject_init_internal(struct kobj_type *ktype); //初始化内部成员\nstruct kobject *kobject_get(struct kobject *kobj);  //引用计数增加\nvoid kobject_put(struct kobject*kobj); //引用计数减少\nint kobject_set_name(struct kobject *kobj, const char *fmt, ...); //设置名字\nint kobject_rename(struct kobject *kobj, const char *new_name); //修改名字\n````\n\n其中的 `kobj_type` 是 kobject 的属性结构体，里面包含了 kobject 的属性（attribute）和属性操作方法（sysfs_ops）。相应的操作函数是：\n\n### 1.2 kset 结构体\n它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 kboject 实现，因而它同时也是一个 kobject (面向对象 OOP 概念中的继承关系) ，具有 kobject 的全部功能；\n````C\nstruct kset {\n        struct list_head list;\n        spinlock_t list_lock;\n        struct kobject kobj;\n        struct kset_uevent_ops *uevent_ops;\n};````\n\n在 /sys 根目录之下的都是 kset，它们组织了 /sys 的顶层目录视图；在部分 kset 下有二级或更深层次的 kset；\n每个 kset 目录下再包含着一个或多个 kobject，这表示一个集合所包含的 kobject 结构体；\n在 kobject 下有属性(attrs)文件和属性组(attr_group)，属性组就是组织属性的一个目录，它们一起向用户层提供了表示和操作这个 kobject 的属性特征的接口；\n在 kobject 下还有一些符号链接文件，指向其它的 kobject，这些符号链接文件用于组织上面所说的 device, driver, bus_type, class, module 之间的关系；\n不同类型如设备类型的、设备驱动类型的 kobject 都有不同的属性，不同驱动程序支持的 sysfs 接口也有不同的属性文件；而相同类型的设备上有很多相同的属性文件。\n\n## 二、设备驱动模型的三大组件\n设备驱动模型有三个重要的组件：总线、设备、驱动。它们三者是紧密联系的。总线将设备和驱动绑定，在系统每注册一个设备的时候，都会寻找相应的驱动，相反的，当系统每注册一个驱动的时候都会寻找与之匹配的设备。\n### 2.1 总线\n总线的定义如下：\n````C\nstruct bus_type {\n    const char *name; /* 总线类型名 */\n    struct bus_attribute *bus_attrs; /* 总线的属性 */\n    struct device_attribute *dev_attrs; /* 设备属性,为每个加入总线的设备建立属性链表 */\n    struct driver_attribute *drv_attrs; /* 驱动属性,为每个加入总线的驱动建立属性链表 */\n    int (*match)(struct device *dev, struct device_driver *drv); /* 驱动与设备匹配函数 */\n    int (*hotplug)(struct sevice *device, char **envp, int num_envp, \n                   char*buffer, int buffer_size)/*热插拔函数*/\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    int (*probe)(struct device *dev); /* */\n    int (*remove)(struct device *dev); /* 设备移除调用操作 */\n    void (*shutdown)(struct device *dev);\n    int (*suspend)(struct device *dev, pm_message_t state);\n    int (*resume)(struct device *dev);\n    const struct dev_pm_ops *pm;\n    struct subsys_private *p; /* 一个很重要的域，包含了device链表和drivers链表 */\n};````\n总线中间最重要的是两个方法：`match` 一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次，若指定的驱动程序能够处理指定的设备，则返回非零值。必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序。`hotplug`在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）。\n\n### 2.2 设备\n设备在内核的定义如下：\n````C\nstruct device {\n    struct device *parent; /* 父设备，总线设备指定为NULL */\n    struct kobject kobj;\n    char bus_id[BUS_ID_SIZE];\n    const char *init_name; /* 初始默认的设备名,但@device_add调用之后又重新设为NULL */\n    struct device_type *type;\n    struct mutex mutex; /* mutex to synchronize calls to its driver */\n    struct bus_type *bus; /* type of bus device is on */\n    struct device_driver *driver; /* which driver has allocated this device */\n    void *platform_data; /* Platform specific data, device core doesn't touch it */\n    void (*release)(struct device *dev); \n    ...\n};````\n\n### 2.3 设备驱动\n设备驱动在内核中的表示如下：\n````C\nstruct device_driver {\n    const char *name; /* 驱动名称,在sysfs中以文件夹名出现 */\n    struct bus_type *bus; /* 驱动关联的总线类型 */\n    struct module *owner;\n    const char *mod_name; /* used for built-in modules */\n    bool suppress_bind_attrs; /* disables bind/unbind via sysfs */\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n    void (*shutdown) (struct device *dev);\n    int (*suspend) (struct device *dev, pm_message_t state);\n    int (*resume) (struct device *dev);\n    struct driver_private *p;\n    ...\n};\nstruct driver_private { /* 定义device_driver中的私有数据类型 */\n   struct kobject kobj; /* 内建kobject */\n   struct klist klist_devices; /* 驱动关联的设备链表，一个驱动可以关联多个设备 */\n   struct klist_node knode_bus;\n   struct module_kobject *mkobj;\n   struct device_driver *driver; /* 连接到的驱动链表 */\n};````\n\n","slug":"Linux驱动开发07","published":1,"updated":"2017-12-06T13:44:13.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n0020bkw1p7lkl5z3","content":"<p>设备驱动模型提供了硬件的抽象，内核使用这样的抽象可以完成很多硬件重复的工作，<br><a id=\"more\"></a><br>这些抽象工作包括几个部分：</p>\n<ol>\n<li><strong>电源管理</strong><br>设备驱动模型使电源管理子系统可以以正确的顺序遍历系统上的设备。</li>\n<li><strong>热插拔设备</strong><br>设备驱动模型自动捕捉插拔信号，加载驱动程序，使内核容易和设备通信。</li>\n<li><strong>与用户空间通信</strong><br>用户空间程序通过 sysfs 虚拟文件系统访问设备的相关信息。通过对 sysfs 文件系统的操作，就能够控制设备，或者从设备中读取相应的信息。</li>\n</ol>\n<h2 id=\"一、sysfs-文件系统\"><a href=\"#一、sysfs-文件系统\" class=\"headerlink\" title=\"一、sysfs 文件系统\"></a>一、sysfs 文件系统</h2><p>sysfs 文件系统是 Linux 文件系统中的一个。它的设计目的是：</p>\n<ol>\n<li>显示设备驱动模型中相关数据结构之间的关系；</li>\n<li>显示相应数据结构的信息。</li>\n</ol>\n<p>sysfs 文件系统与驱动模型结构的对应关系如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>所包含的内容</th>\n<th>对应内核数据结构</th>\n<th>对应/sys目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设备(Devices)</td>\n<td>设备是此模型中最基本的类型，以设备本身的连接按层次组织</td>\n<td>struct device</td>\n<td>/sys/devices/<em>/</em>/…/</td>\n</tr>\n<tr>\n<td>设备驱动(Device Drivers)</td>\n<td>在一个系统中安装多个相同设备，只需要一份驱动程序的支持</td>\n<td>struct device_driver</td>\n<td>/sys/bus/pci/drivers/*/</td>\n</tr>\n<tr>\n<td>总线类型(Bus Types)</td>\n<td>在整个总线级别对此总线上连接的所有设备进行管理</td>\n<td>struct bus_type</td>\n<td>/sys/bus/*/</td>\n</tr>\n<tr>\n<td>设备类别(Device Classes)</td>\n<td>这是按照功能进行分类组织的设备层次树</td>\n<td>struct class</td>\n<td>/sys/class/*/</td>\n</tr>\n</tbody>\n</table>\n<p>其中的 sysfs 中的目录主要有<br>├── block      //系统中的块设备目录<br>├── bus        //系统中的总线目录<br>├── class      //按照设备功能分类的设备模型<br>├── dev        //系统中的发现的设备<br>├── devices    //系统中所有设备的分层次表达<br>├── firmware   //系统加载固件机制接口<br>├── fs         //系统中的文件系统<br>├── kernel     //内核可调整模块<br>├── module     //系统中所有的模块信息<br>└── power      //系统的电源选项</p>\n<h3 id=\"1-1-kobject-结构体\"><a href=\"#1-1-kobject-结构体\" class=\"headerlink\" title=\"1.1 kobject 结构体\"></a>1.1 kobject 结构体</h3><p>sysfs 文件系统树形结构的每一个目录都与一个 <code>kobject</code> 对象相对应，其中包含了该目录的组织结构和名字等信息。它的功能是：提供引用计数、维持父子和平级目录结构。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> kobject &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>              *name;       <span class=\"comment\">//kobject的名称</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> list_head        entry;       <span class=\"comment\">//连接下一个 kobject 结构</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kobject          *parent;     <span class=\"comment\">//指向父级 kobject</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kset             *kset;       <span class=\"comment\">//指向 kset 集合</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kobj_type        *ktype;      <span class=\"comment\">//指向 kobject 的类型描述符</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> sysfs_dirent     *sd;         <span class=\"comment\">//对应 sysfs 的文件目录</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kref             kref;        <span class=\"comment\">//kobject 的引用计数</span></div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_initialized:<span class=\"number\">1</span>;    <span class=\"comment\">//是否初始化</span></div><div class=\"line\">\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_in_sysfs:<span class=\"number\">1</span>;       <span class=\"comment\">//是否加入sysfs</span></div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_add_uevent_sent:<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_remove_uevent_sent:<span class=\"number\">1</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><code>device</code>, <code>device_driver</code> 等各对象都是以 <code>kobject</code> 基础功能之上实现的。相应的 kobject 操作方法有：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kobject_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj, <span class=\"keyword\">struct</span> kobj_type *ktype)</span></span>;  <span class=\"comment\">//初始化</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">kobject_init_internal</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobj_type *ktype)</span></span>; <span class=\"comment\">//初始化内部成员</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> kobject *<span class=\"title\">kobject_get</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj)</span></span>;  <span class=\"comment\">//引用计数增加</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kobject_put</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject*kobj)</span></span>; <span class=\"comment\">//引用计数减少</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kobject_set_name</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *fmt, ...)</span></span>; <span class=\"comment\">//设置名字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kobject_rename</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *new_name)</span></span>; <span class=\"comment\">//修改名字</span></div></pre></td></tr></table></figure></p>\n<p>其中的 <code>kobj_type</code> 是 kobject 的属性结构体，里面包含了 kobject 的属性（attribute）和属性操作方法（sysfs_ops）。相应的操作函数是：</p>\n<h3 id=\"1-2-kset-结构体\"><a href=\"#1-2-kset-结构体\" class=\"headerlink\" title=\"1.2 kset 结构体\"></a>1.2 kset 结构体</h3><p>它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 kboject 实现，因而它同时也是一个 kobject (面向对象 OOP 概念中的继承关系) ，具有 kobject 的全部功能；<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> kset &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> list_head <span class=\"built_in\">list</span>;</div><div class=\"line\">        <span class=\"keyword\">spinlock_t</span> list_lock;</div><div class=\"line\">        <span class=\"keyword\">struct</span> kobject kobj;</div><div class=\"line\">        <span class=\"keyword\">struct</span> kset_uevent_ops *uevent_ops;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在 /sys 根目录之下的都是 kset，它们组织了 /sys 的顶层目录视图；在部分 kset 下有二级或更深层次的 kset；<br>每个 kset 目录下再包含着一个或多个 kobject，这表示一个集合所包含的 kobject 结构体；<br>在 kobject 下有属性(attrs)文件和属性组(attr_group)，属性组就是组织属性的一个目录，它们一起向用户层提供了表示和操作这个 kobject 的属性特征的接口；<br>在 kobject 下还有一些符号链接文件，指向其它的 kobject，这些符号链接文件用于组织上面所说的 device, driver, bus_type, class, module 之间的关系；<br>不同类型如设备类型的、设备驱动类型的 kobject 都有不同的属性，不同驱动程序支持的 sysfs 接口也有不同的属性文件；而相同类型的设备上有很多相同的属性文件。</p>\n<h2 id=\"二、设备驱动模型的三大组件\"><a href=\"#二、设备驱动模型的三大组件\" class=\"headerlink\" title=\"二、设备驱动模型的三大组件\"></a>二、设备驱动模型的三大组件</h2><p>设备驱动模型有三个重要的组件：总线、设备、驱动。它们三者是紧密联系的。总线将设备和驱动绑定，在系统每注册一个设备的时候，都会寻找相应的驱动，相反的，当系统每注册一个驱动的时候都会寻找与之匹配的设备。</p>\n<h3 id=\"2-1-总线\"><a href=\"#2-1-总线\" class=\"headerlink\" title=\"2.1 总线\"></a>2.1 总线</h3><p>总线的定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> bus_type &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">/* 总线类型名 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> bus_attribute *bus_attrs; <span class=\"comment\">/* 总线的属性 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> device_attribute *dev_attrs; <span class=\"comment\">/* 设备属性,为每个加入总线的设备建立属性链表 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> driver_attribute *drv_attrs; <span class=\"comment\">/* 驱动属性,为每个加入总线的驱动建立属性链表 */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> device_driver *drv); <span class=\"comment\">/* 驱动与设备匹配函数 */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*hotplug)(<span class=\"keyword\">struct</span> sevice *device, <span class=\"keyword\">char</span> **envp, <span class=\"keyword\">int</span> num_envp, </div><div class=\"line\">                   <span class=\"keyword\">char</span>*buffer, <span class=\"keyword\">int</span> buffer_size)<span class=\"comment\">/*热插拔函数*/</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*uevent)(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> kobj_uevent_env *env);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*probe)(<span class=\"keyword\">struct</span> device *dev); <span class=\"comment\">/* */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*remove)(<span class=\"keyword\">struct</span> device *dev); <span class=\"comment\">/* 设备移除调用操作 */</span></div><div class=\"line\">    <span class=\"keyword\">void</span> (*shutdown)(<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*suspend)(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">pm_message_t</span> state);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*resume)(<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> dev_pm_ops *pm;</div><div class=\"line\">    <span class=\"keyword\">struct</span> subsys_private *p; <span class=\"comment\">/* 一个很重要的域，包含了device链表和drivers链表 */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>总线中间最重要的是两个方法：<code>match</code> 一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次，若指定的驱动程序能够处理指定的设备，则返回非零值。必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序。<code>hotplug</code>在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）。</p>\n<h3 id=\"2-2-设备\"><a href=\"#2-2-设备\" class=\"headerlink\" title=\"2.2 设备\"></a>2.2 设备</h3><p>设备在内核的定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> device &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> device *parent; <span class=\"comment\">/* 父设备，总线设备指定为NULL */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> kobject kobj;</div><div class=\"line\">    <span class=\"keyword\">char</span> bus_id[BUS_ID_SIZE];</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init_name; <span class=\"comment\">/* 初始默认的设备名,但@device_add调用之后又重新设为NULL */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> device_type *type;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mutex mutex; <span class=\"comment\">/* mutex to synchronize calls to its driver */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> bus_type *bus; <span class=\"comment\">/* type of bus device is on */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> device_driver *driver; <span class=\"comment\">/* which driver has allocated this device */</span></div><div class=\"line\">    <span class=\"keyword\">void</span> *platform_data; <span class=\"comment\">/* Platform specific data, device core doesn't touch it */</span></div><div class=\"line\">    <span class=\"keyword\">void</span> (*release)(<span class=\"keyword\">struct</span> device *dev); </div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-设备驱动\"><a href=\"#2-3-设备驱动\" class=\"headerlink\" title=\"2.3 设备驱动\"></a>2.3 设备驱动</h3><p>设备驱动在内核中的表示如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> device_driver &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">/* 驱动名称,在sysfs中以文件夹名出现 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> bus_type *bus; <span class=\"comment\">/* 驱动关联的总线类型 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"keyword\">module</span> *owner;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mod_name; <span class=\"comment\">/* used for built-in modules */</span></div><div class=\"line\">    <span class=\"keyword\">bool</span> suppress_bind_attrs; <span class=\"comment\">/* disables bind/unbind via sysfs */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*probe) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*remove) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">void</span> (*shutdown) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*suspend) (<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">pm_message_t</span> state);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*resume) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">struct</span> driver_private *p;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">struct</span> driver_private &#123; <span class=\"comment\">/* 定义device_driver中的私有数据类型 */</span></div><div class=\"line\">   <span class=\"keyword\">struct</span> kobject kobj; <span class=\"comment\">/* 内建kobject */</span></div><div class=\"line\">   <span class=\"keyword\">struct</span> klist klist_devices; <span class=\"comment\">/* 驱动关联的设备链表，一个驱动可以关联多个设备 */</span></div><div class=\"line\">   <span class=\"keyword\">struct</span> klist_node knode_bus;</div><div class=\"line\">   <span class=\"keyword\">struct</span> module_kobject *mkobj;</div><div class=\"line\">   <span class=\"keyword\">struct</span> device_driver *driver; <span class=\"comment\">/* 连接到的驱动链表 */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>设备驱动模型提供了硬件的抽象，内核使用这样的抽象可以完成很多硬件重复的工作，<br>","more":"<br>这些抽象工作包括几个部分：</p>\n<ol>\n<li><strong>电源管理</strong><br>设备驱动模型使电源管理子系统可以以正确的顺序遍历系统上的设备。</li>\n<li><strong>热插拔设备</strong><br>设备驱动模型自动捕捉插拔信号，加载驱动程序，使内核容易和设备通信。</li>\n<li><strong>与用户空间通信</strong><br>用户空间程序通过 sysfs 虚拟文件系统访问设备的相关信息。通过对 sysfs 文件系统的操作，就能够控制设备，或者从设备中读取相应的信息。</li>\n</ol>\n<h2 id=\"一、sysfs-文件系统\"><a href=\"#一、sysfs-文件系统\" class=\"headerlink\" title=\"一、sysfs 文件系统\"></a>一、sysfs 文件系统</h2><p>sysfs 文件系统是 Linux 文件系统中的一个。它的设计目的是：</p>\n<ol>\n<li>显示设备驱动模型中相关数据结构之间的关系；</li>\n<li>显示相应数据结构的信息。</li>\n</ol>\n<p>sysfs 文件系统与驱动模型结构的对应关系如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>所包含的内容</th>\n<th>对应内核数据结构</th>\n<th>对应/sys目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设备(Devices)</td>\n<td>设备是此模型中最基本的类型，以设备本身的连接按层次组织</td>\n<td>struct device</td>\n<td>/sys/devices/<em>/</em>/…/</td>\n</tr>\n<tr>\n<td>设备驱动(Device Drivers)</td>\n<td>在一个系统中安装多个相同设备，只需要一份驱动程序的支持</td>\n<td>struct device_driver</td>\n<td>/sys/bus/pci/drivers/*/</td>\n</tr>\n<tr>\n<td>总线类型(Bus Types)</td>\n<td>在整个总线级别对此总线上连接的所有设备进行管理</td>\n<td>struct bus_type</td>\n<td>/sys/bus/*/</td>\n</tr>\n<tr>\n<td>设备类别(Device Classes)</td>\n<td>这是按照功能进行分类组织的设备层次树</td>\n<td>struct class</td>\n<td>/sys/class/*/</td>\n</tr>\n</tbody>\n</table>\n<p>其中的 sysfs 中的目录主要有<br>├── block      //系统中的块设备目录<br>├── bus        //系统中的总线目录<br>├── class      //按照设备功能分类的设备模型<br>├── dev        //系统中的发现的设备<br>├── devices    //系统中所有设备的分层次表达<br>├── firmware   //系统加载固件机制接口<br>├── fs         //系统中的文件系统<br>├── kernel     //内核可调整模块<br>├── module     //系统中所有的模块信息<br>└── power      //系统的电源选项</p>\n<h3 id=\"1-1-kobject-结构体\"><a href=\"#1-1-kobject-结构体\" class=\"headerlink\" title=\"1.1 kobject 结构体\"></a>1.1 kobject 结构体</h3><p>sysfs 文件系统树形结构的每一个目录都与一个 <code>kobject</code> 对象相对应，其中包含了该目录的组织结构和名字等信息。它的功能是：提供引用计数、维持父子和平级目录结构。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> kobject &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>              *name;       <span class=\"comment\">//kobject的名称</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> list_head        entry;       <span class=\"comment\">//连接下一个 kobject 结构</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kobject          *parent;     <span class=\"comment\">//指向父级 kobject</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kset             *kset;       <span class=\"comment\">//指向 kset 集合</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kobj_type        *ktype;      <span class=\"comment\">//指向 kobject 的类型描述符</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> sysfs_dirent     *sd;         <span class=\"comment\">//对应 sysfs 的文件目录</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> kref             kref;        <span class=\"comment\">//kobject 的引用计数</span></div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_initialized:<span class=\"number\">1</span>;    <span class=\"comment\">//是否初始化</span></div><div class=\"line\">\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_in_sysfs:<span class=\"number\">1</span>;       <span class=\"comment\">//是否加入sysfs</span></div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_add_uevent_sent:<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> state_remove_uevent_sent:<span class=\"number\">1</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><code>device</code>, <code>device_driver</code> 等各对象都是以 <code>kobject</code> 基础功能之上实现的。相应的 kobject 操作方法有：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kobject_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj, <span class=\"keyword\">struct</span> kobj_type *ktype)</span></span>;  <span class=\"comment\">//初始化</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">kobject_init_internal</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobj_type *ktype)</span></span>; <span class=\"comment\">//初始化内部成员</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> kobject *<span class=\"title\">kobject_get</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj)</span></span>;  <span class=\"comment\">//引用计数增加</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kobject_put</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject*kobj)</span></span>; <span class=\"comment\">//引用计数减少</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kobject_set_name</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *fmt, ...)</span></span>; <span class=\"comment\">//设置名字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kobject_rename</span><span class=\"params\">(<span class=\"keyword\">struct</span> kobject *kobj, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *new_name)</span></span>; <span class=\"comment\">//修改名字</span></div></pre></td></tr></table></figure></p>\n<p>其中的 <code>kobj_type</code> 是 kobject 的属性结构体，里面包含了 kobject 的属性（attribute）和属性操作方法（sysfs_ops）。相应的操作函数是：</p>\n<h3 id=\"1-2-kset-结构体\"><a href=\"#1-2-kset-结构体\" class=\"headerlink\" title=\"1.2 kset 结构体\"></a>1.2 kset 结构体</h3><p>它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 kboject 实现，因而它同时也是一个 kobject (面向对象 OOP 概念中的继承关系) ，具有 kobject 的全部功能；<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> kset &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> list_head <span class=\"built_in\">list</span>;</div><div class=\"line\">        <span class=\"keyword\">spinlock_t</span> list_lock;</div><div class=\"line\">        <span class=\"keyword\">struct</span> kobject kobj;</div><div class=\"line\">        <span class=\"keyword\">struct</span> kset_uevent_ops *uevent_ops;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在 /sys 根目录之下的都是 kset，它们组织了 /sys 的顶层目录视图；在部分 kset 下有二级或更深层次的 kset；<br>每个 kset 目录下再包含着一个或多个 kobject，这表示一个集合所包含的 kobject 结构体；<br>在 kobject 下有属性(attrs)文件和属性组(attr_group)，属性组就是组织属性的一个目录，它们一起向用户层提供了表示和操作这个 kobject 的属性特征的接口；<br>在 kobject 下还有一些符号链接文件，指向其它的 kobject，这些符号链接文件用于组织上面所说的 device, driver, bus_type, class, module 之间的关系；<br>不同类型如设备类型的、设备驱动类型的 kobject 都有不同的属性，不同驱动程序支持的 sysfs 接口也有不同的属性文件；而相同类型的设备上有很多相同的属性文件。</p>\n<h2 id=\"二、设备驱动模型的三大组件\"><a href=\"#二、设备驱动模型的三大组件\" class=\"headerlink\" title=\"二、设备驱动模型的三大组件\"></a>二、设备驱动模型的三大组件</h2><p>设备驱动模型有三个重要的组件：总线、设备、驱动。它们三者是紧密联系的。总线将设备和驱动绑定，在系统每注册一个设备的时候，都会寻找相应的驱动，相反的，当系统每注册一个驱动的时候都会寻找与之匹配的设备。</p>\n<h3 id=\"2-1-总线\"><a href=\"#2-1-总线\" class=\"headerlink\" title=\"2.1 总线\"></a>2.1 总线</h3><p>总线的定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> bus_type &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">/* 总线类型名 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> bus_attribute *bus_attrs; <span class=\"comment\">/* 总线的属性 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> device_attribute *dev_attrs; <span class=\"comment\">/* 设备属性,为每个加入总线的设备建立属性链表 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> driver_attribute *drv_attrs; <span class=\"comment\">/* 驱动属性,为每个加入总线的驱动建立属性链表 */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> device_driver *drv); <span class=\"comment\">/* 驱动与设备匹配函数 */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*hotplug)(<span class=\"keyword\">struct</span> sevice *device, <span class=\"keyword\">char</span> **envp, <span class=\"keyword\">int</span> num_envp, </div><div class=\"line\">                   <span class=\"keyword\">char</span>*buffer, <span class=\"keyword\">int</span> buffer_size)<span class=\"comment\">/*热插拔函数*/</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*uevent)(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> kobj_uevent_env *env);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*probe)(<span class=\"keyword\">struct</span> device *dev); <span class=\"comment\">/* */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*remove)(<span class=\"keyword\">struct</span> device *dev); <span class=\"comment\">/* 设备移除调用操作 */</span></div><div class=\"line\">    <span class=\"keyword\">void</span> (*shutdown)(<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*suspend)(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">pm_message_t</span> state);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*resume)(<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> dev_pm_ops *pm;</div><div class=\"line\">    <span class=\"keyword\">struct</span> subsys_private *p; <span class=\"comment\">/* 一个很重要的域，包含了device链表和drivers链表 */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>总线中间最重要的是两个方法：<code>match</code> 一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次，若指定的驱动程序能够处理指定的设备，则返回非零值。必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序。<code>hotplug</code>在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）。</p>\n<h3 id=\"2-2-设备\"><a href=\"#2-2-设备\" class=\"headerlink\" title=\"2.2 设备\"></a>2.2 设备</h3><p>设备在内核的定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> device &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> device *parent; <span class=\"comment\">/* 父设备，总线设备指定为NULL */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> kobject kobj;</div><div class=\"line\">    <span class=\"keyword\">char</span> bus_id[BUS_ID_SIZE];</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init_name; <span class=\"comment\">/* 初始默认的设备名,但@device_add调用之后又重新设为NULL */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> device_type *type;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mutex mutex; <span class=\"comment\">/* mutex to synchronize calls to its driver */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> bus_type *bus; <span class=\"comment\">/* type of bus device is on */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> device_driver *driver; <span class=\"comment\">/* which driver has allocated this device */</span></div><div class=\"line\">    <span class=\"keyword\">void</span> *platform_data; <span class=\"comment\">/* Platform specific data, device core doesn't touch it */</span></div><div class=\"line\">    <span class=\"keyword\">void</span> (*release)(<span class=\"keyword\">struct</span> device *dev); </div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-设备驱动\"><a href=\"#2-3-设备驱动\" class=\"headerlink\" title=\"2.3 设备驱动\"></a>2.3 设备驱动</h3><p>设备驱动在内核中的表示如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> device_driver &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; <span class=\"comment\">/* 驱动名称,在sysfs中以文件夹名出现 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> bus_type *bus; <span class=\"comment\">/* 驱动关联的总线类型 */</span></div><div class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"keyword\">module</span> *owner;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mod_name; <span class=\"comment\">/* used for built-in modules */</span></div><div class=\"line\">    <span class=\"keyword\">bool</span> suppress_bind_attrs; <span class=\"comment\">/* disables bind/unbind via sysfs */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> (*probe) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*remove) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">void</span> (*shutdown) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*suspend) (<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">pm_message_t</span> state);</div><div class=\"line\">    <span class=\"keyword\">int</span> (*resume) (<span class=\"keyword\">struct</span> device *dev);</div><div class=\"line\">    <span class=\"keyword\">struct</span> driver_private *p;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">struct</span> driver_private &#123; <span class=\"comment\">/* 定义device_driver中的私有数据类型 */</span></div><div class=\"line\">   <span class=\"keyword\">struct</span> kobject kobj; <span class=\"comment\">/* 内建kobject */</span></div><div class=\"line\">   <span class=\"keyword\">struct</span> klist klist_devices; <span class=\"comment\">/* 驱动关联的设备链表，一个驱动可以关联多个设备 */</span></div><div class=\"line\">   <span class=\"keyword\">struct</span> klist_node knode_bus;</div><div class=\"line\">   <span class=\"keyword\">struct</span> module_kobject *mkobj;</div><div class=\"line\">   <span class=\"keyword\">struct</span> device_driver *driver; <span class=\"comment\">/* 连接到的驱动链表 */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>"},{"title":"VS Code 快捷键总结","date":"2017-12-10T08:42:10.000Z","_content":"本文只是简单对 VS Code 的快捷键进行总结。\n<!-- more -->\n# 命令行使用\nCtrl+Shift+P, F1  打开命令面板\nCtrl+P 打开最近打开文件列表\nCtrl+T  显示符号\nCtrl+G  转到行\nCtrl+P  转到文件\nCtrl+Shift+O  转到符号\n\n# 文件相关\nCtrl+Shift+N 打开新的编辑器窗口\nCtrl+Shift+W 关闭编辑器窗口\nCtrl+, 打开用户配置文件\nCtrl+K Ctrl+S  打开键盘快捷键\nCtrl+K F  关闭文件夹\nCtrl+\\  分栏\nCtrl+ 1 / 2 / 3 跳转分栏\n\n# 编辑使用\nAlt+ ↑ / ↓  当前行上移下移\nShift+Alt + ↓ / ↑ 向上向下复制当前行\nCtrl+Shift+K 删除当前行\nCtrl+Enter 下方插入行\nCtrl+Shift+Enter 上方插入行\nCtrl+Shift+\\ 跳到匹配的括号\nCtrl+] / [  缩进\nCtrl+Shift+[/]  打开关闭代码块\nCtrl+K Ctrl+C  添加行注释\nCtrl+K Ctrl+U  去除行注释\nCtrl+/  行注释\nShift+Alt+A 快注释\nAlt+Z  行缩进\n\n# 面板\nCtrl+Shift+M  打开问题面板\nAlt+ ← / →   返回/前进\nCtrl+M  面板移动\n\n# 字符查找\nCtrl+F  寻找\nCtrl+H  替换\nF3 / Shift+F3  前一个后一个\nAlt+Enter  选中所有匹配\nCtrl+D  搜索当前选中\nAlt+Click  添加鼠标\nCtrl+Alt+ ↑ / ↓  向上向下添加鼠标\nCtrl+U  返回上个光标操作\nShift+Alt+I  在选中的行尾添加光标\nCtrl+I  选中当前行\nCtrl+Shift+L  选中所有当前选中的\nCtrl+F2  同上\nShift+Alt+→  扩展选取\nShift+Alt+←  缩减选取\n\n# 语义跳转\nCtrl+K Ctrl+F  格式化\nF12  转到定义\nAlt+F12  展开定义\nCtrl+K F12  在侧边打开定义\nCtrl+.  Quick Fix\nShift+F12  展开引用\nCtrl+K M  更改语言模式\n","source":"_posts/VS-Code-快捷键总结.md","raw":"\n---\ntitle: VS Code 快捷键总结\ndate: 2017-12-10 16:42:10\ncategories: 工具使用\ntags: [VS Code,IDE]\n---\n本文只是简单对 VS Code 的快捷键进行总结。\n<!-- more -->\n# 命令行使用\nCtrl+Shift+P, F1  打开命令面板\nCtrl+P 打开最近打开文件列表\nCtrl+T  显示符号\nCtrl+G  转到行\nCtrl+P  转到文件\nCtrl+Shift+O  转到符号\n\n# 文件相关\nCtrl+Shift+N 打开新的编辑器窗口\nCtrl+Shift+W 关闭编辑器窗口\nCtrl+, 打开用户配置文件\nCtrl+K Ctrl+S  打开键盘快捷键\nCtrl+K F  关闭文件夹\nCtrl+\\  分栏\nCtrl+ 1 / 2 / 3 跳转分栏\n\n# 编辑使用\nAlt+ ↑ / ↓  当前行上移下移\nShift+Alt + ↓ / ↑ 向上向下复制当前行\nCtrl+Shift+K 删除当前行\nCtrl+Enter 下方插入行\nCtrl+Shift+Enter 上方插入行\nCtrl+Shift+\\ 跳到匹配的括号\nCtrl+] / [  缩进\nCtrl+Shift+[/]  打开关闭代码块\nCtrl+K Ctrl+C  添加行注释\nCtrl+K Ctrl+U  去除行注释\nCtrl+/  行注释\nShift+Alt+A 快注释\nAlt+Z  行缩进\n\n# 面板\nCtrl+Shift+M  打开问题面板\nAlt+ ← / →   返回/前进\nCtrl+M  面板移动\n\n# 字符查找\nCtrl+F  寻找\nCtrl+H  替换\nF3 / Shift+F3  前一个后一个\nAlt+Enter  选中所有匹配\nCtrl+D  搜索当前选中\nAlt+Click  添加鼠标\nCtrl+Alt+ ↑ / ↓  向上向下添加鼠标\nCtrl+U  返回上个光标操作\nShift+Alt+I  在选中的行尾添加光标\nCtrl+I  选中当前行\nCtrl+Shift+L  选中所有当前选中的\nCtrl+F2  同上\nShift+Alt+→  扩展选取\nShift+Alt+←  缩减选取\n\n# 语义跳转\nCtrl+K Ctrl+F  格式化\nF12  转到定义\nAlt+F12  展开定义\nCtrl+K F12  在侧边打开定义\nCtrl+.  Quick Fix\nShift+F12  展开引用\nCtrl+K M  更改语言模式\n","slug":"VS-Code-快捷键总结","published":1,"updated":"2017-12-10T10:12:14.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n0022bkw1xhy93moz","content":"<p>本文只是简单对 VS Code 的快捷键进行总结。<br><a id=\"more\"></a></p>\n<h1 id=\"命令行使用\"><a href=\"#命令行使用\" class=\"headerlink\" title=\"命令行使用\"></a>命令行使用</h1><p>Ctrl+Shift+P, F1  打开命令面板<br>Ctrl+P 打开最近打开文件列表<br>Ctrl+T  显示符号<br>Ctrl+G  转到行<br>Ctrl+P  转到文件<br>Ctrl+Shift+O  转到符号</p>\n<h1 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h1><p>Ctrl+Shift+N 打开新的编辑器窗口<br>Ctrl+Shift+W 关闭编辑器窗口<br>Ctrl+, 打开用户配置文件<br>Ctrl+K Ctrl+S  打开键盘快捷键<br>Ctrl+K F  关闭文件夹<br>Ctrl+\\  分栏<br>Ctrl+ 1 / 2 / 3 跳转分栏</p>\n<h1 id=\"编辑使用\"><a href=\"#编辑使用\" class=\"headerlink\" title=\"编辑使用\"></a>编辑使用</h1><p>Alt+ ↑ / ↓  当前行上移下移<br>Shift+Alt + ↓ / ↑ 向上向下复制当前行<br>Ctrl+Shift+K 删除当前行<br>Ctrl+Enter 下方插入行<br>Ctrl+Shift+Enter 上方插入行<br>Ctrl+Shift+\\ 跳到匹配的括号<br>Ctrl+] / [  缩进<br>Ctrl+Shift+[/]  打开关闭代码块<br>Ctrl+K Ctrl+C  添加行注释<br>Ctrl+K Ctrl+U  去除行注释<br>Ctrl+/  行注释<br>Shift+Alt+A 快注释<br>Alt+Z  行缩进</p>\n<h1 id=\"面板\"><a href=\"#面板\" class=\"headerlink\" title=\"面板\"></a>面板</h1><p>Ctrl+Shift+M  打开问题面板<br>Alt+ ← / →   返回/前进<br>Ctrl+M  面板移动</p>\n<h1 id=\"字符查找\"><a href=\"#字符查找\" class=\"headerlink\" title=\"字符查找\"></a>字符查找</h1><p>Ctrl+F  寻找<br>Ctrl+H  替换<br>F3 / Shift+F3  前一个后一个<br>Alt+Enter  选中所有匹配<br>Ctrl+D  搜索当前选中<br>Alt+Click  添加鼠标<br>Ctrl+Alt+ ↑ / ↓  向上向下添加鼠标<br>Ctrl+U  返回上个光标操作<br>Shift+Alt+I  在选中的行尾添加光标<br>Ctrl+I  选中当前行<br>Ctrl+Shift+L  选中所有当前选中的<br>Ctrl+F2  同上<br>Shift+Alt+→  扩展选取<br>Shift+Alt+←  缩减选取</p>\n<h1 id=\"语义跳转\"><a href=\"#语义跳转\" class=\"headerlink\" title=\"语义跳转\"></a>语义跳转</h1><p>Ctrl+K Ctrl+F  格式化<br>F12  转到定义<br>Alt+F12  展开定义<br>Ctrl+K F12  在侧边打开定义<br>Ctrl+.  Quick Fix<br>Shift+F12  展开引用<br>Ctrl+K M  更改语言模式</p>\n","excerpt":"<p>本文只是简单对 VS Code 的快捷键进行总结。<br>","more":"</p>\n<h1 id=\"命令行使用\"><a href=\"#命令行使用\" class=\"headerlink\" title=\"命令行使用\"></a>命令行使用</h1><p>Ctrl+Shift+P, F1  打开命令面板<br>Ctrl+P 打开最近打开文件列表<br>Ctrl+T  显示符号<br>Ctrl+G  转到行<br>Ctrl+P  转到文件<br>Ctrl+Shift+O  转到符号</p>\n<h1 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h1><p>Ctrl+Shift+N 打开新的编辑器窗口<br>Ctrl+Shift+W 关闭编辑器窗口<br>Ctrl+, 打开用户配置文件<br>Ctrl+K Ctrl+S  打开键盘快捷键<br>Ctrl+K F  关闭文件夹<br>Ctrl+\\  分栏<br>Ctrl+ 1 / 2 / 3 跳转分栏</p>\n<h1 id=\"编辑使用\"><a href=\"#编辑使用\" class=\"headerlink\" title=\"编辑使用\"></a>编辑使用</h1><p>Alt+ ↑ / ↓  当前行上移下移<br>Shift+Alt + ↓ / ↑ 向上向下复制当前行<br>Ctrl+Shift+K 删除当前行<br>Ctrl+Enter 下方插入行<br>Ctrl+Shift+Enter 上方插入行<br>Ctrl+Shift+\\ 跳到匹配的括号<br>Ctrl+] / [  缩进<br>Ctrl+Shift+[/]  打开关闭代码块<br>Ctrl+K Ctrl+C  添加行注释<br>Ctrl+K Ctrl+U  去除行注释<br>Ctrl+/  行注释<br>Shift+Alt+A 快注释<br>Alt+Z  行缩进</p>\n<h1 id=\"面板\"><a href=\"#面板\" class=\"headerlink\" title=\"面板\"></a>面板</h1><p>Ctrl+Shift+M  打开问题面板<br>Alt+ ← / →   返回/前进<br>Ctrl+M  面板移动</p>\n<h1 id=\"字符查找\"><a href=\"#字符查找\" class=\"headerlink\" title=\"字符查找\"></a>字符查找</h1><p>Ctrl+F  寻找<br>Ctrl+H  替换<br>F3 / Shift+F3  前一个后一个<br>Alt+Enter  选中所有匹配<br>Ctrl+D  搜索当前选中<br>Alt+Click  添加鼠标<br>Ctrl+Alt+ ↑ / ↓  向上向下添加鼠标<br>Ctrl+U  返回上个光标操作<br>Shift+Alt+I  在选中的行尾添加光标<br>Ctrl+I  选中当前行<br>Ctrl+Shift+L  选中所有当前选中的<br>Ctrl+F2  同上<br>Shift+Alt+→  扩展选取<br>Shift+Alt+←  缩减选取</p>\n<h1 id=\"语义跳转\"><a href=\"#语义跳转\" class=\"headerlink\" title=\"语义跳转\"></a>语义跳转</h1><p>Ctrl+K Ctrl+F  格式化<br>F12  转到定义<br>Alt+F12  展开定义<br>Ctrl+K F12  在侧边打开定义<br>Ctrl+.  Quick Fix<br>Shift+F12  展开引用<br>Ctrl+K M  更改语言模式</p>"},{"title":"使用Hexo配置Github建立个人站点方法备忘","date":"2017-12-25T08:21:25.000Z","_content":"使用 Hexo 来建立自己的个人博客已经一年多了，虽说没有什么人来看，但是作为自己的一个知识整理库。还是有一定的效果的，但是当有时候更换电脑重装环境后，总是需要重新去查看如何安装 Hexo 本地环境。因此，还是在这里自己记录一下。\n<!-- more -->\n\n## 一、安装\n安装 Hexo 之前，必须先安装 Node 环境。同时，因为我们的博客是托管在 Github 上的，需要安装 Git 工具，申请 Github 账号，并建立对应的 Rep。\n### 1、安装 Node\n首先，点击进入 [`node.js`](https://nodejs.org/en/)官网。\n\n选择想要的版本，下载。\n\n随后一路按照正常的安装方法安装即可。\n\n### 2、安装 Git\n同样，点击进入 [`Git`](https://git-scm.com/downloads)官网。\n\n选择想要的版本，下载。\n\n随后一路按照正常的安装方法安装即可。\n\n### 3、GitHub 注册和建立 Rep \n注册这一点就不再详细描述，进入 [`GitHub`](https://github.com) 官网注册即可。\n\n注册完成后，建立与用户名对应的仓库，譬如我的即为 `myintelex.github.io`\n\n### 4、安装 Hexo\n进入主角环节，创建书写 Blog 的文件夹，进入文件夹后，执行以下命令：\n````\nnpm install -g hexo\n````\n即可安装 Hexo。\n\n随后执行命令进行初始化：\n````\nhexo init\n````\n这时候 Hexo 就已经安装好了。\n\n### 5、配置测试\n首先，需要与远程仓库绑定，打开博客目录下的 `_config.yml` 文件，将下列内容\n````\ndeploy:\n\n     type: git\n\n     repo: https://github.com/myintelex/myintelex.github.io.git\n\n     branch: master\n````\n中的 `repo` 更改为自己的 repo 地址。\n\n这时候可以执行`hexo g`命令，生成静态页面。\n\n完成后，执行 `hexo server` 启动本地服务。\n\n浏览器打开 [http://localhost:4000](http://localhost:4000)，即可测试本地效果。\n\n\n## 二、Hexo 常用命令：\n|命令|含义|\n|--|--|\n|hexo new\"postName\" |#新建文章\n|hexo new page\"pageName\" |#新建页面\n|hexo generate |#生成静态页面至 public 目录\n|hexo server |#开启预览访问端口（默认端口 4000，'ctrl + c'关闭 server）\n|hexo deploy |#将. deploy 目录部署到 GitHub\n|hexo help |# 查看帮助\n|hexo version |#查看 Hexo 的版本\n\n## 三、报错总结（此项持续更新）\n\n* `ERROR Deployer not found: git 或者 ERROR Deployer not found: github`\n\n  解决方法： `npm install hexo-deployer-git --save`     \n  如发生报错： `ERROR Process failed: layout/.DS_Store `, 那么进入主题里面 `layout` 和 `_partial` 目录下，删除 `.DS_Store` \n\n* `ERROR Plugin load failed: hexo-server`\n\n  解决方法，执行命令：`sudo npm install hexo-server`\n","source":"_posts/使用Hexo配置Github建立个人站点方法备忘.md","raw":"---\ntitle: 使用Hexo配置Github建立个人站点方法备忘\ndate: 2017-12-25 16:21:25\ncategories: 开发经验\ntags: [Hexo, Blog, Github]\n---\n使用 Hexo 来建立自己的个人博客已经一年多了，虽说没有什么人来看，但是作为自己的一个知识整理库。还是有一定的效果的，但是当有时候更换电脑重装环境后，总是需要重新去查看如何安装 Hexo 本地环境。因此，还是在这里自己记录一下。\n<!-- more -->\n\n## 一、安装\n安装 Hexo 之前，必须先安装 Node 环境。同时，因为我们的博客是托管在 Github 上的，需要安装 Git 工具，申请 Github 账号，并建立对应的 Rep。\n### 1、安装 Node\n首先，点击进入 [`node.js`](https://nodejs.org/en/)官网。\n\n选择想要的版本，下载。\n\n随后一路按照正常的安装方法安装即可。\n\n### 2、安装 Git\n同样，点击进入 [`Git`](https://git-scm.com/downloads)官网。\n\n选择想要的版本，下载。\n\n随后一路按照正常的安装方法安装即可。\n\n### 3、GitHub 注册和建立 Rep \n注册这一点就不再详细描述，进入 [`GitHub`](https://github.com) 官网注册即可。\n\n注册完成后，建立与用户名对应的仓库，譬如我的即为 `myintelex.github.io`\n\n### 4、安装 Hexo\n进入主角环节，创建书写 Blog 的文件夹，进入文件夹后，执行以下命令：\n````\nnpm install -g hexo\n````\n即可安装 Hexo。\n\n随后执行命令进行初始化：\n````\nhexo init\n````\n这时候 Hexo 就已经安装好了。\n\n### 5、配置测试\n首先，需要与远程仓库绑定，打开博客目录下的 `_config.yml` 文件，将下列内容\n````\ndeploy:\n\n     type: git\n\n     repo: https://github.com/myintelex/myintelex.github.io.git\n\n     branch: master\n````\n中的 `repo` 更改为自己的 repo 地址。\n\n这时候可以执行`hexo g`命令，生成静态页面。\n\n完成后，执行 `hexo server` 启动本地服务。\n\n浏览器打开 [http://localhost:4000](http://localhost:4000)，即可测试本地效果。\n\n\n## 二、Hexo 常用命令：\n|命令|含义|\n|--|--|\n|hexo new\"postName\" |#新建文章\n|hexo new page\"pageName\" |#新建页面\n|hexo generate |#生成静态页面至 public 目录\n|hexo server |#开启预览访问端口（默认端口 4000，'ctrl + c'关闭 server）\n|hexo deploy |#将. deploy 目录部署到 GitHub\n|hexo help |# 查看帮助\n|hexo version |#查看 Hexo 的版本\n\n## 三、报错总结（此项持续更新）\n\n* `ERROR Deployer not found: git 或者 ERROR Deployer not found: github`\n\n  解决方法： `npm install hexo-deployer-git --save`     \n  如发生报错： `ERROR Process failed: layout/.DS_Store `, 那么进入主题里面 `layout` 和 `_partial` 目录下，删除 `.DS_Store` \n\n* `ERROR Plugin load failed: hexo-server`\n\n  解决方法，执行命令：`sudo npm install hexo-server`\n","slug":"使用Hexo配置Github建立个人站点方法备忘","published":1,"updated":"2018-01-01T06:13:24.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n0024bkw1winkypet","content":"<p>使用 Hexo 来建立自己的个人博客已经一年多了，虽说没有什么人来看，但是作为自己的一个知识整理库。还是有一定的效果的，但是当有时候更换电脑重装环境后，总是需要重新去查看如何安装 Hexo 本地环境。因此，还是在这里自己记录一下。<br><a id=\"more\"></a></p>\n<h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><p>安装 Hexo 之前，必须先安装 Node 环境。同时，因为我们的博客是托管在 Github 上的，需要安装 Git 工具，申请 Github 账号，并建立对应的 Rep。</p>\n<h3 id=\"1、安装-Node\"><a href=\"#1、安装-Node\" class=\"headerlink\" title=\"1、安装 Node\"></a>1、安装 Node</h3><p>首先，点击进入 <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\"><code>node.js</code></a>官网。</p>\n<p>选择想要的版本，下载。</p>\n<p>随后一路按照正常的安装方法安装即可。</p>\n<h3 id=\"2、安装-Git\"><a href=\"#2、安装-Git\" class=\"headerlink\" title=\"2、安装 Git\"></a>2、安装 Git</h3><p>同样，点击进入 <a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\"><code>Git</code></a>官网。</p>\n<p>选择想要的版本，下载。</p>\n<p>随后一路按照正常的安装方法安装即可。</p>\n<h3 id=\"3、GitHub-注册和建立-Rep\"><a href=\"#3、GitHub-注册和建立-Rep\" class=\"headerlink\" title=\"3、GitHub 注册和建立 Rep\"></a>3、GitHub 注册和建立 Rep</h3><p>注册这一点就不再详细描述，进入 <a href=\"https://github.com\" target=\"_blank\" rel=\"external\"><code>GitHub</code></a> 官网注册即可。</p>\n<p>注册完成后，建立与用户名对应的仓库，譬如我的即为 <code>myintelex.github.io</code></p>\n<h3 id=\"4、安装-Hexo\"><a href=\"#4、安装-Hexo\" class=\"headerlink\" title=\"4、安装 Hexo\"></a>4、安装 Hexo</h3><p>进入主角环节，创建书写 Blog 的文件夹，进入文件夹后，执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo</div></pre></td></tr></table></figure></p>\n<p>即可安装 Hexo。</p>\n<p>随后执行命令进行初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure></p>\n<p>这时候 Hexo 就已经安装好了。</p>\n<h3 id=\"5、配置测试\"><a href=\"#5、配置测试\" class=\"headerlink\" title=\"5、配置测试\"></a>5、配置测试</h3><p>首先，需要与远程仓库绑定，打开博客目录下的 <code>_config.yml</code> 文件，将下列内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\"></div><div class=\"line\">     type: git</div><div class=\"line\"></div><div class=\"line\">     repo: https://github.com/myintelex/myintelex.github.io.git</div><div class=\"line\"></div><div class=\"line\">     branch: master</div></pre></td></tr></table></figure></p>\n<p>中的 <code>repo</code> 更改为自己的 repo 地址。</p>\n<p>这时候可以执行<code>hexo g</code>命令，生成静态页面。</p>\n<p>完成后，执行 <code>hexo server</code> 启动本地服务。</p>\n<p>浏览器打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a>，即可测试本地效果。</p>\n<h2 id=\"二、Hexo-常用命令：\"><a href=\"#二、Hexo-常用命令：\" class=\"headerlink\" title=\"二、Hexo 常用命令：\"></a>二、Hexo 常用命令：</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hexo new”postName”</td>\n<td>#新建文章</td>\n</tr>\n<tr>\n<td>hexo new page”pageName”</td>\n<td>#新建页面</td>\n</tr>\n<tr>\n<td>hexo generate</td>\n<td>#生成静态页面至 public 目录</td>\n</tr>\n<tr>\n<td>hexo server</td>\n<td>#开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）</td>\n</tr>\n<tr>\n<td>hexo deploy</td>\n<td>#将. deploy 目录部署到 GitHub</td>\n</tr>\n<tr>\n<td>hexo help</td>\n<td># 查看帮助</td>\n</tr>\n<tr>\n<td>hexo version</td>\n<td>#查看 Hexo 的版本</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、报错总结（此项持续更新）\"><a href=\"#三、报错总结（此项持续更新）\" class=\"headerlink\" title=\"三、报错总结（此项持续更新）\"></a>三、报错总结（此项持续更新）</h2><ul>\n<li><p><code>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</code></p>\n<p>解决方法： <code>npm install hexo-deployer-git --save</code><br>如发生报错： <code>ERROR Process failed: layout/.DS_Store</code>, 那么进入主题里面 <code>layout</code> 和 <code>_partial</code> 目录下，删除 <code>.DS_Store</code> </p>\n</li>\n<li><p><code>ERROR Plugin load failed: hexo-server</code></p>\n<p>解决方法，执行命令：<code>sudo npm install hexo-server</code></p>\n</li>\n</ul>\n","excerpt":"<p>使用 Hexo 来建立自己的个人博客已经一年多了，虽说没有什么人来看，但是作为自己的一个知识整理库。还是有一定的效果的，但是当有时候更换电脑重装环境后，总是需要重新去查看如何安装 Hexo 本地环境。因此，还是在这里自己记录一下。<br>","more":"</p>\n<h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><p>安装 Hexo 之前，必须先安装 Node 环境。同时，因为我们的博客是托管在 Github 上的，需要安装 Git 工具，申请 Github 账号，并建立对应的 Rep。</p>\n<h3 id=\"1、安装-Node\"><a href=\"#1、安装-Node\" class=\"headerlink\" title=\"1、安装 Node\"></a>1、安装 Node</h3><p>首先，点击进入 <a href=\"https://nodejs.org/en/\"><code>node.js</code></a>官网。</p>\n<p>选择想要的版本，下载。</p>\n<p>随后一路按照正常的安装方法安装即可。</p>\n<h3 id=\"2、安装-Git\"><a href=\"#2、安装-Git\" class=\"headerlink\" title=\"2、安装 Git\"></a>2、安装 Git</h3><p>同样，点击进入 <a href=\"https://git-scm.com/downloads\"><code>Git</code></a>官网。</p>\n<p>选择想要的版本，下载。</p>\n<p>随后一路按照正常的安装方法安装即可。</p>\n<h3 id=\"3、GitHub-注册和建立-Rep\"><a href=\"#3、GitHub-注册和建立-Rep\" class=\"headerlink\" title=\"3、GitHub 注册和建立 Rep\"></a>3、GitHub 注册和建立 Rep</h3><p>注册这一点就不再详细描述，进入 <a href=\"https://github.com\"><code>GitHub</code></a> 官网注册即可。</p>\n<p>注册完成后，建立与用户名对应的仓库，譬如我的即为 <code>myintelex.github.io</code></p>\n<h3 id=\"4、安装-Hexo\"><a href=\"#4、安装-Hexo\" class=\"headerlink\" title=\"4、安装 Hexo\"></a>4、安装 Hexo</h3><p>进入主角环节，创建书写 Blog 的文件夹，进入文件夹后，执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo</div></pre></td></tr></table></figure></p>\n<p>即可安装 Hexo。</p>\n<p>随后执行命令进行初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure></p>\n<p>这时候 Hexo 就已经安装好了。</p>\n<h3 id=\"5、配置测试\"><a href=\"#5、配置测试\" class=\"headerlink\" title=\"5、配置测试\"></a>5、配置测试</h3><p>首先，需要与远程仓库绑定，打开博客目录下的 <code>_config.yml</code> 文件，将下列内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\"></div><div class=\"line\">     type: git</div><div class=\"line\"></div><div class=\"line\">     repo: https://github.com/myintelex/myintelex.github.io.git</div><div class=\"line\"></div><div class=\"line\">     branch: master</div></pre></td></tr></table></figure></p>\n<p>中的 <code>repo</code> 更改为自己的 repo 地址。</p>\n<p>这时候可以执行<code>hexo g</code>命令，生成静态页面。</p>\n<p>完成后，执行 <code>hexo server</code> 启动本地服务。</p>\n<p>浏览器打开 <a href=\"http://localhost:4000\">http://localhost:4000</a>，即可测试本地效果。</p>\n<h2 id=\"二、Hexo-常用命令：\"><a href=\"#二、Hexo-常用命令：\" class=\"headerlink\" title=\"二、Hexo 常用命令：\"></a>二、Hexo 常用命令：</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hexo new”postName”</td>\n<td>#新建文章</td>\n</tr>\n<tr>\n<td>hexo new page”pageName”</td>\n<td>#新建页面</td>\n</tr>\n<tr>\n<td>hexo generate</td>\n<td>#生成静态页面至 public 目录</td>\n</tr>\n<tr>\n<td>hexo server</td>\n<td>#开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）</td>\n</tr>\n<tr>\n<td>hexo deploy</td>\n<td>#将. deploy 目录部署到 GitHub</td>\n</tr>\n<tr>\n<td>hexo help</td>\n<td># 查看帮助</td>\n</tr>\n<tr>\n<td>hexo version</td>\n<td>#查看 Hexo 的版本</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、报错总结（此项持续更新）\"><a href=\"#三、报错总结（此项持续更新）\" class=\"headerlink\" title=\"三、报错总结（此项持续更新）\"></a>三、报错总结（此项持续更新）</h2><ul>\n<li><p><code>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</code></p>\n<p>解决方法： <code>npm install hexo-deployer-git --save</code><br>如发生报错： <code>ERROR Process failed: layout/.DS_Store</code>, 那么进入主题里面 <code>layout</code> 和 <code>_partial</code> 目录下，删除 <code>.DS_Store</code> </p>\n</li>\n<li><p><code>ERROR Plugin load failed: hexo-server</code></p>\n<p>解决方法，执行命令：<code>sudo npm install hexo-server</code></p>\n</li>\n</ul>"},{"title":"Visual Studio Code 自动补全插件设置\n\n","date":"2017-12-06T03:24:11.000Z","_content":"本篇是 VS Code 使用的第一篇，简单介绍下自己对于IDE和编辑器的选择，并说明 VS Code 自动补全插件的使用。\n<!--more-->\n\n从开始接触编程到现在，不管是编辑器还是IDE都接触过很多，从一开始的 NotePad 到后来 VIM、Qt Creator，每种工具都有自己的特点，但是使用上总有不顺手的地方。当然IDE和编辑器还是两种不同的东西，但是考虑到毕竟IDE使用的过程中，最多的时候还是在和代码打交道，所以，自己还是希望能够有一个统一的编码平台的。\n\n经过一番比较，最后自己还是选定了 VS Code 作为这个代码编辑工具。本系列就是折腾 VS Code 过程中的一些记录。介绍如何能够使 VS Code 更好的进行 C/C++ 的自动补全。\n\nVS Code 的自动补全现在其实也是有很多版本不同的方案的，目前主流的是以下三个插件：\n* 微软爸爸自己的 C/C++ 插件\n* C++ Intellisense\n* C/C++ Clang Command Adapter\n\n但是综合使用之后，还是使用最方便的微软自己的插件来的方便，不管是 C++ Intellisense 还是 C/C++ Clang Command Adapter 都需要下载额外的环境进行配置。C/C++ 这个插件是微软官方提供的，为 VS Code 提供了 C/C++ 语言的支持。\n\n当下载了这个插件之后，VS Code 会在 C/C++ 项目下的 `.vscode` 文件夹下建立一系列的设置文件。\n\n## 智能补全\n为了实现智能补全的功能，需要编辑 `c_cpp_properties.json` 这个文件。将你需要添加的 include 文件夹添加在配置项中。\n\n按照以下步骤操作：\n* 找到代码中的一个提示\n* 点击小黄灯图标\n* 点击 **Edit \"includePath\" setting**\n* 找到你所使用的平台，将头文件路径包含在 **browse** 中的 **path** 中\n\n同样，可以使用 `Ctrl+Shift+P` 键快捷唤出控制台，并输入 `C/Cpp:Edit Configurations` 命令来打开 `c_cpp_properties.json`。\n\n## 代码格式化\n可以使用 `Ctrl+Shift+F` 键来格式化全文，或使用 `Ctrl+K Ctrl+F` 键来格式化当前选中内容。\n\n可以在工作区创建 `.clang-format` 文件来定义代码格式，如果没有这个文件，格式化样式通过 `C_Cpp.clang_format_fallbackStyle` 设置来指定。默认的样式为 **Visual Studio**。\n\n## 其他快捷键\n可以使用 `F12` 来快速跳转到定义位置，使用 `Alt+F12` 来查看声明。 \n\n使用 `Ctrl+P` 打开命令行，输入 `@` 列出当前文件的符号，或输入 `#` 当前项目的所有符号。 \n\n同样可以使用 `Ctrl+Shift+o` 来直接列出当前文件符号。\n\n## 使用 C/C++ Clang Command Adapter 增强代码补全\n微软的插件在自动补全的时候会提供大量的无关的符号，这时候其实C/C++ Clang Command Adapter 这个插件使用柑橘更好。\n当然，从名字可想而知，首先需要下载 [clang](http://clang.llvm.org/)。\n然后将 clang 设置在环境变量中，或通过设置 `clang.executable` 来指定 clang 的路径。\n","source":"_posts/Visual-Studio-Code-自动补全插件设置“.md","raw":"---\ntitle: |+\n  Visual Studio Code 自动补全插件设置\n\ndate: 2017-12-06 11:24:11\ncategories: 工具使用\ntags: [VS Code,IDE]\n---\n本篇是 VS Code 使用的第一篇，简单介绍下自己对于IDE和编辑器的选择，并说明 VS Code 自动补全插件的使用。\n<!--more-->\n\n从开始接触编程到现在，不管是编辑器还是IDE都接触过很多，从一开始的 NotePad 到后来 VIM、Qt Creator，每种工具都有自己的特点，但是使用上总有不顺手的地方。当然IDE和编辑器还是两种不同的东西，但是考虑到毕竟IDE使用的过程中，最多的时候还是在和代码打交道，所以，自己还是希望能够有一个统一的编码平台的。\n\n经过一番比较，最后自己还是选定了 VS Code 作为这个代码编辑工具。本系列就是折腾 VS Code 过程中的一些记录。介绍如何能够使 VS Code 更好的进行 C/C++ 的自动补全。\n\nVS Code 的自动补全现在其实也是有很多版本不同的方案的，目前主流的是以下三个插件：\n* 微软爸爸自己的 C/C++ 插件\n* C++ Intellisense\n* C/C++ Clang Command Adapter\n\n但是综合使用之后，还是使用最方便的微软自己的插件来的方便，不管是 C++ Intellisense 还是 C/C++ Clang Command Adapter 都需要下载额外的环境进行配置。C/C++ 这个插件是微软官方提供的，为 VS Code 提供了 C/C++ 语言的支持。\n\n当下载了这个插件之后，VS Code 会在 C/C++ 项目下的 `.vscode` 文件夹下建立一系列的设置文件。\n\n## 智能补全\n为了实现智能补全的功能，需要编辑 `c_cpp_properties.json` 这个文件。将你需要添加的 include 文件夹添加在配置项中。\n\n按照以下步骤操作：\n* 找到代码中的一个提示\n* 点击小黄灯图标\n* 点击 **Edit \"includePath\" setting**\n* 找到你所使用的平台，将头文件路径包含在 **browse** 中的 **path** 中\n\n同样，可以使用 `Ctrl+Shift+P` 键快捷唤出控制台，并输入 `C/Cpp:Edit Configurations` 命令来打开 `c_cpp_properties.json`。\n\n## 代码格式化\n可以使用 `Ctrl+Shift+F` 键来格式化全文，或使用 `Ctrl+K Ctrl+F` 键来格式化当前选中内容。\n\n可以在工作区创建 `.clang-format` 文件来定义代码格式，如果没有这个文件，格式化样式通过 `C_Cpp.clang_format_fallbackStyle` 设置来指定。默认的样式为 **Visual Studio**。\n\n## 其他快捷键\n可以使用 `F12` 来快速跳转到定义位置，使用 `Alt+F12` 来查看声明。 \n\n使用 `Ctrl+P` 打开命令行，输入 `@` 列出当前文件的符号，或输入 `#` 当前项目的所有符号。 \n\n同样可以使用 `Ctrl+Shift+o` 来直接列出当前文件符号。\n\n## 使用 C/C++ Clang Command Adapter 增强代码补全\n微软的插件在自动补全的时候会提供大量的无关的符号，这时候其实C/C++ Clang Command Adapter 这个插件使用柑橘更好。\n当然，从名字可想而知，首先需要下载 [clang](http://clang.llvm.org/)。\n然后将 clang 设置在环境变量中，或通过设置 `clang.executable` 来指定 clang 的路径。\n","slug":"Visual-Studio-Code-自动补全插件设置“","published":1,"updated":"2017-12-06T13:29:10.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n0028bkw1rkcqypr0","content":"<p>本篇是 VS Code 使用的第一篇，简单介绍下自己对于IDE和编辑器的选择，并说明 VS Code 自动补全插件的使用。<br><a id=\"more\"></a></p>\n<p>从开始接触编程到现在，不管是编辑器还是IDE都接触过很多，从一开始的 NotePad 到后来 VIM、Qt Creator，每种工具都有自己的特点，但是使用上总有不顺手的地方。当然IDE和编辑器还是两种不同的东西，但是考虑到毕竟IDE使用的过程中，最多的时候还是在和代码打交道，所以，自己还是希望能够有一个统一的编码平台的。</p>\n<p>经过一番比较，最后自己还是选定了 VS Code 作为这个代码编辑工具。本系列就是折腾 VS Code 过程中的一些记录。介绍如何能够使 VS Code 更好的进行 C/C++ 的自动补全。</p>\n<p>VS Code 的自动补全现在其实也是有很多版本不同的方案的，目前主流的是以下三个插件：</p>\n<ul>\n<li>微软爸爸自己的 C/C++ 插件</li>\n<li>C++ Intellisense</li>\n<li>C/C++ Clang Command Adapter</li>\n</ul>\n<p>但是综合使用之后，还是使用最方便的微软自己的插件来的方便，不管是 C++ Intellisense 还是 C/C++ Clang Command Adapter 都需要下载额外的环境进行配置。C/C++ 这个插件是微软官方提供的，为 VS Code 提供了 C/C++ 语言的支持。</p>\n<p>当下载了这个插件之后，VS Code 会在 C/C++ 项目下的 <code>.vscode</code> 文件夹下建立一系列的设置文件。</p>\n<h2 id=\"智能补全\"><a href=\"#智能补全\" class=\"headerlink\" title=\"智能补全\"></a>智能补全</h2><p>为了实现智能补全的功能，需要编辑 <code>c_cpp_properties.json</code> 这个文件。将你需要添加的 include 文件夹添加在配置项中。</p>\n<p>按照以下步骤操作：</p>\n<ul>\n<li>找到代码中的一个提示</li>\n<li>点击小黄灯图标</li>\n<li>点击 <strong>Edit “includePath” setting</strong></li>\n<li>找到你所使用的平台，将头文件路径包含在 <strong>browse</strong> 中的 <strong>path</strong> 中</li>\n</ul>\n<p>同样，可以使用 <code>Ctrl+Shift+P</code> 键快捷唤出控制台，并输入 <code>C/Cpp:Edit Configurations</code> 命令来打开 <code>c_cpp_properties.json</code>。</p>\n<h2 id=\"代码格式化\"><a href=\"#代码格式化\" class=\"headerlink\" title=\"代码格式化\"></a>代码格式化</h2><p>可以使用 <code>Ctrl+Shift+F</code> 键来格式化全文，或使用 <code>Ctrl+K Ctrl+F</code> 键来格式化当前选中内容。</p>\n<p>可以在工作区创建 <code>.clang-format</code> 文件来定义代码格式，如果没有这个文件，格式化样式通过 <code>C_Cpp.clang_format_fallbackStyle</code> 设置来指定。默认的样式为 <strong>Visual Studio</strong>。</p>\n<h2 id=\"其他快捷键\"><a href=\"#其他快捷键\" class=\"headerlink\" title=\"其他快捷键\"></a>其他快捷键</h2><p>可以使用 <code>F12</code> 来快速跳转到定义位置，使用 <code>Alt+F12</code> 来查看声明。 </p>\n<p>使用 <code>Ctrl+P</code> 打开命令行，输入 <code>@</code> 列出当前文件的符号，或输入 <code>#</code> 当前项目的所有符号。 </p>\n<p>同样可以使用 <code>Ctrl+Shift+o</code> 来直接列出当前文件符号。</p>\n<h2 id=\"使用-C-C-Clang-Command-Adapter-增强代码补全\"><a href=\"#使用-C-C-Clang-Command-Adapter-增强代码补全\" class=\"headerlink\" title=\"使用 C/C++ Clang Command Adapter 增强代码补全\"></a>使用 C/C++ Clang Command Adapter 增强代码补全</h2><p>微软的插件在自动补全的时候会提供大量的无关的符号，这时候其实C/C++ Clang Command Adapter 这个插件使用柑橘更好。<br>当然，从名字可想而知，首先需要下载 <a href=\"http://clang.llvm.org/\" target=\"_blank\" rel=\"external\">clang</a>。<br>然后将 clang 设置在环境变量中，或通过设置 <code>clang.executable</code> 来指定 clang 的路径。</p>\n","excerpt":"<p>本篇是 VS Code 使用的第一篇，简单介绍下自己对于IDE和编辑器的选择，并说明 VS Code 自动补全插件的使用。<br>","more":"</p>\n<p>从开始接触编程到现在，不管是编辑器还是IDE都接触过很多，从一开始的 NotePad 到后来 VIM、Qt Creator，每种工具都有自己的特点，但是使用上总有不顺手的地方。当然IDE和编辑器还是两种不同的东西，但是考虑到毕竟IDE使用的过程中，最多的时候还是在和代码打交道，所以，自己还是希望能够有一个统一的编码平台的。</p>\n<p>经过一番比较，最后自己还是选定了 VS Code 作为这个代码编辑工具。本系列就是折腾 VS Code 过程中的一些记录。介绍如何能够使 VS Code 更好的进行 C/C++ 的自动补全。</p>\n<p>VS Code 的自动补全现在其实也是有很多版本不同的方案的，目前主流的是以下三个插件：</p>\n<ul>\n<li>微软爸爸自己的 C/C++ 插件</li>\n<li>C++ Intellisense</li>\n<li>C/C++ Clang Command Adapter</li>\n</ul>\n<p>但是综合使用之后，还是使用最方便的微软自己的插件来的方便，不管是 C++ Intellisense 还是 C/C++ Clang Command Adapter 都需要下载额外的环境进行配置。C/C++ 这个插件是微软官方提供的，为 VS Code 提供了 C/C++ 语言的支持。</p>\n<p>当下载了这个插件之后，VS Code 会在 C/C++ 项目下的 <code>.vscode</code> 文件夹下建立一系列的设置文件。</p>\n<h2 id=\"智能补全\"><a href=\"#智能补全\" class=\"headerlink\" title=\"智能补全\"></a>智能补全</h2><p>为了实现智能补全的功能，需要编辑 <code>c_cpp_properties.json</code> 这个文件。将你需要添加的 include 文件夹添加在配置项中。</p>\n<p>按照以下步骤操作：</p>\n<ul>\n<li>找到代码中的一个提示</li>\n<li>点击小黄灯图标</li>\n<li>点击 <strong>Edit “includePath” setting</strong></li>\n<li>找到你所使用的平台，将头文件路径包含在 <strong>browse</strong> 中的 <strong>path</strong> 中</li>\n</ul>\n<p>同样，可以使用 <code>Ctrl+Shift+P</code> 键快捷唤出控制台，并输入 <code>C/Cpp:Edit Configurations</code> 命令来打开 <code>c_cpp_properties.json</code>。</p>\n<h2 id=\"代码格式化\"><a href=\"#代码格式化\" class=\"headerlink\" title=\"代码格式化\"></a>代码格式化</h2><p>可以使用 <code>Ctrl+Shift+F</code> 键来格式化全文，或使用 <code>Ctrl+K Ctrl+F</code> 键来格式化当前选中内容。</p>\n<p>可以在工作区创建 <code>.clang-format</code> 文件来定义代码格式，如果没有这个文件，格式化样式通过 <code>C_Cpp.clang_format_fallbackStyle</code> 设置来指定。默认的样式为 <strong>Visual Studio</strong>。</p>\n<h2 id=\"其他快捷键\"><a href=\"#其他快捷键\" class=\"headerlink\" title=\"其他快捷键\"></a>其他快捷键</h2><p>可以使用 <code>F12</code> 来快速跳转到定义位置，使用 <code>Alt+F12</code> 来查看声明。 </p>\n<p>使用 <code>Ctrl+P</code> 打开命令行，输入 <code>@</code> 列出当前文件的符号，或输入 <code>#</code> 当前项目的所有符号。 </p>\n<p>同样可以使用 <code>Ctrl+Shift+o</code> 来直接列出当前文件符号。</p>\n<h2 id=\"使用-C-C-Clang-Command-Adapter-增强代码补全\"><a href=\"#使用-C-C-Clang-Command-Adapter-增强代码补全\" class=\"headerlink\" title=\"使用 C/C++ Clang Command Adapter 增强代码补全\"></a>使用 C/C++ Clang Command Adapter 增强代码补全</h2><p>微软的插件在自动补全的时候会提供大量的无关的符号，这时候其实C/C++ Clang Command Adapter 这个插件使用柑橘更好。<br>当然，从名字可想而知，首先需要下载 <a href=\"http://clang.llvm.org/\">clang</a>。<br>然后将 clang 设置在环境变量中，或通过设置 <code>clang.executable</code> 来指定 clang 的路径。</p>"},{"title":"system调用Qt程序的问题","date":"2016-11-22T09:53:10.000Z","_content":"\n在公司做了一个嵌入式系统的引导程序，进程在系统开始后自启动（这里使用的是 rc.local 添加启动项的方法），随后按照相应的顺序依次启动相应的程序，之前一直没有出现什么问题，直到增加了一个启动 Qt 程序，并监控程序状态的需求后，出现了一些无法解释的问题。\n<!--more-->\n## 编写代码的过程 \n* 第一个需求：进程中调用一个 Qt 程序。\n\n这个代码很简单，为了省事，简单使用了 `system()` 函数。\n\n        system(\"QtApplication -qws\");\n\n* 第二个需求：需要获取 QtApplication 的返回值。\n\nsystem 函数的执行过程分为三个步骤：\n 1. 创建一个子进程，主要是 `fork()` 等过程。\n 2. 调用 `/bin/sh` 拉起 shell 脚本。\n 3. 执行相应的 shell 脚本，waitpid()。\n\n因此，system 的返回值(status)囊括了以上三个步骤的结果：\n 1. 如果调用子进程失败，或者 waitpid() 返回除了 `EINTR` 之外的错误，system 返回 -1；\n 2. 如果 shell 拉起失败或未正常执行结束（**只要能够调用到 `/bin/sh`，并且执行shell过程中没有被其他信号异常中断，都算正常结束**），原因值被写入到status的低8~15比特位中。<br>\n 系统提供了宏：`WIFEXITED(status)` 来判断 shell 的执行结果。如果 `WIFEXITED(status)` 为真，则说明正常结束。\n 3. 如果 shell 脚本正常执行结束，将 shell 返回值填到 status 的低8~15比特位中。<br>\n 同样系统提供了宏：`WEXITSTATUS(status)` 来获取相应脚本的执行结果。\n\n一个简单的执行代码如下, 因为程序需要执行一段时间，所以添加了一个轮询：\n````C++\nint system_call() {\n  int status = 9;\n  status = system(\"QtApplication -qws\");\n  for (int i = 0; i < 6000; i++) {\n    if (status != 9) {\n      if ( -1 == status) { //status == -1， 子进程创建失败\n        printf(\"system error!\"); \n        return -1;\n      } else {\n        if (WIFEXITED(status)) {//WIFEXITED(status) 为真，QtApplication 成功执行\n          if (0 == WEXITSTATUS(status)) {\n            printf(\"QtApplication successfully.\\n\"); //Qt 程序执行成功\n            return 0;\n          } else {\n            printf(\"QtApplication failed, exit code: [%d]\\n\", WEXITSTATUS(status));//Qt 程序执行失败，获取失败返回值。\n            return -1;\n          }\n        } else {\n          printf(\"exit status = [%d]\\n\", WEXITSTATUS(status)); //WIFEXITED(status) 不为真，shell 调用失败。\n          return -1;\n        }\n      }\n    }\n    usleep(100);\n  }\n  return -1;\n}````\n\n## 出现的问题\n 编写完这个代码后简单的执行，调试，没有发现什么问题，所以开始进行测试，结果出现一个很奇怪的现象：\n 当 Qt 程序没有执行完成的时候，system 返回了程序的返回值，并打印了以下的语句：`exit status = [0]`\n \n 更为奇怪的是同样的问题，当手动执行 system_call 的时候，并不会出现这样的问题。\n\n## 为什么会出现这样的问题？\n经过对系统代码的分析，发现，在系统启动时启动一个拨号程序，而这个程序在系统启动大概200ms的时候杀死了所有的 sh 程序。\n\n## 问题的解决\n因为拨号程序不能更改，所以只能先通过 exec 的方法调用程序，毕竟**system()函数用起来很容易出错！！！**\n\n于是，尝试了使用 exec 直接执行的方式来调用子程序，代码如下：\n````C++\nint system_call()\n{\n  pid_t pid, ret;\n  int status;\n  if ((pid = fork()) < 0) {\n    printf(\"Fork Failed!\");\n    return -1;\n  } else if (pid == 0) {\n    if ((status = execlp(\"QtApplication\", \n                        \"QtApplication\", \n                        \"-qws\", \n                        NULL)) < 0) {\n      printf(\"EXEC Failed!\");\n    }\n  } else {\n    for (int i = 0; i < 6000; i++) {\n      ret = waitpid(pid, &status, WNOHANG);\n      if (ret == pid) {\n        if (WIFEXITED(status)) {\n          if (0 == WEXITSTATUS(status)) {\n            printf(\"QtApplication successful\", 3);\n            return 0;\n          } else {\n            printf(\"tcu_update failed with CODE[%d]\",  \n                    WEXITSTATUS(status));\n            return -1;\n          }\n        } else {\n          printf(\"tcu_update start failed with CODE[%d]\",  \n                  WEXITSTATUS(status));\n          return -2;\n        }\n      }\n      usleep(100000);\n    }\n    return -2;\n  }\n}````\n\n## 参考:\n[【C/C++】Linux下system()函数引发的错误)](https://my.oschina.net/renhc/blog/54582)\n[【C/C++】Linux下system()函数引发的错误](https://my.oschina.net/renhc/blog/54582)\n","source":"_posts/system调用Qt程序的问题.md","raw":"---\ntitle: system调用Qt程序的问题\ndate: 2016-11-22 17:53:10\ncategories: 工作记录\ntags: [system,Qt]\n---\n\n在公司做了一个嵌入式系统的引导程序，进程在系统开始后自启动（这里使用的是 rc.local 添加启动项的方法），随后按照相应的顺序依次启动相应的程序，之前一直没有出现什么问题，直到增加了一个启动 Qt 程序，并监控程序状态的需求后，出现了一些无法解释的问题。\n<!--more-->\n## 编写代码的过程 \n* 第一个需求：进程中调用一个 Qt 程序。\n\n这个代码很简单，为了省事，简单使用了 `system()` 函数。\n\n        system(\"QtApplication -qws\");\n\n* 第二个需求：需要获取 QtApplication 的返回值。\n\nsystem 函数的执行过程分为三个步骤：\n 1. 创建一个子进程，主要是 `fork()` 等过程。\n 2. 调用 `/bin/sh` 拉起 shell 脚本。\n 3. 执行相应的 shell 脚本，waitpid()。\n\n因此，system 的返回值(status)囊括了以上三个步骤的结果：\n 1. 如果调用子进程失败，或者 waitpid() 返回除了 `EINTR` 之外的错误，system 返回 -1；\n 2. 如果 shell 拉起失败或未正常执行结束（**只要能够调用到 `/bin/sh`，并且执行shell过程中没有被其他信号异常中断，都算正常结束**），原因值被写入到status的低8~15比特位中。<br>\n 系统提供了宏：`WIFEXITED(status)` 来判断 shell 的执行结果。如果 `WIFEXITED(status)` 为真，则说明正常结束。\n 3. 如果 shell 脚本正常执行结束，将 shell 返回值填到 status 的低8~15比特位中。<br>\n 同样系统提供了宏：`WEXITSTATUS(status)` 来获取相应脚本的执行结果。\n\n一个简单的执行代码如下, 因为程序需要执行一段时间，所以添加了一个轮询：\n````C++\nint system_call() {\n  int status = 9;\n  status = system(\"QtApplication -qws\");\n  for (int i = 0; i < 6000; i++) {\n    if (status != 9) {\n      if ( -1 == status) { //status == -1， 子进程创建失败\n        printf(\"system error!\"); \n        return -1;\n      } else {\n        if (WIFEXITED(status)) {//WIFEXITED(status) 为真，QtApplication 成功执行\n          if (0 == WEXITSTATUS(status)) {\n            printf(\"QtApplication successfully.\\n\"); //Qt 程序执行成功\n            return 0;\n          } else {\n            printf(\"QtApplication failed, exit code: [%d]\\n\", WEXITSTATUS(status));//Qt 程序执行失败，获取失败返回值。\n            return -1;\n          }\n        } else {\n          printf(\"exit status = [%d]\\n\", WEXITSTATUS(status)); //WIFEXITED(status) 不为真，shell 调用失败。\n          return -1;\n        }\n      }\n    }\n    usleep(100);\n  }\n  return -1;\n}````\n\n## 出现的问题\n 编写完这个代码后简单的执行，调试，没有发现什么问题，所以开始进行测试，结果出现一个很奇怪的现象：\n 当 Qt 程序没有执行完成的时候，system 返回了程序的返回值，并打印了以下的语句：`exit status = [0]`\n \n 更为奇怪的是同样的问题，当手动执行 system_call 的时候，并不会出现这样的问题。\n\n## 为什么会出现这样的问题？\n经过对系统代码的分析，发现，在系统启动时启动一个拨号程序，而这个程序在系统启动大概200ms的时候杀死了所有的 sh 程序。\n\n## 问题的解决\n因为拨号程序不能更改，所以只能先通过 exec 的方法调用程序，毕竟**system()函数用起来很容易出错！！！**\n\n于是，尝试了使用 exec 直接执行的方式来调用子程序，代码如下：\n````C++\nint system_call()\n{\n  pid_t pid, ret;\n  int status;\n  if ((pid = fork()) < 0) {\n    printf(\"Fork Failed!\");\n    return -1;\n  } else if (pid == 0) {\n    if ((status = execlp(\"QtApplication\", \n                        \"QtApplication\", \n                        \"-qws\", \n                        NULL)) < 0) {\n      printf(\"EXEC Failed!\");\n    }\n  } else {\n    for (int i = 0; i < 6000; i++) {\n      ret = waitpid(pid, &status, WNOHANG);\n      if (ret == pid) {\n        if (WIFEXITED(status)) {\n          if (0 == WEXITSTATUS(status)) {\n            printf(\"QtApplication successful\", 3);\n            return 0;\n          } else {\n            printf(\"tcu_update failed with CODE[%d]\",  \n                    WEXITSTATUS(status));\n            return -1;\n          }\n        } else {\n          printf(\"tcu_update start failed with CODE[%d]\",  \n                  WEXITSTATUS(status));\n          return -2;\n        }\n      }\n      usleep(100000);\n    }\n    return -2;\n  }\n}````\n\n## 参考:\n[【C/C++】Linux下system()函数引发的错误)](https://my.oschina.net/renhc/blog/54582)\n[【C/C++】Linux下system()函数引发的错误](https://my.oschina.net/renhc/blog/54582)\n","slug":"system调用Qt程序的问题","published":1,"updated":"2016-12-12T12:17:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n002bbkw1c1t1db0l","content":"<p>在公司做了一个嵌入式系统的引导程序，进程在系统开始后自启动（这里使用的是 rc.local 添加启动项的方法），随后按照相应的顺序依次启动相应的程序，之前一直没有出现什么问题，直到增加了一个启动 Qt 程序，并监控程序状态的需求后，出现了一些无法解释的问题。<br><a id=\"more\"></a></p>\n<h2 id=\"编写代码的过程\"><a href=\"#编写代码的过程\" class=\"headerlink\" title=\"编写代码的过程\"></a>编写代码的过程</h2><ul>\n<li>第一个需求：进程中调用一个 Qt 程序。</li>\n</ul>\n<p>这个代码很简单，为了省事，简单使用了 <code>system()</code> 函数。</p>\n<pre><code>system(&quot;QtApplication -qws&quot;);\n</code></pre><ul>\n<li>第二个需求：需要获取 QtApplication 的返回值。</li>\n</ul>\n<p>system 函数的执行过程分为三个步骤：</p>\n<ol>\n<li>创建一个子进程，主要是 <code>fork()</code> 等过程。</li>\n<li>调用 <code>/bin/sh</code> 拉起 shell 脚本。</li>\n<li>执行相应的 shell 脚本，waitpid()。</li>\n</ol>\n<p>因此，system 的返回值(status)囊括了以上三个步骤的结果：</p>\n<ol>\n<li>如果调用子进程失败，或者 waitpid() 返回除了 <code>EINTR</code> 之外的错误，system 返回 -1；</li>\n<li>如果 shell 拉起失败或未正常执行结束（<strong>只要能够调用到 <code>/bin/sh</code>，并且执行shell过程中没有被其他信号异常中断，都算正常结束</strong>），原因值被写入到status的低8~15比特位中。<br><br>系统提供了宏：<code>WIFEXITED(status)</code> 来判断 shell 的执行结果。如果 <code>WIFEXITED(status)</code> 为真，则说明正常结束。</li>\n<li>如果 shell 脚本正常执行结束，将 shell 返回值填到 status 的低8~15比特位中。<br><br>同样系统提供了宏：<code>WEXITSTATUS(status)</code> 来获取相应脚本的执行结果。</li>\n</ol>\n<p>一个简单的执行代码如下, 因为程序需要执行一段时间，所以添加了一个轮询：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">system_call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> status = <span class=\"number\">9</span>;</div><div class=\"line\">  status = system(<span class=\"string\">\"QtApplication -qws\"</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6000</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (status != <span class=\"number\">9</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> ( <span class=\"number\">-1</span> == status) &#123; <span class=\"comment\">//status == -1， 子进程创建失败</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"system error!\"</span>); </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (WIFEXITED(status)) &#123;<span class=\"comment\">//WIFEXITED(status) 为真，QtApplication 成功执行</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == WEXITSTATUS(status)) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"QtApplication successfully.\\n\"</span>); <span class=\"comment\">//Qt 程序执行成功</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"QtApplication failed, exit code: [%d]\\n\"</span>, WEXITSTATUS(status));<span class=\"comment\">//Qt 程序执行失败，获取失败返回值。</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"exit status = [%d]\\n\"</span>, WEXITSTATUS(status)); <span class=\"comment\">//WIFEXITED(status) 不为真，shell 调用失败。</span></div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    usleep(<span class=\"number\">100</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"出现的问题\"><a href=\"#出现的问题\" class=\"headerlink\" title=\"出现的问题\"></a>出现的问题</h2><p> 编写完这个代码后简单的执行，调试，没有发现什么问题，所以开始进行测试，结果出现一个很奇怪的现象：<br> 当 Qt 程序没有执行完成的时候，system 返回了程序的返回值，并打印了以下的语句：<code>exit status = [0]</code></p>\n<p> 更为奇怪的是同样的问题，当手动执行 system_call 的时候，并不会出现这样的问题。</p>\n<h2 id=\"为什么会出现这样的问题？\"><a href=\"#为什么会出现这样的问题？\" class=\"headerlink\" title=\"为什么会出现这样的问题？\"></a>为什么会出现这样的问题？</h2><p>经过对系统代码的分析，发现，在系统启动时启动一个拨号程序，而这个程序在系统启动大概200ms的时候杀死了所有的 sh 程序。</p>\n<h2 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h2><p>因为拨号程序不能更改，所以只能先通过 exec 的方法调用程序，毕竟<strong>system()函数用起来很容易出错！！！</strong></p>\n<p>于是，尝试了使用 exec 直接执行的方式来调用子程序，代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">system_call</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">pid_t</span> pid, ret;</div><div class=\"line\">  <span class=\"keyword\">int</span> status;</div><div class=\"line\">  <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Fork Failed!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((status = execlp(<span class=\"string\">\"QtApplication\"</span>, </div><div class=\"line\">                        <span class=\"string\">\"QtApplication\"</span>, </div><div class=\"line\">                        <span class=\"string\">\"-qws\"</span>, </div><div class=\"line\">                        <span class=\"literal\">NULL</span>)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"EXEC Failed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6000</span>; i++) &#123;</div><div class=\"line\">      ret = waitpid(pid, &amp;status, WNOHANG);</div><div class=\"line\">      <span class=\"keyword\">if</span> (ret == pid) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (WIFEXITED(status)) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == WEXITSTATUS(status)) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"QtApplication successful\"</span>, <span class=\"number\">3</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"tcu_update failed with CODE[%d]\"</span>,  </div><div class=\"line\">                    WEXITSTATUS(status));</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"tcu_update start failed with CODE[%d]\"</span>,  </div><div class=\"line\">                  WEXITSTATUS(status));</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      usleep(<span class=\"number\">100000</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h2><p><a href=\"https://my.oschina.net/renhc/blog/54582\" target=\"_blank\" rel=\"external\">【C/C++】Linux下system()函数引发的错误)</a><br><a href=\"https://my.oschina.net/renhc/blog/54582\" target=\"_blank\" rel=\"external\">【C/C++】Linux下system()函数引发的错误</a></p>\n","excerpt":"<p>在公司做了一个嵌入式系统的引导程序，进程在系统开始后自启动（这里使用的是 rc.local 添加启动项的方法），随后按照相应的顺序依次启动相应的程序，之前一直没有出现什么问题，直到增加了一个启动 Qt 程序，并监控程序状态的需求后，出现了一些无法解释的问题。<br>","more":"</p>\n<h2 id=\"编写代码的过程\"><a href=\"#编写代码的过程\" class=\"headerlink\" title=\"编写代码的过程\"></a>编写代码的过程</h2><ul>\n<li>第一个需求：进程中调用一个 Qt 程序。</li>\n</ul>\n<p>这个代码很简单，为了省事，简单使用了 <code>system()</code> 函数。</p>\n<pre><code>system(&quot;QtApplication -qws&quot;);\n</code></pre><ul>\n<li>第二个需求：需要获取 QtApplication 的返回值。</li>\n</ul>\n<p>system 函数的执行过程分为三个步骤：</p>\n<ol>\n<li>创建一个子进程，主要是 <code>fork()</code> 等过程。</li>\n<li>调用 <code>/bin/sh</code> 拉起 shell 脚本。</li>\n<li>执行相应的 shell 脚本，waitpid()。</li>\n</ol>\n<p>因此，system 的返回值(status)囊括了以上三个步骤的结果：</p>\n<ol>\n<li>如果调用子进程失败，或者 waitpid() 返回除了 <code>EINTR</code> 之外的错误，system 返回 -1；</li>\n<li>如果 shell 拉起失败或未正常执行结束（<strong>只要能够调用到 <code>/bin/sh</code>，并且执行shell过程中没有被其他信号异常中断，都算正常结束</strong>），原因值被写入到status的低8~15比特位中。<br><br>系统提供了宏：<code>WIFEXITED(status)</code> 来判断 shell 的执行结果。如果 <code>WIFEXITED(status)</code> 为真，则说明正常结束。</li>\n<li>如果 shell 脚本正常执行结束，将 shell 返回值填到 status 的低8~15比特位中。<br><br>同样系统提供了宏：<code>WEXITSTATUS(status)</code> 来获取相应脚本的执行结果。</li>\n</ol>\n<p>一个简单的执行代码如下, 因为程序需要执行一段时间，所以添加了一个轮询：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">system_call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> status = <span class=\"number\">9</span>;</div><div class=\"line\">  status = system(<span class=\"string\">\"QtApplication -qws\"</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6000</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (status != <span class=\"number\">9</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> ( <span class=\"number\">-1</span> == status) &#123; <span class=\"comment\">//status == -1， 子进程创建失败</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"system error!\"</span>); </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (WIFEXITED(status)) &#123;<span class=\"comment\">//WIFEXITED(status) 为真，QtApplication 成功执行</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == WEXITSTATUS(status)) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"QtApplication successfully.\\n\"</span>); <span class=\"comment\">//Qt 程序执行成功</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"QtApplication failed, exit code: [%d]\\n\"</span>, WEXITSTATUS(status));<span class=\"comment\">//Qt 程序执行失败，获取失败返回值。</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"exit status = [%d]\\n\"</span>, WEXITSTATUS(status)); <span class=\"comment\">//WIFEXITED(status) 不为真，shell 调用失败。</span></div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    usleep(<span class=\"number\">100</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"出现的问题\"><a href=\"#出现的问题\" class=\"headerlink\" title=\"出现的问题\"></a>出现的问题</h2><p> 编写完这个代码后简单的执行，调试，没有发现什么问题，所以开始进行测试，结果出现一个很奇怪的现象：<br> 当 Qt 程序没有执行完成的时候，system 返回了程序的返回值，并打印了以下的语句：<code>exit status = [0]</code></p>\n<p> 更为奇怪的是同样的问题，当手动执行 system_call 的时候，并不会出现这样的问题。</p>\n<h2 id=\"为什么会出现这样的问题？\"><a href=\"#为什么会出现这样的问题？\" class=\"headerlink\" title=\"为什么会出现这样的问题？\"></a>为什么会出现这样的问题？</h2><p>经过对系统代码的分析，发现，在系统启动时启动一个拨号程序，而这个程序在系统启动大概200ms的时候杀死了所有的 sh 程序。</p>\n<h2 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h2><p>因为拨号程序不能更改，所以只能先通过 exec 的方法调用程序，毕竟<strong>system()函数用起来很容易出错！！！</strong></p>\n<p>于是，尝试了使用 exec 直接执行的方式来调用子程序，代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">system_call</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">pid_t</span> pid, ret;</div><div class=\"line\">  <span class=\"keyword\">int</span> status;</div><div class=\"line\">  <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Fork Failed!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((status = execlp(<span class=\"string\">\"QtApplication\"</span>, </div><div class=\"line\">                        <span class=\"string\">\"QtApplication\"</span>, </div><div class=\"line\">                        <span class=\"string\">\"-qws\"</span>, </div><div class=\"line\">                        <span class=\"literal\">NULL</span>)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"EXEC Failed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6000</span>; i++) &#123;</div><div class=\"line\">      ret = waitpid(pid, &amp;status, WNOHANG);</div><div class=\"line\">      <span class=\"keyword\">if</span> (ret == pid) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (WIFEXITED(status)) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == WEXITSTATUS(status)) &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"QtApplication successful\"</span>, <span class=\"number\">3</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"tcu_update failed with CODE[%d]\"</span>,  </div><div class=\"line\">                    WEXITSTATUS(status));</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"tcu_update start failed with CODE[%d]\"</span>,  </div><div class=\"line\">                  WEXITSTATUS(status));</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      usleep(<span class=\"number\">100000</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h2><p><a href=\"https://my.oschina.net/renhc/blog/54582\">【C/C++】Linux下system()函数引发的错误)</a><br><a href=\"https://my.oschina.net/renhc/blog/54582\">【C/C++】Linux下system()函数引发的错误</a></p>"},{"title":"在windows下打出tar.gz的尝试","date":"2016-11-21T08:20:46.000Z","_content":"作为一名嵌入式开发人员，Linux是必须使用的，但是不可避免的有些时候手头上没有装有Linux的电脑，或者不想去打开虚拟机。尤其是当你仅仅只是需要打个tar包的时候。这时候当然你可以使用7z的桌面版程序，就可以解决这种简单的需求。但是目前我遇到了一个这样的问题：公司需要对外提供一个软件打包工具，而用户通常是没有Linux系统的。这时候需要在程序中打出tar.gz的压缩包。\n\n<!--more-->\n# 第一种方法：使用gnu tar for windows\n\n和其他很多GNU的软件一样，tar提供了Windows的版本，可以从[gnu tar for windows](http://gnuwin32.sourceforge.net/packages/gtar.htm \"gnu tar for windows\")这里下载，官方分别提供了二进制可执行文件、文档、源代码的安装包和压缩包，可以根据需要进行下载。\n因为时间要求比较紧，所以我直接使用了调用二进制文件的方式进行打包，使用命令`tar.exe cvf xxx.tar file`即可简单的打出tar包，需要注意的是，使用tar.exe的同时需要提供`libintl-2`和`libiconv-2 `两个文件。\n但是遗憾的是，使用tar.exe仅仅只能打出tar包，对与gz暂时无法提供：\n>The Win32 port can only create tar archives, but cannot pipe its output to other programs such as gzip or compress, and will not create tar.gz archives; you will have to use or simulate a batch pipe. BsdTar does have the ability to direcly create and manipulate .tar, .tar.gz, tar.bz2, .zip, .gz and .bz2 archives, understands the most-used options of GNU Tar, and is also much faster; for most purposes it is to be preferred to GNU Tar. \n\n# 第二种方法：使用7z\n作为很好的一种压缩软件，7z拥有很多的用户，同时7z也是一款开源软件，当然也提供了源代码和相应的命令行软件。从[这里](http://www.7-zip.org/sdk.html \"7z\")可以下载相应的文件。\n同样使用调用二进制文件的方式，7z的使用很简单。命令如下：\n\n\t7z.exe a archive files\n\n7z可以直接通过archive 的后缀判断需要生成的压缩包的类型。使用7z打出tar.gz需要以下两步：\n\n\t7z.exe a archive.tar files\n\t7z.exe a archive.tar.gz archive.tar\n\n这样圆满的解决了我遇到的问题。当然这是一种很取巧的方式，在程序中更提倡使用的还是使用源代码调用相应的方法。之后，我会继续研读tar和7z的源码。","source":"_posts/在windows下打出tar-gz的尝试.md","raw":"---\ntitle: 在windows下打出tar.gz的尝试\ndate: 2016-11-21 16:20:46\ncategories: 工作记录\ntags: [tar,7z,gz]\n---\n作为一名嵌入式开发人员，Linux是必须使用的，但是不可避免的有些时候手头上没有装有Linux的电脑，或者不想去打开虚拟机。尤其是当你仅仅只是需要打个tar包的时候。这时候当然你可以使用7z的桌面版程序，就可以解决这种简单的需求。但是目前我遇到了一个这样的问题：公司需要对外提供一个软件打包工具，而用户通常是没有Linux系统的。这时候需要在程序中打出tar.gz的压缩包。\n\n<!--more-->\n# 第一种方法：使用gnu tar for windows\n\n和其他很多GNU的软件一样，tar提供了Windows的版本，可以从[gnu tar for windows](http://gnuwin32.sourceforge.net/packages/gtar.htm \"gnu tar for windows\")这里下载，官方分别提供了二进制可执行文件、文档、源代码的安装包和压缩包，可以根据需要进行下载。\n因为时间要求比较紧，所以我直接使用了调用二进制文件的方式进行打包，使用命令`tar.exe cvf xxx.tar file`即可简单的打出tar包，需要注意的是，使用tar.exe的同时需要提供`libintl-2`和`libiconv-2 `两个文件。\n但是遗憾的是，使用tar.exe仅仅只能打出tar包，对与gz暂时无法提供：\n>The Win32 port can only create tar archives, but cannot pipe its output to other programs such as gzip or compress, and will not create tar.gz archives; you will have to use or simulate a batch pipe. BsdTar does have the ability to direcly create and manipulate .tar, .tar.gz, tar.bz2, .zip, .gz and .bz2 archives, understands the most-used options of GNU Tar, and is also much faster; for most purposes it is to be preferred to GNU Tar. \n\n# 第二种方法：使用7z\n作为很好的一种压缩软件，7z拥有很多的用户，同时7z也是一款开源软件，当然也提供了源代码和相应的命令行软件。从[这里](http://www.7-zip.org/sdk.html \"7z\")可以下载相应的文件。\n同样使用调用二进制文件的方式，7z的使用很简单。命令如下：\n\n\t7z.exe a archive files\n\n7z可以直接通过archive 的后缀判断需要生成的压缩包的类型。使用7z打出tar.gz需要以下两步：\n\n\t7z.exe a archive.tar files\n\t7z.exe a archive.tar.gz archive.tar\n\n这样圆满的解决了我遇到的问题。当然这是一种很取巧的方式，在程序中更提倡使用的还是使用源代码调用相应的方法。之后，我会继续研读tar和7z的源码。","slug":"在windows下打出tar-gz的尝试","published":1,"updated":"2016-11-22T09:58:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n002fbkw177ssq29q","content":"<p>作为一名嵌入式开发人员，Linux是必须使用的，但是不可避免的有些时候手头上没有装有Linux的电脑，或者不想去打开虚拟机。尤其是当你仅仅只是需要打个tar包的时候。这时候当然你可以使用7z的桌面版程序，就可以解决这种简单的需求。但是目前我遇到了一个这样的问题：公司需要对外提供一个软件打包工具，而用户通常是没有Linux系统的。这时候需要在程序中打出tar.gz的压缩包。</p>\n<a id=\"more\"></a>\n<h1 id=\"第一种方法：使用gnu-tar-for-windows\"><a href=\"#第一种方法：使用gnu-tar-for-windows\" class=\"headerlink\" title=\"第一种方法：使用gnu tar for windows\"></a>第一种方法：使用gnu tar for windows</h1><p>和其他很多GNU的软件一样，tar提供了Windows的版本，可以从<a href=\"http://gnuwin32.sourceforge.net/packages/gtar.htm\" title=\"gnu tar for windows\" target=\"_blank\" rel=\"external\">gnu tar for windows</a>这里下载，官方分别提供了二进制可执行文件、文档、源代码的安装包和压缩包，可以根据需要进行下载。<br>因为时间要求比较紧，所以我直接使用了调用二进制文件的方式进行打包，使用命令<code>tar.exe cvf xxx.tar file</code>即可简单的打出tar包，需要注意的是，使用tar.exe的同时需要提供<code>libintl-2</code>和<code>libiconv-2</code>两个文件。<br>但是遗憾的是，使用tar.exe仅仅只能打出tar包，对与gz暂时无法提供：</p>\n<blockquote>\n<p>The Win32 port can only create tar archives, but cannot pipe its output to other programs such as gzip or compress, and will not create tar.gz archives; you will have to use or simulate a batch pipe. BsdTar does have the ability to direcly create and manipulate .tar, .tar.gz, tar.bz2, .zip, .gz and .bz2 archives, understands the most-used options of GNU Tar, and is also much faster; for most purposes it is to be preferred to GNU Tar. </p>\n</blockquote>\n<h1 id=\"第二种方法：使用7z\"><a href=\"#第二种方法：使用7z\" class=\"headerlink\" title=\"第二种方法：使用7z\"></a>第二种方法：使用7z</h1><p>作为很好的一种压缩软件，7z拥有很多的用户，同时7z也是一款开源软件，当然也提供了源代码和相应的命令行软件。从<a href=\"http://www.7-zip.org/sdk.html\" title=\"7z\" target=\"_blank\" rel=\"external\">这里</a>可以下载相应的文件。<br>同样使用调用二进制文件的方式，7z的使用很简单。命令如下：</p>\n<pre><code>7z.exe a archive files\n</code></pre><p>7z可以直接通过archive 的后缀判断需要生成的压缩包的类型。使用7z打出tar.gz需要以下两步：</p>\n<pre><code>7z.exe a archive.tar files\n7z.exe a archive.tar.gz archive.tar\n</code></pre><p>这样圆满的解决了我遇到的问题。当然这是一种很取巧的方式，在程序中更提倡使用的还是使用源代码调用相应的方法。之后，我会继续研读tar和7z的源码。</p>\n","excerpt":"<p>作为一名嵌入式开发人员，Linux是必须使用的，但是不可避免的有些时候手头上没有装有Linux的电脑，或者不想去打开虚拟机。尤其是当你仅仅只是需要打个tar包的时候。这时候当然你可以使用7z的桌面版程序，就可以解决这种简单的需求。但是目前我遇到了一个这样的问题：公司需要对外提供一个软件打包工具，而用户通常是没有Linux系统的。这时候需要在程序中打出tar.gz的压缩包。</p>","more":"<h1 id=\"第一种方法：使用gnu-tar-for-windows\"><a href=\"#第一种方法：使用gnu-tar-for-windows\" class=\"headerlink\" title=\"第一种方法：使用gnu tar for windows\"></a>第一种方法：使用gnu tar for windows</h1><p>和其他很多GNU的软件一样，tar提供了Windows的版本，可以从<a href=\"http://gnuwin32.sourceforge.net/packages/gtar.htm\" title=\"gnu tar for windows\">gnu tar for windows</a>这里下载，官方分别提供了二进制可执行文件、文档、源代码的安装包和压缩包，可以根据需要进行下载。<br>因为时间要求比较紧，所以我直接使用了调用二进制文件的方式进行打包，使用命令<code>tar.exe cvf xxx.tar file</code>即可简单的打出tar包，需要注意的是，使用tar.exe的同时需要提供<code>libintl-2</code>和<code>libiconv-2</code>两个文件。<br>但是遗憾的是，使用tar.exe仅仅只能打出tar包，对与gz暂时无法提供：</p>\n<blockquote>\n<p>The Win32 port can only create tar archives, but cannot pipe its output to other programs such as gzip or compress, and will not create tar.gz archives; you will have to use or simulate a batch pipe. BsdTar does have the ability to direcly create and manipulate .tar, .tar.gz, tar.bz2, .zip, .gz and .bz2 archives, understands the most-used options of GNU Tar, and is also much faster; for most purposes it is to be preferred to GNU Tar. </p>\n</blockquote>\n<h1 id=\"第二种方法：使用7z\"><a href=\"#第二种方法：使用7z\" class=\"headerlink\" title=\"第二种方法：使用7z\"></a>第二种方法：使用7z</h1><p>作为很好的一种压缩软件，7z拥有很多的用户，同时7z也是一款开源软件，当然也提供了源代码和相应的命令行软件。从<a href=\"http://www.7-zip.org/sdk.html\" title=\"7z\">这里</a>可以下载相应的文件。<br>同样使用调用二进制文件的方式，7z的使用很简单。命令如下：</p>\n<pre><code>7z.exe a archive files\n</code></pre><p>7z可以直接通过archive 的后缀判断需要生成的压缩包的类型。使用7z打出tar.gz需要以下两步：</p>\n<pre><code>7z.exe a archive.tar files\n7z.exe a archive.tar.gz archive.tar\n</code></pre><p>这样圆满的解决了我遇到的问题。当然这是一种很取巧的方式，在程序中更提倡使用的还是使用源代码调用相应的方法。之后，我会继续研读tar和7z的源码。</p>"},{"title":"《程序员的修炼之道》读书笔记","date":"2016-12-28T10:07:47.000Z","_content":"\n最近看了《程序员的修炼之道-从小工到专家》，里面讲的是怎样成为一个注重实效的程序员。讲的是程序员，但是其实中间的很多道理作为一个职场人来说，都是适用的。因为最近看得个人管理方面的书籍比较多，还是按照很多大师经常提到的**道、术、器、用**四个字来总结一下这本书，也是给自己的一个发展定位：我自己想要成为一个怎样的程序员。\n\n<!--more-->\n![程序员的修炼之道](http://ogf054qp1.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93-%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86%20%282%29.png)\n## 道：一个注重实效程序员需要秉持的理念\n书的第一章的名字叫*注重实效的哲学*。其实不像很多人想的那样，程序员并不是一个冷冰冰的枯燥的集体。反而，程序员是更多善于思考的一个集体，不仅仅是对工作，对于人生、世界，程序员都有属于自己的解释。所以才会有这么多的程序员的纷争，从大了讲有自由与封建（开源/闭源）之争；往具体处说，又有诸如**UNIX哲学**等哲学流派。但作为一个注重实效的程序员，秉持的理念是怎样的、他的人生观应该是怎样的？这本书的第一章给开了个头。\n\n注重实效的程序员在编程的时候，他们是**完美主义**和**实用主义**的结合者。他们对自己的代码要求完美，对自己的**错误负责**，他们不能容忍破窗户的存在，因为它最终会导致一个失败的项目。但同时，他们也知道在什么时候止步，他们明白他们是在一个不完美的世界上开发代码的，所以他们通常把质量作为一种需求，而不是一个极大的简单期望。\n但是他们的世界是**宏观**的，他们往往想要从更高的角度来思考问题。他们需要确认自己的每一步都是为了自己的最终愿景，每一行代码都是为了项目的完美实现。他们秉持着这样的价值观，不断的判断自己是否偏离了最终的方向。\n另一方面，所有的高效的程序员都是进化论的支持者，所以他们十分注重自己的进化。他们往往会定期的**投资自己**，用知识不断武装自己，来适应不断更新的环境。同时，他们不断的同环境**交流**，很多时候是使用网络或者书面的形式。同时，他们会让自己的产品同样是可进化的化，具有**可撤销性**，来适应环境。\n最终，是所有注重实效的程序员都坚持的一个原则：简单原则。他们会尽一切可能**避免重复**，尽一切的可能进行**正交**的操作。\n\n## 术：实现高效的流程方法\n根据上面的原则，我们有通常的几个规律来实现我们的项目。\n当我们面对一个新的项目的时候，我们不应该过于详细的进行每个模块的设计，而是应该使用**曳光弹**，首先搭建起我们软件框架。随后，在我们缺的程序框架上进行完善。这样能够高效的优先确定我们的路径。\n随后，当我们实现具体的功能的时候，我们可以使用**原型**，原型可以允许适当的忽略某些细节，来快速验证我们的想法。\n针对具体的问题，我们应该刨除编程语言的干扰，靠近问题领域编程，使用领域语言对问题进行有针对性的开发。\n另外两个适用的通用规律是**估算**和**合约**。我们应该使用合约对我们的项目需求和设计进行规范，我们应该使用估算对我们的项目建立模型，设定自己的计划，随后进行代码迭代。\n\n## 器：带来效率提升的工具\n从思想上提高了认识之后，我们可以从工具着手提高我们的效率。当然最先确定应该是我们的**编辑器**，一个高效的编辑器应该满足下面的特点：\n * 可配置 \n * 可扩展\n * 可编程\n使用适当的编辑器可以快速的帮助我们提高生产效率。此外我们应该使用适当的**调试工具**，及时的进行我们的测试和错误跟踪。随后我们应学会使用**源码控制工具**，使用源码控制工具不仅可以帮助撤销错误的操作，还可以让我们能够快速的定位错误，自动化的进行测试。这是最重要的三个工具，另外一些可以提高我们工作效率的工具是：\n * **纯文本**，它可以用来保存我们的配置、数据、历史工作等，这是一种通用不过时的工具，可以协同我们的开发、测试，且不受特定语言和系统的影响。\n * **命令行工具**和**脚本语言**，有效的利用这两者一方面可以让我更加深入的使用计算机的很多功能，另一方面提供了我们自动化的方式来进行的我们的编码、测试、乃至快捷地搭建我们的架构。同时可以帮助我们编写自己的**代码生成器**，避免我们进行重复的工作。\n\n## 用：践行高效的过程\n### 1. 项目之前\n在一个项目开始之前，我们需要的是深入挖掘需求，按照合约设计的方法，规范我们的项目。我们应该找到我们的设计的边际，找到我们真正的约束。\n\n### 2. 项目架构\n对于软件的架构，如上所说，应遵顼**正交性**的原则，这就要求我们将我们模块之间的耦合降低至最低，有下面的方法帮助我们实现这个目的：\n\n1. 我们按照德墨忒耳法则来编写代码：\n   > 得墨忒耳定律－－对象 O 的 M 方法，可以访问/调用如下的：\n   * 对象 O 本身\n   * M方法的传入参数\n   * M方法中创建或实例化的任意对象\n   * 对象 O 直接的组件对象\n   * 在M范围内，可被O访问的全局变量\n\n2. 我们使用元程序的设计\n   使用我们上面提到的纯文本工具，将我们的配置等抽离出来。将抽象放进代码，将细节放进元数据。\n\n3. 我们将时间解耦\n   将那些时间上不互相依赖的模块解耦，提高并发性。\n\n4. 使用合适的软件架构，如：\n   使用 MVC 架构，将视图和模型分开\n   使用 Blackboard 架构，协调工作流。\n\n### 3. 项目编程\n当我们编程的时候，应该首先保证程序的准确性，主要是两个方面：\n * 让错误尽可能早的体现出来，而不是让错误来破坏我们的代码。\n * 对于不可能发生的事情，应该使用**断言**确保它不会发生。\n\n另外，我们需要认清**异常**的意义：异常应该用于异常的问题，而不是那些我们自己需要前置判断的问题。比如我们的资源使用，必须考虑到**资源配平**的问题。\n\n其次，我们应在编程的过程中重视**重构**和**测试**的意义。\n\n","source":"_posts/《程序员的修炼之道》读书笔记.md","raw":"---\ntitle: 《程序员的修炼之道》读书笔记\ndate: 2016-12-28 18:07:47\ncategories: 读书笔记\ntags: [程序员的修炼之道]\n---\n\n最近看了《程序员的修炼之道-从小工到专家》，里面讲的是怎样成为一个注重实效的程序员。讲的是程序员，但是其实中间的很多道理作为一个职场人来说，都是适用的。因为最近看得个人管理方面的书籍比较多，还是按照很多大师经常提到的**道、术、器、用**四个字来总结一下这本书，也是给自己的一个发展定位：我自己想要成为一个怎样的程序员。\n\n<!--more-->\n![程序员的修炼之道](http://ogf054qp1.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93-%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86%20%282%29.png)\n## 道：一个注重实效程序员需要秉持的理念\n书的第一章的名字叫*注重实效的哲学*。其实不像很多人想的那样，程序员并不是一个冷冰冰的枯燥的集体。反而，程序员是更多善于思考的一个集体，不仅仅是对工作，对于人生、世界，程序员都有属于自己的解释。所以才会有这么多的程序员的纷争，从大了讲有自由与封建（开源/闭源）之争；往具体处说，又有诸如**UNIX哲学**等哲学流派。但作为一个注重实效的程序员，秉持的理念是怎样的、他的人生观应该是怎样的？这本书的第一章给开了个头。\n\n注重实效的程序员在编程的时候，他们是**完美主义**和**实用主义**的结合者。他们对自己的代码要求完美，对自己的**错误负责**，他们不能容忍破窗户的存在，因为它最终会导致一个失败的项目。但同时，他们也知道在什么时候止步，他们明白他们是在一个不完美的世界上开发代码的，所以他们通常把质量作为一种需求，而不是一个极大的简单期望。\n但是他们的世界是**宏观**的，他们往往想要从更高的角度来思考问题。他们需要确认自己的每一步都是为了自己的最终愿景，每一行代码都是为了项目的完美实现。他们秉持着这样的价值观，不断的判断自己是否偏离了最终的方向。\n另一方面，所有的高效的程序员都是进化论的支持者，所以他们十分注重自己的进化。他们往往会定期的**投资自己**，用知识不断武装自己，来适应不断更新的环境。同时，他们不断的同环境**交流**，很多时候是使用网络或者书面的形式。同时，他们会让自己的产品同样是可进化的化，具有**可撤销性**，来适应环境。\n最终，是所有注重实效的程序员都坚持的一个原则：简单原则。他们会尽一切可能**避免重复**，尽一切的可能进行**正交**的操作。\n\n## 术：实现高效的流程方法\n根据上面的原则，我们有通常的几个规律来实现我们的项目。\n当我们面对一个新的项目的时候，我们不应该过于详细的进行每个模块的设计，而是应该使用**曳光弹**，首先搭建起我们软件框架。随后，在我们缺的程序框架上进行完善。这样能够高效的优先确定我们的路径。\n随后，当我们实现具体的功能的时候，我们可以使用**原型**，原型可以允许适当的忽略某些细节，来快速验证我们的想法。\n针对具体的问题，我们应该刨除编程语言的干扰，靠近问题领域编程，使用领域语言对问题进行有针对性的开发。\n另外两个适用的通用规律是**估算**和**合约**。我们应该使用合约对我们的项目需求和设计进行规范，我们应该使用估算对我们的项目建立模型，设定自己的计划，随后进行代码迭代。\n\n## 器：带来效率提升的工具\n从思想上提高了认识之后，我们可以从工具着手提高我们的效率。当然最先确定应该是我们的**编辑器**，一个高效的编辑器应该满足下面的特点：\n * 可配置 \n * 可扩展\n * 可编程\n使用适当的编辑器可以快速的帮助我们提高生产效率。此外我们应该使用适当的**调试工具**，及时的进行我们的测试和错误跟踪。随后我们应学会使用**源码控制工具**，使用源码控制工具不仅可以帮助撤销错误的操作，还可以让我们能够快速的定位错误，自动化的进行测试。这是最重要的三个工具，另外一些可以提高我们工作效率的工具是：\n * **纯文本**，它可以用来保存我们的配置、数据、历史工作等，这是一种通用不过时的工具，可以协同我们的开发、测试，且不受特定语言和系统的影响。\n * **命令行工具**和**脚本语言**，有效的利用这两者一方面可以让我更加深入的使用计算机的很多功能，另一方面提供了我们自动化的方式来进行的我们的编码、测试、乃至快捷地搭建我们的架构。同时可以帮助我们编写自己的**代码生成器**，避免我们进行重复的工作。\n\n## 用：践行高效的过程\n### 1. 项目之前\n在一个项目开始之前，我们需要的是深入挖掘需求，按照合约设计的方法，规范我们的项目。我们应该找到我们的设计的边际，找到我们真正的约束。\n\n### 2. 项目架构\n对于软件的架构，如上所说，应遵顼**正交性**的原则，这就要求我们将我们模块之间的耦合降低至最低，有下面的方法帮助我们实现这个目的：\n\n1. 我们按照德墨忒耳法则来编写代码：\n   > 得墨忒耳定律－－对象 O 的 M 方法，可以访问/调用如下的：\n   * 对象 O 本身\n   * M方法的传入参数\n   * M方法中创建或实例化的任意对象\n   * 对象 O 直接的组件对象\n   * 在M范围内，可被O访问的全局变量\n\n2. 我们使用元程序的设计\n   使用我们上面提到的纯文本工具，将我们的配置等抽离出来。将抽象放进代码，将细节放进元数据。\n\n3. 我们将时间解耦\n   将那些时间上不互相依赖的模块解耦，提高并发性。\n\n4. 使用合适的软件架构，如：\n   使用 MVC 架构，将视图和模型分开\n   使用 Blackboard 架构，协调工作流。\n\n### 3. 项目编程\n当我们编程的时候，应该首先保证程序的准确性，主要是两个方面：\n * 让错误尽可能早的体现出来，而不是让错误来破坏我们的代码。\n * 对于不可能发生的事情，应该使用**断言**确保它不会发生。\n\n另外，我们需要认清**异常**的意义：异常应该用于异常的问题，而不是那些我们自己需要前置判断的问题。比如我们的资源使用，必须考虑到**资源配平**的问题。\n\n其次，我们应在编程的过程中重视**重构**和**测试**的意义。\n\n","slug":"《程序员的修炼之道》读书笔记","published":1,"updated":"2017-12-06T13:31:48.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n1n002ibkw1rram0zmb","content":"<p>最近看了《程序员的修炼之道-从小工到专家》，里面讲的是怎样成为一个注重实效的程序员。讲的是程序员，但是其实中间的很多道理作为一个职场人来说，都是适用的。因为最近看得个人管理方面的书籍比较多，还是按照很多大师经常提到的<strong>道、术、器、用</strong>四个字来总结一下这本书，也是给自己的一个发展定位：我自己想要成为一个怎样的程序员。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://ogf054qp1.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93-%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86%20%282%29.png\" alt=\"程序员的修炼之道\"></p>\n<h2 id=\"道：一个注重实效程序员需要秉持的理念\"><a href=\"#道：一个注重实效程序员需要秉持的理念\" class=\"headerlink\" title=\"道：一个注重实效程序员需要秉持的理念\"></a>道：一个注重实效程序员需要秉持的理念</h2><p>书的第一章的名字叫<em>注重实效的哲学</em>。其实不像很多人想的那样，程序员并不是一个冷冰冰的枯燥的集体。反而，程序员是更多善于思考的一个集体，不仅仅是对工作，对于人生、世界，程序员都有属于自己的解释。所以才会有这么多的程序员的纷争，从大了讲有自由与封建（开源/闭源）之争；往具体处说，又有诸如<strong>UNIX哲学</strong>等哲学流派。但作为一个注重实效的程序员，秉持的理念是怎样的、他的人生观应该是怎样的？这本书的第一章给开了个头。</p>\n<p>注重实效的程序员在编程的时候，他们是<strong>完美主义</strong>和<strong>实用主义</strong>的结合者。他们对自己的代码要求完美，对自己的<strong>错误负责</strong>，他们不能容忍破窗户的存在，因为它最终会导致一个失败的项目。但同时，他们也知道在什么时候止步，他们明白他们是在一个不完美的世界上开发代码的，所以他们通常把质量作为一种需求，而不是一个极大的简单期望。<br>但是他们的世界是<strong>宏观</strong>的，他们往往想要从更高的角度来思考问题。他们需要确认自己的每一步都是为了自己的最终愿景，每一行代码都是为了项目的完美实现。他们秉持着这样的价值观，不断的判断自己是否偏离了最终的方向。<br>另一方面，所有的高效的程序员都是进化论的支持者，所以他们十分注重自己的进化。他们往往会定期的<strong>投资自己</strong>，用知识不断武装自己，来适应不断更新的环境。同时，他们不断的同环境<strong>交流</strong>，很多时候是使用网络或者书面的形式。同时，他们会让自己的产品同样是可进化的化，具有<strong>可撤销性</strong>，来适应环境。<br>最终，是所有注重实效的程序员都坚持的一个原则：简单原则。他们会尽一切可能<strong>避免重复</strong>，尽一切的可能进行<strong>正交</strong>的操作。</p>\n<h2 id=\"术：实现高效的流程方法\"><a href=\"#术：实现高效的流程方法\" class=\"headerlink\" title=\"术：实现高效的流程方法\"></a>术：实现高效的流程方法</h2><p>根据上面的原则，我们有通常的几个规律来实现我们的项目。<br>当我们面对一个新的项目的时候，我们不应该过于详细的进行每个模块的设计，而是应该使用<strong>曳光弹</strong>，首先搭建起我们软件框架。随后，在我们缺的程序框架上进行完善。这样能够高效的优先确定我们的路径。<br>随后，当我们实现具体的功能的时候，我们可以使用<strong>原型</strong>，原型可以允许适当的忽略某些细节，来快速验证我们的想法。<br>针对具体的问题，我们应该刨除编程语言的干扰，靠近问题领域编程，使用领域语言对问题进行有针对性的开发。<br>另外两个适用的通用规律是<strong>估算</strong>和<strong>合约</strong>。我们应该使用合约对我们的项目需求和设计进行规范，我们应该使用估算对我们的项目建立模型，设定自己的计划，随后进行代码迭代。</p>\n<h2 id=\"器：带来效率提升的工具\"><a href=\"#器：带来效率提升的工具\" class=\"headerlink\" title=\"器：带来效率提升的工具\"></a>器：带来效率提升的工具</h2><p>从思想上提高了认识之后，我们可以从工具着手提高我们的效率。当然最先确定应该是我们的<strong>编辑器</strong>，一个高效的编辑器应该满足下面的特点：</p>\n<ul>\n<li>可配置 </li>\n<li>可扩展</li>\n<li>可编程<br>使用适当的编辑器可以快速的帮助我们提高生产效率。此外我们应该使用适当的<strong>调试工具</strong>，及时的进行我们的测试和错误跟踪。随后我们应学会使用<strong>源码控制工具</strong>，使用源码控制工具不仅可以帮助撤销错误的操作，还可以让我们能够快速的定位错误，自动化的进行测试。这是最重要的三个工具，另外一些可以提高我们工作效率的工具是：</li>\n<li><strong>纯文本</strong>，它可以用来保存我们的配置、数据、历史工作等，这是一种通用不过时的工具，可以协同我们的开发、测试，且不受特定语言和系统的影响。</li>\n<li><strong>命令行工具</strong>和<strong>脚本语言</strong>，有效的利用这两者一方面可以让我更加深入的使用计算机的很多功能，另一方面提供了我们自动化的方式来进行的我们的编码、测试、乃至快捷地搭建我们的架构。同时可以帮助我们编写自己的<strong>代码生成器</strong>，避免我们进行重复的工作。</li>\n</ul>\n<h2 id=\"用：践行高效的过程\"><a href=\"#用：践行高效的过程\" class=\"headerlink\" title=\"用：践行高效的过程\"></a>用：践行高效的过程</h2><h3 id=\"1-项目之前\"><a href=\"#1-项目之前\" class=\"headerlink\" title=\"1. 项目之前\"></a>1. 项目之前</h3><p>在一个项目开始之前，我们需要的是深入挖掘需求，按照合约设计的方法，规范我们的项目。我们应该找到我们的设计的边际，找到我们真正的约束。</p>\n<h3 id=\"2-项目架构\"><a href=\"#2-项目架构\" class=\"headerlink\" title=\"2. 项目架构\"></a>2. 项目架构</h3><p>对于软件的架构，如上所说，应遵顼<strong>正交性</strong>的原则，这就要求我们将我们模块之间的耦合降低至最低，有下面的方法帮助我们实现这个目的：</p>\n<ol>\n<li><p>我们按照德墨忒耳法则来编写代码：</p>\n<blockquote>\n<p>得墨忒耳定律－－对象 O 的 M 方法，可以访问/调用如下的：</p>\n<ul>\n<li>对象 O 本身</li>\n<li>M方法的传入参数</li>\n<li>M方法中创建或实例化的任意对象</li>\n<li>对象 O 直接的组件对象</li>\n<li>在M范围内，可被O访问的全局变量</li>\n</ul>\n</blockquote>\n</li>\n<li><p>我们使用元程序的设计<br>使用我们上面提到的纯文本工具，将我们的配置等抽离出来。将抽象放进代码，将细节放进元数据。</p>\n</li>\n<li><p>我们将时间解耦<br>将那些时间上不互相依赖的模块解耦，提高并发性。</p>\n</li>\n<li><p>使用合适的软件架构，如：<br>使用 MVC 架构，将视图和模型分开<br>使用 Blackboard 架构，协调工作流。</p>\n</li>\n</ol>\n<h3 id=\"3-项目编程\"><a href=\"#3-项目编程\" class=\"headerlink\" title=\"3. 项目编程\"></a>3. 项目编程</h3><p>当我们编程的时候，应该首先保证程序的准确性，主要是两个方面：</p>\n<ul>\n<li>让错误尽可能早的体现出来，而不是让错误来破坏我们的代码。</li>\n<li>对于不可能发生的事情，应该使用<strong>断言</strong>确保它不会发生。</li>\n</ul>\n<p>另外，我们需要认清<strong>异常</strong>的意义：异常应该用于异常的问题，而不是那些我们自己需要前置判断的问题。比如我们的资源使用，必须考虑到<strong>资源配平</strong>的问题。</p>\n<p>其次，我们应在编程的过程中重视<strong>重构</strong>和<strong>测试</strong>的意义。</p>\n","excerpt":"<p>最近看了《程序员的修炼之道-从小工到专家》，里面讲的是怎样成为一个注重实效的程序员。讲的是程序员，但是其实中间的很多道理作为一个职场人来说，都是适用的。因为最近看得个人管理方面的书籍比较多，还是按照很多大师经常提到的<strong>道、术、器、用</strong>四个字来总结一下这本书，也是给自己的一个发展定位：我自己想要成为一个怎样的程序员。</p>","more":"<p><img src=\"http://ogf054qp1.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93-%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86%20%282%29.png\" alt=\"程序员的修炼之道\"></p>\n<h2 id=\"道：一个注重实效程序员需要秉持的理念\"><a href=\"#道：一个注重实效程序员需要秉持的理念\" class=\"headerlink\" title=\"道：一个注重实效程序员需要秉持的理念\"></a>道：一个注重实效程序员需要秉持的理念</h2><p>书的第一章的名字叫<em>注重实效的哲学</em>。其实不像很多人想的那样，程序员并不是一个冷冰冰的枯燥的集体。反而，程序员是更多善于思考的一个集体，不仅仅是对工作，对于人生、世界，程序员都有属于自己的解释。所以才会有这么多的程序员的纷争，从大了讲有自由与封建（开源/闭源）之争；往具体处说，又有诸如<strong>UNIX哲学</strong>等哲学流派。但作为一个注重实效的程序员，秉持的理念是怎样的、他的人生观应该是怎样的？这本书的第一章给开了个头。</p>\n<p>注重实效的程序员在编程的时候，他们是<strong>完美主义</strong>和<strong>实用主义</strong>的结合者。他们对自己的代码要求完美，对自己的<strong>错误负责</strong>，他们不能容忍破窗户的存在，因为它最终会导致一个失败的项目。但同时，他们也知道在什么时候止步，他们明白他们是在一个不完美的世界上开发代码的，所以他们通常把质量作为一种需求，而不是一个极大的简单期望。<br>但是他们的世界是<strong>宏观</strong>的，他们往往想要从更高的角度来思考问题。他们需要确认自己的每一步都是为了自己的最终愿景，每一行代码都是为了项目的完美实现。他们秉持着这样的价值观，不断的判断自己是否偏离了最终的方向。<br>另一方面，所有的高效的程序员都是进化论的支持者，所以他们十分注重自己的进化。他们往往会定期的<strong>投资自己</strong>，用知识不断武装自己，来适应不断更新的环境。同时，他们不断的同环境<strong>交流</strong>，很多时候是使用网络或者书面的形式。同时，他们会让自己的产品同样是可进化的化，具有<strong>可撤销性</strong>，来适应环境。<br>最终，是所有注重实效的程序员都坚持的一个原则：简单原则。他们会尽一切可能<strong>避免重复</strong>，尽一切的可能进行<strong>正交</strong>的操作。</p>\n<h2 id=\"术：实现高效的流程方法\"><a href=\"#术：实现高效的流程方法\" class=\"headerlink\" title=\"术：实现高效的流程方法\"></a>术：实现高效的流程方法</h2><p>根据上面的原则，我们有通常的几个规律来实现我们的项目。<br>当我们面对一个新的项目的时候，我们不应该过于详细的进行每个模块的设计，而是应该使用<strong>曳光弹</strong>，首先搭建起我们软件框架。随后，在我们缺的程序框架上进行完善。这样能够高效的优先确定我们的路径。<br>随后，当我们实现具体的功能的时候，我们可以使用<strong>原型</strong>，原型可以允许适当的忽略某些细节，来快速验证我们的想法。<br>针对具体的问题，我们应该刨除编程语言的干扰，靠近问题领域编程，使用领域语言对问题进行有针对性的开发。<br>另外两个适用的通用规律是<strong>估算</strong>和<strong>合约</strong>。我们应该使用合约对我们的项目需求和设计进行规范，我们应该使用估算对我们的项目建立模型，设定自己的计划，随后进行代码迭代。</p>\n<h2 id=\"器：带来效率提升的工具\"><a href=\"#器：带来效率提升的工具\" class=\"headerlink\" title=\"器：带来效率提升的工具\"></a>器：带来效率提升的工具</h2><p>从思想上提高了认识之后，我们可以从工具着手提高我们的效率。当然最先确定应该是我们的<strong>编辑器</strong>，一个高效的编辑器应该满足下面的特点：</p>\n<ul>\n<li>可配置 </li>\n<li>可扩展</li>\n<li>可编程<br>使用适当的编辑器可以快速的帮助我们提高生产效率。此外我们应该使用适当的<strong>调试工具</strong>，及时的进行我们的测试和错误跟踪。随后我们应学会使用<strong>源码控制工具</strong>，使用源码控制工具不仅可以帮助撤销错误的操作，还可以让我们能够快速的定位错误，自动化的进行测试。这是最重要的三个工具，另外一些可以提高我们工作效率的工具是：</li>\n<li><strong>纯文本</strong>，它可以用来保存我们的配置、数据、历史工作等，这是一种通用不过时的工具，可以协同我们的开发、测试，且不受特定语言和系统的影响。</li>\n<li><strong>命令行工具</strong>和<strong>脚本语言</strong>，有效的利用这两者一方面可以让我更加深入的使用计算机的很多功能，另一方面提供了我们自动化的方式来进行的我们的编码、测试、乃至快捷地搭建我们的架构。同时可以帮助我们编写自己的<strong>代码生成器</strong>，避免我们进行重复的工作。</li>\n</ul>\n<h2 id=\"用：践行高效的过程\"><a href=\"#用：践行高效的过程\" class=\"headerlink\" title=\"用：践行高效的过程\"></a>用：践行高效的过程</h2><h3 id=\"1-项目之前\"><a href=\"#1-项目之前\" class=\"headerlink\" title=\"1. 项目之前\"></a>1. 项目之前</h3><p>在一个项目开始之前，我们需要的是深入挖掘需求，按照合约设计的方法，规范我们的项目。我们应该找到我们的设计的边际，找到我们真正的约束。</p>\n<h3 id=\"2-项目架构\"><a href=\"#2-项目架构\" class=\"headerlink\" title=\"2. 项目架构\"></a>2. 项目架构</h3><p>对于软件的架构，如上所说，应遵顼<strong>正交性</strong>的原则，这就要求我们将我们模块之间的耦合降低至最低，有下面的方法帮助我们实现这个目的：</p>\n<ol>\n<li><p>我们按照德墨忒耳法则来编写代码：</p>\n<blockquote>\n<p>得墨忒耳定律－－对象 O 的 M 方法，可以访问/调用如下的：</p>\n<ul>\n<li>对象 O 本身</li>\n<li>M方法的传入参数</li>\n<li>M方法中创建或实例化的任意对象</li>\n<li>对象 O 直接的组件对象</li>\n<li>在M范围内，可被O访问的全局变量</li>\n</ul>\n</blockquote>\n</li>\n<li><p>我们使用元程序的设计<br>使用我们上面提到的纯文本工具，将我们的配置等抽离出来。将抽象放进代码，将细节放进元数据。</p>\n</li>\n<li><p>我们将时间解耦<br>将那些时间上不互相依赖的模块解耦，提高并发性。</p>\n</li>\n<li><p>使用合适的软件架构，如：<br>使用 MVC 架构，将视图和模型分开<br>使用 Blackboard 架构，协调工作流。</p>\n</li>\n</ol>\n<h3 id=\"3-项目编程\"><a href=\"#3-项目编程\" class=\"headerlink\" title=\"3. 项目编程\"></a>3. 项目编程</h3><p>当我们编程的时候，应该首先保证程序的准确性，主要是两个方面：</p>\n<ul>\n<li>让错误尽可能早的体现出来，而不是让错误来破坏我们的代码。</li>\n<li>对于不可能发生的事情，应该使用<strong>断言</strong>确保它不会发生。</li>\n</ul>\n<p>另外，我们需要认清<strong>异常</strong>的意义：异常应该用于异常的问题，而不是那些我们自己需要前置判断的问题。比如我们的资源使用，必须考虑到<strong>资源配平</strong>的问题。</p>\n<p>其次，我们应在编程的过程中重视<strong>重构</strong>和<strong>测试</strong>的意义。</p>"},{"title":"操作系统命名规范","date":"2017-02-24T05:22:03.000Z","_content":"之前在交叉使用 Linux 和 Windows 的时候，经常遇到 Windows 下命名的文件，在 Linux 下读取不一致的情况，通常是由于命名不规范导致。所以，我把常见的操作系统的命名规范在网上搜索了以下，记录在这里。\n<!--more-->\n|操作系统|命名长度|允许字符|\n|--|--|--|\n|ISO 9660 标准|8 个字符及点号及 3 个字母的扩展名|字母、数字及 _|\n|DOS 和 Windows 3.x （ FAT 文件系统）|8 个字符及点号及 3 个字母的扩展名|字母、数字及 _, -, $, %, ', `, -, @, ^, !, &, [, ], (, ), #|\n|Windows/NT,NFS 和 Windows 95 VFAT, Windows 98 FAT32|最多250 个| 除了以下字符其余均可： \\,/,*,”,<,>,\\||\n|Macintosh|最多 31 个字符|除了字符 : 其余均可|\n|UNIX|最多 255 个字符|除了字符 / 及空格其余均可|\n\n### 参考:\n[Linux Windows等操作系统文件名命名规范](http://www.linuxidc.com/Linux/2012-03/56993.htm)","source":"_posts/操作系统命名规范.md","raw":"---\ntitle: 操作系统命名规范\ndate: 2017-02-24 13:22:03\ncategories: \ntags: [操作系统, 文件命名, Linux]\n---\n之前在交叉使用 Linux 和 Windows 的时候，经常遇到 Windows 下命名的文件，在 Linux 下读取不一致的情况，通常是由于命名不规范导致。所以，我把常见的操作系统的命名规范在网上搜索了以下，记录在这里。\n<!--more-->\n|操作系统|命名长度|允许字符|\n|--|--|--|\n|ISO 9660 标准|8 个字符及点号及 3 个字母的扩展名|字母、数字及 _|\n|DOS 和 Windows 3.x （ FAT 文件系统）|8 个字符及点号及 3 个字母的扩展名|字母、数字及 _, -, $, %, ', `, -, @, ^, !, &, [, ], (, ), #|\n|Windows/NT,NFS 和 Windows 95 VFAT, Windows 98 FAT32|最多250 个| 除了以下字符其余均可： \\,/,*,”,<,>,\\||\n|Macintosh|最多 31 个字符|除了字符 : 其余均可|\n|UNIX|最多 255 个字符|除了字符 / 及空格其余均可|\n\n### 参考:\n[Linux Windows等操作系统文件名命名规范](http://www.linuxidc.com/Linux/2012-03/56993.htm)","slug":"操作系统命名规范","published":1,"updated":"2017-12-06T13:44:43.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n23002mbkw1qswtyx6f","content":"<p>之前在交叉使用 Linux 和 Windows 的时候，经常遇到 Windows 下命名的文件，在 Linux 下读取不一致的情况，通常是由于命名不规范导致。所以，我把常见的操作系统的命名规范在网上搜索了以下，记录在这里。<br><a id=\"more\"></a><br>|操作系统|命名长度|允许字符|<br>|–|–|–|<br>|ISO 9660 标准|8 个字符及点号及 3 个字母的扩展名|字母、数字及 <em>|<br>|DOS 和 Windows 3.x （ FAT 文件系统）|8 个字符及点号及 3 个字母的扩展名|字母、数字及 </em>, -, $, %, ‘, `, -, @, ^, !, &amp;, [, ], (, ), #|<br>|Windows/NT,NFS 和 Windows 95 VFAT, Windows 98 FAT32|最多250 个| 除了以下字符其余均可： \\,/,*,”,&lt;,&gt;,||<br>|Macintosh|最多 31 个字符|除了字符 : 其余均可|<br>|UNIX|最多 255 个字符|除了字符 / 及空格其余均可|</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h3><p><a href=\"http://www.linuxidc.com/Linux/2012-03/56993.htm\" target=\"_blank\" rel=\"external\">Linux Windows等操作系统文件名命名规范</a></p>\n","excerpt":"<p>之前在交叉使用 Linux 和 Windows 的时候，经常遇到 Windows 下命名的文件，在 Linux 下读取不一致的情况，通常是由于命名不规范导致。所以，我把常见的操作系统的命名规范在网上搜索了以下，记录在这里。<br>","more":"<br>|操作系统|命名长度|允许字符|<br>|–|–|–|<br>|ISO 9660 标准|8 个字符及点号及 3 个字母的扩展名|字母、数字及 <em>|<br>|DOS 和 Windows 3.x （ FAT 文件系统）|8 个字符及点号及 3 个字母的扩展名|字母、数字及 </em>, -, $, %, ‘, `, -, @, ^, !, &amp;, [, ], (, ), #|<br>|Windows/NT,NFS 和 Windows 95 VFAT, Windows 98 FAT32|最多250 个| 除了以下字符其余均可： \\,/,*,”,&lt;,&gt;,||<br>|Macintosh|最多 31 个字符|除了字符 : 其余均可|<br>|UNIX|最多 255 个字符|除了字符 / 及空格其余均可|</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h3><p><a href=\"http://www.linuxidc.com/Linux/2012-03/56993.htm\">Linux Windows等操作系统文件名命名规范</a></p>"},{"title":"环境变量总结","date":"2016-11-26T13:30:19.000Z","_content":"本篇对经常使用的环境变量进行总结。\n<!--more-->\n## 环境变量是什么：\n环境变量是操作系统中指定操作系统或者应用程序运行的一些**参数**，可以看作是系统的**全局变量**。可以分为系统级变量和用户级变量。  \n当要求系统运行一个程序却没有指定完整的路径时，首先会在当前目录下寻找相应的可执行文件，当没有符合条件的文件时，会到path指定的路径下寻找。  \n当程序运行需要一些参数时，可以通过环境变量将需要的参数传递进去。\n## 环境变量有什么用：\n解决未指定路径的应用程序运行。  \n解决双系统下软件共用的问题：当一些软件运行时需要写入注册表的文件时，可以通过环境变量更改完成共用，具体见具体的文件。  \n设置一些软件或者体系的运行环境时。\n\n## Ubuntu环境变量设置\n\n### 一些有关环境变量的命令\n1. **echo** 显示某个环境变量值echo $PATH\n2. **export** 设置一个新的环境变量export HELLO=hello (可以无引号)\n3. **env** 显示所有环境变量\n4. **set** 显示本地定义的shell变量\n5. **unset** 清除环境变量unset HELLO\n6. **readonly** 设置只读环境变量readonly HELLO\n\n## 2. Linux的变量种类\n\n按变量的生存周期来划分，Linux变量可分为两类：\n- 永久的：需要修改配置文件，变量永久生效。\n- 临时的：使用export命令声明即可，变量在关闭shell时失效。\n\n### 设置变量的三种方法\n- 在/etc/profile文件中添加变量【对 **所有用户** 生效 **永久的**】\n\n  用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是**永久的**;例如：编辑/etc/profile文件，添加CLASSPATH变量\n\n            vi /etc/profile\n            export CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n\n  > 修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。\n- 在用户目录下的.bash\\_profile文件中增加变量【对 **单一用户** 生效 **永久的**】\n\n  用VI在用户目录下的.bash\\_profile文件中增加变量，改变量仅会对当前用户有效，并且是**永久的**。例如：编辑guok用户目录(/home/guok)下的.bash\\_profile\n\n        $ vi /home/guok/.bash.profile\n        export CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n\n  >注：修改文件后要想马上生效还要运行$ source /home/guok/.bash\\_profile不然只能在下次重进此用户时生效。\n- 直接运行export命令定义变量【只对 **当前shell(BASH)** 有效 **临时的**】\n\n  在shell的命令行下直接使用`[export 变量名=变量值]`定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。\n\n### 环境变量的查看\n- 使用`echo`命令查看单个环境变量。例如：`echo $PATH`\n- 使用`env`查看所有环境变量。\n- 使用`set`查看所有本地定义的环境变量,`unset`可以删除指定的环境变量。\n\n### Ubuntu下都有那些软件需要设置环境变量？\n\n`PATH`：指定命令的搜索路径\n`HOME`：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）\n`HISTSIZE`：指保存历史命令记录的条数。\n`LOGNAME`：指当前用户的登录名。\n`HOSTNAME`：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。\n`SHELL`：指当前用户用的是哪种Shell。\n`LANG/LANGUGE`：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。\n`MAIL`：指当前用户的邮件存放目录。\n`PS1`：命令基本提示符，对于root用户是#，对于普通用户是$。\n`PS2`：附属提示符，默认是&gt;。\n\n## windows环境变量设置\n### 有两种方法可以设置windows的环境变量：\n1. 可以通过命令行set的方式设定，具体的命令有：\n    - `set` 打印所有的环境变量\n    - `set 变量名 =`   清空某个环境变量\n    - `set 变量名 = 内容`   设置某个变量内容\n    - `set 变量名 = %变量名%内容`  追加变量内容\n2. 可以在窗口修改\n\n第一种修改方法仅在当前窗口内有效。\n第二种修改方法全局生效。\n\n### 都有那些环境变量？\n\n`%ALLUSERSPROFILE%` 局部 返回所有用户配置文件的位置。  \n`%APPDATA%` 局部 返回默认情况下应用程序存储数据的位置。  \n`%CD%` 局部 返回当前目录字符串。  \n`%CMDCMDLINE%` 局部 返回用来启动当前的 Cmd.exe 的准确命令行。  \n`%CMDEXTVERSION%` 系统 返回当前的命令处理程序扩展的版本号。  \n`%COMPUTERNAME%` 系统 返回计算机的名称。  \n`%COMSPEC%` 系统 返回命令行解释器可执行程序的准确路径。  \n`%DATE%` 系统 返回当前日期。  \n`%ERRORLEVEL%` 系统 返回最近使用过的命令的错误代码。通常用非零值表示错误。  \n`%HOMEDRIVE%` 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值的设置。用户主目录是在本地用户和组中指定的。  \n`%HOMEPATH%` 系统 返回用户主目录的完整路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。  \n`%HOMESHARE%` 系统 返回用户的共享主目录的网络路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。  \n`%LOGONSEVER%` 局部 返回验证当前登录会话的域控制器的名称。  \n`%NUMBER\\_OF\\_PROCESSORS%` 系统 指定安装在计算机上的处理器的数目。  \n`%OS%` 系统 返回操作系统的名称。Windows 2000 将操作系统显示为 Windows\\_NT。  \n`%PATH%` 系统 指定可执行文件的搜索路径。  \n`%PATHEXT%` 系统 返回操作系统认为可执行的文件扩展名的列表。  \n`%PROCESSOR\\_ARCHITECTURE%` 系统 返回处理器的芯片体系结构。值: x86，IA64。  \n`%PROCESSOR\\_IDENTFIER%` 系统 返回处理器说明。  \n`%PROCESSOR\\_LEVEL%` 系统 返回计算机上安装的处理器的型号。  \n`%PROCESSOR\\_REVISION%` 系统 返回处理器修订号的系统变量。  \n`%PROMPT%` 局部 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。  \n`%RANDOM%` 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。  \n`%SYSTEMDRIVE%` 系统 返回包含 Windows XP 根目录（即系统根目录）的驱动器。  \n`%SYSTEMROOT%` 系统 返回 Windows XP 根目录的位置。  \n`%TEMP%` and %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其它应用程序则需要 TMP。  \n`%TIME%` 系统 返回当前时间。  \n`%USERDOMAIN%` 局部 返回包含用户帐户的域的名称。  \n`%USERNAME%` 局部 返回当前登录的用户的名称。  \n`%UserProfile%` 局部 返回当前用户的配置文件的位置。  \n`%WINDIR%` 系统 返回操作系统目录的位置。  \n\n## Java环境变量的设置\n### Java都需要设置那些环境变量？\n`JAVA\\_HOME` 指明JDK安装路径.(在安装好java之后就该配置)\n`Path`使得系统可以在任何路径下识别java命令.(如果你采用命令形式编译java源码,设置这个很方便)\n`classpath`为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别它.\n\n### Java在windows和linux下配置环境变量\n\nwindows：系统设置  分别设置这三项。\n\nLinux：\n\n1. 修改`/etc/profile`文件  \n  如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。\n\n    - 用文本编辑器打开/etc/profile\n    - 在profile文件末尾加入：\n\n            export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\n            export PATH=$JAVA\\_HOME/bin:$PATH\n            export CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n\n    - 重新登录\n\n    > 注解\n        1. 你要将 /usr/share/jdk1.6.0\\_14改为你的jdk安装目录  \n        2. linux下用冒号:来分隔路径  \n        3. $PATH / $CLASSPATH / $JAVA\\_HOME 是用来引用原来的环境变量的值  \n        在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。  \n        4. CLASSPATH中当前目录.不能丢,把当前目录丢掉也是常见的错误。  \n        5. export是把这三个变量导出为全局变量。  \n        6. 大小写必须严格区分。  \n\n2. 修改`.bash\\_profile`文件\n\n   这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash\\_profile文件就可以了。\n\n    - 用文本编辑器打开用户目录下的.bash\\_profile文件\n    - 在.bash\\_profile文件末尾加入：\n\n            export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\n            export PATH=$JAVA\\_HOME/bin:$PATH\n            export CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n\n    - 重新登录\n\n3. 直接在shell下设置变量\n\n   不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。\n\n    - 只需在shell终端执行下列命令：\n\n            export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\n            export PATH=$JAVA\\_HOME/bin:$PATH\n            export CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n\n## 引用来源\n[http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html](http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html)\n[http://blog.chinaunix.net/uid-27135166-id-3304153.html](http://blog.chinaunix.net/uid-27135166-id-3304153.html)\n[http://www.jb51.net/LINUXjishu/77524.html](http://www.jb51.net/LINUXjishu/77524.html)\n[http://blog.chinaunix.net/uid-27135166-id-3304153.html](http://blog.chinaunix.net/uid-27135166-id-3304153.html)\n[http://blog.csdn.net/fb281906011/article/details/8057672](http://blog.csdn.net/fb281906011/article/details/8057672)\n[http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html](http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html)","source":"_posts/环境变量总结.md","raw":"---\ntitle: 环境变量总结\ndate: 2016-11-26 21:30:19\ncategories: [学习记录]\ntags: [环境变量]\n---\n本篇对经常使用的环境变量进行总结。\n<!--more-->\n## 环境变量是什么：\n环境变量是操作系统中指定操作系统或者应用程序运行的一些**参数**，可以看作是系统的**全局变量**。可以分为系统级变量和用户级变量。  \n当要求系统运行一个程序却没有指定完整的路径时，首先会在当前目录下寻找相应的可执行文件，当没有符合条件的文件时，会到path指定的路径下寻找。  \n当程序运行需要一些参数时，可以通过环境变量将需要的参数传递进去。\n## 环境变量有什么用：\n解决未指定路径的应用程序运行。  \n解决双系统下软件共用的问题：当一些软件运行时需要写入注册表的文件时，可以通过环境变量更改完成共用，具体见具体的文件。  \n设置一些软件或者体系的运行环境时。\n\n## Ubuntu环境变量设置\n\n### 一些有关环境变量的命令\n1. **echo** 显示某个环境变量值echo $PATH\n2. **export** 设置一个新的环境变量export HELLO=hello (可以无引号)\n3. **env** 显示所有环境变量\n4. **set** 显示本地定义的shell变量\n5. **unset** 清除环境变量unset HELLO\n6. **readonly** 设置只读环境变量readonly HELLO\n\n## 2. Linux的变量种类\n\n按变量的生存周期来划分，Linux变量可分为两类：\n- 永久的：需要修改配置文件，变量永久生效。\n- 临时的：使用export命令声明即可，变量在关闭shell时失效。\n\n### 设置变量的三种方法\n- 在/etc/profile文件中添加变量【对 **所有用户** 生效 **永久的**】\n\n  用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是**永久的**;例如：编辑/etc/profile文件，添加CLASSPATH变量\n\n            vi /etc/profile\n            export CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n\n  > 修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。\n- 在用户目录下的.bash\\_profile文件中增加变量【对 **单一用户** 生效 **永久的**】\n\n  用VI在用户目录下的.bash\\_profile文件中增加变量，改变量仅会对当前用户有效，并且是**永久的**。例如：编辑guok用户目录(/home/guok)下的.bash\\_profile\n\n        $ vi /home/guok/.bash.profile\n        export CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n\n  >注：修改文件后要想马上生效还要运行$ source /home/guok/.bash\\_profile不然只能在下次重进此用户时生效。\n- 直接运行export命令定义变量【只对 **当前shell(BASH)** 有效 **临时的**】\n\n  在shell的命令行下直接使用`[export 变量名=变量值]`定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。\n\n### 环境变量的查看\n- 使用`echo`命令查看单个环境变量。例如：`echo $PATH`\n- 使用`env`查看所有环境变量。\n- 使用`set`查看所有本地定义的环境变量,`unset`可以删除指定的环境变量。\n\n### Ubuntu下都有那些软件需要设置环境变量？\n\n`PATH`：指定命令的搜索路径\n`HOME`：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）\n`HISTSIZE`：指保存历史命令记录的条数。\n`LOGNAME`：指当前用户的登录名。\n`HOSTNAME`：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。\n`SHELL`：指当前用户用的是哪种Shell。\n`LANG/LANGUGE`：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。\n`MAIL`：指当前用户的邮件存放目录。\n`PS1`：命令基本提示符，对于root用户是#，对于普通用户是$。\n`PS2`：附属提示符，默认是&gt;。\n\n## windows环境变量设置\n### 有两种方法可以设置windows的环境变量：\n1. 可以通过命令行set的方式设定，具体的命令有：\n    - `set` 打印所有的环境变量\n    - `set 变量名 =`   清空某个环境变量\n    - `set 变量名 = 内容`   设置某个变量内容\n    - `set 变量名 = %变量名%内容`  追加变量内容\n2. 可以在窗口修改\n\n第一种修改方法仅在当前窗口内有效。\n第二种修改方法全局生效。\n\n### 都有那些环境变量？\n\n`%ALLUSERSPROFILE%` 局部 返回所有用户配置文件的位置。  \n`%APPDATA%` 局部 返回默认情况下应用程序存储数据的位置。  \n`%CD%` 局部 返回当前目录字符串。  \n`%CMDCMDLINE%` 局部 返回用来启动当前的 Cmd.exe 的准确命令行。  \n`%CMDEXTVERSION%` 系统 返回当前的命令处理程序扩展的版本号。  \n`%COMPUTERNAME%` 系统 返回计算机的名称。  \n`%COMSPEC%` 系统 返回命令行解释器可执行程序的准确路径。  \n`%DATE%` 系统 返回当前日期。  \n`%ERRORLEVEL%` 系统 返回最近使用过的命令的错误代码。通常用非零值表示错误。  \n`%HOMEDRIVE%` 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值的设置。用户主目录是在本地用户和组中指定的。  \n`%HOMEPATH%` 系统 返回用户主目录的完整路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。  \n`%HOMESHARE%` 系统 返回用户的共享主目录的网络路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。  \n`%LOGONSEVER%` 局部 返回验证当前登录会话的域控制器的名称。  \n`%NUMBER\\_OF\\_PROCESSORS%` 系统 指定安装在计算机上的处理器的数目。  \n`%OS%` 系统 返回操作系统的名称。Windows 2000 将操作系统显示为 Windows\\_NT。  \n`%PATH%` 系统 指定可执行文件的搜索路径。  \n`%PATHEXT%` 系统 返回操作系统认为可执行的文件扩展名的列表。  \n`%PROCESSOR\\_ARCHITECTURE%` 系统 返回处理器的芯片体系结构。值: x86，IA64。  \n`%PROCESSOR\\_IDENTFIER%` 系统 返回处理器说明。  \n`%PROCESSOR\\_LEVEL%` 系统 返回计算机上安装的处理器的型号。  \n`%PROCESSOR\\_REVISION%` 系统 返回处理器修订号的系统变量。  \n`%PROMPT%` 局部 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。  \n`%RANDOM%` 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。  \n`%SYSTEMDRIVE%` 系统 返回包含 Windows XP 根目录（即系统根目录）的驱动器。  \n`%SYSTEMROOT%` 系统 返回 Windows XP 根目录的位置。  \n`%TEMP%` and %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其它应用程序则需要 TMP。  \n`%TIME%` 系统 返回当前时间。  \n`%USERDOMAIN%` 局部 返回包含用户帐户的域的名称。  \n`%USERNAME%` 局部 返回当前登录的用户的名称。  \n`%UserProfile%` 局部 返回当前用户的配置文件的位置。  \n`%WINDIR%` 系统 返回操作系统目录的位置。  \n\n## Java环境变量的设置\n### Java都需要设置那些环境变量？\n`JAVA\\_HOME` 指明JDK安装路径.(在安装好java之后就该配置)\n`Path`使得系统可以在任何路径下识别java命令.(如果你采用命令形式编译java源码,设置这个很方便)\n`classpath`为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别它.\n\n### Java在windows和linux下配置环境变量\n\nwindows：系统设置  分别设置这三项。\n\nLinux：\n\n1. 修改`/etc/profile`文件  \n  如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。\n\n    - 用文本编辑器打开/etc/profile\n    - 在profile文件末尾加入：\n\n            export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\n            export PATH=$JAVA\\_HOME/bin:$PATH\n            export CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n\n    - 重新登录\n\n    > 注解\n        1. 你要将 /usr/share/jdk1.6.0\\_14改为你的jdk安装目录  \n        2. linux下用冒号:来分隔路径  \n        3. $PATH / $CLASSPATH / $JAVA\\_HOME 是用来引用原来的环境变量的值  \n        在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。  \n        4. CLASSPATH中当前目录.不能丢,把当前目录丢掉也是常见的错误。  \n        5. export是把这三个变量导出为全局变量。  \n        6. 大小写必须严格区分。  \n\n2. 修改`.bash\\_profile`文件\n\n   这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash\\_profile文件就可以了。\n\n    - 用文本编辑器打开用户目录下的.bash\\_profile文件\n    - 在.bash\\_profile文件末尾加入：\n\n            export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\n            export PATH=$JAVA\\_HOME/bin:$PATH\n            export CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n\n    - 重新登录\n\n3. 直接在shell下设置变量\n\n   不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。\n\n    - 只需在shell终端执行下列命令：\n\n            export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\n            export PATH=$JAVA\\_HOME/bin:$PATH\n            export CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n\n## 引用来源\n[http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html](http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html)\n[http://blog.chinaunix.net/uid-27135166-id-3304153.html](http://blog.chinaunix.net/uid-27135166-id-3304153.html)\n[http://www.jb51.net/LINUXjishu/77524.html](http://www.jb51.net/LINUXjishu/77524.html)\n[http://blog.chinaunix.net/uid-27135166-id-3304153.html](http://blog.chinaunix.net/uid-27135166-id-3304153.html)\n[http://blog.csdn.net/fb281906011/article/details/8057672](http://blog.csdn.net/fb281906011/article/details/8057672)\n[http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html](http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html)","slug":"环境变量总结","published":1,"updated":"2017-12-06T13:50:47.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n4f0088bkw1y0nzn7xk","content":"<p>本篇对经常使用的环境变量进行总结。<br><a id=\"more\"></a></p>\n<h2 id=\"环境变量是什么：\"><a href=\"#环境变量是什么：\" class=\"headerlink\" title=\"环境变量是什么：\"></a>环境变量是什么：</h2><p>环境变量是操作系统中指定操作系统或者应用程序运行的一些<strong>参数</strong>，可以看作是系统的<strong>全局变量</strong>。可以分为系统级变量和用户级变量。<br>当要求系统运行一个程序却没有指定完整的路径时，首先会在当前目录下寻找相应的可执行文件，当没有符合条件的文件时，会到path指定的路径下寻找。<br>当程序运行需要一些参数时，可以通过环境变量将需要的参数传递进去。</p>\n<h2 id=\"环境变量有什么用：\"><a href=\"#环境变量有什么用：\" class=\"headerlink\" title=\"环境变量有什么用：\"></a>环境变量有什么用：</h2><p>解决未指定路径的应用程序运行。<br>解决双系统下软件共用的问题：当一些软件运行时需要写入注册表的文件时，可以通过环境变量更改完成共用，具体见具体的文件。<br>设置一些软件或者体系的运行环境时。</p>\n<h2 id=\"Ubuntu环境变量设置\"><a href=\"#Ubuntu环境变量设置\" class=\"headerlink\" title=\"Ubuntu环境变量设置\"></a>Ubuntu环境变量设置</h2><h3 id=\"一些有关环境变量的命令\"><a href=\"#一些有关环境变量的命令\" class=\"headerlink\" title=\"一些有关环境变量的命令\"></a>一些有关环境变量的命令</h3><ol>\n<li><strong>echo</strong> 显示某个环境变量值echo $PATH</li>\n<li><strong>export</strong> 设置一个新的环境变量export HELLO=hello (可以无引号)</li>\n<li><strong>env</strong> 显示所有环境变量</li>\n<li><strong>set</strong> 显示本地定义的shell变量</li>\n<li><strong>unset</strong> 清除环境变量unset HELLO</li>\n<li><strong>readonly</strong> 设置只读环境变量readonly HELLO</li>\n</ol>\n<h2 id=\"2-Linux的变量种类\"><a href=\"#2-Linux的变量种类\" class=\"headerlink\" title=\"2. Linux的变量种类\"></a>2. Linux的变量种类</h2><p>按变量的生存周期来划分，Linux变量可分为两类：</p>\n<ul>\n<li>永久的：需要修改配置文件，变量永久生效。</li>\n<li>临时的：使用export命令声明即可，变量在关闭shell时失效。</li>\n</ul>\n<h3 id=\"设置变量的三种方法\"><a href=\"#设置变量的三种方法\" class=\"headerlink\" title=\"设置变量的三种方法\"></a>设置变量的三种方法</h3><ul>\n<li><p>在/etc/profile文件中添加变量【对 <strong>所有用户</strong> 生效 <strong>永久的</strong>】</p>\n<p>用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是<strong>永久的</strong>;例如：编辑/etc/profile文件，添加CLASSPATH变量</p>\n<pre><code>vi /etc/profile\nexport CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n</code></pre><blockquote>\n<p>修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。</p>\n</blockquote>\n</li>\n<li><p>在用户目录下的.bash_profile文件中增加变量【对 <strong>单一用户</strong> 生效 <strong>永久的</strong>】</p>\n<p>用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是<strong>永久的</strong>。例如：编辑guok用户目录(/home/guok)下的.bash_profile</p>\n<pre><code>$ vi /home/guok/.bash.profile\nexport CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n</code></pre><blockquote>\n<p>注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。</p>\n</blockquote>\n</li>\n<li><p>直接运行export命令定义变量【只对 <strong>当前shell(BASH)</strong> 有效 <strong>临时的</strong>】</p>\n<p>在shell的命令行下直接使用<code>[export 变量名=变量值]</code>定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p>\n</li>\n</ul>\n<h3 id=\"环境变量的查看\"><a href=\"#环境变量的查看\" class=\"headerlink\" title=\"环境变量的查看\"></a>环境变量的查看</h3><ul>\n<li>使用<code>echo</code>命令查看单个环境变量。例如：<code>echo $PATH</code></li>\n<li>使用<code>env</code>查看所有环境变量。</li>\n<li>使用<code>set</code>查看所有本地定义的环境变量,<code>unset</code>可以删除指定的环境变量。</li>\n</ul>\n<h3 id=\"Ubuntu下都有那些软件需要设置环境变量？\"><a href=\"#Ubuntu下都有那些软件需要设置环境变量？\" class=\"headerlink\" title=\"Ubuntu下都有那些软件需要设置环境变量？\"></a>Ubuntu下都有那些软件需要设置环境变量？</h3><p><code>PATH</code>：指定命令的搜索路径<br><code>HOME</code>：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）<br><code>HISTSIZE</code>：指保存历史命令记录的条数。<br><code>LOGNAME</code>：指当前用户的登录名。<br><code>HOSTNAME</code>：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。<br><code>SHELL</code>：指当前用户用的是哪种Shell。<br><code>LANG/LANGUGE</code>：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。<br><code>MAIL</code>：指当前用户的邮件存放目录。<br><code>PS1</code>：命令基本提示符，对于root用户是#，对于普通用户是$。<br><code>PS2</code>：附属提示符，默认是&gt;。</p>\n<h2 id=\"windows环境变量设置\"><a href=\"#windows环境变量设置\" class=\"headerlink\" title=\"windows环境变量设置\"></a>windows环境变量设置</h2><h3 id=\"有两种方法可以设置windows的环境变量：\"><a href=\"#有两种方法可以设置windows的环境变量：\" class=\"headerlink\" title=\"有两种方法可以设置windows的环境变量：\"></a>有两种方法可以设置windows的环境变量：</h3><ol>\n<li>可以通过命令行set的方式设定，具体的命令有：<ul>\n<li><code>set</code> 打印所有的环境变量</li>\n<li><code>set 变量名 =</code>   清空某个环境变量</li>\n<li><code>set 变量名 = 内容</code>   设置某个变量内容</li>\n<li><code>set 变量名 = %变量名%内容</code>  追加变量内容</li>\n</ul>\n</li>\n<li>可以在窗口修改</li>\n</ol>\n<p>第一种修改方法仅在当前窗口内有效。<br>第二种修改方法全局生效。</p>\n<h3 id=\"都有那些环境变量？\"><a href=\"#都有那些环境变量？\" class=\"headerlink\" title=\"都有那些环境变量？\"></a>都有那些环境变量？</h3><p><code>%ALLUSERSPROFILE%</code> 局部 返回所有用户配置文件的位置。<br><code>%APPDATA%</code> 局部 返回默认情况下应用程序存储数据的位置。<br><code>%CD%</code> 局部 返回当前目录字符串。<br><code>%CMDCMDLINE%</code> 局部 返回用来启动当前的 Cmd.exe 的准确命令行。<br><code>%CMDEXTVERSION%</code> 系统 返回当前的命令处理程序扩展的版本号。<br><code>%COMPUTERNAME%</code> 系统 返回计算机的名称。<br><code>%COMSPEC%</code> 系统 返回命令行解释器可执行程序的准确路径。<br><code>%DATE%</code> 系统 返回当前日期。<br><code>%ERRORLEVEL%</code> 系统 返回最近使用过的命令的错误代码。通常用非零值表示错误。<br><code>%HOMEDRIVE%</code> 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值的设置。用户主目录是在本地用户和组中指定的。<br><code>%HOMEPATH%</code> 系统 返回用户主目录的完整路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。<br><code>%HOMESHARE%</code> 系统 返回用户的共享主目录的网络路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。<br><code>%LOGONSEVER%</code> 局部 返回验证当前登录会话的域控制器的名称。<br><code>%NUMBER\\_OF\\_PROCESSORS%</code> 系统 指定安装在计算机上的处理器的数目。<br><code>%OS%</code> 系统 返回操作系统的名称。Windows 2000 将操作系统显示为 Windows_NT。<br><code>%PATH%</code> 系统 指定可执行文件的搜索路径。<br><code>%PATHEXT%</code> 系统 返回操作系统认为可执行的文件扩展名的列表。<br><code>%PROCESSOR\\_ARCHITECTURE%</code> 系统 返回处理器的芯片体系结构。值: x86，IA64。<br><code>%PROCESSOR\\_IDENTFIER%</code> 系统 返回处理器说明。<br><code>%PROCESSOR\\_LEVEL%</code> 系统 返回计算机上安装的处理器的型号。<br><code>%PROCESSOR\\_REVISION%</code> 系统 返回处理器修订号的系统变量。<br><code>%PROMPT%</code> 局部 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。<br><code>%RANDOM%</code> 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。<br><code>%SYSTEMDRIVE%</code> 系统 返回包含 Windows XP 根目录（即系统根目录）的驱动器。<br><code>%SYSTEMROOT%</code> 系统 返回 Windows XP 根目录的位置。<br><code>%TEMP%</code> and %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其它应用程序则需要 TMP。<br><code>%TIME%</code> 系统 返回当前时间。<br><code>%USERDOMAIN%</code> 局部 返回包含用户帐户的域的名称。<br><code>%USERNAME%</code> 局部 返回当前登录的用户的名称。<br><code>%UserProfile%</code> 局部 返回当前用户的配置文件的位置。<br><code>%WINDIR%</code> 系统 返回操作系统目录的位置。  </p>\n<h2 id=\"Java环境变量的设置\"><a href=\"#Java环境变量的设置\" class=\"headerlink\" title=\"Java环境变量的设置\"></a>Java环境变量的设置</h2><h3 id=\"Java都需要设置那些环境变量？\"><a href=\"#Java都需要设置那些环境变量？\" class=\"headerlink\" title=\"Java都需要设置那些环境变量？\"></a>Java都需要设置那些环境变量？</h3><p><code>JAVA\\_HOME</code> 指明JDK安装路径.(在安装好java之后就该配置)<br><code>Path</code>使得系统可以在任何路径下识别java命令.(如果你采用命令形式编译java源码,设置这个很方便)<br><code>classpath</code>为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别它.</p>\n<h3 id=\"Java在windows和linux下配置环境变量\"><a href=\"#Java在windows和linux下配置环境变量\" class=\"headerlink\" title=\"Java在windows和linux下配置环境变量\"></a>Java在windows和linux下配置环境变量</h3><p>windows：系统设置  分别设置这三项。</p>\n<p>Linux：</p>\n<ol>\n<li><p>修改<code>/etc/profile</code>文件<br>如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。</p>\n<ul>\n<li>用文本编辑器打开/etc/profile</li>\n<li><p>在profile文件末尾加入：</p>\n<pre><code>export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\nexport PATH=$JAVA\\_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n</code></pre></li>\n<li><p>重新登录</p>\n<blockquote>\n<p>注解</p>\n<ol>\n<li>你要将 /usr/share/jdk1.6.0_14改为你的jdk安装目录  </li>\n<li>linux下用冒号:来分隔路径  </li>\n<li>$PATH / $CLASSPATH / $JAVA_HOME 是用来引用原来的环境变量的值<br>在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。  </li>\n<li>CLASSPATH中当前目录.不能丢,把当前目录丢掉也是常见的错误。  </li>\n<li>export是把这三个变量导出为全局变量。  </li>\n<li>大小写必须严格区分。  </li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>修改<code>.bash\\_profile</code>文件</p>\n<p>这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash_profile文件就可以了。</p>\n<ul>\n<li>用文本编辑器打开用户目录下的.bash_profile文件</li>\n<li><p>在.bash_profile文件末尾加入：</p>\n<pre><code>export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\nexport PATH=$JAVA\\_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n</code></pre></li>\n<li><p>重新登录</p>\n</li>\n</ul>\n</li>\n<li><p>直接在shell下设置变量</p>\n<p>不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。</p>\n<ul>\n<li><p>只需在shell终端执行下列命令：</p>\n<pre><code>export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\nexport PATH=$JAVA\\_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"引用来源\"><a href=\"#引用来源\" class=\"headerlink\" title=\"引用来源\"></a>引用来源</h2><p><a href=\"http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html</a><br><a href=\"http://blog.chinaunix.net/uid-27135166-id-3304153.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-27135166-id-3304153.html</a><br><a href=\"http://www.jb51.net/LINUXjishu/77524.html\" target=\"_blank\" rel=\"external\">http://www.jb51.net/LINUXjishu/77524.html</a><br><a href=\"http://blog.chinaunix.net/uid-27135166-id-3304153.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-27135166-id-3304153.html</a><br><a href=\"http://blog.csdn.net/fb281906011/article/details/8057672\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/fb281906011/article/details/8057672</a><br><a href=\"http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html</a></p>\n","excerpt":"<p>本篇对经常使用的环境变量进行总结。<br>","more":"</p>\n<h2 id=\"环境变量是什么：\"><a href=\"#环境变量是什么：\" class=\"headerlink\" title=\"环境变量是什么：\"></a>环境变量是什么：</h2><p>环境变量是操作系统中指定操作系统或者应用程序运行的一些<strong>参数</strong>，可以看作是系统的<strong>全局变量</strong>。可以分为系统级变量和用户级变量。<br>当要求系统运行一个程序却没有指定完整的路径时，首先会在当前目录下寻找相应的可执行文件，当没有符合条件的文件时，会到path指定的路径下寻找。<br>当程序运行需要一些参数时，可以通过环境变量将需要的参数传递进去。</p>\n<h2 id=\"环境变量有什么用：\"><a href=\"#环境变量有什么用：\" class=\"headerlink\" title=\"环境变量有什么用：\"></a>环境变量有什么用：</h2><p>解决未指定路径的应用程序运行。<br>解决双系统下软件共用的问题：当一些软件运行时需要写入注册表的文件时，可以通过环境变量更改完成共用，具体见具体的文件。<br>设置一些软件或者体系的运行环境时。</p>\n<h2 id=\"Ubuntu环境变量设置\"><a href=\"#Ubuntu环境变量设置\" class=\"headerlink\" title=\"Ubuntu环境变量设置\"></a>Ubuntu环境变量设置</h2><h3 id=\"一些有关环境变量的命令\"><a href=\"#一些有关环境变量的命令\" class=\"headerlink\" title=\"一些有关环境变量的命令\"></a>一些有关环境变量的命令</h3><ol>\n<li><strong>echo</strong> 显示某个环境变量值echo $PATH</li>\n<li><strong>export</strong> 设置一个新的环境变量export HELLO=hello (可以无引号)</li>\n<li><strong>env</strong> 显示所有环境变量</li>\n<li><strong>set</strong> 显示本地定义的shell变量</li>\n<li><strong>unset</strong> 清除环境变量unset HELLO</li>\n<li><strong>readonly</strong> 设置只读环境变量readonly HELLO</li>\n</ol>\n<h2 id=\"2-Linux的变量种类\"><a href=\"#2-Linux的变量种类\" class=\"headerlink\" title=\"2. Linux的变量种类\"></a>2. Linux的变量种类</h2><p>按变量的生存周期来划分，Linux变量可分为两类：</p>\n<ul>\n<li>永久的：需要修改配置文件，变量永久生效。</li>\n<li>临时的：使用export命令声明即可，变量在关闭shell时失效。</li>\n</ul>\n<h3 id=\"设置变量的三种方法\"><a href=\"#设置变量的三种方法\" class=\"headerlink\" title=\"设置变量的三种方法\"></a>设置变量的三种方法</h3><ul>\n<li><p>在/etc/profile文件中添加变量【对 <strong>所有用户</strong> 生效 <strong>永久的</strong>】</p>\n<p>用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是<strong>永久的</strong>;例如：编辑/etc/profile文件，添加CLASSPATH变量</p>\n<pre><code>vi /etc/profile\nexport CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n</code></pre><blockquote>\n<p>修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。</p>\n</blockquote>\n</li>\n<li><p>在用户目录下的.bash_profile文件中增加变量【对 <strong>单一用户</strong> 生效 <strong>永久的</strong>】</p>\n<p>用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是<strong>永久的</strong>。例如：编辑guok用户目录(/home/guok)下的.bash_profile</p>\n<pre><code>$ vi /home/guok/.bash.profile\nexport CLASSPATH=./JAVA\\_HOME/lib;$JAVA\\_HOME/jre/lib\n</code></pre><blockquote>\n<p>注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。</p>\n</blockquote>\n</li>\n<li><p>直接运行export命令定义变量【只对 <strong>当前shell(BASH)</strong> 有效 <strong>临时的</strong>】</p>\n<p>在shell的命令行下直接使用<code>[export 变量名=变量值]</code>定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p>\n</li>\n</ul>\n<h3 id=\"环境变量的查看\"><a href=\"#环境变量的查看\" class=\"headerlink\" title=\"环境变量的查看\"></a>环境变量的查看</h3><ul>\n<li>使用<code>echo</code>命令查看单个环境变量。例如：<code>echo $PATH</code></li>\n<li>使用<code>env</code>查看所有环境变量。</li>\n<li>使用<code>set</code>查看所有本地定义的环境变量,<code>unset</code>可以删除指定的环境变量。</li>\n</ul>\n<h3 id=\"Ubuntu下都有那些软件需要设置环境变量？\"><a href=\"#Ubuntu下都有那些软件需要设置环境变量？\" class=\"headerlink\" title=\"Ubuntu下都有那些软件需要设置环境变量？\"></a>Ubuntu下都有那些软件需要设置环境变量？</h3><p><code>PATH</code>：指定命令的搜索路径<br><code>HOME</code>：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）<br><code>HISTSIZE</code>：指保存历史命令记录的条数。<br><code>LOGNAME</code>：指当前用户的登录名。<br><code>HOSTNAME</code>：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。<br><code>SHELL</code>：指当前用户用的是哪种Shell。<br><code>LANG/LANGUGE</code>：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。<br><code>MAIL</code>：指当前用户的邮件存放目录。<br><code>PS1</code>：命令基本提示符，对于root用户是#，对于普通用户是$。<br><code>PS2</code>：附属提示符，默认是&gt;。</p>\n<h2 id=\"windows环境变量设置\"><a href=\"#windows环境变量设置\" class=\"headerlink\" title=\"windows环境变量设置\"></a>windows环境变量设置</h2><h3 id=\"有两种方法可以设置windows的环境变量：\"><a href=\"#有两种方法可以设置windows的环境变量：\" class=\"headerlink\" title=\"有两种方法可以设置windows的环境变量：\"></a>有两种方法可以设置windows的环境变量：</h3><ol>\n<li>可以通过命令行set的方式设定，具体的命令有：<ul>\n<li><code>set</code> 打印所有的环境变量</li>\n<li><code>set 变量名 =</code>   清空某个环境变量</li>\n<li><code>set 变量名 = 内容</code>   设置某个变量内容</li>\n<li><code>set 变量名 = %变量名%内容</code>  追加变量内容</li>\n</ul>\n</li>\n<li>可以在窗口修改</li>\n</ol>\n<p>第一种修改方法仅在当前窗口内有效。<br>第二种修改方法全局生效。</p>\n<h3 id=\"都有那些环境变量？\"><a href=\"#都有那些环境变量？\" class=\"headerlink\" title=\"都有那些环境变量？\"></a>都有那些环境变量？</h3><p><code>%ALLUSERSPROFILE%</code> 局部 返回所有用户配置文件的位置。<br><code>%APPDATA%</code> 局部 返回默认情况下应用程序存储数据的位置。<br><code>%CD%</code> 局部 返回当前目录字符串。<br><code>%CMDCMDLINE%</code> 局部 返回用来启动当前的 Cmd.exe 的准确命令行。<br><code>%CMDEXTVERSION%</code> 系统 返回当前的命令处理程序扩展的版本号。<br><code>%COMPUTERNAME%</code> 系统 返回计算机的名称。<br><code>%COMSPEC%</code> 系统 返回命令行解释器可执行程序的准确路径。<br><code>%DATE%</code> 系统 返回当前日期。<br><code>%ERRORLEVEL%</code> 系统 返回最近使用过的命令的错误代码。通常用非零值表示错误。<br><code>%HOMEDRIVE%</code> 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值的设置。用户主目录是在本地用户和组中指定的。<br><code>%HOMEPATH%</code> 系统 返回用户主目录的完整路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。<br><code>%HOMESHARE%</code> 系统 返回用户的共享主目录的网络路径。基于主目录值的设置。用户主目录是在本地用户和组中指定的。<br><code>%LOGONSEVER%</code> 局部 返回验证当前登录会话的域控制器的名称。<br><code>%NUMBER\\_OF\\_PROCESSORS%</code> 系统 指定安装在计算机上的处理器的数目。<br><code>%OS%</code> 系统 返回操作系统的名称。Windows 2000 将操作系统显示为 Windows_NT。<br><code>%PATH%</code> 系统 指定可执行文件的搜索路径。<br><code>%PATHEXT%</code> 系统 返回操作系统认为可执行的文件扩展名的列表。<br><code>%PROCESSOR\\_ARCHITECTURE%</code> 系统 返回处理器的芯片体系结构。值: x86，IA64。<br><code>%PROCESSOR\\_IDENTFIER%</code> 系统 返回处理器说明。<br><code>%PROCESSOR\\_LEVEL%</code> 系统 返回计算机上安装的处理器的型号。<br><code>%PROCESSOR\\_REVISION%</code> 系统 返回处理器修订号的系统变量。<br><code>%PROMPT%</code> 局部 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。<br><code>%RANDOM%</code> 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。<br><code>%SYSTEMDRIVE%</code> 系统 返回包含 Windows XP 根目录（即系统根目录）的驱动器。<br><code>%SYSTEMROOT%</code> 系统 返回 Windows XP 根目录的位置。<br><code>%TEMP%</code> and %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其它应用程序则需要 TMP。<br><code>%TIME%</code> 系统 返回当前时间。<br><code>%USERDOMAIN%</code> 局部 返回包含用户帐户的域的名称。<br><code>%USERNAME%</code> 局部 返回当前登录的用户的名称。<br><code>%UserProfile%</code> 局部 返回当前用户的配置文件的位置。<br><code>%WINDIR%</code> 系统 返回操作系统目录的位置。  </p>\n<h2 id=\"Java环境变量的设置\"><a href=\"#Java环境变量的设置\" class=\"headerlink\" title=\"Java环境变量的设置\"></a>Java环境变量的设置</h2><h3 id=\"Java都需要设置那些环境变量？\"><a href=\"#Java都需要设置那些环境变量？\" class=\"headerlink\" title=\"Java都需要设置那些环境变量？\"></a>Java都需要设置那些环境变量？</h3><p><code>JAVA\\_HOME</code> 指明JDK安装路径.(在安装好java之后就该配置)<br><code>Path</code>使得系统可以在任何路径下识别java命令.(如果你采用命令形式编译java源码,设置这个很方便)<br><code>classpath</code>为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别它.</p>\n<h3 id=\"Java在windows和linux下配置环境变量\"><a href=\"#Java在windows和linux下配置环境变量\" class=\"headerlink\" title=\"Java在windows和linux下配置环境变量\"></a>Java在windows和linux下配置环境变量</h3><p>windows：系统设置  分别设置这三项。</p>\n<p>Linux：</p>\n<ol>\n<li><p>修改<code>/etc/profile</code>文件<br>如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。</p>\n<ul>\n<li>用文本编辑器打开/etc/profile</li>\n<li><p>在profile文件末尾加入：</p>\n<pre><code>export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\nexport PATH=$JAVA\\_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n</code></pre></li>\n<li><p>重新登录</p>\n<blockquote>\n<p>注解</p>\n<ol>\n<li>你要将 /usr/share/jdk1.6.0_14改为你的jdk安装目录  </li>\n<li>linux下用冒号:来分隔路径  </li>\n<li>$PATH / $CLASSPATH / $JAVA_HOME 是用来引用原来的环境变量的值<br>在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。  </li>\n<li>CLASSPATH中当前目录.不能丢,把当前目录丢掉也是常见的错误。  </li>\n<li>export是把这三个变量导出为全局变量。  </li>\n<li>大小写必须严格区分。  </li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>修改<code>.bash\\_profile</code>文件</p>\n<p>这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash_profile文件就可以了。</p>\n<ul>\n<li>用文本编辑器打开用户目录下的.bash_profile文件</li>\n<li><p>在.bash_profile文件末尾加入：</p>\n<pre><code>export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\nexport PATH=$JAVA\\_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n</code></pre></li>\n<li><p>重新登录</p>\n</li>\n</ul>\n</li>\n<li><p>直接在shell下设置变量</p>\n<p>不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。</p>\n<ul>\n<li><p>只需在shell终端执行下列命令：</p>\n<pre><code>export JAVA\\_HOME=/usr/share/jdk1.6.0\\_14\nexport PATH=$JAVA\\_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA\\_HOME/lib/dt.jar:$JAVA\\_HOME/lib/tools.jar\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"引用来源\"><a href=\"#引用来源\" class=\"headerlink\" title=\"引用来源\"></a>引用来源</h2><p><a href=\"http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html\">http://www.cnblogs.com/samcn/archive/2011/03/16/1986248.html</a><br><a href=\"http://blog.chinaunix.net/uid-27135166-id-3304153.html\">http://blog.chinaunix.net/uid-27135166-id-3304153.html</a><br><a href=\"http://www.jb51.net/LINUXjishu/77524.html\">http://www.jb51.net/LINUXjishu/77524.html</a><br><a href=\"http://blog.chinaunix.net/uid-27135166-id-3304153.html\">http://blog.chinaunix.net/uid-27135166-id-3304153.html</a><br><a href=\"http://blog.csdn.net/fb281906011/article/details/8057672\">http://blog.csdn.net/fb281906011/article/details/8057672</a><br><a href=\"http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html\">http://jingyan.baidu.com/article/4ae03de320d99f3eff9e6bfd.html</a></p>"},{"title":"线性表的实现--链表","date":"2016-11-30T06:57:14.000Z","_content":"线性表是最常用最简单的一种线性数据结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。通常我们见到的有：数组，链表。而链表又分为单链表、双链表等不同种类。\n<!--more-->\n## 单向链表\n单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。\n\n    typedef struct node {\n        datatype data;\n        struct node * next;\n    }listnode;\n\n### 单链表创建\n通常我们创建一个空链表的时候指的是我们创建了一个头结点，这个节点指向了链表的第一个节点。\n\n    listnode * list_create() {\n        listnode * H;\n\n        H = (listnode *)malloc(sizeof(listnode));\n        if (H == NULL) {\n            printf(\"malloc failed!\\n\");\n            return NULL;\n        }\n\n        H->data = 0;\n        H->next = NULL;\n\n        return H;\n    }\n\n### 单链表的操作\n链表的操作通常有增删改查等：\n具体的实现代码在这里不再呈现，相应的操作逻辑是：  \n**增：**在指定的节点A后添加节点B是创建一个新的节点B，将此B节点的指针指向指定位置节点A的下个节点，再将指定位置节点A的指针指向节点B。  \n**删：**删除指定节点A首先找到A的上个节点B，将B节点的指针指向A的下个节点C，随后释放A节点空间。\n\n## 双向链表\n双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。\n\n    template<class T> \n    struct DuLNode\n    {\n        T data;\n        DuLNode *prev;\n        DuLNode *next;\n    };\n\n### 双向链表的相应操作\n**创建：**双向链表的创建同样是创建了一个空节点，此时链表指针指向和此节点的头尾指针均指向当前节点\n\n    template<class T>\n    DoubleLink<T>::DoubleLink() : count(0)\n    {\n        // 创建“表头”。注意：表头没有存储数据！\n        phead = new DNode<T>();\n        phead->prev = phead->next = phead;\n        // 设置链表计数为0\n        //count = 0;\n    }\n \n **增：**在指定的节点A，B中间添加节点C是创建一个新的节点C，将此C节点的头指针指向节点A尾指针指向B，再将A的尾指针B的头指针指向C。  \n **删：**删除AC节点中间的B节点是将A节点的尾指针指向C，将C节点头指针指向A，释放B节点  \n \n ## 栈\n Stack是一种常用的线性结构，主要有以下两个特点：\n * 栈中的数据是按照后进先出（LIFO）的顺序进行操作的\n * 向栈中添加数据和删除数据只能在栈顶进行操作\n \n ## 队列\n Queue是另外一种常见的线性结构，主要有以下两个特点：\n * 队列中数据是按照\"先进先出（FIFO）\"方式进出队列的。\n * 队列只允许在\"队首\"进行删除操作，而在\"队尾\"进行插入操作。\n ","source":"_posts/线性表的实现.md","raw":"---\ntitle: 线性表的实现--链表\ndate: 2016-11-30 14:57:14\ncategories: 数据结构\ntags: [数据结构,线性表]\n---\n线性表是最常用最简单的一种线性数据结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。通常我们见到的有：数组，链表。而链表又分为单链表、双链表等不同种类。\n<!--more-->\n## 单向链表\n单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。\n\n    typedef struct node {\n        datatype data;\n        struct node * next;\n    }listnode;\n\n### 单链表创建\n通常我们创建一个空链表的时候指的是我们创建了一个头结点，这个节点指向了链表的第一个节点。\n\n    listnode * list_create() {\n        listnode * H;\n\n        H = (listnode *)malloc(sizeof(listnode));\n        if (H == NULL) {\n            printf(\"malloc failed!\\n\");\n            return NULL;\n        }\n\n        H->data = 0;\n        H->next = NULL;\n\n        return H;\n    }\n\n### 单链表的操作\n链表的操作通常有增删改查等：\n具体的实现代码在这里不再呈现，相应的操作逻辑是：  \n**增：**在指定的节点A后添加节点B是创建一个新的节点B，将此B节点的指针指向指定位置节点A的下个节点，再将指定位置节点A的指针指向节点B。  \n**删：**删除指定节点A首先找到A的上个节点B，将B节点的指针指向A的下个节点C，随后释放A节点空间。\n\n## 双向链表\n双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。\n\n    template<class T> \n    struct DuLNode\n    {\n        T data;\n        DuLNode *prev;\n        DuLNode *next;\n    };\n\n### 双向链表的相应操作\n**创建：**双向链表的创建同样是创建了一个空节点，此时链表指针指向和此节点的头尾指针均指向当前节点\n\n    template<class T>\n    DoubleLink<T>::DoubleLink() : count(0)\n    {\n        // 创建“表头”。注意：表头没有存储数据！\n        phead = new DNode<T>();\n        phead->prev = phead->next = phead;\n        // 设置链表计数为0\n        //count = 0;\n    }\n \n **增：**在指定的节点A，B中间添加节点C是创建一个新的节点C，将此C节点的头指针指向节点A尾指针指向B，再将A的尾指针B的头指针指向C。  \n **删：**删除AC节点中间的B节点是将A节点的尾指针指向C，将C节点头指针指向A，释放B节点  \n \n ## 栈\n Stack是一种常用的线性结构，主要有以下两个特点：\n * 栈中的数据是按照后进先出（LIFO）的顺序进行操作的\n * 向栈中添加数据和删除数据只能在栈顶进行操作\n \n ## 队列\n Queue是另外一种常见的线性结构，主要有以下两个特点：\n * 队列中数据是按照\"先进先出（FIFO）\"方式进出队列的。\n * 队列只允许在\"队首\"进行删除操作，而在\"队尾\"进行插入操作。\n ","slug":"线性表的实现","published":1,"updated":"2016-12-16T01:29:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbvt9n4v0089bkw17ecxwhuc","content":"<p>线性表是最常用最简单的一种线性数据结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。通常我们见到的有：数组，链表。而链表又分为单链表、双链表等不同种类。<br><a id=\"more\"></a></p>\n<h2 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h2><p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。</p>\n<pre><code>typedef struct node {\n    datatype data;\n    struct node * next;\n}listnode;\n</code></pre><h3 id=\"单链表创建\"><a href=\"#单链表创建\" class=\"headerlink\" title=\"单链表创建\"></a>单链表创建</h3><p>通常我们创建一个空链表的时候指的是我们创建了一个头结点，这个节点指向了链表的第一个节点。</p>\n<pre><code>listnode * list_create() {\n    listnode * H;\n\n    H = (listnode *)malloc(sizeof(listnode));\n    if (H == NULL) {\n        printf(&quot;malloc failed!\\n&quot;);\n        return NULL;\n    }\n\n    H-&gt;data = 0;\n    H-&gt;next = NULL;\n\n    return H;\n}\n</code></pre><h3 id=\"单链表的操作\"><a href=\"#单链表的操作\" class=\"headerlink\" title=\"单链表的操作\"></a>单链表的操作</h3><p>链表的操作通常有增删改查等：<br>具体的实现代码在这里不再呈现，相应的操作逻辑是：<br><strong>增：</strong>在指定的节点A后添加节点B是创建一个新的节点B，将此B节点的指针指向指定位置节点A的下个节点，再将指定位置节点A的指针指向节点B。<br><strong>删：</strong>删除指定节点A首先找到A的上个节点B，将B节点的指针指向A的下个节点C，随后释放A节点空间。</p>\n<h2 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h2><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p>\n<pre><code>template&lt;class T&gt; \nstruct DuLNode\n{\n    T data;\n    DuLNode *prev;\n    DuLNode *next;\n};\n</code></pre><h3 id=\"双向链表的相应操作\"><a href=\"#双向链表的相应操作\" class=\"headerlink\" title=\"双向链表的相应操作\"></a>双向链表的相应操作</h3><p><strong>创建：</strong>双向链表的创建同样是创建了一个空节点，此时链表指针指向和此节点的头尾指针均指向当前节点</p>\n<pre><code>template&lt;class T&gt;\nDoubleLink&lt;T&gt;::DoubleLink() : count(0)\n{\n    // 创建“表头”。注意：表头没有存储数据！\n    phead = new DNode&lt;T&gt;();\n    phead-&gt;prev = phead-&gt;next = phead;\n    // 设置链表计数为0\n    //count = 0;\n}\n</code></pre><p> <strong>增：</strong>在指定的节点A，B中间添加节点C是创建一个新的节点C，将此C节点的头指针指向节点A尾指针指向B，再将A的尾指针B的头指针指向C。<br> <strong>删：</strong>删除AC节点中间的B节点是将A节点的尾指针指向C，将C节点头指针指向A，释放B节点  </p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p> Stack是一种常用的线性结构，主要有以下两个特点：</p>\n<ul>\n<li>栈中的数据是按照后进先出（LIFO）的顺序进行操作的</li>\n<li><p>向栈中添加数据和删除数据只能在栈顶进行操作</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>Queue是另外一种常见的线性结构，主要有以下两个特点：</p>\n</li>\n<li>队列中数据是按照”先进先出（FIFO）”方式进出队列的。</li>\n<li>队列只允许在”队首”进行删除操作，而在”队尾”进行插入操作。</li>\n</ul>\n","excerpt":"<p>线性表是最常用最简单的一种线性数据结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。通常我们见到的有：数组，链表。而链表又分为单链表、双链表等不同种类。<br>","more":"</p>\n<h2 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h2><p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。</p>\n<pre><code>typedef struct node {\n    datatype data;\n    struct node * next;\n}listnode;\n</code></pre><h3 id=\"单链表创建\"><a href=\"#单链表创建\" class=\"headerlink\" title=\"单链表创建\"></a>单链表创建</h3><p>通常我们创建一个空链表的时候指的是我们创建了一个头结点，这个节点指向了链表的第一个节点。</p>\n<pre><code>listnode * list_create() {\n    listnode * H;\n\n    H = (listnode *)malloc(sizeof(listnode));\n    if (H == NULL) {\n        printf(&quot;malloc failed!\\n&quot;);\n        return NULL;\n    }\n\n    H-&gt;data = 0;\n    H-&gt;next = NULL;\n\n    return H;\n}\n</code></pre><h3 id=\"单链表的操作\"><a href=\"#单链表的操作\" class=\"headerlink\" title=\"单链表的操作\"></a>单链表的操作</h3><p>链表的操作通常有增删改查等：<br>具体的实现代码在这里不再呈现，相应的操作逻辑是：<br><strong>增：</strong>在指定的节点A后添加节点B是创建一个新的节点B，将此B节点的指针指向指定位置节点A的下个节点，再将指定位置节点A的指针指向节点B。<br><strong>删：</strong>删除指定节点A首先找到A的上个节点B，将B节点的指针指向A的下个节点C，随后释放A节点空间。</p>\n<h2 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h2><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p>\n<pre><code>template&lt;class T&gt; \nstruct DuLNode\n{\n    T data;\n    DuLNode *prev;\n    DuLNode *next;\n};\n</code></pre><h3 id=\"双向链表的相应操作\"><a href=\"#双向链表的相应操作\" class=\"headerlink\" title=\"双向链表的相应操作\"></a>双向链表的相应操作</h3><p><strong>创建：</strong>双向链表的创建同样是创建了一个空节点，此时链表指针指向和此节点的头尾指针均指向当前节点</p>\n<pre><code>template&lt;class T&gt;\nDoubleLink&lt;T&gt;::DoubleLink() : count(0)\n{\n    // 创建“表头”。注意：表头没有存储数据！\n    phead = new DNode&lt;T&gt;();\n    phead-&gt;prev = phead-&gt;next = phead;\n    // 设置链表计数为0\n    //count = 0;\n}\n</code></pre><p> <strong>增：</strong>在指定的节点A，B中间添加节点C是创建一个新的节点C，将此C节点的头指针指向节点A尾指针指向B，再将A的尾指针B的头指针指向C。<br> <strong>删：</strong>删除AC节点中间的B节点是将A节点的尾指针指向C，将C节点头指针指向A，释放B节点  </p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p> Stack是一种常用的线性结构，主要有以下两个特点：</p>\n<ul>\n<li>栈中的数据是按照后进先出（LIFO）的顺序进行操作的</li>\n<li><p>向栈中添加数据和删除数据只能在栈顶进行操作</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>Queue是另外一种常见的线性结构，主要有以下两个特点：</p>\n</li>\n<li>队列中数据是按照”先进先出（FIFO）”方式进出队列的。</li>\n<li>队列只允许在”队首”进行删除操作，而在”队尾”进行插入操作。</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjbvt9myw0000bkw1o3bvouv7","category_id":"cjbvt9mzf0004bkw1mh1r0wie","_id":"cjbvt9mzx000dbkw1sfuih9fi"},{"post_id":"cjbvt9myw0002bkw1suqooyaa","category_id":"cjbvt9mzt0009bkw1lfiza05y","_id":"cjbvt9n05000jbkw1weh33ccz"},{"post_id":"cjbvt9mzj0006bkw1rip2f13m","category_id":"cjbvt9mzt0009bkw1lfiza05y","_id":"cjbvt9n0a000obkw1kp9c2g6m"},{"post_id":"cjbvt9mzl0007bkw1hutlh7gd","category_id":"cjbvt9mzt0009bkw1lfiza05y","_id":"cjbvt9n0l000ubkw11m234h9n"},{"post_id":"cjbvt9mzr0008bkw1hiil316a","category_id":"cjbvt9n0b000pbkw1xxzkbl80","_id":"cjbvt9n0s0011bkw1tdbz6bn4"},{"post_id":"cjbvt9mzw000cbkw1ouzatoxn","category_id":"cjbvt9n0m000vbkw1q2byqiyg","_id":"cjbvt9n0s0016bkw150ubo4hj"},{"post_id":"cjbvt9mzy000ebkw1xdj4zkyz","category_id":"cjbvt9n0b000pbkw1xxzkbl80","_id":"cjbvt9n0s001cbkw1o7hdvf26"},{"post_id":"cjbvt9n02000hbkw13mtjvf1z","category_id":"cjbvt9n0b000pbkw1xxzkbl80","_id":"cjbvt9n17001jbkw18nzpd5wv"},{"post_id":"cjbvt9n03000ibkw1cwf7ccgg","category_id":"cjbvt9n0b000pbkw1xxzkbl80","_id":"cjbvt9n17001pbkw1mzz7l7d3"},{"post_id":"cjbvt9n06000mbkw1i7d3vs5h","category_id":"cjbvt9n0b000pbkw1xxzkbl80","_id":"cjbvt9n17001ubkw1ckgzc21j"},{"post_id":"cjbvt9n09000nbkw1bo50lw2c","category_id":"cjbvt9n17001qbkw10hrmztnq","_id":"cjbvt9n1n001zbkw19k6tds6t"},{"post_id":"cjbvt9n0c000rbkw1ey3ky1sa","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n1n0025bkw1kk2i2k2c"},{"post_id":"cjbvt9n0e000tbkw17ft9ribw","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n1n002cbkw1jwhnzbe3"},{"post_id":"cjbvt9n0p000ybkw16mgx24hl","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n23002jbkw1ybk8j8m9"},{"post_id":"cjbvt9n0r0010bkw14u74smwt","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n23002pbkw1t746qw33"},{"post_id":"cjbvt9n0s0013bkw1b1nqq3yy","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n23002rbkw12xksvj96"},{"post_id":"cjbvt9n0s0015bkw1ur6g9dxz","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n23002wbkw1613gjca9"},{"post_id":"cjbvt9n0s0018bkw1bdcac090","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n23002zbkw1rdnxb0hu"},{"post_id":"cjbvt9n0s001abkw1q1puu8uh","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n230032bkw1nlqk1f9t"},{"post_id":"cjbvt9n0s001ebkw1sztk77q8","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n230036bkw180yi9ivy"},{"post_id":"cjbvt9n17001hbkw15g48hcvl","category_id":"cjbvt9n17001wbkw1nrnlv3yk","_id":"cjbvt9n23003bbkw1uy2m1n5o"},{"post_id":"cjbvt9n17001lbkw10fktdean","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n23003fbkw1qp39mrmd"},{"post_id":"cjbvt9n17001obkw1n1cqios3","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n2l003jbkw1i9nvs79a"},{"post_id":"cjbvt9n17001rbkw1r55vqzts","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n2n003nbkw1i8mmwk9i"},{"post_id":"cjbvt9n17001sbkw1qil0eefc","category_id":"cjbvt9n2m003kbkw1rfsqicd8","_id":"cjbvt9n2n003sbkw1glbkw23k"},{"post_id":"cjbvt9n17001vbkw10ccve32d","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n2n003wbkw1urds2hcg"},{"post_id":"cjbvt9n17001xbkw1oy1x59md","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n2n003zbkw1uel9figc"},{"post_id":"cjbvt9n1n0020bkw1p7lkl5z3","category_id":"cjbvt9n23002tbkw1gj6mq67d","_id":"cjbvt9n2n0044bkw1875g4lxh"},{"post_id":"cjbvt9n1n0022bkw1xhy93moz","category_id":"cjbvt9n2m003kbkw1rfsqicd8","_id":"cjbvt9n330047bkw13cyv2u3g"},{"post_id":"cjbvt9n1n0024bkw1winkypet","category_id":"cjbvt9n2n0045bkw1hyo3lj94","_id":"cjbvt9n33004cbkw1tqj0cffp"},{"post_id":"cjbvt9n1n0028bkw1rkcqypr0","category_id":"cjbvt9n2m003kbkw1rfsqicd8","_id":"cjbvt9n33004fbkw1yl1xdo7q"},{"post_id":"cjbvt9n1n002bbkw1c1t1db0l","category_id":"cjbvt9n33004dbkw18bwuhoi1","_id":"cjbvt9n33004ibkw1v4b4dkd3"},{"post_id":"cjbvt9n1n002fbkw177ssq29q","category_id":"cjbvt9n33004dbkw18bwuhoi1","_id":"cjbvt9n33004kbkw1lycwa212"},{"post_id":"cjbvt9n1n002ibkw1rram0zmb","category_id":"cjbvt9n33004jbkw1yl2ijp0c","_id":"cjbvt9n33004mbkw1c44gpkuc"},{"post_id":"cjbvt9n4f0088bkw1y0nzn7xk","category_id":"cjbvt9n17001qbkw10hrmztnq","_id":"cjbvt9n4v008cbkw1s5o41t5s"},{"post_id":"cjbvt9n4v0089bkw17ecxwhuc","category_id":"cjbvt9n4v008bbkw1bryjyk9z","_id":"cjbvt9n4v008fbkw1cf0or4t9"}],"PostTag":[{"post_id":"cjbvt9myw0000bkw1o3bvouv7","tag_id":"cjbvt9mzi0005bkw1dvdjon0x","_id":"cjbvt9mzv000bbkw1znmwmx6k"},{"post_id":"cjbvt9myw0002bkw1suqooyaa","tag_id":"cjbvt9mzu000abkw1ai1wdp8r","_id":"cjbvt9n0d000sbkw1m6fbw46c"},{"post_id":"cjbvt9myw0002bkw1suqooyaa","tag_id":"cjbvt9mzz000gbkw1qt3o57rz","_id":"cjbvt9n0o000wbkw1hf4w0u6q"},{"post_id":"cjbvt9myw0002bkw1suqooyaa","tag_id":"cjbvt9n06000lbkw1fvbxbe2p","_id":"cjbvt9n0r000zbkw1hjzawhju"},{"post_id":"cjbvt9mzl0007bkw1hutlh7gd","tag_id":"cjbvt9mzu000abkw1ai1wdp8r","_id":"cjbvt9n0s001bbkw1pvw7bu7m"},{"post_id":"cjbvt9mzl0007bkw1hutlh7gd","tag_id":"cjbvt9n0o000xbkw1l480r20j","_id":"cjbvt9n17001fbkw1u3m7ja0y"},{"post_id":"cjbvt9mzl0007bkw1hutlh7gd","tag_id":"cjbvt9n0s0014bkw17z0i9vaw","_id":"cjbvt9n17001ibkw1x6iplv7g"},{"post_id":"cjbvt9mzr0008bkw1hiil316a","tag_id":"cjbvt9n0s0019bkw16j6jw6ro","_id":"cjbvt9n17001mbkw1q9nfhiqb"},{"post_id":"cjbvt9mzw000cbkw1ouzatoxn","tag_id":"cjbvt9n17001gbkw1hztlw1j0","_id":"cjbvt9n1n0027bkw1k157kabx"},{"post_id":"cjbvt9mzw000cbkw1ouzatoxn","tag_id":"cjbvt9n17001nbkw18xtpca0m","_id":"cjbvt9n1n0029bkw16lu8ddc1"},{"post_id":"cjbvt9mzw000cbkw1ouzatoxn","tag_id":"cjbvt9n17001tbkw1g0rw6u23","_id":"cjbvt9n1n002ebkw1epzdt09p"},{"post_id":"cjbvt9mzw000cbkw1ouzatoxn","tag_id":"cjbvt9n1n001ybkw1q5wsrwtu","_id":"cjbvt9n1n002gbkw1z8g4xh3e"},{"post_id":"cjbvt9mzy000ebkw1xdj4zkyz","tag_id":"cjbvt9n0s0019bkw16j6jw6ro","_id":"cjbvt9n23002lbkw1oepa2hsz"},{"post_id":"cjbvt9mzy000ebkw1xdj4zkyz","tag_id":"cjbvt9n1n002abkw10fhi0clb","_id":"cjbvt9n23002nbkw1t7dttqjl"},{"post_id":"cjbvt9n02000hbkw13mtjvf1z","tag_id":"cjbvt9n0s0019bkw16j6jw6ro","_id":"cjbvt9n23002ubkw133dp982v"},{"post_id":"cjbvt9n02000hbkw13mtjvf1z","tag_id":"cjbvt9n23002obkw1yzj0v8c1","_id":"cjbvt9n23002vbkw1nnnt2h3c"},{"post_id":"cjbvt9n03000ibkw1cwf7ccgg","tag_id":"cjbvt9n0s0019bkw16j6jw6ro","_id":"cjbvt9n230035bkw1uxgdie2n"},{"post_id":"cjbvt9n03000ibkw1cwf7ccgg","tag_id":"cjbvt9n23002xbkw12cbeputl","_id":"cjbvt9n230037bkw1jzodfajw"},{"post_id":"cjbvt9n03000ibkw1cwf7ccgg","tag_id":"cjbvt9n230030bkw1n7wbvufn","_id":"cjbvt9n23003abkw1bg0tl91a"},{"post_id":"cjbvt9n06000mbkw1i7d3vs5h","tag_id":"cjbvt9n0s0019bkw16j6jw6ro","_id":"cjbvt9n23003ebkw17i4hbdtl"},{"post_id":"cjbvt9n06000mbkw1i7d3vs5h","tag_id":"cjbvt9n230039bkw1rykysgiw","_id":"cjbvt9n2j003hbkw1yc6dro88"},{"post_id":"cjbvt9n09000nbkw1bo50lw2c","tag_id":"cjbvt9n23003dbkw1p8p1qtjz","_id":"cjbvt9n2n003mbkw1fjvy9gj3"},{"post_id":"cjbvt9n09000nbkw1bo50lw2c","tag_id":"cjbvt9mzu000abkw1ai1wdp8r","_id":"cjbvt9n2n003pbkw125efr4va"},{"post_id":"cjbvt9n09000nbkw1bo50lw2c","tag_id":"cjbvt9n2l003ibkw1u1g7whf8","_id":"cjbvt9n2n003rbkw14l4fmbuf"},{"post_id":"cjbvt9n0c000rbkw1ey3ky1sa","tag_id":"cjbvt9n2m003lbkw1ddy7trzz","_id":"cjbvt9n2n003ubkw14f7aihv1"},{"post_id":"cjbvt9n0e000tbkw17ft9ribw","tag_id":"cjbvt9n2m003lbkw1ddy7trzz","_id":"cjbvt9n2n0040bkw1fflf02fm"},{"post_id":"cjbvt9n0e000tbkw17ft9ribw","tag_id":"cjbvt9n2n003vbkw1tgbls3b2","_id":"cjbvt9n2n0042bkw165ccskvl"},{"post_id":"cjbvt9n0p000ybkw16mgx24hl","tag_id":"cjbvt9n2n003vbkw1tgbls3b2","_id":"cjbvt9n330048bkw1ry5m1bfg"},{"post_id":"cjbvt9n0p000ybkw16mgx24hl","tag_id":"cjbvt9n2n0043bkw1rrayryp1","_id":"cjbvt9n33004abkw10bcqu4fp"},{"post_id":"cjbvt9n0r0010bkw14u74smwt","tag_id":"cjbvt9n2n0046bkw1tspt5nbd","_id":"cjbvt9n33004obkw1x21iukam"},{"post_id":"cjbvt9n0r0010bkw14u74smwt","tag_id":"cjbvt9n33004bbkw17scr5nex","_id":"cjbvt9n33004pbkw1zcltk7nj"},{"post_id":"cjbvt9n0r0010bkw14u74smwt","tag_id":"cjbvt9n33004ebkw1v8pxo77o","_id":"cjbvt9n33004rbkw1hd18phth"},{"post_id":"cjbvt9n0r0010bkw14u74smwt","tag_id":"cjbvt9n33004hbkw1p8ji8g37","_id":"cjbvt9n33004sbkw11n13zhoc"},{"post_id":"cjbvt9n0r0010bkw14u74smwt","tag_id":"cjbvt9n33004lbkw1j3tjl6m5","_id":"cjbvt9n33004ubkw1aq2w8jfa"},{"post_id":"cjbvt9n0s0013bkw1b1nqq3yy","tag_id":"cjbvt9n2n0046bkw1tspt5nbd","_id":"cjbvt9n33004vbkw187pqdfsp"},{"post_id":"cjbvt9n0s0013bkw1b1nqq3yy","tag_id":"cjbvt9n33004ebkw1v8pxo77o","_id":"cjbvt9n33004xbkw1xwqgg5fx"},{"post_id":"cjbvt9n0s0015bkw1ur6g9dxz","tag_id":"cjbvt9n33004tbkw1kjcnwoht","_id":"cjbvt9n33004ybkw1t2lu22gx"},{"post_id":"cjbvt9n0s0018bkw1bdcac090","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n330053bkw1cxu8b4kn"},{"post_id":"cjbvt9n0s0018bkw1bdcac090","tag_id":"cjbvt9n33004zbkw1gaahairx","_id":"cjbvt9n330054bkw1b9xea7bm"},{"post_id":"cjbvt9n0s0018bkw1bdcac090","tag_id":"cjbvt9n330050bkw1ul4lf0go","_id":"cjbvt9n330056bkw1l3evaetu"},{"post_id":"cjbvt9n0s0018bkw1bdcac090","tag_id":"cjbvt9n330051bkw1o8ohx4oa","_id":"cjbvt9n3j0057bkw1ffb5l6h4"},{"post_id":"cjbvt9n0s001abkw1q1puu8uh","tag_id":"cjbvt9n330052bkw15fifrsdp","_id":"cjbvt9n3k005bbkw19xq809l8"},{"post_id":"cjbvt9n0s001abkw1q1puu8uh","tag_id":"cjbvt9n330055bkw1be9flkg6","_id":"cjbvt9n3k005cbkw1miwk4yz9"},{"post_id":"cjbvt9n0s001abkw1q1puu8uh","tag_id":"cjbvt9n3j0058bkw1meayue39","_id":"cjbvt9n3k005ebkw155d3dsu6"},{"post_id":"cjbvt9n0s001abkw1q1puu8uh","tag_id":"cjbvt9n3k0059bkw1w9qc6llj","_id":"cjbvt9n3k005fbkw1oyr6rmki"},{"post_id":"cjbvt9n0s001ebkw1sztk77q8","tag_id":"cjbvt9n3k005abkw1d46uvqgd","_id":"cjbvt9n3k005kbkw1eho9q67k"},{"post_id":"cjbvt9n0s001ebkw1sztk77q8","tag_id":"cjbvt9n3k005dbkw1egy8c5oy","_id":"cjbvt9n3k005lbkw18t3cx16h"},{"post_id":"cjbvt9n0s001ebkw1sztk77q8","tag_id":"cjbvt9n3k005gbkw1o0omz4kj","_id":"cjbvt9n3k005nbkw1pqorwotp"},{"post_id":"cjbvt9n0s001ebkw1sztk77q8","tag_id":"cjbvt9n3k005hbkw1wft7p23s","_id":"cjbvt9n3k005obkw1sji6ffew"},{"post_id":"cjbvt9n0s001ebkw1sztk77q8","tag_id":"cjbvt9n3k005ibkw18elknu5r","_id":"cjbvt9n3k005qbkw1pulig507"},{"post_id":"cjbvt9n17001hbkw15g48hcvl","tag_id":"cjbvt9n3k005jbkw1fm7rmwvr","_id":"cjbvt9n3k005tbkw1z44yc2hu"},{"post_id":"cjbvt9n17001hbkw15g48hcvl","tag_id":"cjbvt9n3k005mbkw1743sp99e","_id":"cjbvt9n3k005ubkw1cwtgr5nu"},{"post_id":"cjbvt9n17001hbkw15g48hcvl","tag_id":"cjbvt9n3k005pbkw1p0katkgm","_id":"cjbvt9n3k005wbkw1r3jo8dzj"},{"post_id":"cjbvt9n17001hbkw15g48hcvl","tag_id":"cjbvt9n3k005rbkw15w7a23rp","_id":"cjbvt9n3k005xbkw1sfeepoj9"},{"post_id":"cjbvt9n17001lbkw10fktdean","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n3k0061bkw1fl4gices"},{"post_id":"cjbvt9n17001lbkw10fktdean","tag_id":"cjbvt9n3k005vbkw1zbjpid88","_id":"cjbvt9n3k0062bkw1zqeiuy5a"},{"post_id":"cjbvt9n17001lbkw10fktdean","tag_id":"cjbvt9n3k005ybkw1k93ewuln","_id":"cjbvt9n3k0064bkw1r6ujx38b"},{"post_id":"cjbvt9n17001lbkw10fktdean","tag_id":"cjbvt9n3k0059bkw1w9qc6llj","_id":"cjbvt9n3k0065bkw1ezdr4lu7"},{"post_id":"cjbvt9n17001obkw1n1cqios3","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n3k006abkw1ls65ddb1"},{"post_id":"cjbvt9n17001obkw1n1cqios3","tag_id":"cjbvt9n2n0046bkw1tspt5nbd","_id":"cjbvt9n3k006bbkw1poxlx41q"},{"post_id":"cjbvt9n17001obkw1n1cqios3","tag_id":"cjbvt9n33004hbkw1p8ji8g37","_id":"cjbvt9n3k006dbkw11byxdplm"},{"post_id":"cjbvt9n17001obkw1n1cqios3","tag_id":"cjbvt9n3k0067bkw1eelqil73","_id":"cjbvt9n3k006ebkw1v7eb9lu7"},{"post_id":"cjbvt9n17001obkw1n1cqios3","tag_id":"cjbvt9n3k0068bkw1tzuqls8x","_id":"cjbvt9n3k006gbkw1nzt8riz0"},{"post_id":"cjbvt9n17001rbkw1r55vqzts","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n3k006ibkw165c49wkk"},{"post_id":"cjbvt9n17001rbkw1r55vqzts","tag_id":"cjbvt9n3k006cbkw1mt5jp6vf","_id":"cjbvt9n3k006jbkw1ag0ejuuh"},{"post_id":"cjbvt9n17001rbkw1r55vqzts","tag_id":"cjbvt9n3k006fbkw115r3v0q8","_id":"cjbvt9n3k006lbkw159gyklky"},{"post_id":"cjbvt9n17001sbkw1qil0eefc","tag_id":"cjbvt9n3k006hbkw1vik4v480","_id":"cjbvt9n3k006nbkw1qa5fjdyb"},{"post_id":"cjbvt9n17001sbkw1qil0eefc","tag_id":"cjbvt9n3k006kbkw16gi4nwf8","_id":"cjbvt9n3k006obkw135w2wwb3"},{"post_id":"cjbvt9n17001vbkw10ccve32d","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n3k006tbkw1g6egjwag"},{"post_id":"cjbvt9n17001vbkw10ccve32d","tag_id":"cjbvt9n3k006pbkw1xqhawtuw","_id":"cjbvt9n3k006ubkw10x4u6ic9"},{"post_id":"cjbvt9n17001vbkw10ccve32d","tag_id":"cjbvt9n3k006qbkw18py8vxhx","_id":"cjbvt9n3k006wbkw1iz5rjakm"},{"post_id":"cjbvt9n17001vbkw10ccve32d","tag_id":"cjbvt9n3k006rbkw1r2sq2yys","_id":"cjbvt9n3k006xbkw104y3m2hn"},{"post_id":"cjbvt9n17001xbkw1oy1x59md","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n400071bkw16qftevp7"},{"post_id":"cjbvt9n17001xbkw1oy1x59md","tag_id":"cjbvt9n3k006vbkw12qh782dk","_id":"cjbvt9n400072bkw1khphadqs"},{"post_id":"cjbvt9n17001xbkw1oy1x59md","tag_id":"cjbvt9n3k006ybkw1pddtvn6a","_id":"cjbvt9n400074bkw19hjkj2my"},{"post_id":"cjbvt9n17001xbkw1oy1x59md","tag_id":"cjbvt9n40006zbkw15cmaazw3","_id":"cjbvt9n400075bkw1jjv2aud4"},{"post_id":"cjbvt9n1n0020bkw1p7lkl5z3","tag_id":"cjbvt9n33004wbkw1r31tyev2","_id":"cjbvt9n400079bkw1alo7923x"},{"post_id":"cjbvt9n1n0020bkw1p7lkl5z3","tag_id":"cjbvt9n3k006vbkw12qh782dk","_id":"cjbvt9n40007abkw1rymhgxq9"},{"post_id":"cjbvt9n1n0020bkw1p7lkl5z3","tag_id":"cjbvt9n3k006ybkw1pddtvn6a","_id":"cjbvt9n40007cbkw1ci20ky87"},{"post_id":"cjbvt9n1n0020bkw1p7lkl5z3","tag_id":"cjbvt9n40006zbkw15cmaazw3","_id":"cjbvt9n40007dbkw11wlrgqjo"},{"post_id":"cjbvt9n1n0022bkw1xhy93moz","tag_id":"cjbvt9n3k006hbkw1vik4v480","_id":"cjbvt9n40007fbkw1mgbcr586"},{"post_id":"cjbvt9n1n0022bkw1xhy93moz","tag_id":"cjbvt9n3k006kbkw16gi4nwf8","_id":"cjbvt9n40007gbkw1knixv8e2"},{"post_id":"cjbvt9n1n0024bkw1winkypet","tag_id":"cjbvt9n40007ebkw1jnr4dcij","_id":"cjbvt9n40007kbkw19q239ku7"},{"post_id":"cjbvt9n1n0024bkw1winkypet","tag_id":"cjbvt9n40007hbkw12j5c4vga","_id":"cjbvt9n40007lbkw1hiewunf7"},{"post_id":"cjbvt9n1n0024bkw1winkypet","tag_id":"cjbvt9n40007ibkw1a0dthzqp","_id":"cjbvt9n40007nbkw1z8ejxtze"},{"post_id":"cjbvt9n1n0028bkw1rkcqypr0","tag_id":"cjbvt9n3k006hbkw1vik4v480","_id":"cjbvt9n40007pbkw1o7l9fbey"},{"post_id":"cjbvt9n1n0028bkw1rkcqypr0","tag_id":"cjbvt9n3k006kbkw16gi4nwf8","_id":"cjbvt9n40007qbkw10h4msyoi"},{"post_id":"cjbvt9n1n002bbkw1c1t1db0l","tag_id":"cjbvt9n40007obkw1m8eao0fd","_id":"cjbvt9n40007tbkw1blr13y84"},{"post_id":"cjbvt9n1n002bbkw1c1t1db0l","tag_id":"cjbvt9n40007rbkw1yg5033ae","_id":"cjbvt9n4f007ubkw18yysysrs"},{"post_id":"cjbvt9n1n002fbkw177ssq29q","tag_id":"cjbvt9n40007sbkw10lzz5asr","_id":"cjbvt9n4f007ybkw19y9tvtsj"},{"post_id":"cjbvt9n1n002fbkw177ssq29q","tag_id":"cjbvt9n4f007vbkw141c59mnu","_id":"cjbvt9n4f007zbkw16ytxuswj"},{"post_id":"cjbvt9n1n002fbkw177ssq29q","tag_id":"cjbvt9n4f007wbkw1iwsfi6pm","_id":"cjbvt9n4f0081bkw13yiaoyr5"},{"post_id":"cjbvt9n1n002ibkw1rram0zmb","tag_id":"cjbvt9n4f007xbkw1sru0ot8g","_id":"cjbvt9n4f0082bkw17ii2fmnz"},{"post_id":"cjbvt9n23002mbkw1qswtyx6f","tag_id":"cjbvt9n4f0080bkw1kowft8u8","_id":"cjbvt9n4f0085bkw1v37k1zfv"},{"post_id":"cjbvt9n23002mbkw1qswtyx6f","tag_id":"cjbvt9n4f0083bkw1ii3nvzfi","_id":"cjbvt9n4f0086bkw1usiw4fqk"},{"post_id":"cjbvt9n23002mbkw1qswtyx6f","tag_id":"cjbvt9n2m003lbkw1ddy7trzz","_id":"cjbvt9n4f0087bkw18915fwg7"},{"post_id":"cjbvt9n4f0088bkw1y0nzn7xk","tag_id":"cjbvt9n4v008abkw1etyfdwzj","_id":"cjbvt9n4v008ebkw1w89t50t4"},{"post_id":"cjbvt9n4v0089bkw17ecxwhuc","tag_id":"cjbvt9n230039bkw1rykysgiw","_id":"cjbvt9n4v008gbkw17gttfa0i"},{"post_id":"cjbvt9n4v0089bkw17ecxwhuc","tag_id":"cjbvt9n4v008dbkw1x7crhh2t","_id":"cjbvt9n4v008hbkw106duu8oh"}],"Tag":[{"name":"Boa","_id":"cjbvt9mzi0005bkw1dvdjon0x"},{"name":"C++","_id":"cjbvt9mzu000abkw1ai1wdp8r"},{"name":"STL","_id":"cjbvt9mzz000gbkw1qt3o57rz"},{"name":"标准库","_id":"cjbvt9n06000lbkw1fvbxbe2p"},{"name":"模板","_id":"cjbvt9n0o000xbkw1l480r20j"},{"name":"函数重载","_id":"cjbvt9n0s0014bkw17z0i9vaw"},{"name":"C语言","_id":"cjbvt9n0s0019bkw16j6jw6ro"},{"name":"string","_id":"cjbvt9n17001gbkw1hztlw1j0"},{"name":"int","_id":"cjbvt9n17001nbkw18xtpca0m"},{"name":"char *","_id":"cjbvt9n17001tbkw1g0rw6u23"},{"name":"类型转换","_id":"cjbvt9n1n001ybkw1q5wsrwtu"},{"name":"指针","_id":"cjbvt9n1n002abkw10fhi0clb"},{"name":"标准C库","_id":"cjbvt9n23002obkw1yzj0v8c1"},{"name":"GCC","_id":"cjbvt9n23002xbkw12cbeputl"},{"name":"GDB","_id":"cjbvt9n230030bkw1n7wbvufn"},{"name":"数据结构","_id":"cjbvt9n230039bkw1rykysgiw"},{"name":"Google","_id":"cjbvt9n23003dbkw1p8p1qtjz"},{"name":"Code Style","_id":"cjbvt9n2l003ibkw1u1g7whf8"},{"name":"Linux","_id":"cjbvt9n2m003lbkw1ddy7trzz"},{"name":"Shell","_id":"cjbvt9n2n003vbkw1tgbls3b2"},{"name":"命令","_id":"cjbvt9n2n0043bkw1rrayryp1"},{"name":"I/O","_id":"cjbvt9n2n0046bkw1tspt5nbd"},{"name":"阻塞式I/O","_id":"cjbvt9n33004bbkw17scr5nex"},{"name":"select","_id":"cjbvt9n33004ebkw1v8pxo77o"},{"name":"poll","_id":"cjbvt9n33004hbkw1p8ji8g37"},{"name":"epoll","_id":"cjbvt9n33004lbkw1j3tjl6m5"},{"name":"进程","_id":"cjbvt9n33004tbkw1kjcnwoht"},{"name":"驱动","_id":"cjbvt9n33004wbkw1r31tyev2"},{"name":"内核","_id":"cjbvt9n33004zbkw1gaahairx"},{"name":"设备文件系统","_id":"cjbvt9n330050bkw1ul4lf0go"},{"name":"udev","_id":"cjbvt9n330051bkw1o8ohx4oa"},{"name":"进程间通信","_id":"cjbvt9n330052bkw15fifrsdp"},{"name":"消息队列","_id":"cjbvt9n330055bkw1be9flkg6"},{"name":"共享内存","_id":"cjbvt9n3j0058bkw1meayue39"},{"name":"信号量","_id":"cjbvt9n3k0059bkw1w9qc6llj"},{"name":"网络","_id":"cjbvt9n3k005abkw1d46uvqgd"},{"name":"TCP","_id":"cjbvt9n3k005dbkw1egy8c5oy"},{"name":"UDP","_id":"cjbvt9n3k005gbkw1o0omz4kj"},{"name":"组播","_id":"cjbvt9n3k005hbkw1wft7p23s"},{"name":"广播","_id":"cjbvt9n3k005ibkw18elknu5r"},{"name":"线程","_id":"cjbvt9n3k005jbkw1fm7rmwvr"},{"name":"条件变量","_id":"cjbvt9n3k005mbkw1743sp99e"},{"name":"线程属性","_id":"cjbvt9n3k005pbkw1p0katkgm"},{"name":"互斥锁","_id":"cjbvt9n3k005rbkw15w7a23rp"},{"name":"并发","_id":"cjbvt9n3k005vbkw1zbjpid88"},{"name":"自旋锁","_id":"cjbvt9n3k005ybkw1k93ewuln"},{"name":"等待队列","_id":"cjbvt9n3k0067bkw1eelqil73"},{"name":"异步通知","_id":"cjbvt9n3k0068bkw1tzuqls8x"},{"name":"file_operations","_id":"cjbvt9n3k006cbkw1mt5jp6vf"},{"name":"驱动加载","_id":"cjbvt9n3k006fbkw115r3v0q8"},{"name":"VS Code","_id":"cjbvt9n3k006hbkw1vik4v480"},{"name":"IDE","_id":"cjbvt9n3k006kbkw16gi4nwf8"},{"name":"中断","_id":"cjbvt9n3k006pbkw1xqhawtuw"},{"name":"定时器","_id":"cjbvt9n3k006qbkw18py8vxhx"},{"name":"延时","_id":"cjbvt9n3k006rbkw1r2sq2yys"},{"name":"内存","_id":"cjbvt9n3k006vbkw12qh782dk"},{"name":"IO","_id":"cjbvt9n3k006ybkw1pddtvn6a"},{"name":"硬件通信","_id":"cjbvt9n40006zbkw15cmaazw3"},{"name":"Hexo","_id":"cjbvt9n40007ebkw1jnr4dcij"},{"name":"Blog","_id":"cjbvt9n40007hbkw12j5c4vga"},{"name":"Github","_id":"cjbvt9n40007ibkw1a0dthzqp"},{"name":"system","_id":"cjbvt9n40007obkw1m8eao0fd"},{"name":"Qt","_id":"cjbvt9n40007rbkw1yg5033ae"},{"name":"tar","_id":"cjbvt9n40007sbkw10lzz5asr"},{"name":"7z","_id":"cjbvt9n4f007vbkw141c59mnu"},{"name":"gz","_id":"cjbvt9n4f007wbkw1iwsfi6pm"},{"name":"程序员的修炼之道","_id":"cjbvt9n4f007xbkw1sru0ot8g"},{"name":"操作系统","_id":"cjbvt9n4f0080bkw1kowft8u8"},{"name":"文件命名","_id":"cjbvt9n4f0083bkw1ii3nvzfi"},{"name":"环境变量","_id":"cjbvt9n4v008abkw1etyfdwzj"},{"name":"线性表","_id":"cjbvt9n4v008dbkw1x7crhh2t"}]}}